# 3.3 스마트 컨트랙트와 ZK 증명 통합

## 개요

이 문서에서는 snarkjs로 생성한 ZK 증명을 Ethereum 스마트 컨트랙트에서 검증하는 전체 과정을 다룬다. Verifier 컨트랙트 생성부터 프론트엔드 통합, 가스 최적화, 프로덕션 배포까지 실전 개발에 필요한 모든 내용을 포함한다.

---

## 1. Verifier 컨트랙트 생성

### 1.1 snarkjs로 Verifier 생성

```bash
# Groth16 Verifier 생성
snarkjs zkey export solidityverifier \
    keys/circuit_final.zkey \
    contracts/Verifier.sol

# PLONK Verifier 생성
snarkjs zkey export solidityverifier \
    keys/circuit_plonk.zkey \
    contracts/PlonkVerifier.sol

# Calldata 생성 (테스트용)
snarkjs zkey export soliditycalldata \
    proofs/public.json \
    proofs/proof.json

# 출력 예시:
# ["0x1234...", "0x5678..."],
# [["0xabcd...", "0xefgh..."], ["0x1111...", "0x2222..."]],
# ["0x3333...", "0x4444..."],
# ["0x5555...", "0x6666..."]
```

### 1.2 생성된 Groth16 Verifier 분석

```solidity
// contracts/Verifier.sol (snarkjs 생성)
// SPDX-License-Identifier: GPL-3.0
pragma solidity >=0.7.0 <0.9.0;

contract Groth16Verifier {
    // BN254 곡선 상수
    uint256 constant SNARK_SCALAR_FIELD =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;
    uint256 constant PRIME_Q =
        21888242871839275222246405745257275088696311157297823662689037894645226208583;

    // Verification Key (setup에서 생성)
    struct VerifyingKey {
        Pairing.G1Point alfa1;
        Pairing.G2Point beta2;
        Pairing.G2Point gamma2;
        Pairing.G2Point delta2;
        Pairing.G1Point[] IC;  // public input 개수 + 1
    }

    // verifyProof 함수
    function verifyProof(
        uint[2] calldata _pA,      // proof.pi_a
        uint[2][2] calldata _pB,   // proof.pi_b
        uint[2] calldata _pC,      // proof.pi_c
        uint[N] calldata _pubSignals  // public signals
    ) public view returns (bool) {
        // 1. public input 검증
        // 2. vk_x 계산: IC[0] + Σ pubSignals[i] * IC[i+1]
        // 3. Pairing check 수행
        // 4. 결과 반환
    }
}
```

### 1.3 Verifier 최적화

```solidity
// contracts/OptimizedVerifier.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/// @title Optimized Groth16 Verifier
/// @notice 가스 최적화된 Groth16 검증자
contract OptimizedVerifier {
    // 상수로 직접 선언 (SLOAD 비용 절감)
    uint256 private constant SNARK_SCALAR_FIELD =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;

    // Verification Key를 상수로 하드코딩
    uint256 private constant VK_ALPHA_X = 0x...;
    uint256 private constant VK_ALPHA_Y = 0x...;
    // ... 나머지 VK 요소들

    // IC (Input Commitments) - public input 수에 따라
    uint256 private constant IC0_X = 0x...;
    uint256 private constant IC0_Y = 0x...;
    uint256 private constant IC1_X = 0x...;
    uint256 private constant IC1_Y = 0x...;
    // ...

    /// @notice ZK 증명 검증
    /// @param proof 증명 데이터 [pA[2], pB[2][2], pC[2]]
    /// @param pubSignals 공개 신호
    /// @return valid 검증 성공 여부
    function verifyProof(
        uint256[8] calldata proof,
        uint256[2] calldata pubSignals  // 예: 2개의 public signal
    ) external view returns (bool valid) {
        assembly {
            // 메모리 할당
            let f := mload(0x40)

            // 1. public input 범위 검증
            let pubSignal0 := calldataload(add(pubSignals.offset, 0x00))
            let pubSignal1 := calldataload(add(pubSignals.offset, 0x20))

            if iszero(lt(pubSignal0, SNARK_SCALAR_FIELD)) {
                mstore(0, 0)
                return(0, 0x20)
            }
            if iszero(lt(pubSignal1, SNARK_SCALAR_FIELD)) {
                mstore(0, 0)
                return(0, 0x20)
            }

            // 2. vk_x 계산: IC[0] + pubSignals[0] * IC[1] + pubSignals[1] * IC[2]
            // ecMul(IC[1], pubSignals[0])
            mstore(f, IC1_X)
            mstore(add(f, 0x20), IC1_Y)
            mstore(add(f, 0x40), pubSignal0)
            if iszero(staticcall(gas(), 7, f, 0x60, f, 0x40)) {
                mstore(0, 0)
                return(0, 0x20)
            }

            // ecAdd(result, IC[0])
            mstore(add(f, 0x40), IC0_X)
            mstore(add(f, 0x60), IC0_Y)
            if iszero(staticcall(gas(), 6, f, 0x80, f, 0x40)) {
                mstore(0, 0)
                return(0, 0x20)
            }

            // ... IC[2] 처리 ...

            // 3. Pairing check
            // e(pA, pB) == e(alpha, beta) * e(vk_x, gamma) * e(pC, delta)
            // 또는 동등하게:
            // e(-pA, pB) * e(alpha, beta) * e(vk_x, gamma) * e(pC, delta) == 1

            // pairing precompile (0x08) 호출
            // 입력: 6개 점의 좌표
            // ...

            // 결과 확인
            valid := mload(f)
        }
    }
}
```

---

## 2. 애플리케이션 컨트랙트 설계

### 2.1 기본 통합 패턴

```solidity
// contracts/ZKApplication.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./Verifier.sol";

/// @title ZK 증명 기반 애플리케이션
contract ZKApplication {
    Groth16Verifier public immutable verifier;

    // 상태 변수
    mapping(bytes32 => bool) public nullifierUsed;
    bytes32 public merkleRoot;

    // 이벤트
    event ActionExecuted(
        bytes32 indexed nullifierHash,
        address indexed actor,
        uint256 timestamp
    );

    constructor(address _verifier, bytes32 _merkleRoot) {
        verifier = Groth16Verifier(_verifier);
        merkleRoot = _merkleRoot;
    }

    /// @notice ZK 증명으로 보호된 액션 실행
    /// @param proof Groth16 증명
    /// @param pubSignals 공개 신호 [merkleRoot, nullifierHash, commitment]
    function executeAction(
        uint256[8] calldata proof,
        uint256[3] calldata pubSignals
    ) external {
        // 1. 공개 입력 추출
        bytes32 proofMerkleRoot = bytes32(pubSignals[0]);
        bytes32 nullifierHash = bytes32(pubSignals[1]);
        bytes32 commitment = bytes32(pubSignals[2]);

        // 2. 상태 검증
        require(proofMerkleRoot == merkleRoot, "Invalid merkle root");
        require(!nullifierUsed[nullifierHash], "Nullifier already used");

        // 3. ZK 증명 검증
        require(
            verifier.verifyProof(
                [proof[0], proof[1]],
                [[proof[2], proof[3]], [proof[4], proof[5]]],
                [proof[6], proof[7]],
                pubSignals
            ),
            "Invalid proof"
        );

        // 4. nullifier 마킹 (이중 사용 방지)
        nullifierUsed[nullifierHash] = true;

        // 5. 액션 실행
        _executeAction(commitment);

        emit ActionExecuted(nullifierHash, msg.sender, block.timestamp);
    }

    function _executeAction(bytes32 commitment) internal virtual {
        // 구체적인 액션 구현
    }
}
```

### 2.2 비공개 토큰 전송

```solidity
// contracts/PrivateToken.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./Verifier.sol";
import "@openzeppelin/contracts/security/ReentrancyGuard.sol";

/// @title 비공개 토큰 (UTXO 모델)
contract PrivateToken is ReentrancyGuard {
    Groth16Verifier public immutable verifier;

    // Merkle Tree 상태
    uint256 public constant TREE_DEPTH = 20;
    uint256 public nextLeafIndex;
    mapping(uint256 => bytes32) public filledSubtrees;
    bytes32 public currentRoot;
    mapping(bytes32 => bool) public roots;  // 유효한 루트 히스토리

    // Nullifier 추적
    mapping(bytes32 => bool) public nullifierUsed;

    // UTXO commitment 저장
    mapping(bytes32 => bool) public commitments;

    // 이벤트
    event Deposit(
        bytes32 indexed commitment,
        uint256 leafIndex,
        uint256 timestamp
    );

    event Withdrawal(
        bytes32 indexed nullifierHash,
        address indexed recipient,
        uint256 amount
    );

    event Transfer(
        bytes32[] inputNullifiers,
        bytes32[] outputCommitments
    );

    constructor(address _verifier) {
        verifier = Groth16Verifier(_verifier);
        _initializeMerkleTree();
    }

    /// @notice 토큰 입금 (공개 → 비공개)
    function deposit(bytes32 commitment) external payable nonReentrant {
        require(msg.value > 0, "Amount must be positive");
        require(!commitments[commitment], "Commitment already exists");

        // Merkle tree에 commitment 추가
        uint256 leafIndex = nextLeafIndex;
        _insertLeaf(commitment);

        commitments[commitment] = true;

        emit Deposit(commitment, leafIndex, block.timestamp);
    }

    /// @notice 토큰 출금 (비공개 → 공개)
    /// @param proof 출금 증명
    /// @param pubSignals [root, nullifierHash, recipient, amount]
    function withdraw(
        uint256[8] calldata proof,
        uint256[4] calldata pubSignals
    ) external nonReentrant {
        bytes32 root = bytes32(pubSignals[0]);
        bytes32 nullifierHash = bytes32(pubSignals[1]);
        address recipient = address(uint160(pubSignals[2]));
        uint256 amount = pubSignals[3];

        // 1. 루트 유효성 검증
        require(isKnownRoot(root), "Unknown merkle root");

        // 2. Nullifier 중복 검증
        require(!nullifierUsed[nullifierHash], "Already withdrawn");

        // 3. ZK 증명 검증
        require(
            verifier.verifyProof(
                [proof[0], proof[1]],
                [[proof[2], proof[3]], [proof[4], proof[5]]],
                [proof[6], proof[7]],
                pubSignals
            ),
            "Invalid withdrawal proof"
        );

        // 4. Nullifier 마킹
        nullifierUsed[nullifierHash] = true;

        // 5. 토큰 전송
        (bool success, ) = recipient.call{value: amount}("");
        require(success, "Transfer failed");

        emit Withdrawal(nullifierHash, recipient, amount);
    }

    /// @notice 비공개 전송
    /// @param proof 전송 증명
    /// @param pubSignals [root, nullifier1, nullifier2, commitment1, commitment2]
    function transfer(
        uint256[8] calldata proof,
        uint256[5] calldata pubSignals
    ) external nonReentrant {
        bytes32 root = bytes32(pubSignals[0]);
        bytes32 nullifier1 = bytes32(pubSignals[1]);
        bytes32 nullifier2 = bytes32(pubSignals[2]);
        bytes32 outCommitment1 = bytes32(pubSignals[3]);
        bytes32 outCommitment2 = bytes32(pubSignals[4]);

        // 1. 루트 검증
        require(isKnownRoot(root), "Unknown merkle root");

        // 2. Nullifier 검증
        require(!nullifierUsed[nullifier1], "Nullifier 1 used");
        require(!nullifierUsed[nullifier2], "Nullifier 2 used");

        // 3. ZK 증명 검증
        require(
            verifier.verifyProof(
                [proof[0], proof[1]],
                [[proof[2], proof[3]], [proof[4], proof[5]]],
                [proof[6], proof[7]],
                pubSignals
            ),
            "Invalid transfer proof"
        );

        // 4. Nullifiers 마킹
        nullifierUsed[nullifier1] = true;
        nullifierUsed[nullifier2] = true;

        // 5. 새 commitment 추가
        _insertLeaf(outCommitment1);
        _insertLeaf(outCommitment2);

        bytes32[] memory nullifiers = new bytes32[](2);
        nullifiers[0] = nullifier1;
        nullifiers[1] = nullifier2;

        bytes32[] memory outputs = new bytes32[](2);
        outputs[0] = outCommitment1;
        outputs[1] = outCommitment2;

        emit Transfer(nullifiers, outputs);
    }

    // Merkle Tree 관리 함수들
    function _initializeMerkleTree() internal {
        bytes32 zero = bytes32(0);
        for (uint256 i = 0; i < TREE_DEPTH; i++) {
            filledSubtrees[i] = zero;
            zero = _hashPair(zero, zero);
        }
        currentRoot = zero;
        roots[currentRoot] = true;
    }

    function _insertLeaf(bytes32 leaf) internal {
        uint256 index = nextLeafIndex;
        require(index < 2**TREE_DEPTH, "Merkle tree full");

        bytes32 currentHash = leaf;
        uint256 currentIndex = index;

        for (uint256 i = 0; i < TREE_DEPTH; i++) {
            if (currentIndex % 2 == 0) {
                filledSubtrees[i] = currentHash;
                currentHash = _hashPair(currentHash, _zeros(i));
            } else {
                currentHash = _hashPair(filledSubtrees[i], currentHash);
            }
            currentIndex /= 2;
        }

        currentRoot = currentHash;
        roots[currentRoot] = true;
        nextLeafIndex++;
    }

    function isKnownRoot(bytes32 root) public view returns (bool) {
        return roots[root];
    }

    function _hashPair(bytes32 left, bytes32 right) internal pure returns (bytes32) {
        // Poseidon 또는 MiMC 해시 사용
        // 실제로는 precompile 또는 라이브러리 사용
        return keccak256(abi.encodePacked(left, right));
    }

    function _zeros(uint256 level) internal pure returns (bytes32) {
        // 미리 계산된 zero 값들 반환
        // ...
    }
}
```

### 2.3 비밀 투표 시스템

```solidity
// contracts/SecretVoting.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

import "./Verifier.sol";

/// @title 비밀 투표 시스템
contract SecretVoting {
    Groth16Verifier public immutable verifier;

    // 투표 상태
    enum VoteState { NotStarted, Active, Ended }

    struct Proposal {
        string description;
        uint256 startTime;
        uint256 endTime;
        bytes32 voterMerkleRoot;
        uint256 yesVotes;
        uint256 noVotes;
        VoteState state;
    }

    // 상태 변수
    uint256 public proposalCount;
    mapping(uint256 => Proposal) public proposals;
    mapping(uint256 => mapping(bytes32 => bool)) public nullifierUsed;

    // 이벤트
    event ProposalCreated(
        uint256 indexed proposalId,
        string description,
        bytes32 voterMerkleRoot
    );

    event VoteCast(
        uint256 indexed proposalId,
        bytes32 indexed nullifierHash,
        bool encrypted  // 실제 투표 내용은 비공개
    );

    event ProposalEnded(
        uint256 indexed proposalId,
        uint256 yesVotes,
        uint256 noVotes
    );

    constructor(address _verifier) {
        verifier = Groth16Verifier(_verifier);
    }

    /// @notice 새 제안 생성
    function createProposal(
        string calldata description,
        bytes32 voterMerkleRoot,
        uint256 duration
    ) external returns (uint256 proposalId) {
        proposalId = proposalCount++;

        proposals[proposalId] = Proposal({
            description: description,
            startTime: block.timestamp,
            endTime: block.timestamp + duration,
            voterMerkleRoot: voterMerkleRoot,
            yesVotes: 0,
            noVotes: 0,
            state: VoteState.Active
        });

        emit ProposalCreated(proposalId, description, voterMerkleRoot);
    }

    /// @notice 비밀 투표
    /// @param proposalId 제안 ID
    /// @param proof ZK 증명
    /// @param pubSignals [merkleRoot, nullifierHash, voteCommitment, vote(encrypted)]
    function vote(
        uint256 proposalId,
        uint256[8] calldata proof,
        uint256[4] calldata pubSignals
    ) external {
        Proposal storage proposal = proposals[proposalId];

        // 1. 투표 기간 검증
        require(proposal.state == VoteState.Active, "Voting not active");
        require(block.timestamp <= proposal.endTime, "Voting ended");

        bytes32 merkleRoot = bytes32(pubSignals[0]);
        bytes32 nullifierHash = bytes32(pubSignals[1]);
        // pubSignals[2]: vote commitment (검증에만 사용)
        uint256 voteValue = pubSignals[3];  // 0 또는 1

        // 2. Merkle root 검증
        require(
            merkleRoot == proposal.voterMerkleRoot,
            "Invalid voter set"
        );

        // 3. 중복 투표 검증
        require(
            !nullifierUsed[proposalId][nullifierHash],
            "Already voted"
        );

        // 4. ZK 증명 검증
        require(
            verifier.verifyProof(
                [proof[0], proof[1]],
                [[proof[2], proof[3]], [proof[4], proof[5]]],
                [proof[6], proof[7]],
                pubSignals
            ),
            "Invalid vote proof"
        );

        // 5. 투표 기록
        nullifierUsed[proposalId][nullifierHash] = true;

        // 6. 투표 집계 (vote는 회로에서 0 또는 1로 검증됨)
        if (voteValue == 1) {
            proposal.yesVotes++;
        } else {
            proposal.noVotes++;
        }

        emit VoteCast(proposalId, nullifierHash, true);
    }

    /// @notice 투표 종료
    function endProposal(uint256 proposalId) external {
        Proposal storage proposal = proposals[proposalId];

        require(proposal.state == VoteState.Active, "Not active");
        require(block.timestamp > proposal.endTime, "Not ended yet");

        proposal.state = VoteState.Ended;

        emit ProposalEnded(proposalId, proposal.yesVotes, proposal.noVotes);
    }

    /// @notice 제안 결과 조회
    function getResult(uint256 proposalId) external view returns (
        uint256 yesVotes,
        uint256 noVotes,
        bool passed
    ) {
        Proposal storage proposal = proposals[proposalId];
        require(proposal.state == VoteState.Ended, "Not ended");

        yesVotes = proposal.yesVotes;
        noVotes = proposal.noVotes;
        passed = yesVotes > noVotes;
    }
}
```

---

## 3. 프론트엔드 통합

### 3.1 증명 생성 및 제출

```typescript
// src/zkProver.ts
import { groth16 } from "snarkjs";
import { ethers } from "ethers";

interface ProofResult {
    proof: {
        a: [string, string];
        b: [[string, string], [string, string]];
        c: [string, string];
    };
    publicSignals: string[];
}

export class ZKProver {
    private wasmPath: string;
    private zkeyPath: string;

    constructor(wasmPath: string, zkeyPath: string) {
        this.wasmPath = wasmPath;
        this.zkeyPath = zkeyPath;
    }

    async generateProof(input: Record<string, any>): Promise<ProofResult> {
        console.log("Generating proof with input:", input);

        const { proof, publicSignals } = await groth16.fullProve(
            input,
            this.wasmPath,
            this.zkeyPath
        );

        // Solidity 형식으로 변환
        return {
            proof: {
                a: [proof.pi_a[0], proof.pi_a[1]],
                b: [
                    [proof.pi_b[0][1], proof.pi_b[0][0]],  // 순서 주의!
                    [proof.pi_b[1][1], proof.pi_b[1][0]]
                ],
                c: [proof.pi_c[0], proof.pi_c[1]]
            },
            publicSignals
        };
    }

    // 컨트랙트 calldata 형식으로 변환
    formatCalldata(proofResult: ProofResult): {
        proof: string[];
        pubSignals: string[];
    } {
        const { proof, publicSignals } = proofResult;

        return {
            proof: [
                proof.a[0], proof.a[1],
                proof.b[0][0], proof.b[0][1],
                proof.b[1][0], proof.b[1][1],
                proof.c[0], proof.c[1]
            ],
            pubSignals: publicSignals
        };
    }
}
```

### 3.2 React Hook

```typescript
// src/hooks/useZKProof.ts
import { useState, useCallback } from "react";
import { useAccount, useContractWrite, usePrepareContractWrite } from "wagmi";
import { ZKProver } from "../zkProver";

interface UseZKProofOptions {
    wasmPath: string;
    zkeyPath: string;
    contractAddress: string;
    contractAbi: any[];
    functionName: string;
}

interface UseZKProofReturn {
    generateAndSubmit: (input: Record<string, any>) => Promise<void>;
    isGenerating: boolean;
    isSubmitting: boolean;
    error: Error | null;
    txHash: string | null;
}

export function useZKProof(options: UseZKProofOptions): UseZKProofReturn {
    const { wasmPath, zkeyPath, contractAddress, contractAbi, functionName } = options;

    const [isGenerating, setIsGenerating] = useState(false);
    const [proofData, setProofData] = useState<{
        proof: string[];
        pubSignals: string[];
    } | null>(null);
    const [error, setError] = useState<Error | null>(null);

    const prover = new ZKProver(wasmPath, zkeyPath);

    // 컨트랙트 쓰기 준비
    const { config } = usePrepareContractWrite({
        address: contractAddress as `0x${string}`,
        abi: contractAbi,
        functionName,
        args: proofData ? [proofData.proof, proofData.pubSignals] : undefined,
        enabled: !!proofData
    });

    const { write, isLoading: isSubmitting, data: txData } = useContractWrite(config);

    const generateAndSubmit = useCallback(async (input: Record<string, any>) => {
        try {
            setIsGenerating(true);
            setError(null);

            // 1. 증명 생성
            console.log("Generating proof...");
            const proofResult = await prover.generateProof(input);

            // 2. calldata 형식으로 변환
            const calldata = prover.formatCalldata(proofResult);
            setProofData(calldata);

            // 3. 트랜잭션 제출
            console.log("Submitting transaction...");
            if (write) {
                write();
            }
        } catch (err) {
            console.error("ZK proof error:", err);
            setError(err as Error);
        } finally {
            setIsGenerating(false);
        }
    }, [prover, write]);

    return {
        generateAndSubmit,
        isGenerating,
        isSubmitting,
        error,
        txHash: txData?.hash || null
    };
}
```

### 3.3 투표 컴포넌트 예시

```tsx
// src/components/SecretVote.tsx
import React, { useState } from "react";
import { useZKProof } from "../hooks/useZKProof";
import { buildPoseidon } from "circomlibjs";
import VotingABI from "../abi/SecretVoting.json";

interface VoteFormProps {
    proposalId: number;
    voterSecret: string;
    merkleProof: {
        pathElements: string[];
        pathIndices: number[];
        root: string;
    };
}

export function SecretVoteForm({ proposalId, voterSecret, merkleProof }: VoteFormProps) {
    const [vote, setVote] = useState<0 | 1>(1);
    const [status, setStatus] = useState<string>("");

    const { generateAndSubmit, isGenerating, isSubmitting, error, txHash } = useZKProof({
        wasmPath: "/circuits/vote.wasm",
        zkeyPath: "/circuits/vote_final.zkey",
        contractAddress: process.env.REACT_APP_VOTING_CONTRACT!,
        contractAbi: VotingABI,
        functionName: "vote"
    });

    const handleVote = async () => {
        try {
            setStatus("Preparing vote...");

            // Poseidon 해시 계산
            const poseidon = await buildPoseidon();
            const F = poseidon.F;

            // Nullifier 계산
            const nullifierHash = F.toString(
                poseidon([BigInt(voterSecret), BigInt(merkleProof.root)])
            );

            // Vote commitment 계산
            const voteCommitment = F.toString(
                poseidon([BigInt(vote), BigInt(voterSecret)])
            );

            // 회로 입력 준비
            const input = {
                // Private inputs
                secret: voterSecret,
                vote: vote.toString(),
                pathElements: merkleProof.pathElements,
                pathIndices: merkleProof.pathIndices,

                // Public inputs (회로에서 검증)
                merkleRoot: merkleProof.root,
                nullifierHash: nullifierHash,
                voteCommitment: voteCommitment
            };

            setStatus("Generating ZK proof...");
            await generateAndSubmit(input);

            setStatus("Vote submitted!");
        } catch (err) {
            console.error("Vote error:", err);
            setStatus(`Error: ${(err as Error).message}`);
        }
    };

    return (
        <div className="vote-form">
            <h2>Proposal #{proposalId}</h2>

            <div className="vote-options">
                <label>
                    <input
                        type="radio"
                        name="vote"
                        checked={vote === 1}
                        onChange={() => setVote(1)}
                    />
                    Yes
                </label>
                <label>
                    <input
                        type="radio"
                        name="vote"
                        checked={vote === 0}
                        onChange={() => setVote(0)}
                    />
                    No
                </label>
            </div>

            <button
                onClick={handleVote}
                disabled={isGenerating || isSubmitting}
            >
                {isGenerating ? "Generating Proof..." :
                 isSubmitting ? "Submitting..." :
                 "Cast Secret Vote"}
            </button>

            <div className="status">
                {status && <p>{status}</p>}
                {error && <p className="error">{error.message}</p>}
                {txHash && (
                    <p>
                        Transaction: <a href={`https://etherscan.io/tx/${txHash}`}>{txHash}</a>
                    </p>
                )}
            </div>
        </div>
    );
}
```

---

## 4. 가스 최적화

### 4.1 증명 데이터 압축

```solidity
// contracts/CompressedVerifier.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/// @title 압축된 증명 데이터를 처리하는 Verifier
contract CompressedVerifier {

    /// @notice 압축된 증명 검증
    /// @param compressedProof 압축된 증명 (더 작은 calldata)
    function verifyCompressed(
        bytes calldata compressedProof
    ) external view returns (bool) {
        // 압축 해제
        (
            uint256[2] memory pA,
            uint256[2][2] memory pB,
            uint256[2] memory pC,
            uint256[] memory pubSignals
        ) = _decompress(compressedProof);

        // 검증 수행
        return _verify(pA, pB, pC, pubSignals);
    }

    function _decompress(bytes calldata data)
        internal
        pure
        returns (
            uint256[2] memory,
            uint256[2][2] memory,
            uint256[2] memory,
            uint256[] memory
        )
    {
        // ABI 디코딩
        return abi.decode(data, (uint256[2], uint256[2][2], uint256[2], uint256[]));
    }
}
```

### 4.2 Batch Verification

```solidity
// contracts/BatchVerifier.sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.19;

/// @title 여러 증명을 한 번에 검증
contract BatchVerifier {

    /// @notice 배치 증명 검증
    /// @dev 랜덤 선형 결합으로 여러 증명을 하나로 결합
    function verifyBatch(
        uint256[8][] calldata proofs,
        uint256[][] calldata pubSignals
    ) external view returns (bool) {
        require(proofs.length == pubSignals.length, "Length mismatch");
        require(proofs.length > 0, "Empty batch");

        // 단일 증명은 직접 검증
        if (proofs.length == 1) {
            return _verifySingle(proofs[0], pubSignals[0]);
        }

        // 랜덤 계수 생성 (Fiat-Shamir)
        uint256[] memory coefficients = new uint256[](proofs.length);
        coefficients[0] = 1;

        bytes32 seed = keccak256(abi.encode(proofs, pubSignals));
        for (uint256 i = 1; i < proofs.length; i++) {
            coefficients[i] = uint256(keccak256(abi.encode(seed, i))) % SNARK_SCALAR_FIELD;
        }

        // 선형 결합으로 증명 집계
        // ∑ r_i * proof_i
        uint256[8] memory aggregatedProof = _aggregateProofs(proofs, coefficients);
        uint256[] memory aggregatedPubSignals = _aggregatePubSignals(pubSignals, coefficients);

        // 집계된 증명 검증
        return _verifySingle(aggregatedProof, aggregatedPubSignals);
    }

    uint256 constant SNARK_SCALAR_FIELD = 21888242871839275222246405745257275088548364400416034343698204186575808495617;

    function _aggregateProofs(
        uint256[8][] calldata proofs,
        uint256[] memory coefficients
    ) internal pure returns (uint256[8] memory result) {
        // EC 점들의 가중합 계산
        // 실제로는 assembly로 최적화 필요
    }

    function _aggregatePubSignals(
        uint256[][] calldata pubSignals,
        uint256[] memory coefficients
    ) internal pure returns (uint256[] memory result) {
        // 공개 신호의 가중합
    }

    function _verifySingle(
        uint256[8] calldata proof,
        uint256[] memory pubSignals
    ) internal view returns (bool) {
        // 단일 증명 검증
    }
}
```

### 4.3 가스 비용 비교

```
Groth16 검증 가스 비용:

| 구성 요소 | 가스 비용 |
|-----------|----------|
| Calldata (증명) | ~5,000 |
| Calldata (공개 입력) | ~2,000 * n |
| ecMul (공개 입력 처리) | ~6,000 * n |
| ecAdd | ~500 * n |
| Pairing (3개) | ~180,000 |
| 기타 연산 | ~10,000 |
| 총계 (n=2) | ~220,000 |

최적화 후:
| 최적화 | 절감 |
|--------|------|
| 상수화된 VK | ~5,000 |
| Assembly 사용 | ~10,000 |
| Calldata 압축 | ~2,000 |
| 총 절감 | ~17,000 (8%) |

PLONK vs Groth16:
| 시스템 | 가스 비용 |
|--------|----------|
| Groth16 | ~220,000 |
| PLONK | ~300,000 |
| FFLONK | ~250,000 |
```

---

## 5. 테스트

### 5.1 Hardhat 테스트

```typescript
// test/ZKApplication.test.ts
import { expect } from "chai";
import { ethers } from "hardhat";
import { groth16 } from "snarkjs";
import path from "path";

describe("ZKApplication", function () {
    let verifier: any;
    let zkApp: any;
    let owner: any;

    const wasmPath = path.join(__dirname, "../build/circuit_js/circuit.wasm");
    const zkeyPath = path.join(__dirname, "../keys/circuit_final.zkey");

    before(async function () {
        [owner] = await ethers.getSigners();

        // Verifier 배포
        const Verifier = await ethers.getContractFactory("Groth16Verifier");
        verifier = await Verifier.deploy();

        // 애플리케이션 배포
        const merkleRoot = ethers.utils.hexZeroPad("0x1234", 32);
        const ZKApp = await ethers.getContractFactory("ZKApplication");
        zkApp = await ZKApp.deploy(verifier.address, merkleRoot);
    });

    it("should verify valid proof", async function () {
        // 입력 준비
        const input = {
            a: "123",
            b: "456",
            merkleRoot: "0x1234",
            secret: "789"
        };

        // 증명 생성
        const { proof, publicSignals } = await groth16.fullProve(
            input,
            wasmPath,
            zkeyPath
        );

        // Solidity calldata 형식으로 변환
        const proofFormatted = [
            proof.pi_a[0], proof.pi_a[1],
            proof.pi_b[0][1], proof.pi_b[0][0],
            proof.pi_b[1][1], proof.pi_b[1][0],
            proof.pi_c[0], proof.pi_c[1]
        ];

        // 트랜잭션 실행
        const tx = await zkApp.executeAction(proofFormatted, publicSignals);
        await tx.wait();

        // 이벤트 확인
        const events = await zkApp.queryFilter(zkApp.filters.ActionExecuted());
        expect(events.length).to.equal(1);
    });

    it("should reject invalid proof", async function () {
        // 잘못된 증명
        const invalidProof = Array(8).fill("0");
        const invalidPubSignals = ["1", "2", "3"];

        await expect(
            zkApp.executeAction(invalidProof, invalidPubSignals)
        ).to.be.revertedWith("Invalid proof");
    });

    it("should reject double spend", async function () {
        // 첫 번째 증명 생성 및 제출
        const input = { /* ... */ };
        const { proof, publicSignals } = await groth16.fullProve(input, wasmPath, zkeyPath);
        const proofFormatted = [/* ... */];

        await zkApp.executeAction(proofFormatted, publicSignals);

        // 같은 nullifier로 다시 시도
        await expect(
            zkApp.executeAction(proofFormatted, publicSignals)
        ).to.be.revertedWith("Nullifier already used");
    });
});
```

### 5.2 가스 리포트

```javascript
// hardhat.config.js
require("hardhat-gas-reporter");

module.exports = {
    gasReporter: {
        enabled: true,
        currency: "USD",
        gasPrice: 30,  // Gwei
        coinmarketcap: process.env.COINMARKETCAP_API_KEY,
        outputFile: "gas-report.txt",
        noColors: true
    }
};

// 실행
// npx hardhat test --network hardhat

// 출력 예시:
// ·-----------------------------|---------------------------|-------------|-----------------------------·
// |     Solc version: 0.8.19    ·  Optimizer enabled: true  ·  Runs: 200  ·  Block limit: 30000000 gas  │
// ······························|···························|·············|······························
// |  Methods                                                                                             │
// ·············|················|·············|·············|·············|···············|··············
// |  Contract  ·  Method        ·  Min        ·  Max        ·  Avg        ·  # calls      ·  usd (avg)  │
// ·············|················|·············|·············|·············|···············|··············
// |  ZKApp     ·  executeAction ·    218,432  ·    225,891  ·    222,156  ·           10  ·       8.67  │
// ·············|················|·············|·············|·············|···············|··············
```

---

## 6. 배포

### 6.1 배포 스크립트

```typescript
// scripts/deploy.ts
import { ethers, run } from "hardhat";

async function main() {
    console.log("Deploying ZK contracts...");

    // 1. Verifier 배포
    console.log("Deploying Verifier...");
    const Verifier = await ethers.getContractFactory("Groth16Verifier");
    const verifier = await Verifier.deploy();
    await verifier.deployed();
    console.log("Verifier deployed to:", verifier.address);

    // 2. 애플리케이션 배포
    console.log("Deploying ZKApplication...");
    const merkleRoot = ethers.utils.hexZeroPad("0x0", 32);  // 초기 루트
    const ZKApp = await ethers.getContractFactory("ZKApplication");
    const zkApp = await ZKApp.deploy(verifier.address, merkleRoot);
    await zkApp.deployed();
    console.log("ZKApplication deployed to:", zkApp.address);

    // 3. 컨트랙트 검증 (Etherscan)
    if (process.env.ETHERSCAN_API_KEY) {
        console.log("Verifying contracts on Etherscan...");

        await run("verify:verify", {
            address: verifier.address,
            constructorArguments: []
        });

        await run("verify:verify", {
            address: zkApp.address,
            constructorArguments: [verifier.address, merkleRoot]
        });
    }

    console.log("Deployment complete!");
    console.log({
        verifier: verifier.address,
        zkApp: zkApp.address
    });
}

main().catch((error) => {
    console.error(error);
    process.exitCode = 1;
});
```

### 6.2 Hardhat 설정

```typescript
// hardhat.config.ts
import { HardhatUserConfig } from "hardhat/config";
import "@nomicfoundation/hardhat-toolbox";
import "hardhat-gas-reporter";
import "hardhat-contract-sizer";
import * as dotenv from "dotenv";

dotenv.config();

const config: HardhatUserConfig = {
    solidity: {
        version: "0.8.19",
        settings: {
            optimizer: {
                enabled: true,
                runs: 200
            },
            viaIR: true  // 추가 최적화
        }
    },
    networks: {
        hardhat: {
            allowUnlimitedContractSize: true
        },
        sepolia: {
            url: process.env.SEPOLIA_RPC_URL || "",
            accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : []
        },
        mainnet: {
            url: process.env.MAINNET_RPC_URL || "",
            accounts: process.env.PRIVATE_KEY ? [process.env.PRIVATE_KEY] : []
        }
    },
    etherscan: {
        apiKey: process.env.ETHERSCAN_API_KEY
    },
    gasReporter: {
        enabled: true,
        currency: "USD"
    },
    contractSizer: {
        alphaSort: true,
        runOnCompile: true
    }
};

export default config;
```

---

## 7. 보안 고려사항

### 7.1 일반적인 취약점

```solidity
// 취약점 1: Nullifier 충돌
// 잘못된 예
function withdraw(bytes32 nullifier) external {
    require(!used[nullifier], "Used");
    used[nullifier] = true;
    // ... nullifier가 증명과 일치하는지 검증 안 함!
}

// 올바른 예
function withdraw(uint256[8] calldata proof, uint256[3] calldata pubSignals) external {
    bytes32 nullifier = bytes32(pubSignals[1]);
    require(!used[nullifier], "Used");

    // 증명 검증에서 nullifier 포함
    require(verifier.verifyProof(...), "Invalid proof");

    used[nullifier] = true;
}

// 취약점 2: Merkle Root 관리
// 잘못된 예 - 오래된 root 허용
function verify(bytes32 root) external view returns (bool) {
    return roots[root];  // 오래된 root도 유효
}

// 올바른 예 - root 히스토리 제한
uint256 constant ROOT_HISTORY_SIZE = 100;
bytes32[ROOT_HISTORY_SIZE] public rootHistory;
uint256 public currentRootIndex;

function isKnownRoot(bytes32 root) public view returns (bool) {
    if (root == 0) return false;
    uint256 i = currentRootIndex;
    do {
        if (root == rootHistory[i]) return true;
        if (i == 0) i = ROOT_HISTORY_SIZE;
        i--;
    } while (i != currentRootIndex);
    return false;
}

// 취약점 3: Front-running
// 증명 제출 시 msg.sender 바인딩 필요
// 회로에서 recipient를 public input으로 포함
```

### 7.2 보안 체크리스트

```
[ ] 회로 보안
    [ ] 모든 제약 조건 검증됨
    [ ] Under-constrained 없음
    [ ] 경계 조건 테스트 완료

[ ] 컨트랙트 보안
    [ ] Reentrancy 방어
    [ ] Integer overflow 검사
    [ ] Access control 설정
    [ ] Nullifier 중복 검증
    [ ] Merkle root 검증

[ ] 통합 보안
    [ ] Front-running 방어
    [ ] MEV 고려
    [ ] 가스 한도 테스트

[ ] 운영 보안
    [ ] 키 관리
    [ ] 업그레이드 메커니즘
    [ ] 비상 정지 기능
```

---

## 요약

```
스마트 컨트랙트 통합 핵심:

1. Verifier 생성:
   snarkjs zkey export solidityverifier
   - Groth16: ~220K gas
   - PLONK: ~300K gas

2. 애플리케이션 설계:
   - Nullifier로 이중 사용 방지
   - Merkle root로 멤버십 검증
   - 공개 입력/출력 분리

3. 프론트엔드 통합:
   - snarkjs로 브라우저 증명 생성
   - ethers.js로 트랜잭션 제출
   - React hooks로 상태 관리

4. 가스 최적화:
   - VK 상수화
   - Assembly 사용
   - Batch verification

5. 테스트:
   - Hardhat + snarkjs 통합
   - 가스 리포팅
   - 보안 테스트

6. 보안:
   - Nullifier 검증
   - Root 히스토리 관리
   - Front-running 방어
   - 감사 필수
```
