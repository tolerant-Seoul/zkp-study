# 4.1 ZK-Rollup Deep Dive

## 개요

ZK-Rollup은 영지식 증명을 활용하여 Ethereum의 확장성 문제를 해결하는 Layer 2 솔루션입니다. 이 문서에서는 주요 ZK-Rollup 프로젝트들의 아키텍처, 증명 시스템, 그리고 구현 세부사항을 분석합니다.

## ZK-Rollup 핵심 개념

### 기본 아키텍처

```
┌─────────────────────────────────────────────────────────────┐
│                      Layer 1 (Ethereum)                      │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │   Rollup    │  │   Bridge    │  │   Data Availability │  │
│  │  Contract   │  │  Contract   │  │      Contract       │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
                              ▲
                              │ Proof + State Root
                              │
┌─────────────────────────────────────────────────────────────┐
│                      Layer 2 (Rollup)                        │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────────────┐  │
│  │  Sequencer  │──│   Prover    │──│   State Manager     │  │
│  └─────────────┘  └─────────────┘  └─────────────────────┘  │
│         │                                    │               │
│         ▼                                    ▼               │
│  ┌─────────────┐                    ┌─────────────────────┐  │
│  │    Batch    │                    │   Merkle State Tree │  │
│  │  Processor  │                    │                     │  │
│  └─────────────┘                    └─────────────────────┘  │
└─────────────────────────────────────────────────────────────┘
```

### ZK-Rollup 동작 원리

```typescript
// ZK-Rollup 핵심 흐름
interface ZKRollupFlow {
    // 1. 트랜잭션 수집
    collectTransactions(): Transaction[];

    // 2. 배치 생성
    createBatch(txs: Transaction[]): Batch;

    // 3. 상태 전이 실행
    executeStateTransition(batch: Batch): StateTransition;

    // 4. 증명 생성
    generateProof(transition: StateTransition): ZKProof;

    // 5. L1 제출
    submitToL1(proof: ZKProof, newStateRoot: bytes32): void;
}

// 상태 전이 구조
interface StateTransition {
    preStateRoot: bytes32;
    postStateRoot: bytes32;
    transactions: Transaction[];
    publicInputs: PublicInputs;
}
```

---

## zkSync Era

### 아키텍처 개요

zkSync Era는 LLVM 기반 컴파일러를 사용하여 EVM 호환성을 제공하는 ZK-Rollup입니다.

```
┌──────────────────────────────────────────────────────────────┐
│                      zkSync Era Architecture                  │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐     │
│  │   Solidity  │────▶│    zksolc   │────▶│   zkEVM     │     │
│  │    Code     │     │  Compiler   │     │  Bytecode   │     │
│  └─────────────┘     └─────────────┘     └─────────────┘     │
│                                                 │             │
│                                                 ▼             │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                    zkEVM Execution                       │ │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐  ┌──────────┐ │ │
│  │  │  Stack   │  │  Memory  │  │ Storage  │  │  Events  │ │ │
│  │  └──────────┘  └──────────┘  └──────────┘  └──────────┘ │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              │                                │
│                              ▼                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Boojum Proving System (PLONK)               │ │
│  │  • GPU Accelerated                                       │ │
│  │  • Recursive Proofs                                      │ │
│  │  • ~100K constraints per transaction                     │ │
│  └─────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────┘
```

### Boojum 증명 시스템

```rust
// zkSync Boojum 증명 시스템 구조 (Rust)
use boojum::cs::traits::cs::ConstraintSystem;
use boojum::field::goldilocks::GoldilocksField;

// 기본 타입 정의
type F = GoldilocksField;
type P = GoldilocksField;

// 회로 정의
pub struct ZkSyncCircuit<F: SmallField> {
    // 입력 witness
    pub witness: CircuitWitness<F>,
    // 공개 입력
    pub public_inputs: Vec<F>,
    // 설정
    pub config: CircuitConfig,
}

impl<F: SmallField> Circuit<F> for ZkSyncCircuit<F> {
    fn synthesize<CS: ConstraintSystem<F>>(
        &self,
        cs: &mut CS,
    ) -> Result<(), SynthesisError> {
        // 1. 상태 루트 검증
        let pre_state_root = cs.alloc_input(|| self.witness.pre_state_root)?;
        let post_state_root = cs.alloc_input(|| self.witness.post_state_root)?;

        // 2. 트랜잭션 처리
        for tx in &self.witness.transactions {
            self.process_transaction(cs, tx)?;
        }

        // 3. 최종 상태 검증
        cs.enforce_equal(
            computed_state_root,
            post_state_root,
        )?;

        Ok(())
    }
}
```

### zkSync 스마트 컨트랙트 배포

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

// zkSync Era용 컨트랙트 (L2)
contract ZkSyncExample {
    mapping(address => uint256) public balances;

    // zkSync 특화 시스템 컨트랙트
    address constant BOOTLOADER = address(0x8001);
    address constant NONCE_HOLDER = address(0x8003);
    address constant KNOWN_CODES = address(0x8004);

    // 계정 추상화 지원
    function validateTransaction(
        bytes32 _txHash,
        bytes32 _suggestedSignedHash,
        Transaction calldata _transaction
    ) external payable returns (bytes4 magic) {
        // 서명 검증 로직
        require(
            _validateSignature(_suggestedSignedHash, _transaction.signature),
            "Invalid signature"
        );
        return ACCOUNT_VALIDATION_SUCCESS_MAGIC;
    }

    // L1 -> L2 메시지 처리
    function consumeMessageFromL1(
        uint256 _l1MessageIndex,
        uint16 _l1TxNumberInBatch,
        bytes calldata _message,
        bytes32[] calldata _proof
    ) external {
        // Merkle proof 검증
        require(
            _verifyL1Message(_l1MessageIndex, _l1TxNumberInBatch, _message, _proof),
            "Invalid L1 message proof"
        );

        // 메시지 처리
        _processMessage(_message);
    }
}
```

### zkSync SDK 사용

```typescript
import { Provider, Wallet, Contract } from "zksync-ethers";
import { ethers } from "ethers";

// zkSync Era 연결
async function connectToZkSync() {
    // Provider 설정
    const provider = new Provider("https://mainnet.era.zksync.io");

    // 지갑 연결
    const wallet = new Wallet(
        process.env.PRIVATE_KEY!,
        provider
    );

    console.log("Address:", await wallet.getAddress());
    console.log("Balance:", await wallet.getBalance());

    return { provider, wallet };
}

// 컨트랙트 배포
async function deployContract(wallet: Wallet) {
    const artifact = require("./artifacts/MyContract.json");

    // 배포 팩토리
    const factory = new ContractFactory(
        artifact.abi,
        artifact.bytecode,
        wallet
    );

    // 배포 (가스 추정 자동)
    const contract = await factory.deploy();
    await contract.waitForDeployment();

    console.log("Deployed at:", await contract.getAddress());
    return contract;
}

// L1 <-> L2 브릿지
async function bridgeToL2(
    l1Wallet: ethers.Wallet,
    l2Wallet: Wallet,
    amount: bigint
) {
    // L1에서 L2로 ETH 전송
    const depositHandle = await l2Wallet.deposit({
        token: "0x0000000000000000000000000000000000000000", // ETH
        amount: amount,
        to: await l2Wallet.getAddress(),
    });

    // 트랜잭션 완료 대기
    const depositReceipt = await depositHandle.wait();
    console.log("Deposit tx hash:", depositReceipt.hash);

    // L2 확정 대기
    await depositHandle.waitFinalize();
    console.log("Deposit finalized");
}
```

---

## StarkNet

### Cairo 언어와 STARK 증명

StarkNet은 Cairo 언어와 STARK 증명 시스템을 사용합니다.

```
┌──────────────────────────────────────────────────────────────┐
│                    StarkNet Architecture                      │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────┐     ┌─────────────┐     ┌─────────────┐     │
│  │   Cairo     │────▶│   Sierra    │────▶│    CASM    │     │
│  │   Code      │     │     IR      │     │  Bytecode   │     │
│  └─────────────┘     └─────────────┘     └─────────────┘     │
│                                                 │             │
│                                                 ▼             │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   StarkNet OS                            │ │
│  │  • Transaction Execution                                 │ │
│  │  • State Management                                      │ │
│  │  • Fee Calculation                                       │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              │                                │
│                              ▼                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                 STARK Proving System                     │ │
│  │  • AIR (Algebraic Intermediate Representation)          │ │
│  │  • FRI (Fast Reed-Solomon IOP)                          │ │
│  │  • No Trusted Setup Required                            │ │
│  └─────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────┘
```

### Cairo 스마트 컨트랙트

```rust
// Cairo 1.0 컨트랙트 예제
use starknet::ContractAddress;

#[starknet::interface]
trait ICounter<TContractState> {
    fn get_count(self: @TContractState) -> u256;
    fn increment(ref self: TContractState);
    fn decrement(ref self: TContractState);
}

#[starknet::contract]
mod Counter {
    use starknet::ContractAddress;
    use starknet::get_caller_address;

    #[storage]
    struct Storage {
        count: u256,
        owner: ContractAddress,
    }

    #[event]
    #[derive(Drop, starknet::Event)]
    enum Event {
        CountChanged: CountChanged,
    }

    #[derive(Drop, starknet::Event)]
    struct CountChanged {
        #[key]
        from: ContractAddress,
        old_count: u256,
        new_count: u256,
    }

    #[constructor]
    fn constructor(ref self: ContractState, initial_count: u256) {
        self.count.write(initial_count);
        self.owner.write(get_caller_address());
    }

    #[abi(embed_v0)]
    impl CounterImpl of super::ICounter<ContractState> {
        fn get_count(self: @ContractState) -> u256 {
            self.count.read()
        }

        fn increment(ref self: ContractState) {
            let old_count = self.count.read();
            let new_count = old_count + 1;
            self.count.write(new_count);

            self.emit(CountChanged {
                from: get_caller_address(),
                old_count,
                new_count,
            });
        }

        fn decrement(ref self: ContractState) {
            let old_count = self.count.read();
            assert(old_count > 0, 'Count cannot be negative');
            let new_count = old_count - 1;
            self.count.write(new_count);

            self.emit(CountChanged {
                from: get_caller_address(),
                old_count,
                new_count,
            });
        }
    }
}
```

### StarkNet.js SDK

```typescript
import {
    Provider,
    Account,
    Contract,
    CallData,
    cairo,
    stark
} from "starknet";

// StarkNet 연결
async function connectToStarkNet() {
    // Provider 설정
    const provider = new Provider({
        sequencer: { network: "mainnet-alpha" }
    });

    // 계정 연결
    const account = new Account(
        provider,
        process.env.STARKNET_ACCOUNT_ADDRESS!,
        process.env.STARKNET_PRIVATE_KEY!
    );

    return { provider, account };
}

// Cairo 컨트랙트 배포
async function deployContract(account: Account) {
    // 컴파일된 컨트랙트 로드
    const compiledContract = await provider.getClassByHash(
        "0x..." // class hash
    );

    // 배포 트랜잭션
    const deployResponse = await account.deployContract({
        classHash: "0x...",
        constructorCalldata: CallData.compile({
            initial_count: cairo.uint256(0)
        }),
    });

    // 트랜잭션 완료 대기
    await provider.waitForTransaction(deployResponse.transaction_hash);

    return deployResponse.contract_address;
}

// 컨트랙트 호출
async function callContract(
    account: Account,
    contractAddress: string
) {
    // 컨트랙트 인스턴스
    const contract = new Contract(
        counterAbi,
        contractAddress,
        provider
    );
    contract.connect(account);

    // 읽기 호출 (가스 없음)
    const count = await contract.get_count();
    console.log("Current count:", count.toString());

    // 쓰기 호출 (가스 필요)
    const { transaction_hash } = await contract.increment();
    await provider.waitForTransaction(transaction_hash);

    console.log("Incremented!");
}

// 멀티콜 (여러 트랜잭션 묶기)
async function multicall(account: Account, contract: Contract) {
    const calls = [
        contract.populate("increment", []),
        contract.populate("increment", []),
        contract.populate("increment", []),
    ];

    const { transaction_hash } = await account.execute(calls);
    await provider.waitForTransaction(transaction_hash);

    console.log("Executed 3 increments in single tx");
}
```

---

## Polygon zkEVM

### Type 2 zkEVM 아키텍처

Polygon zkEVM은 EVM 바이트코드 수준의 호환성을 제공합니다.

```
┌──────────────────────────────────────────────────────────────┐
│                  Polygon zkEVM Architecture                   │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                    EVM Bytecode                          │ │
│  │  (Solidity/Vyper 컴파일 결과 그대로 사용)                │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              │                                │
│                              ▼                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                  zkEVM ROM Processor                     │ │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐              │ │
│  │  │  Main SM │  │ Memory SM│  │Storage SM│              │ │
│  │  └──────────┘  └──────────┘  └──────────┘              │ │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐              │ │
│  │  │ Arith SM │  │ Binary SM│  │Poseidon SM│             │ │
│  │  └──────────┘  └──────────┘  └──────────┘              │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              │                                │
│                              ▼                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              PIL (Polynomial Identity Language)          │ │
│  │  • Custom constraint system for zkEVM                   │ │
│  │  • 13 state machines for EVM opcodes                    │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              │                                │
│                              ▼                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   FFLONK Prover                          │ │
│  │  • Fast verification (~350K gas)                        │ │
│  │  • Recursive proof aggregation                          │ │
│  └─────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────┘
```

### zkEVM State Machine 구조

```javascript
// Polygon zkEVM 상태 머신 개념 (PIL 기반)
// PIL (Polynomial Identity Language) 예시

/*
 * Main State Machine
 * EVM 실행의 핵심 로직을 담당
 */
namespace Main {
    // 상태 레지스터
    pol commit A, B, C, D, E;      // 범용 레지스터
    pol commit SP;                  // Stack Pointer
    pol commit PC;                  // Program Counter
    pol commit GAS;                 // Remaining Gas
    pol commit zkPC;                // Internal PC for zkEVM

    // Lookup을 위한 셀렉터
    pol commit inA, inB, inC;
    pol commit setA, setB, setC;

    // 다항식 제약조건
    // 레지스터 업데이트 규칙
    A' = setA * (A + inA * FREE) + (1 - setA) * A;
    B' = setB * (B + inB * FREE) + (1 - setB) * B;
    C' = setC * (C + inC * FREE) + (1 - setC) * C;

    // opcode 실행 로직
    pol commit op;
    pol commit isStackOp, isMemoryOp, isStorageOp;

    // 가스 계산
    GAS' = GAS - gasCost;
    GAS >= 0;  // 가스 부족 방지
}

/*
 * Memory State Machine
 * EVM 메모리 연산 처리
 */
namespace Memory {
    pol commit addr;
    pol commit step;
    pol commit mOp;  // memory operation type
    pol commit val;

    // 메모리 일관성 제약
    // 같은 주소, 이전 step의 값과 일치해야 함 (쓰기 전까지)
    (addr' - addr) * (val' - val) * (1 - mOp') === 0;
}

/*
 * Storage State Machine
 * 스토리지 읽기/쓰기 처리
 */
namespace Storage {
    pol commit oldRoot, newRoot;
    pol commit key, valueLow, valueHigh;
    pol commit isSet;

    // SMT(Sparse Merkle Tree) 업데이트 제약
    // Poseidon 해시를 사용한 경로 검증
}
```

### Polygon zkEVM 배포 및 사용

```typescript
import { ethers } from "ethers";

// Polygon zkEVM은 표준 EVM 도구 사용 가능
async function deployToPolygonZkEVM() {
    // 표준 ethers.js Provider
    const provider = new ethers.JsonRpcProvider(
        "https://zkevm-rpc.com"
    );

    const wallet = new ethers.Wallet(
        process.env.PRIVATE_KEY!,
        provider
    );

    // 표준 Solidity 컨트랙트 그대로 배포
    const factory = new ethers.ContractFactory(
        abi,
        bytecode,
        wallet
    );

    const contract = await factory.deploy();
    await contract.waitForDeployment();

    console.log("Deployed at:", await contract.getAddress());
}

// L1 <-> zkEVM 브릿지
async function bridgeAssets() {
    const bridgeContract = new ethers.Contract(
        POLYGON_ZKEVM_BRIDGE_ADDRESS,
        bridgeAbi,
        wallet
    );

    // L1 -> zkEVM 브릿지
    const tx = await bridgeContract.bridgeAsset(
        1,  // destination network (1 = zkEVM)
        destinationAddress,
        ethers.parseEther("1.0"),
        ethers.ZeroAddress,  // ETH
        true,  // force update global exit root
        "0x"   // permit data
    );

    await tx.wait();
    console.log("Bridge initiated:", tx.hash);
}
```

---

## Scroll

### zkEVM Type 2.5 아키텍처

```
┌──────────────────────────────────────────────────────────────┐
│                    Scroll Architecture                        │
├──────────────────────────────────────────────────────────────┤
│                                                               │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   Sequencer Layer                        │ │
│  │  • Transaction ordering                                  │ │
│  │  • Block production                                      │ │
│  │  • State execution                                       │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              │                                │
│                              ▼                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                   Prover Network                         │ │
│  │  ┌──────────┐  ┌──────────┐  ┌──────────┐              │ │
│  │  │Coordinator│  │  Prover  │  │  Prover  │  ...        │ │
│  │  └──────────┘  └──────────┘  └──────────┘              │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              │                                │
│                              ▼                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │                zkEVM Circuit (Halo2)                     │ │
│  │  • EVM Circuit (opcode 실행)                            │ │
│  │  • State Circuit (상태 전이)                            │ │
│  │  • MPT Circuit (Merkle Patricia Trie)                   │ │
│  │  • Keccak Circuit (해시)                                │ │
│  │  • Signature Circuit (ECDSA)                            │ │
│  └─────────────────────────────────────────────────────────┘ │
│                              │                                │
│                              ▼                                │
│  ┌─────────────────────────────────────────────────────────┐ │
│  │              Aggregation Circuit                         │ │
│  │  • Batch proof aggregation                              │ │
│  │  • Final SNARK proof for L1                             │ │
│  └─────────────────────────────────────────────────────────┘ │
└──────────────────────────────────────────────────────────────┘
```

### Scroll zkEVM 회로 구조

```rust
// Scroll zkEVM Halo2 회로 구조
use halo2_proofs::{
    circuit::{Layouter, SimpleFloorPlanner, Value},
    plonk::{Circuit, ConstraintSystem, Error},
    poly::Rotation,
};

/// EVM 회로 - 각 opcode 실행 증명
pub struct EvmCircuit<F: Field> {
    /// 트랜잭션 목록
    pub txs: Vec<Transaction>,
    /// 실행 추적
    pub execution_trace: ExecutionTrace,
    /// 최대 단계 수
    pub max_steps: usize,
}

impl<F: Field> Circuit<F> for EvmCircuit<F> {
    type Config = EvmCircuitConfig<F>;
    type FloorPlanner = SimpleFloorPlanner;

    fn configure(meta: &mut ConstraintSystem<F>) -> Self::Config {
        // 각 opcode 별 제약조건 설정
        let config = EvmCircuitConfig::configure(meta, |meta| {
            // Stack 연산 제약
            let stack_config = StackConfig::configure(meta);

            // Memory 연산 제약
            let memory_config = MemoryConfig::configure(meta);

            // Storage 연산 제약
            let storage_config = StorageConfig::configure(meta);

            // Opcode 특화 제약
            OpcodeConfig {
                add: AddGadget::configure(meta),
                mul: MulGadget::configure(meta),
                call: CallGadget::configure(meta),
                sload: SloadGadget::configure(meta),
                sstore: SstoreGadget::configure(meta),
                // ... 모든 opcode
            }
        });

        config
    }

    fn synthesize(
        &self,
        config: Self::Config,
        mut layouter: impl Layouter<F>,
    ) -> Result<(), Error> {
        // 실행 추적을 회로에 할당
        for (step_idx, step) in self.execution_trace.steps.iter().enumerate() {
            layouter.assign_region(
                || format!("step {}", step_idx),
                |mut region| {
                    config.assign_step(&mut region, step)
                }
            )?;
        }

        Ok(())
    }
}

/// State 회로 - 상태 전이 증명
pub struct StateCircuit<F: Field> {
    pub pre_state_root: F,
    pub post_state_root: F,
    pub state_updates: Vec<StateUpdate>,
}

impl<F: Field> Circuit<F> for StateCircuit<F> {
    // MPT 업데이트 증명
    fn synthesize(
        &self,
        config: Self::Config,
        mut layouter: impl Layouter<F>,
    ) -> Result<(), Error> {
        // 각 상태 업데이트에 대해 MPT 경로 검증
        for update in &self.state_updates {
            config.verify_mpt_update(
                &mut layouter,
                &update.old_proof,
                &update.new_proof,
                &update.key,
                &update.old_value,
                &update.new_value,
            )?;
        }

        Ok(())
    }
}
```

### Scroll SDK 사용

```typescript
import { ethers } from "ethers";

// Scroll은 표준 EVM 호환
async function deployToScroll() {
    const provider = new ethers.JsonRpcProvider(
        "https://rpc.scroll.io"
    );

    const wallet = new ethers.Wallet(
        process.env.PRIVATE_KEY!,
        provider
    );

    // 표준 배포
    const factory = new ethers.ContractFactory(abi, bytecode, wallet);
    const contract = await factory.deploy();
    await contract.waitForDeployment();

    return contract;
}

// Scroll 브릿지
async function bridgeToScroll(l1Wallet: ethers.Wallet) {
    const messengerContract = new ethers.Contract(
        SCROLL_MESSENGER_ADDRESS,
        messengerAbi,
        l1Wallet
    );

    // L1 -> L2 메시지 전송
    const tx = await messengerContract.sendMessage(
        l2TargetAddress,
        0n,  // value
        "0x",  // message data
        gasLimit,
        { value: ethers.parseEther("0.1") }  // 브릿지 비용
    );

    await tx.wait();
}
```

---

## ZK-Rollup 비교 분석

### 기술 스택 비교

| 특성 | zkSync Era | StarkNet | Polygon zkEVM | Scroll |
|------|-----------|----------|---------------|--------|
| **증명 시스템** | PLONK (Boojum) | STARK (Stone) | FFLONK | Halo2 |
| **언어** | Solidity (zksolc) | Cairo | Solidity | Solidity |
| **EVM 호환** | Type 4 | Type 4 | Type 2 | Type 2.5 |
| **Trusted Setup** | 필요 | 불필요 | 필요 | 필요 |
| **증명 크기** | ~200 bytes | ~40-200 KB | ~200 bytes | ~200 bytes |
| **검증 가스** | ~300K | ~1M | ~350K | ~300K |

### 성능 비교

```typescript
// ZK-Rollup 성능 메트릭
interface RollupPerformance {
    tps: number;           // Transactions per second
    finality: number;      // Finality time (minutes)
    proofTime: number;     // Proof generation time (seconds)
    verifyGas: number;     // L1 verification gas
    proofSize: number;     // Proof size (bytes)
}

const performanceComparison: Record<string, RollupPerformance> = {
    zkSync: {
        tps: 2000,
        finality: 15,
        proofTime: 60,
        verifyGas: 300000,
        proofSize: 200,
    },
    starkNet: {
        tps: 100,
        finality: 60,
        proofTime: 300,
        verifyGas: 1000000,
        proofSize: 50000,
    },
    polygonZkEVM: {
        tps: 500,
        finality: 30,
        proofTime: 120,
        verifyGas: 350000,
        proofSize: 200,
    },
    scroll: {
        tps: 1000,
        finality: 20,
        proofTime: 90,
        verifyGas: 300000,
        proofSize: 200,
    },
};
```

### 선택 가이드

```
┌─────────────────────────────────────────────────────────────────┐
│                   ZK-Rollup 선택 가이드                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  기존 Solidity 코드 마이그레이션?                                │
│  ├─ YES ─▶ Polygon zkEVM 또는 Scroll                            │
│  │         (바이트코드 호환, 최소 수정)                          │
│  │                                                               │
│  └─ NO ──▶ 계정 추상화 필요?                                     │
│            ├─ YES ─▶ zkSync Era                                  │
│            │         (Native AA 지원)                            │
│            │                                                     │
│            └─ NO ──▶ Trusted Setup 없이?                         │
│                      ├─ YES ─▶ StarkNet                          │
│                      │         (STARK, Cairo 학습 필요)          │
│                      │                                           │
│                      └─ NO ──▶ 요구사항별 선택                   │
│                                • 최고 처리량 ─▶ zkSync           │
│                                • EVM 호환성 ─▶ Polygon/Scroll   │
│                                • 탈중앙화 ─▶ StarkNet           │
└─────────────────────────────────────────────────────────────────┘
```

---

## 실전 개발 가이드

### 프로젝트 설정

```bash
# zkSync Era 프로젝트
mkdir my-zksync-project && cd my-zksync-project
npx zksync-cli create . --template hardhat_solidity

# StarkNet 프로젝트
curl --proto '=https' --tlsv1.2 -sSf https://docs.swmansion.com/scarb/install.sh | sh
scarb new my_starknet_project

# Polygon zkEVM / Scroll 프로젝트 (표준 Hardhat)
npx hardhat init
npm install @openzeppelin/contracts
```

### Hardhat 설정 예시

```typescript
// hardhat.config.ts (멀티 롤업 지원)
import { HardhatUserConfig } from "hardhat/config";
import "@matterlabs/hardhat-zksync-solc";
import "@matterlabs/hardhat-zksync-deploy";

const config: HardhatUserConfig = {
    solidity: "0.8.20",

    networks: {
        // zkSync Era
        zkSyncMainnet: {
            url: "https://mainnet.era.zksync.io",
            ethNetwork: "mainnet",
            zksync: true,
            verifyURL: "https://zksync2-mainnet-explorer.zksync.io/contract_verification",
        },

        // Polygon zkEVM
        polygonZkEVM: {
            url: "https://zkevm-rpc.com",
            accounts: [process.env.PRIVATE_KEY!],
        },

        // Scroll
        scroll: {
            url: "https://rpc.scroll.io",
            accounts: [process.env.PRIVATE_KEY!],
        },
    },

    zksolc: {
        version: "1.3.13",
        settings: {},
    },
};

export default config;
```

### 크로스 롤업 애플리케이션

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC20/IERC20.sol";

/**
 * @title CrossRollupBridge
 * @notice 여러 ZK-Rollup 간 자산 브릿지 컨트랙트
 */
contract CrossRollupBridge {
    enum RollupType { ZKSYNC, STARKNET, POLYGON_ZKEVM, SCROLL }

    struct BridgeRequest {
        address sender;
        address recipient;
        address token;
        uint256 amount;
        RollupType sourceRollup;
        RollupType destRollup;
        bytes32 commitment;
        bool processed;
    }

    mapping(bytes32 => BridgeRequest) public requests;
    mapping(RollupType => address) public rollupVerifiers;

    event BridgeInitiated(
        bytes32 indexed requestId,
        address indexed sender,
        RollupType sourceRollup,
        RollupType destRollup,
        uint256 amount
    );

    event BridgeCompleted(
        bytes32 indexed requestId,
        address indexed recipient,
        uint256 amount
    );

    /**
     * @notice 브릿지 요청 시작
     */
    function initiateBridge(
        address token,
        uint256 amount,
        address recipient,
        RollupType destRollup,
        bytes32 secretHash
    ) external returns (bytes32 requestId) {
        // 토큰 잠금
        IERC20(token).transferFrom(msg.sender, address(this), amount);

        // 요청 ID 생성
        requestId = keccak256(abi.encodePacked(
            msg.sender,
            recipient,
            token,
            amount,
            block.timestamp,
            secretHash
        ));

        requests[requestId] = BridgeRequest({
            sender: msg.sender,
            recipient: recipient,
            token: token,
            amount: amount,
            sourceRollup: getCurrentRollup(),
            destRollup: destRollup,
            commitment: secretHash,
            processed: false
        });

        emit BridgeInitiated(
            requestId,
            msg.sender,
            getCurrentRollup(),
            destRollup,
            amount
        );
    }

    /**
     * @notice ZK 증명으로 브릿지 완료
     */
    function completeBridge(
        bytes32 requestId,
        bytes calldata proof,
        bytes32 secret
    ) external {
        BridgeRequest storage request = requests[requestId];
        require(!request.processed, "Already processed");
        require(
            keccak256(abi.encodePacked(secret)) == request.commitment,
            "Invalid secret"
        );

        // 증명 검증 (롤업별 검증자 사용)
        address verifier = rollupVerifiers[request.sourceRollup];
        require(
            IZKVerifier(verifier).verify(proof, abi.encode(requestId, secret)),
            "Invalid proof"
        );

        request.processed = true;

        // 토큰 릴리스
        IERC20(request.token).transfer(request.recipient, request.amount);

        emit BridgeCompleted(requestId, request.recipient, request.amount);
    }

    function getCurrentRollup() internal view returns (RollupType) {
        // 체인 ID로 롤업 타입 결정
        uint256 chainId = block.chainid;
        if (chainId == 324) return RollupType.ZKSYNC;
        if (chainId == 1101) return RollupType.POLYGON_ZKEVM;
        if (chainId == 534352) return RollupType.SCROLL;
        revert("Unknown rollup");
    }
}

interface IZKVerifier {
    function verify(bytes calldata proof, bytes calldata publicInputs)
        external view returns (bool);
}
```

---

## 요약

| 구분 | 핵심 내용 |
|------|----------|
| **zkSync Era** | PLONK 기반, 계정 추상화 네이티브 지원, zksolc 컴파일러 |
| **StarkNet** | STARK 증명, Cairo 언어, Trusted Setup 불필요 |
| **Polygon zkEVM** | Type 2 EVM 호환, 기존 코드 그대로 배포 가능 |
| **Scroll** | Halo2 기반, 분산 프로버 네트워크 |
| **선택 기준** | EVM 호환성, 처리량, 탈중앙화, 개발 경험에 따라 결정 |

다음 문서에서는 ZK-Privacy 애플리케이션 (Tornado Cash, Zcash, Aztec) 구현을 다룹니다.
