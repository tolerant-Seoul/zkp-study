# 2.7 ZK 시스템 실무 선택 가이드

## 개요

이 문서는 ZK 시스템을 실제 프로젝트에 적용할 때 필요한 의사결정 프레임워크를 제공한다. 증명 시스템, lookup scheme, folding 방식 등 다양한 선택지를 프로젝트 요구사항에 맞게 평가하고 선택하는 방법을 다룬다.

---

## 1. 프로젝트 요구사항 분석

### 1.1 핵심 질문 체크리스트

```
1. 성능 요구사항
   [ ] Prover 시간 목표는?
       - 실시간 (<1초)
       - 빠름 (<10초)
       - 허용 가능 (<1분)
       - 배치 처리 (분 단위)

   [ ] Verifier 시간 목표는?
       - 실시간 (<10ms)
       - 빠름 (<100ms)
       - On-chain 검증 필요?

   [ ] Proof 크기 제한은?
       - 최소 (<200B)
       - 작음 (<1KB)
       - 허용 가능 (<10KB)
       - 제한 없음

2. 보안 요구사항
   [ ] Trusted Setup 허용?
       - 불가 (Transparent 필요)
       - Universal Setup 허용
       - Circuit-specific 허용

   [ ] 보안 가정
       - Post-quantum 필요?
       - 표준 암호학 가정 충분?

3. 기능 요구사항
   [ ] 계산 구조
       - 단일 회로
       - 반복 계산 (IVC)
       - 다중 함수 (VM)

   [ ] 특수 연산
       - 비트 연산 많음?
       - Range proof 많음?
       - 해시 연산 많음?
       - 서명 검증?

4. 개발 요구사항
   [ ] 팀 역량
       - ZK 경험 수준
       - 사용 가능한 언어
       - 유지보수 능력

   [ ] 생태계
       - 기존 도구 활용 필요?
       - 커뮤니티 지원 필요?
       - 감사 가능성?
```

### 1.2 트레이드오프 매트릭스

```
주요 트레이드오프:

1. Prover Time vs Proof Size
   빠른 Prover → 보통 큰 Proof
   작은 Proof → 보통 느린 Prover

2. Transparency vs Efficiency
   Transparent Setup → 더 큰 Proof, 느린 Verifier
   Trusted Setup → 더 작은 Proof, 빠른 Verifier

3. 표현력 vs 효율
   범용 회로 → 더 느림
   특화 회로 → 더 빠르지만 제한적

4. 개발 편의성 vs 성능
   High-level DSL → 쉽지만 비효율적
   Low-level → 어렵지만 최적화 가능
```

---

## 2. 증명 시스템 선택

### 2.1 결정 플로우차트

```
                    시작
                      |
         ┌────────────┴────────────┐
         │ Trusted Setup 허용?      │
         └────────────┬────────────┘
              Yes     │     No
         ┌────────────┴────────────┐
         │                         │
    ┌────┴────┐              ┌────┴────┐
    │ Setup   │              │STARK/IPA│
    │ 기반    │              │ 기반    │
    └────┬────┘              └────┬────┘
         │                         │
    ┌────┴────────────┐      ┌────┴────┐
    │최소 Proof Size? │      │성능 우선?│
    └────┬────────────┘      └────┬────┘
    Yes  │  No               Yes  │  No
    ┌────┴────┐              ┌────┴────┐
    │Groth16  │              │STARK    │
    └─────────┘              └─────────┘
              │                    │
    ┌────┴────┐              ┌────┴────┐
    │Universal│              │Halo2    │
    │Setup?   │              │(IPA)    │
    └────┬────┘              └─────────┘
    Yes  │
    ┌────┴────┐
    │PLONK    │
    │FFLONK   │
    └─────────┘
```

### 2.2 시스템별 상세 비교

```
| 시스템 | Setup | Proof Size | Prover | Verifier | Post-Q | 성숙도 |
|--------|-------|------------|--------|----------|--------|--------|
| Groth16 | Circuit | 192B | 중간 | 3 pairings | No | 높음 |
| PLONK | Universal | 400B | 중간 | ~10 G1 + 2p | No | 높음 |
| FFLONK | Universal | 256B | 중간 | 2 pairings | No | 중간 |
| Marlin | Universal | 700B | 느림 | 중간 | No | 중간 |
| Halo 2 | None | 1-3KB | 빠름 | 느림 | No | 높음 |
| STARK | None | 50-200KB | 빠름 | 빠름 | Yes | 높음 |
| Plonky2 | None | 45KB | 매우 빠름 | 빠름 | No | 중간 |
```

### 2.3 사용 사례별 권장

```
1. On-chain 검증 (최소 가스비)
   → Groth16
   이유: 최소 proof size, 최소 verifier 비용

2. 범용 L2 Rollup
   → PLONK/FFLONK
   이유: Universal setup, 유연한 회로, 검증 효율

3. Privacy 애플리케이션
   → Groth16 또는 Halo 2
   이유: Groth16(효율), Halo 2(no trusted setup)

4. zkVM
   → STARK 또는 Plonky2
   이유: 큰 회로 처리, 빠른 prover

5. 탈중앙화 우선
   → STARK
   이유: Transparent, post-quantum, 신뢰 최소화

6. 빠른 개발
   → PLONK (circom)
   이유: 성숙한 도구, 큰 커뮤니티
```

---

## 3. Lookup Scheme 선택

### 3.1 결정 기준

```
Lookup 필요 여부:

필요한 경우:
- 비트 연산 (XOR, AND, OR)
- Range proof (값 범위 검증)
- 해시 함수 (Keccak, SHA256)
- 테이블 기반 연산

불필요한 경우:
- 순수 산술 연산
- 간단한 조건문
- ZK-friendly 해시 (Poseidon)
```

### 3.2 Lookup Scheme 결정 흐름

```
                 Lookup 필요?
                      │
              Yes     │     No
         ┌────────────┴────────────┐
         │                         │
    ┌────┴────┐              ─────────
    │테이블 크기│              Lookup 불사용
    └────┬────┘
         │
    ┌────┴────────────────────────┐
    │                             │
  <2^20                        >=2^20
    │                             │
┌───┴───┐                    ┌───┴───┐
│정렬    │                    │Lasso  │
│가능?   │                    │(Sparse)│
└───┬───┘                    └───────┘
    │
Yes │  No
    │
┌───┴───┐  ┌───────┐
│Plookup│  │LogUp  │
└───────┘  └───────┘
```

### 3.3 상세 비교

```
| 기준 | Plookup | LogUp | Lasso |
|------|---------|-------|-------|
| 테이블 크기 | <2^20 | <2^20 | 2^32+ |
| 정렬 필요 | Yes | No | No |
| 다중 테이블 | 복잡 | 간단 | 간단 |
| Prover | O(n log n) | O(n) | O(m log N) |
| Proof 추가 | ~400B | ~300B | ~2KB |
| 성숙도 | 높음 | 높음 | 중간 |

권장:
- 표준 사용: Plookup
- 다중 테이블: LogUp
- 대규모 테이블: Lasso
```

---

## 4. IVC/Folding 선택

### 4.1 언제 필요한가?

```
IVC/Folding 필요:
- 긴 실행 trace (>10,000 steps)
- 점진적 증명 필요
- Prover 메모리 제한
- 병렬 증명 생성

IVC/Folding 불필요:
- 단일 회로 실행
- 짧은 계산
- 최소 proof size 필요
```

### 4.2 선택 흐름

```
              IVC 필요?
                  │
          Yes     │     No
         ┌────────┴────────┐
         │                 │
    ┌────┴────┐       ─────────
    │함수 수? │       일반 SNARK
    └────┬────┘
         │
    ┌────┴────────────────┐
    │                     │
   1개                  여러 개
    │                     │
┌───┴───┐            ┌───┴───┐
│Nova   │            │Super  │
│       │            │Nova   │
└───────┘            └───────┘
    │
┌───┴────────────────┐
│복잡한 회로 필요?    │
└───┬────────────────┘
    │
Yes │  No
    │
┌───┴───┐
│Hyper  │
│Nova   │
└───────┘
```

### 4.3 상세 비교

```
| 기준 | 재귀 SNARK | Nova | SuperNova | HyperNova |
|------|-----------|------|-----------|-----------|
| Overhead | 높음 | 낮음 | 낮음 | 중간 |
| 함수 수 | 1 | 1 | k | 1 |
| 표현력 | 제한적 | R1CS | R1CS | CCS |
| 성숙도 | 높음 | 중간 | 낮음 | 낮음 |
| 구현 복잡도 | 중간 | 낮음 | 중간 | 높음 |

권장:
- 표준 IVC: Nova
- VM 구현: SuperNova
- PLONK 연동: HyperNova
- 성숙한 솔루션: 재귀 SNARK
```

---

## 5. 개발 도구 및 프레임워크 선택

### 5.1 언어별 옵션

```
Rust:
- arkworks: 범용 암호학 라이브러리
- bellman: Groth16 구현
- halo2: Halo 2 구현
- plonky2: 빠른 STARK/PLONK

Go:
- gnark: 빠른 prover, 여러 backend

JavaScript/TypeScript:
- snarkjs: Groth16, PLONK, Circom 연동
- libsnark-ts: TypeScript 바인딩

Circom (DSL):
- 가장 큰 커뮤니티
- 풍부한 라이브러리
- snarkjs와 연동
```

### 5.2 프레임워크 비교

```
| 프레임워크 | 언어 | 백엔드 | 난이도 | 성능 | 커뮤니티 |
|-----------|------|--------|--------|------|----------|
| Circom+snarkjs | DSL+JS | Groth16/PLONK | 쉬움 | 중간 | 큼 |
| arkworks | Rust | 다양 | 중간 | 빠름 | 중간 |
| gnark | Go | 다양 | 중간 | 매우 빠름 | 중간 |
| halo2 | Rust | Halo 2 | 어려움 | 빠름 | 중간 |
| Cairo | DSL | STARK | 중간 | 빠름 | 성장 중 |
| Noir | DSL | 다양 | 쉬움 | 중간 | 성장 중 |
```

### 5.3 시작점 권장

```
초보자:
1. Circom + snarkjs
   - 가장 쉬운 시작
   - 풍부한 예제
   - 활발한 커뮤니티

2. Noir
   - Rust-like 문법
   - 현대적 도구
   - Aztec 지원

중급자:
1. arkworks (Rust)
   - 유연한 구조
   - 다양한 백엔드
   - 깊은 커스터마이징

2. gnark (Go)
   - 빠른 prover
   - 좋은 문서화
   - 프로덕션 사용

고급자:
1. halo2
   - Custom gates
   - Lookups
   - 최적화 가능

2. 직접 구현
   - 논문 기반
   - 최대 제어
```

---

## 6. 프로젝트 유형별 가이드

### 6.1 zkRollup

```
목표: L2 트랜잭션 배치 증명

권장 스택:
- 증명 시스템: PLONK/FFLONK (범용) 또는 STARK (확장성)
- Lookup: Plookup/LogUp (범위, 서명 검증)
- IVC: 필요시 Nova/재귀 SNARK

고려사항:
- L1 검증 가스비 최적화
- Prover 성능 (배치 처리)
- 데이터 가용성

실제 사례:
- Polygon zkEVM: FFLONK
- zkSync Era: PLONK + Boojum
- Scroll: Halo 2
- StarkNet: STARK
```

### 6.2 Privacy 애플리케이션

```
목표: 거래/데이터 프라이버시

권장 스택:
- 증명 시스템: Groth16 (효율) 또는 Halo 2 (no trusted setup)
- 회로: 간결하게 유지
- Nullifier: 이중 사용 방지

고려사항:
- Proof 생성 시간 (UX)
- 클라이언트 사이드 증명
- Viewing key 구조

실제 사례:
- Zcash: Groth16 (Sapling), Halo 2 (Orchard)
- Tornado Cash: Groth16
- Aztec: UltraPlonk + 재귀
```

### 6.3 zkVM

```
목표: 범용 프로그램 실행 증명

권장 스택:
- 증명 시스템: STARK (확장성) 또는 PLONK+Lookup
- IVC: SuperNova (다중 opcode) 또는 재귀 SNARK
- Lookup: 필수 (opcode 테이블)

고려사항:
- 명령어 세트 선택 (RISC-V, WASM, EVM)
- Prover 하드웨어 요구사항
- 증명 생성 병렬화

실제 사례:
- RISC Zero: STARK
- SP1 (Succinct): Plonky3
- Nexus: Nova/SuperNova
- Cairo: STARK
```

### 6.4 DID/Credential

```
목표: 신원/자격 증명

권장 스택:
- 증명 시스템: Groth16 (클라이언트 효율)
- 회로: Merkle tree + 서명 검증
- 선택적 공개: Custom circuit

고려사항:
- 모바일 증명 생성
- 발급자 서명 방식
- 폐기 메커니즘

실제 사례:
- Polygon ID: Groth16
- Semaphore: Groth16
- WorldCoin: Groth16
```

---

## 7. 성능 최적화 가이드

### 7.1 회로 최적화

```
원칙:

1. Constraint 수 최소화
   - 불필요한 검증 제거
   - 효율적인 알고리즘 선택
   - Lookup 활용

2. 적절한 데이터 구조
   - Merkle tree 깊이 최적화
   - 배치 처리
   - 희소 데이터 활용

3. ZK-friendly 연산
   - Poseidon > SHA256
   - EdDSA > ECDSA
   - 필드 친화적 구조

팁:
- 산술 연산: 1 constraint
- 비교 연산: 많은 constraints
- 해시: 회로 크기 지배 가능
```

### 7.2 Prover 최적화

```
하드웨어:
- GPU: MSM 가속 (10-100x)
- FPGA: 커스텀 최적화
- 메모리: 큰 회로는 GB 필요

소프트웨어:
- 병렬화: 다중 코어 활용
- FFT 최적화: NTT 사용
- 배칭: 여러 증명 동시 생성

라이브러리 선택:
| 목표 | 권장 |
|------|------|
| 최대 성능 | gnark, arkworks-rs |
| GPU 가속 | Icicle, Rapids |
| 개발 편의 | snarkjs |
```

### 7.3 Verifier 최적화

```
On-chain:
- Groth16: ~220K gas
- PLONK: ~300K gas
- FFLONK: ~250K gas

최적화:
- Batch verification
- Precompile 활용 (EIP-196, 197)
- Calldata 최적화

Off-chain:
- Native 검증 구현
- WASM 컴파일
- 병렬 검증
```

---

## 8. 보안 고려사항

### 8.1 일반 원칙

```
1. Trusted Setup
   - MPC ceremony 참여자 수
   - Toxic waste 폐기 검증
   - Universal setup 선호

2. 회로 보안
   - Under-constrained 방지
   - 경계 조건 검증
   - 형식 검증 고려

3. 구현 보안
   - Side-channel 공격 방어
   - 난수 생성 품질
   - 의존성 감사
```

### 8.2 감사 체크리스트

```
[ ] 회로 완전성 검증
[ ] Soundness 분석
[ ] 경계 조건 테스트
[ ] Fuzz testing
[ ] 형식 검증 (가능시)
[ ] 제3자 감사
[ ] 버그 바운티 프로그램
```

---

## 9. 의사결정 요약표

### 9.1 빠른 결정 가이드

```
상황 → 권장 선택

"최소 on-chain 비용"
→ Groth16 + 최적화된 회로

"신뢰 최소화 필수"
→ STARK 또는 Halo 2

"빠른 개발 필요"
→ Circom + snarkjs + Groth16/PLONK

"zkVM 구축"
→ STARK + SuperNova + Lookup

"모바일 증명 생성"
→ Groth16 + 작은 회로

"최대 확장성"
→ STARK + 재귀 + 배치

"기존 EVM 호환"
→ zkEVM (Polygon, Scroll, zkSync 등)
```

### 9.2 복잡도 vs 성능 매트릭스

```
                    성능 (Prover)
                 낮음          높음
              ┌──────────┬──────────┐
      낮음    │snarkjs   │ gnark    │
  복잡도      │(쉬움)    │ (빠름)   │
              ├──────────┼──────────┤
      높음    │halo2     │ 커스텀   │
              │(유연)    │ (최적)   │
              └──────────┴──────────┘
```

---

## 10. 실무 예제

### 10.1 간단한 프로젝트 시작

```
예: 비밀 숫자 맞추기 게임

1. 요구사항 분석
   - 간단한 해시 검증
   - 클라이언트 사이드 증명
   - 빠른 개발

2. 기술 선택
   - DSL: Circom
   - 백엔드: snarkjs + Groth16
   - 프론트엔드: React

3. 회로 설계
   pragma circom 2.0.0;
   include "poseidon.circom";

   template SecretNumber() {
       signal input secret;
       signal input hash;

       component hasher = Poseidon(1);
       hasher.inputs[0] <== secret;

       hash === hasher.out;
   }

4. 구현 단계
   - 회로 컴파일
   - Trusted setup
   - 프론트엔드 연동
   - 테스트
```

### 10.2 복잡한 프로젝트 시작

```
예: zkRollup 구축

1. 요구사항 분석
   - 높은 TPS
   - EVM 호환
   - L1 검증

2. 기술 선택
   - 증명 시스템: PLONK/FFLONK
   - Lookup: LogUp
   - 프레임워크: halo2 또는 커스텀

3. 아키텍처
   ┌─────────────────────────────────┐
   │           Sequencer             │
   └─────────────────┬───────────────┘
                     │
   ┌─────────────────┴───────────────┐
   │         Prover Network          │
   │  ┌───────┐ ┌───────┐ ┌───────┐  │
   │  │GPU 1  │ │GPU 2  │ │GPU n  │  │
   │  └───────┘ └───────┘ └───────┘  │
   └─────────────────┬───────────────┘
                     │
   ┌─────────────────┴───────────────┐
   │      L1 Verifier Contract       │
   └─────────────────────────────────┘

4. 개발 로드맵
   Phase 1: 단순 전송
   Phase 2: 스마트 컨트랙트
   Phase 3: 최적화
   Phase 4: 분산화
```

---

## 요약

```
ZK 시스템 선택 핵심:

1. 요구사항 명확화
   - 성능 목표
   - 보안 요구사항
   - 개발 제약

2. 증명 시스템 선택
   - On-chain: Groth16/FFLONK
   - Transparent: STARK/Halo 2
   - 범용: PLONK

3. 보조 기술 선택
   - Lookup: 비트 연산, 범위 검증
   - Folding: IVC, 긴 계산

4. 도구 선택
   - 초보: Circom + snarkjs
   - 중급: arkworks/gnark
   - 고급: halo2/커스텀

5. 최적화
   - 회로 최소화
   - 하드웨어 가속
   - 배치 처리

6. 보안
   - 감사
   - 테스트
   - 형식 검증

핵심 원칙:
- 단순함 우선 (복잡함은 나중에)
- 요구사항 기반 선택 (유행 추종 X)
- 점진적 복잡도 증가
- 충분한 테스트와 감사
```

---

## 참고 자료

### 필수 리소스
- ZK-Learning: https://zk-learning.org
- Awesome ZK: https://github.com/matter-labs/awesome-zero-knowledge-proofs
- ZK Hack: https://zkhack.dev

### 프레임워크 문서
- Circom: https://docs.circom.io
- arkworks: https://arkworks.rs
- gnark: https://docs.gnark.consensys.net
- halo2: https://zcash.github.io/halo2

### 커뮤니티
- ZK Research Forum: https://zkresear.ch
- Ethereum Research: https://ethresear.ch
- Discord: 각 프로젝트별 서버
