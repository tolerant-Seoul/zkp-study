# 3.2 증명 생성 및 검증 파이프라인

## 개요

이 문서에서는 Circom으로 작성한 회로를 컴파일하고, Trusted Setup을 수행하고, 증명을 생성하고, 검증하는 전체 파이프라인을 상세히 다룬다. snarkjs를 중심으로 Groth16과 PLONK 백엔드를 모두 설명한다.

---

## 1. 파이프라인 개요

### 1.1 전체 흐름

```
┌─────────────────────────────────────────────────────────────────────┐
│                        ZK Proof Pipeline                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  [1. 회로 컴파일]                                                    │
│       circuit.circom                                                │
│            │                                                        │
│            ▼                                                        │
│       ┌─────────┬─────────┬─────────┐                              │
│       │ .r1cs   │ .wasm   │ .sym    │                              │
│       └────┬────┴────┬────┴────┬────┘                              │
│            │         │         │                                    │
│  [2. Trusted Setup]  │         │                                    │
│            │         │         │                                    │
│            ▼         │         │                                    │
│       ┌─────────┐    │         │                                    │
│       │ .zkey   │    │         │                                    │
│       └────┬────┘    │         │                                    │
│            │         │         │                                    │
│  [3. 증명 생성] ◄─────┘         │                                    │
│            │                    │                                    │
│       input.json                │                                    │
│            │                    │                                    │
│            ▼                    │                                    │
│       ┌─────────┐               │                                    │
│       │ proof   │               │                                    │
│       │ public  │               │                                    │
│       └────┬────┘               │                                    │
│            │                    │                                    │
│  [4. 검증]  │                    │                                    │
│            ▼                    │                                    │
│       ✓ Valid / ✗ Invalid       │                                    │
│                                 │                                    │
│  [5. 컨트랙트 생성]              │                                    │
│            │                    ▼                                    │
│            ▼              (디버깅용)                                  │
│       Verifier.sol                                                  │
│                                                                     │
└─────────────────────────────────────────────────────────────────────┘
```

### 1.2 파일 유형

```
파일 확장자 설명:

.circom     - 회로 소스 코드
.r1cs       - 컴파일된 R1CS 제약 시스템 (바이너리)
.wasm       - WebAssembly 위트니스 계산기
.sym        - 심볼 테이블 (디버깅용)
.json       - 입력/출력/증명 데이터

.ptau       - Powers of Tau (Phase 1 결과)
.zkey       - Proving/Verification Key (Phase 2 결과)

proof.json  - 생성된 증명
public.json - 공개 입력/출력
```

---

## 2. 회로 컴파일

### 2.1 컴파일 명령어

```bash
# 기본 컴파일
circom circuit.circom --r1cs --wasm --sym --output ./build

# 옵션 설명
# --r1cs      : R1CS 파일 생성
# --wasm      : WebAssembly witness 계산기 생성
# --sym       : 심볼 파일 생성 (디버깅용)
# --c         : C++ witness 계산기 생성 (선택)
# --output    : 출력 디렉토리
# --O0        : 최적화 없음 (디버깅용)
# --O1        : 기본 최적화
# --O2        : 공격적 최적화 (기본값)

# C++ witness 계산기 (대규모 회로용)
circom circuit.circom --r1cs --wasm --c --sym --output ./build

# C++ 컴파일
cd build/circuit_cpp
make

# 최적화 레벨별 차이
# --O0: 모든 신호 유지, 느림, 디버깅 용이
# --O1: 일부 최적화, 균형
# --O2: 최대 최적화, 가장 빠름, 디버깅 어려움
```

### 2.2 컴파일 출력 분석

```bash
# R1CS 정보 확인
snarkjs r1cs info build/circuit.r1cs

# 출력 예시:
# [INFO]  snarkJS: Curve: bn-128
# [INFO]  snarkJS: # of Wires: 1234
# [INFO]  snarkJS: # of Constraints: 567
# [INFO]  snarkJS: # of Private Inputs: 10
# [INFO]  snarkJS: # of Public Inputs: 3
# [INFO]  snarkJS: # of Labels: 890
# [INFO]  snarkJS: # of Outputs: 2

# R1CS를 JSON으로 내보내기 (분석용)
snarkjs r1cs export json build/circuit.r1cs build/circuit.r1cs.json

# 심볼 파일 확인 (신호 이름 매핑)
cat build/circuit.sym | head -20
# 1,1,0,main.a
# 2,2,0,main.b
# 3,3,1,main.c
# ...
```

### 2.3 컴파일 스크립트

```bash
#!/bin/bash
# scripts/compile.sh

set -e

CIRCUIT_NAME=${1:-"circuit"}
CIRCUIT_PATH="circuits/${CIRCUIT_NAME}.circom"
OUTPUT_DIR="build/${CIRCUIT_NAME}"

echo "=== Compiling ${CIRCUIT_NAME} ==="

# 출력 디렉토리 생성
mkdir -p ${OUTPUT_DIR}

# 컴파일
circom ${CIRCUIT_PATH} \
    --r1cs \
    --wasm \
    --sym \
    --output ${OUTPUT_DIR} \
    -l node_modules

# 회로 정보 출력
echo ""
echo "=== Circuit Info ==="
snarkjs r1cs info ${OUTPUT_DIR}/${CIRCUIT_NAME}.r1cs

echo ""
echo "=== Compilation Complete ==="
echo "Output: ${OUTPUT_DIR}/"
ls -la ${OUTPUT_DIR}/
```

---

## 3. Trusted Setup

### 3.1 Phase 1: Powers of Tau

```bash
# Powers of Tau는 범용 (Universal)
# 한 번 생성하면 여러 회로에 재사용 가능
# 단, 회로 크기 제한 있음 (2^n constraints)

# 새로 생성 (테스트용)
snarkjs powersoftau new bn128 14 pot14_0000.ptau -v
# bn128: 곡선 종류
# 14: 2^14 = 16,384 constraints까지 지원
# -v: verbose 모드

# 기여 추가 (엔트로피 제공)
snarkjs powersoftau contribute pot14_0000.ptau pot14_0001.ptau \
    --name="First contribution" -v -e="random entropy"

# 여러 기여자
snarkjs powersoftau contribute pot14_0001.ptau pot14_0002.ptau \
    --name="Second contribution" -v

# Phase 1 완료 (랜덤 비콘 적용)
snarkjs powersoftau beacon pot14_0002.ptau pot14_beacon.ptau \
    0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f \
    10 -n="Final Beacon"

# Phase 1 준비 완료
snarkjs powersoftau prepare phase2 pot14_beacon.ptau pot14_final.ptau -v

# 검증
snarkjs powersoftau verify pot14_final.ptau
```

### 3.2 Powers of Tau 다운로드 (권장)

```bash
# Hermez의 사전 생성된 Powers of Tau 사용 (권장)
# https://github.com/iden3/snarkjs#7-prepare-phase-2

# 크기별 다운로드
# pot12: 2^12 = 4,096 constraints
# pot14: 2^14 = 16,384 constraints
# pot16: 2^16 = 65,536 constraints
# pot18: 2^18 = 262,144 constraints
# pot20: 2^20 = 1,048,576 constraints
# pot22: 2^22 = 4,194,304 constraints
# pot28: 2^28 = 268,435,456 constraints

wget https://hermez.s3-eu-west-1.amazonaws.com/powersOfTau28_hez_final_14.ptau

# 파일 크기 확인
# pot14: ~50MB
# pot16: ~200MB
# pot18: ~800MB
# pot20: ~3GB
# pot22: ~12GB
```

### 3.3 Phase 2: Circuit-Specific Setup (Groth16)

```bash
# Groth16은 회로별 setup 필요

# Phase 2 시작
snarkjs groth16 setup build/circuit.r1cs pot14_final.ptau circuit_0000.zkey

# 기여 추가
snarkjs zkey contribute circuit_0000.zkey circuit_0001.zkey \
    --name="Contributor 1" -v -e="random entropy"

snarkjs zkey contribute circuit_0001.zkey circuit_0002.zkey \
    --name="Contributor 2" -v

# 랜덤 비콘 적용
snarkjs zkey beacon circuit_0002.zkey circuit_final.zkey \
    0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f \
    10 -n="Final Beacon"

# 검증
snarkjs zkey verify build/circuit.r1cs pot14_final.ptau circuit_final.zkey

# Verification Key 추출
snarkjs zkey export verificationkey circuit_final.zkey verification_key.json
```

### 3.4 PLONK Setup (Universal)

```bash
# PLONK은 Universal Setup
# Phase 2가 회로 독립적

# PLONK setup
snarkjs plonk setup build/circuit.r1cs pot14_final.ptau circuit_plonk.zkey

# Verification Key 추출
snarkjs zkey export verificationkey circuit_plonk.zkey verification_key_plonk.json

# 장점: 회로 변경해도 재setup 불필요
# 단점: Groth16보다 큰 proof, 느린 검증
```

### 3.5 Setup 스크립트

```bash
#!/bin/bash
# scripts/setup.sh

set -e

CIRCUIT_NAME=${1:-"circuit"}
BUILD_DIR="build/${CIRCUIT_NAME}"
KEYS_DIR="keys/${CIRCUIT_NAME}"
PTAU_FILE="ptau/pot14_final.ptau"
PROOF_SYSTEM=${2:-"groth16"}  # groth16 또는 plonk

echo "=== Setting up ${CIRCUIT_NAME} with ${PROOF_SYSTEM} ==="

mkdir -p ${KEYS_DIR}

if [ "$PROOF_SYSTEM" == "groth16" ]; then
    # Groth16 Setup
    echo "Phase 2: Groth16 Setup..."

    snarkjs groth16 setup \
        ${BUILD_DIR}/${CIRCUIT_NAME}.r1cs \
        ${PTAU_FILE} \
        ${KEYS_DIR}/${CIRCUIT_NAME}_0000.zkey

    # 기여 (프로덕션에서는 여러 참가자)
    snarkjs zkey contribute \
        ${KEYS_DIR}/${CIRCUIT_NAME}_0000.zkey \
        ${KEYS_DIR}/${CIRCUIT_NAME}_0001.zkey \
        --name="Setup contribution" -v -e="$(head -c 32 /dev/urandom | xxd -p)"

    # 최종 키
    snarkjs zkey beacon \
        ${KEYS_DIR}/${CIRCUIT_NAME}_0001.zkey \
        ${KEYS_DIR}/${CIRCUIT_NAME}_final.zkey \
        $(head -c 32 /dev/urandom | xxd -p) 10 \
        -n="Final Beacon"

    # 검증
    snarkjs zkey verify \
        ${BUILD_DIR}/${CIRCUIT_NAME}.r1cs \
        ${PTAU_FILE} \
        ${KEYS_DIR}/${CIRCUIT_NAME}_final.zkey

elif [ "$PROOF_SYSTEM" == "plonk" ]; then
    # PLONK Setup
    echo "PLONK Setup..."

    snarkjs plonk setup \
        ${BUILD_DIR}/${CIRCUIT_NAME}.r1cs \
        ${PTAU_FILE} \
        ${KEYS_DIR}/${CIRCUIT_NAME}_plonk.zkey
fi

# Verification Key 추출
snarkjs zkey export verificationkey \
    ${KEYS_DIR}/${CIRCUIT_NAME}_final.zkey \
    ${KEYS_DIR}/verification_key.json

echo ""
echo "=== Setup Complete ==="
echo "Proving Key: ${KEYS_DIR}/${CIRCUIT_NAME}_final.zkey"
echo "Verification Key: ${KEYS_DIR}/verification_key.json"
```

---

## 4. Witness 계산

### 4.1 입력 파일 준비

```json
// inputs/input.json
{
    "a": "123",
    "b": "456",
    "secret": "789",
    "merkleProof": ["111", "222", "333"],
    "merkleIndices": [0, 1, 0]
}
```

### 4.2 Witness 생성

```bash
# Node.js (WASM) 방식
cd build/circuit_js
node generate_witness.js circuit.wasm ../../inputs/input.json witness.wtns

# 또는 snarkjs 직접 사용
snarkjs wtns calculate build/circuit_js/circuit.wasm inputs/input.json witness.wtns

# C++ 방식 (대규모 회로용, 더 빠름)
cd build/circuit_cpp
./circuit inputs/input.json witness.wtns
```

### 4.3 JavaScript에서 Witness 생성

```javascript
// prove.js
const snarkjs = require("snarkjs");
const fs = require("fs");
const path = require("path");

async function generateWitness(circuitName, input) {
    const wasmPath = path.join("build", circuitName + "_js", circuitName + ".wasm");
    const wtnsPath = path.join("build", "witness.wtns");

    // Witness 계산
    await snarkjs.wtns.calculate(
        { type: "mem", data: fs.readFileSync(wasmPath) },
        input,
        { type: "file", fileName: wtnsPath }
    );

    console.log("Witness generated:", wtnsPath);
    return wtnsPath;
}

// 사용
const input = {
    a: "123",
    b: "456"
};

generateWitness("circuit", input);
```

### 4.4 Witness 디버깅

```bash
# Witness를 JSON으로 내보내기
snarkjs wtns export json witness.wtns witness.json

# 신호 값 확인
cat witness.json | jq '.[] | select(. != "0")' | head -20

# 특정 신호 찾기 (심볼 파일과 함께)
# 심볼 파일: 신호 인덱스 -> 이름 매핑
grep "main.result" build/circuit.sym
# 출력: 42,42,1,main.result
# 인덱스 42번이 main.result
```

---

## 5. 증명 생성

### 5.1 Groth16 증명

```bash
# CLI로 증명 생성
snarkjs groth16 prove \
    keys/circuit_final.zkey \
    witness.wtns \
    proofs/proof.json \
    proofs/public.json

# 출력 파일
# proof.json: 증명 데이터
# public.json: 공개 입력/출력
```

### 5.2 PLONK 증명

```bash
# PLONK 증명 생성
snarkjs plonk prove \
    keys/circuit_plonk.zkey \
    witness.wtns \
    proofs/proof_plonk.json \
    proofs/public_plonk.json
```

### 5.3 JavaScript에서 증명 생성

```javascript
// prover.js
const snarkjs = require("snarkjs");
const fs = require("fs");

async function generateProof(circuitName, input, proofSystem = "groth16") {
    const wasmPath = `build/${circuitName}_js/${circuitName}.wasm`;
    const zkeyPath = `keys/${circuitName}_final.zkey`;

    console.log("Generating proof...");
    const startTime = Date.now();

    let result;
    if (proofSystem === "groth16") {
        result = await snarkjs.groth16.fullProve(
            input,
            wasmPath,
            zkeyPath
        );
    } else if (proofSystem === "plonk") {
        const zkeyPathPlonk = `keys/${circuitName}_plonk.zkey`;
        result = await snarkjs.plonk.fullProve(
            input,
            wasmPath,
            zkeyPathPlonk
        );
    }

    const endTime = Date.now();
    console.log(`Proof generated in ${endTime - startTime}ms`);

    return {
        proof: result.proof,
        publicSignals: result.publicSignals
    };
}

// 사용 예시
async function main() {
    const input = {
        a: "123",
        b: "456"
    };

    const { proof, publicSignals } = await generateProof("circuit", input);

    // 파일로 저장
    fs.writeFileSync("proofs/proof.json", JSON.stringify(proof, null, 2));
    fs.writeFileSync("proofs/public.json", JSON.stringify(publicSignals, null, 2));

    console.log("Proof:", JSON.stringify(proof, null, 2));
    console.log("Public signals:", publicSignals);
}

main().catch(console.error);
```

### 5.4 증명 데이터 구조

```json
// proofs/proof.json (Groth16)
{
    "pi_a": [
        "12345...",    // G1 point x
        "67890...",    // G1 point y
        "1"
    ],
    "pi_b": [
        [
            "11111...",  // G2 point x (Fp2)
            "22222..."
        ],
        [
            "33333...",  // G2 point y (Fp2)
            "44444..."
        ],
        ["1", "0"]
    ],
    "pi_c": [
        "55555...",    // G1 point x
        "66666...",    // G1 point y
        "1"
    ],
    "protocol": "groth16",
    "curve": "bn128"
}

// proofs/public.json
[
    "123",     // 첫 번째 공개 출력
    "456",     // 두 번째 공개 출력
    "789"      // 세 번째 공개 입력
]
```

---

## 6. 증명 검증

### 6.1 Off-chain 검증

```bash
# Groth16 검증
snarkjs groth16 verify \
    keys/verification_key.json \
    proofs/public.json \
    proofs/proof.json

# 출력: [INFO]  snarkJS: OK!

# PLONK 검증
snarkjs plonk verify \
    keys/verification_key_plonk.json \
    proofs/public_plonk.json \
    proofs/proof_plonk.json
```

### 6.2 JavaScript 검증

```javascript
// verifier.js
const snarkjs = require("snarkjs");
const fs = require("fs");

async function verifyProof(proofSystem = "groth16") {
    const vkeyPath = "keys/verification_key.json";
    const proofPath = "proofs/proof.json";
    const publicPath = "proofs/public.json";

    const vkey = JSON.parse(fs.readFileSync(vkeyPath));
    const proof = JSON.parse(fs.readFileSync(proofPath));
    const publicSignals = JSON.parse(fs.readFileSync(publicPath));

    console.log("Verifying proof...");
    const startTime = Date.now();

    let isValid;
    if (proofSystem === "groth16") {
        isValid = await snarkjs.groth16.verify(vkey, publicSignals, proof);
    } else if (proofSystem === "plonk") {
        isValid = await snarkjs.plonk.verify(vkey, publicSignals, proof);
    }

    const endTime = Date.now();
    console.log(`Verification completed in ${endTime - startTime}ms`);
    console.log("Valid:", isValid);

    return isValid;
}

// 사용
verifyProof("groth16");
```

### 6.3 Verification Key 구조

```json
// keys/verification_key.json (Groth16)
{
    "protocol": "groth16",
    "curve": "bn128",
    "nPublic": 2,
    "vk_alpha_1": ["123...", "456...", "1"],
    "vk_beta_2": [
        ["111...", "222..."],
        ["333...", "444..."],
        ["1", "0"]
    ],
    "vk_gamma_2": [...],
    "vk_delta_2": [...],
    "vk_alphabeta_12": [...],
    "IC": [
        ["...", "...", "1"],  // IC[0]
        ["...", "...", "1"],  // IC[1] (첫 번째 public input)
        ["...", "...", "1"]   // IC[2] (두 번째 public input)
    ]
}
```

---

## 7. 성능 최적화

### 7.1 Prover 성능 측정

```javascript
// benchmark.js
const snarkjs = require("snarkjs");

async function benchmark(circuitName, input, iterations = 10) {
    const wasmPath = `build/${circuitName}_js/${circuitName}.wasm`;
    const zkeyPath = `keys/${circuitName}_final.zkey`;

    const times = [];

    for (let i = 0; i < iterations; i++) {
        const start = process.hrtime.bigint();

        await snarkjs.groth16.fullProve(input, wasmPath, zkeyPath);

        const end = process.hrtime.bigint();
        const timeMs = Number(end - start) / 1_000_000;
        times.push(timeMs);

        console.log(`Iteration ${i + 1}: ${timeMs.toFixed(2)}ms`);
    }

    const avg = times.reduce((a, b) => a + b, 0) / times.length;
    const min = Math.min(...times);
    const max = Math.max(...times);

    console.log(`\n=== Benchmark Results ===`);
    console.log(`Average: ${avg.toFixed(2)}ms`);
    console.log(`Min: ${min.toFixed(2)}ms`);
    console.log(`Max: ${max.toFixed(2)}ms`);
}
```

### 7.2 메모리 최적화

```javascript
// 대규모 회로용 메모리 관리
const fs = require("fs");
const { readFileSync } = fs;

async function proveWithLowMemory(circuitName, input) {
    // 파일 스트리밍으로 메모리 절약
    const zkeyPath = `keys/${circuitName}_final.zkey`;
    const wasmPath = `build/${circuitName}_js/${circuitName}.wasm`;

    // WASM은 메모리에 로드 (필수)
    const wasm = readFileSync(wasmPath);

    // zkey는 스트리밍 모드 사용
    const { proof, publicSignals } = await snarkjs.groth16.fullProve(
        input,
        { type: "mem", data: wasm },
        { type: "file", fileName: zkeyPath }  // 파일 스트리밍
    );

    return { proof, publicSignals };
}
```

### 7.3 병렬 처리

```javascript
// 여러 증명 병렬 생성
const { Worker, isMainThread, parentPort, workerData } = require("worker_threads");
const os = require("os");

async function parallelProve(inputs) {
    const numCPUs = os.cpus().length;
    const batchSize = Math.ceil(inputs.length / numCPUs);

    const workers = [];
    const results = [];

    for (let i = 0; i < numCPUs && i * batchSize < inputs.length; i++) {
        const batch = inputs.slice(i * batchSize, (i + 1) * batchSize);

        const worker = new Worker("./prover-worker.js", {
            workerData: { batch, index: i }
        });

        workers.push(
            new Promise((resolve, reject) => {
                worker.on("message", resolve);
                worker.on("error", reject);
            })
        );
    }

    const batchResults = await Promise.all(workers);
    return batchResults.flat();
}

// prover-worker.js
const { workerData, parentPort } = require("worker_threads");
const snarkjs = require("snarkjs");

async function processBatch() {
    const results = [];

    for (const input of workerData.batch) {
        const { proof, publicSignals } = await snarkjs.groth16.fullProve(
            input,
            "build/circuit_js/circuit.wasm",
            "keys/circuit_final.zkey"
        );
        results.push({ proof, publicSignals });
    }

    parentPort.postMessage(results);
}

processBatch();
```

### 7.4 rapidsnark (고성능 Prover)

```bash
# rapidsnark: C++로 작성된 고성능 Groth16 prover
# https://github.com/iden3/rapidsnark

# 설치
git clone https://github.com/iden3/rapidsnark.git
cd rapidsnark
npm install
git submodule init
git submodule update
npx task createFieldSources
npx task buildProver

# 사용
./build/prover \
    keys/circuit_final.zkey \
    witness.wtns \
    proof.json \
    public.json

# 성능 비교 (예시)
# snarkjs: 5,000ms
# rapidsnark: 500ms (10x 빠름)
```

---

## 8. 전체 파이프라인 스크립트

### 8.1 통합 빌드 스크립트

```bash
#!/bin/bash
# scripts/build-all.sh

set -e

CIRCUIT_NAME=${1:-"circuit"}
PROOF_SYSTEM=${2:-"groth16"}

echo "=========================================="
echo "  ZK Proof Pipeline: ${CIRCUIT_NAME}"
echo "  Proof System: ${PROOF_SYSTEM}"
echo "=========================================="

# 1. 컴파일
echo ""
echo "[1/4] Compiling circuit..."
./scripts/compile.sh ${CIRCUIT_NAME}

# 2. Setup
echo ""
echo "[2/4] Running trusted setup..."
./scripts/setup.sh ${CIRCUIT_NAME} ${PROOF_SYSTEM}

# 3. 증명 생성 (테스트 입력)
echo ""
echo "[3/4] Generating test proof..."
./scripts/prove.sh ${CIRCUIT_NAME} ${PROOF_SYSTEM}

# 4. 검증
echo ""
echo "[4/4] Verifying proof..."
./scripts/verify.sh ${CIRCUIT_NAME} ${PROOF_SYSTEM}

echo ""
echo "=========================================="
echo "  Pipeline Complete!"
echo "=========================================="
```

### 8.2 Docker 환경

```dockerfile
# Dockerfile
FROM node:18-slim

# 필수 도구 설치
RUN apt-get update && apt-get install -y \
    git \
    curl \
    build-essential \
    && rm -rf /var/lib/apt/lists/*

# Rust 설치
RUN curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
ENV PATH="/root/.cargo/bin:${PATH}"

# Circom 설치
RUN git clone https://github.com/iden3/circom.git /circom \
    && cd /circom \
    && cargo build --release \
    && cp target/release/circom /usr/local/bin/

# snarkjs 설치
RUN npm install -g snarkjs

# 작업 디렉토리
WORKDIR /app

# 의존성 설치
COPY package*.json ./
RUN npm install

# 소스 복사
COPY . .

# 기본 명령
CMD ["npm", "run", "build"]
```

```yaml
# docker-compose.yml
version: '3.8'

services:
  zk-prover:
    build: .
    volumes:
      - ./circuits:/app/circuits
      - ./build:/app/build
      - ./keys:/app/keys
      - ./proofs:/app/proofs
    environment:
      - NODE_OPTIONS=--max-old-space-size=4096
```

---

## 9. 프로덕션 고려사항

### 9.1 Trusted Setup 보안

```
MPC Ceremony 권장사항:

1. 다수의 독립적 참가자 (최소 10명+)
2. 각 참가자는 자신만의 엔트로피 제공
3. 최소 1명이 정직하면 setup 안전
4. 참가자 신원 확인 및 공개
5. 전체 과정 문서화 및 검증 가능

프로덕션 Setup 절차:
1. 공개 MPC ceremony 개최
2. 다양한 참가자 모집 (지역, 조직)
3. 각 기여 검증 후 공개
4. 최종 랜덤 비콘 (공개 난수원)
5. 모든 기록 영구 보관
```

### 9.2 키 관리

```javascript
// 프로덕션 키 관리 예시
const AWS = require("aws-sdk");
const fs = require("fs");

class KeyManager {
    constructor() {
        this.s3 = new AWS.S3();
        this.kms = new AWS.KMS();
    }

    async uploadProvingKey(circuitName, zkeyPath) {
        const key = fs.readFileSync(zkeyPath);

        await this.s3.putObject({
            Bucket: "zk-proving-keys",
            Key: `${circuitName}/proving_key.zkey`,
            Body: key,
            ServerSideEncryption: "aws:kms",
            SSEKMSKeyId: process.env.KMS_KEY_ID
        }).promise();
    }

    async getProvingKey(circuitName) {
        const result = await this.s3.getObject({
            Bucket: "zk-proving-keys",
            Key: `${circuitName}/proving_key.zkey`
        }).promise();

        return result.Body;
    }
}
```

### 9.3 에러 처리

```javascript
// 프로덕션 에러 처리
async function generateProofSafe(circuitName, input) {
    try {
        // 입력 검증
        validateInput(input);

        // 타임아웃 설정
        const timeout = setTimeout(() => {
            throw new Error("Proof generation timeout");
        }, 60000);

        const result = await snarkjs.groth16.fullProve(
            input,
            `build/${circuitName}_js/${circuitName}.wasm`,
            `keys/${circuitName}_final.zkey`
        );

        clearTimeout(timeout);

        // 결과 검증
        if (!result.proof || !result.publicSignals) {
            throw new Error("Invalid proof result");
        }

        return { success: true, ...result };

    } catch (error) {
        console.error("Proof generation failed:", error);

        // 에러 분류
        if (error.message.includes("Assert Failed")) {
            return { success: false, error: "INVALID_INPUT", message: "Circuit constraints not satisfied" };
        } else if (error.message.includes("timeout")) {
            return { success: false, error: "TIMEOUT", message: "Proof generation timed out" };
        } else {
            return { success: false, error: "UNKNOWN", message: error.message };
        }
    }
}

function validateInput(input) {
    // 필수 필드 확인
    const requiredFields = ["a", "b", "secret"];
    for (const field of requiredFields) {
        if (!(field in input)) {
            throw new Error(`Missing required field: ${field}`);
        }
    }

    // 값 범위 확인
    for (const [key, value] of Object.entries(input)) {
        const bigValue = BigInt(value);
        if (bigValue < 0n) {
            throw new Error(`Negative value not allowed: ${key}`);
        }
        // BN254 필드 크기 확인
        const fieldSize = BigInt("21888242871839275222246405745257275088548364400416034343698204186575808495617");
        if (bigValue >= fieldSize) {
            throw new Error(`Value exceeds field size: ${key}`);
        }
    }
}
```

---

## 요약

```
증명 파이프라인 핵심:

1. 컴파일:
   circom → .r1cs + .wasm + .sym
   옵션: --O2 (최적화), --c (C++ witness)

2. Trusted Setup:
   Phase 1: Powers of Tau (범용, 다운로드 권장)
   Phase 2: Circuit-specific (Groth16) 또는 Universal (PLONK)

3. Witness 계산:
   input.json + .wasm → witness.wtns
   대규모: C++ witness 계산기 사용

4. 증명 생성:
   witness.wtns + .zkey → proof.json + public.json
   고성능: rapidsnark 사용

5. 검증:
   verification_key.json + proof.json + public.json → true/false
   On-chain: Verifier.sol 생성

성능 팁:
- Powers of Tau 재사용
- rapidsnark로 10x 속도 향상
- 병렬 처리로 배치 증명
- 메모리: 파일 스트리밍 활용

프로덕션:
- MPC ceremony로 trusted setup
- 키 관리 및 암호화
- 입력 검증 및 에러 처리
- 타임아웃 및 재시도 로직
```
