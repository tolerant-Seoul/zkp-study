# 1.2 Interactive vs Non-Interactive ZKP

## 개요

Zero-Knowledge Proof는 증명자와 검증자 간의 상호작용 방식에 따라 크게 두 가지로 분류된다:
- Interactive ZKP: 다중 라운드의 메시지 교환 필요
- Non-Interactive ZKP (NIZK): 단일 메시지로 증명 완료

이 문서에서는 두 방식의 차이점, 장단점, 그리고 실제 적용 사례를 다룬다.

---

## 1. Interactive Zero-Knowledge Proof

### 1.1 정의

Interactive ZKP는 증명자(Prover)와 검증자(Verifier)가 여러 라운드에 걸쳐 메시지를 주고받으며 증명을 완성하는 방식이다.

```
Interactive ZKP 구조:

    Prover (P)                     Verifier (V)
        |                              |
        |-------- commitment --------->|  Round 1
        |                              |
        |<------- challenge -----------|  Round 2
        |                              |
        |-------- response ----------->|  Round 3
        |                              |
        |         ...                  |
        |                              |
        |                         Accept/Reject
```

### 1.2 Sigma Protocol (시그마 프로토콜)

가장 대표적인 Interactive ZKP 구조로, 3-라운드 프로토콜이다.

```
Sigma Protocol 구조:

Round 1 - Commitment (증명자 -> 검증자):
- 증명자가 랜덤 값을 선택하고 commitment를 전송
- 이 값은 나중에 열릴(open) 약속

Round 2 - Challenge (검증자 -> 증명자):
- 검증자가 랜덤 challenge를 생성하여 전송
- 증명자가 미리 예측할 수 없어야 함

Round 3 - Response (증명자 -> 검증자):
- 증명자가 challenge에 대한 response 계산 및 전송
- 검증자가 (commitment, challenge, response) 검증
```

### 1.3 예시: Schnorr Identification Protocol

```
설정:
- 그룹 G, 생성원 g, 차수 q
- 비밀키 x, 공개키 y = g^x

증명 목표: "나는 y = g^x에 해당하는 x를 알고 있다"

Protocol:
┌────────────────────────────────────────────────────────────────┐
│                                                                │
│  Prover (x 알고 있음)              Verifier (y만 알고 있음)     │
│                                                                │
│  1. 랜덤 r 선택                                                 │
│     a = g^r 계산                                               │
│     ---------------------- a ---------------------->           │
│                                                                │
│                              2. 랜덤 c 선택 (challenge)         │
│     <--------------------- c ----------------------            │
│                                                                │
│  3. z = r + c*x (mod q) 계산                                   │
│     ---------------------- z ---------------------->           │
│                                                                │
│                              4. 검증: g^z == a * y^c ?         │
│                                 g^(r+cx) == g^r * g^(cx)       │
│                                 Accept if equal                │
│                                                                │
└────────────────────────────────────────────────────────────────┘
```

### 1.4 Interactive ZKP의 속성

#### 왜 Zero-Knowledge인가?

```
Simulator 구성:

1. Simulator는 x를 모른다
2. Simulator는 c를 먼저 선택할 수 있다 (시뮬레이션이므로)
3. 랜덤 z를 먼저 선택
4. a = g^z / y^c 로 역계산
5. (a, c, z)는 실제 transcript와 동일한 분포

따라서 실제 증명에서 x에 대한 정보가 누출되지 않는다.
```

#### 왜 Sound인가?

```
Special Soundness:

동일한 a에 대해 서로 다른 두 challenge c1, c2가 있고,
각각에 대한 유효한 response z1, z2가 있다면:

g^z1 = a * y^c1
g^z2 = a * y^c2

나누면:
g^(z1-z2) = y^(c1-c2)
g^(z1-z2) = g^(x*(c1-c2))

따라서:
x = (z1-z2) / (c1-c2) mod q

-> 두 개의 유효한 응답으로부터 비밀키 x를 추출 가능
-> 이는 악의적 증명자가 x 없이 두 challenge에 답할 수 없음을 의미
```

---

## 2. Non-Interactive Zero-Knowledge Proof (NIZK)

### 2.1 정의

NIZK는 증명자가 검증자와의 상호작용 없이 단일 메시지로 증명을 완성하는 방식이다.

```
NIZK 구조:

    Prover (P)                     Verifier (V)
        |                              |
        |                              |
        |-------- proof π ------------>|  단일 메시지
        |                              |
        |                         Accept/Reject
```

### 2.2 문제점: Challenge의 출처

Interactive ZKP에서 검증자가 제공하던 랜덤 challenge를 어떻게 대체할 것인가?

```
해결책들:

1. Common Reference String (CRS) 모델
   - 신뢰할 수 있는 셋업 단계에서 공개 파라미터 생성
   - 모든 참여자가 CRS에 접근

2. Random Oracle 모델 (Fiat-Shamir Transform)
   - 해시 함수를 이상적인 랜덤 오라클로 가정
   - 증명자가 스스로 challenge 생성 가능

3. Random Beacon 모델
   - 외부의 공개적이고 예측 불가능한 랜덤 소스 사용
```

### 2.3 Fiat-Shamir Transform

Interactive ZKP를 Non-Interactive로 변환하는 핵심 기법이다.

```
Fiat-Shamir Transform 원리:

Interactive:
P -> V: commitment a
V -> P: challenge c (랜덤)
P -> V: response z

Non-Interactive (Fiat-Shamir):
c = Hash(a, statement, [context])  // 검증자 대신 해시로 challenge 생성
proof = (a, z)                     // c는 검증자가 재계산

검증:
1. c = Hash(a, statement, [context]) 재계산
2. 원래 검증 수행
```

#### Schnorr 서명 (NIZK로 변환된 예시)

```
Interactive Schnorr -> Non-Interactive Schnorr Signature:

서명 생성:
1. 랜덤 r 선택
2. a = g^r
3. c = Hash(a || m || y)  // message m과 공개키 y 포함
4. z = r + c*x
5. signature = (a, z) 또는 (c, z)

서명 검증:
1. c = Hash(a || m || y) 계산 (또는 a = g^z / y^c 계산)
2. g^z == a * y^c 확인
```

### 2.4 Common Reference String (CRS) 모델

```
CRS 기반 NIZK 구조:

┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│  Setup Phase (신뢰할 수 있는 제3자 또는 MPC):                    │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  CRS = Setup(1^λ)                                        │   │
│  │  - Proving Key (pk): 증명 생성에 사용                     │   │
│  │  - Verification Key (vk): 검증에 사용                     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                          |                                      │
│                          v                                      │
│  ┌──────────────────────────────────────────────────────────┐  │
│  │  공개 배포                                                 │  │
│  └──────────────────────────────────────────────────────────┘  │
│                          |                                      │
│         ┌────────────────┴────────────────┐                    │
│         v                                  v                    │
│  ┌─────────────┐                    ┌─────────────┐            │
│  │   Prover    │                    │  Verifier   │            │
│  │  π = Prove  │                    │  Verify     │            │
│  │  (pk,x,w)   │─────── π ─────────>│  (vk,x,π)   │            │
│  └─────────────┘                    └─────────────┘            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. 비교 분석

### 3.1 주요 차이점

| 특성 | Interactive ZKP | Non-Interactive ZKP |
|------|-----------------|---------------------|
| 통신 라운드 | 다중 (보통 3회 이상) | 단일 |
| 검증자 참여 | 실시간 참여 필요 | 오프라인 검증 가능 |
| Challenge 출처 | 검증자가 생성 | Hash/CRS에서 파생 |
| 증명 재사용 | 불가 (각 세션마다 새로운 증명) | 가능 (누구나 검증) |
| 셋업 요구사항 | 없음 | CRS 또는 Random Oracle |
| 증명 크기 | 가변적 | 고정적 |

### 3.2 장단점 비교

#### Interactive ZKP

```
장점:
- 신뢰 가정 최소화 (Trusted Setup 불필요)
- 이론적으로 더 강한 보안 보장 가능
- 프로토콜 설계가 직관적

단점:
- 실시간 통신 필요
- 블록체인 등 비동기 환경에 부적합
- 증명 재사용 불가
- 각 검증마다 새로운 상호작용 필요
```

#### Non-Interactive ZKP

```
장점:
- 오프라인 검증 가능
- 블록체인, 스마트 컨트랙트와 호환
- 증명 재사용 가능 (공개 검증)
- 비동기 통신 환경에 적합

단점:
- Random Oracle 또는 CRS 모델 필요
- Trusted Setup의 경우 보안 위험
- 이론적 보안 가정이 더 강함
```

### 3.3 보안 모델 비교

```
Interactive ZKP:
┌─────────────────────────────────────────────────────────┐
│  Standard Model에서 증명 가능                            │
│  - 계산적 가정만 필요 (예: DLP가 어렵다)                  │
│  - 추가적인 이상화 가정 불필요                            │
└─────────────────────────────────────────────────────────┘

Non-Interactive ZKP (Fiat-Shamir):
┌─────────────────────────────────────────────────────────┐
│  Random Oracle Model에서 증명                            │
│  - 해시 함수가 이상적인 랜덤 함수라고 가정                │
│  - 현실의 해시 함수는 이 가정을 완벽히 만족하지 않음      │
│  - 실용적으로는 안전하다고 간주                          │
└─────────────────────────────────────────────────────────┘

Non-Interactive ZKP (CRS):
┌─────────────────────────────────────────────────────────┐
│  CRS Model에서 증명                                      │
│  - CRS가 정직하게 생성되었다고 가정                       │
│  - Trusted Setup 또는 MPC Setup 필요                     │
│  - Setup의 toxic waste가 누출되면 보안 붕괴              │
└─────────────────────────────────────────────────────────┘
```

---

## 4. 변환 기법

### 4.1 Fiat-Shamir Heuristic

```
알고리즘:

입력: Sigma Protocol (P_sigma, V_sigma)
출력: NIZK (Prove, Verify)

Prove(x, w):
1. a <- P_sigma.Commit(x, w, r)     // commitment 생성
2. c = H(a || x || [context])       // challenge를 해시로 생성
3. z <- P_sigma.Response(c, r, w)   // response 계산
4. return π = (a, z)

Verify(x, π):
1. Parse π as (a, z)
2. c = H(a || x || [context])       // challenge 재계산
3. return V_sigma.Verify(a, c, z, x)
```

### 4.2 예시: OR-Proof의 Fiat-Shamir 변환

```
목표: "x1 또는 x2 중 하나를 안다"를 NIZK로 증명

Interactive OR-Proof:
- x1에 대한 commitment a1과 x2에 대한 a2 전송
- challenge c 수신
- c = c1 + c2가 되도록 분할하여 response 생성

NIZK로 변환:
1. a1, a2 생성 (하나는 시뮬레이션, 하나는 실제)
2. c = Hash(a1 || a2 || statement)
3. c = c1 + c2로 분할
4. response z1, z2 계산
5. proof = (a1, a2, c1, z1, z2)
```

---

## 5. 실제 적용 사례

### 5.1 블록체인에서의 NIZK

```
왜 Non-Interactive가 필수인가:

블록체인 특성:
- 비동기 통신
- 검증자가 다수 (모든 노드)
- 영구 저장 및 재검증 필요
- 스마트 컨트랙트 내 검증

Interactive ZKP 문제점:
- 각 노드와 개별적으로 상호작용 불가
- 실시간 통신 불가능
- 증명이 한 번 생성되면 누구나 검증 가능해야 함

해결: NIZK 사용
- 증명을 트랜잭션에 포함
- 모든 노드가 독립적으로 검증
- 블록에 영구 저장되어 재검증 가능
```

### 5.2 zkSNARK

```
zkSNARK = Zero-Knowledge Succinct Non-Interactive Argument of Knowledge

특성:
- Non-Interactive: 단일 메시지 증명
- Succinct: 증명 크기가 작음 (수백 바이트)
- Argument: Computational Soundness (계산적 보안)

대표적 구현:
- Groth16: 가장 효율적인 증명 크기, Trusted Setup 필요
- PLONK: Universal Setup, 더 유연함
- Marlin: 빠른 증명 생성
```

### 5.3 zkSTARK

```
zkSTARK = Zero-Knowledge Scalable Transparent Argument of Knowledge

특성:
- Non-Interactive: 단일 메시지 증명
- Transparent: Trusted Setup 불필요 (Random Oracle만 사용)
- Scalable: 증명 생성 시간이 거의 선형적
- Post-Quantum: 해시 함수 기반으로 양자 내성

대표적 구현:
- StarkWare: Cairo 언어 사용
- Polygon Miden: STARK 기반 VM
```

### 5.4 비교: zkSNARK vs zkSTARK

| 특성 | zkSNARK | zkSTARK |
|------|---------|---------|
| 상호작용 | Non-Interactive | Non-Interactive |
| 셋업 | Trusted Setup (CRS) | Transparent (Random Oracle) |
| 증명 크기 | 매우 작음 (~200B) | 큼 (~100KB) |
| 검증 시간 | 매우 빠름 | 빠름 |
| 증명 생성 | 느림 | 빠름 (scalable) |
| 양자 내성 | 없음 | 있음 |

---

## 6. 실습: Sigma Protocol 구현

### 6.1 Python 의사 코드

```python
from hashlib import sha256
from random import randint

# 그룹 파라미터 (예시용 작은 값)
p = 23  # 소수
g = 5   # 생성원

def mod_exp(base, exp, mod):
    """모듈러 거듭제곱"""
    return pow(base, exp, mod)

class SchnorrInteractive:
    """Interactive Schnorr Identification"""

    def __init__(self, x):
        self.x = x  # 비밀키
        self.y = mod_exp(g, x, p)  # 공개키

    def commit(self):
        """Round 1: Commitment 생성"""
        self.r = randint(1, p-2)
        self.a = mod_exp(g, self.r, p)
        return self.a

    def respond(self, c):
        """Round 3: Response 생성"""
        z = (self.r + c * self.x) % (p-1)
        return z

    @staticmethod
    def verify(y, a, c, z):
        """검증"""
        lhs = mod_exp(g, z, p)
        rhs = (a * mod_exp(y, c, p)) % p
        return lhs == rhs


class SchnorrNonInteractive:
    """Non-Interactive Schnorr (Fiat-Shamir)"""

    def __init__(self, x):
        self.x = x
        self.y = mod_exp(g, x, p)

    def prove(self, message):
        """NIZK 증명 생성"""
        # Commitment
        r = randint(1, p-2)
        a = mod_exp(g, r, p)

        # Challenge (Fiat-Shamir)
        c = int(sha256(f"{a}{message}{self.y}".encode()).hexdigest(), 16) % (p-1)

        # Response
        z = (r + c * self.x) % (p-1)

        return (a, z)

    @staticmethod
    def verify(y, message, proof):
        """증명 검증"""
        a, z = proof

        # Challenge 재계산
        c = int(sha256(f"{a}{message}{y}".encode()).hexdigest(), 16) % (p-1)

        # 검증
        lhs = mod_exp(g, z, p)
        rhs = (a * mod_exp(y, c, p)) % p
        return lhs == rhs


# 사용 예시
if __name__ == "__main__":
    # Interactive
    print("=== Interactive Schnorr ===")
    prover = SchnorrInteractive(x=7)  # 비밀키 = 7
    a = prover.commit()
    c = randint(1, p-2)  # Verifier의 challenge
    z = prover.respond(c)
    result = SchnorrInteractive.verify(prover.y, a, c, z)
    print(f"Verification: {result}")

    # Non-Interactive
    print("\n=== Non-Interactive Schnorr ===")
    signer = SchnorrNonInteractive(x=7)
    message = "Hello, ZKP!"
    proof = signer.prove(message)
    result = SchnorrNonInteractive.verify(signer.y, message, proof)
    print(f"Verification: {result}")
```

---

## 7. 정리

### 7.1 선택 가이드

```
Interactive ZKP를 선택해야 할 때:
- Trusted Setup을 피하고 싶을 때
- 실시간 인증이 가능한 환경
- 이론적으로 가장 강한 보안이 필요할 때
- 증명이 재사용될 필요가 없을 때

Non-Interactive ZKP를 선택해야 할 때:
- 블록체인/스마트 컨트랙트 환경
- 오프라인 검증이 필요할 때
- 다수의 검증자가 동일한 증명을 검증할 때
- 증명을 저장하고 나중에 검증할 때
```

### 7.2 핵심 요약

```
┌─────────────────────────────────────────────────────────────────┐
│                 Interactive vs Non-Interactive 요약             │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  Interactive ZKP:                                               │
│  - 다중 라운드 통신 (Commit -> Challenge -> Response)           │
│  - 검증자가 랜덤 challenge 제공                                  │
│  - 실시간 상호작용 필요                                          │
│  - 증명 재사용 불가                                              │
│                                                                 │
│  Non-Interactive ZKP (NIZK):                                    │
│  - 단일 메시지로 증명 완료                                       │
│  - Fiat-Shamir (Hash) 또는 CRS로 challenge 대체                 │
│  - 오프라인 검증 가능                                            │
│  - 블록체인에 필수                                               │
│                                                                 │
│  변환: Fiat-Shamir Transform                                    │
│  - c = Hash(commitment || statement)                            │
│  - Interactive -> Non-Interactive 변환 가능                     │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

---

## 참고 자료

- Fiat, Shamir (1986) - "How to Prove Yourself"
- Schnorr (1991) - "Efficient Signature Generation by Smart Cards"
- Bellare, Rogaway (1993) - "Random Oracles are Practical"
- https://github.com/matter-labs/awesome-zero-knowledge-proofs
