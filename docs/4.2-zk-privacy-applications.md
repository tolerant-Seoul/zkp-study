# 4.2 ZK-Privacy Applications

## 개요

ZK-Privacy 애플리케이션은 영지식 증명을 사용하여 블록체인 트랜잭션의 프라이버시를 보호합니다. 이 문서에서는 주요 프라이버시 프로토콜의 아키텍처와 구현 방법을 분석합니다.

## 프라이버시 프로토콜 개요

### 핵심 프라이버시 요소

```
┌─────────────────────────────────────────────────────────────────┐
│                   블록체인 프라이버시 레이어                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐             │
│  │   Sender    │  │   Amount    │  │  Recipient  │             │
│  │  Anonymity  │  │   Privacy   │  │  Anonymity  │             │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘             │
│         │                │                │                     │
│         ▼                ▼                ▼                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              ZK-SNARK / ZK-STARK 증명 레이어             │   │
│  │  • Commitment Schemes                                   │   │
│  │  • Nullifier Patterns                                   │   │
│  │  • Merkle Tree Membership                               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │              스마트 컨트랙트 / 프로토콜 레이어            │   │
│  │  • Deposit / Withdraw                                   │   │
│  │  • Shield / Unshield                                    │   │
│  │  • Private Transfer                                     │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### Commitment 스킴

```typescript
// Pedersen Commitment
interface PedersenCommitment {
    // C = g^v * h^r
    // v: 값, r: 무작위 blinding factor
    commit(value: bigint, blindingFactor: bigint): Point;
    open(commitment: Point, value: bigint, blindingFactor: bigint): boolean;
}

// Poseidon Hash 기반 Commitment
interface PoseidonCommitment {
    // C = Poseidon(secret, nullifier)
    commit(secret: bigint, nullifier: bigint): bigint;
    // 증명: 주어진 commitment가 secret, nullifier로부터 생성됨을 증명
    proveKnowledge(secret: bigint, nullifier: bigint): ZKProof;
}
```

---

## Tornado Cash 프로토콜 분석

### 아키텍처

Tornado Cash는 이더리움에서 트랜잭션 익명성을 제공하는 대표적인 프라이버시 프로토콜입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│                 Tornado Cash Architecture                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  [Deposit Phase]                                                │
│  User ──▶ Generate (secret, nullifier)                          │
│       ──▶ Compute commitment = Hash(secret, nullifier)          │
│       ──▶ Send ETH + commitment to contract                     │
│       ──▶ Contract adds commitment to Merkle Tree               │
│                                                                  │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                    Merkle Tree                             │  │
│  │              ┌─────────┐                                   │  │
│  │              │  Root   │                                   │  │
│  │            ┌─┴─────────┴─┐                                 │  │
│  │          ┌─┴─┐         ┌─┴─┐                               │  │
│  │         ┌┴┐ ┌┴┐       ┌┴┐ ┌┴┐                              │  │
│  │         C1  C2        C3  ...  (commitments)               │  │
│  └───────────────────────────────────────────────────────────┘  │
│                                                                  │
│  [Withdraw Phase]                                               │
│  User ──▶ Generate ZK proof showing:                            │
│           • Knowledge of (secret, nullifier)                    │
│           • commitment = Hash(secret, nullifier)                │
│           • commitment is in Merkle tree                        │
│       ──▶ Submit proof + nullifierHash to contract             │
│       ──▶ Contract verifies proof and checks nullifier         │
│       ──▶ Contract sends ETH to recipient                      │
└─────────────────────────────────────────────────────────────────┘
```

### Tornado Cash 회로 구현

```circom
// tornado-core/circuits/withdraw.circom (Circom 2.0)
pragma circom 2.0.0;

include "../node_modules/circomlib/circuits/poseidon.circom";
include "../node_modules/circomlib/circuits/bitify.circom";

// Merkle Tree 검증
template MerkleTreeChecker(levels) {
    signal input leaf;
    signal input root;
    signal input pathElements[levels];
    signal input pathIndices[levels];

    component hashers[levels];
    component selectors[levels];

    signal hash[levels + 1];
    hash[0] <== leaf;

    for (var i = 0; i < levels; i++) {
        pathIndices[i] * (1 - pathIndices[i]) === 0;

        hashers[i] = Poseidon(2);

        // pathIndex가 0이면 왼쪽, 1이면 오른쪽
        selectors[i] = DualMux();
        selectors[i].in[0] <== hash[i];
        selectors[i].in[1] <== pathElements[i];
        selectors[i].s <== pathIndices[i];

        hashers[i].inputs[0] <== selectors[i].out[0];
        hashers[i].inputs[1] <== selectors[i].out[1];

        hash[i + 1] <== hashers[i].out;
    }

    root === hash[levels];
}

// Dual Mux - 조건부 스왑
template DualMux() {
    signal input in[2];
    signal input s;
    signal output out[2];

    s * (1 - s) === 0;
    out[0] <== (in[1] - in[0]) * s + in[0];
    out[1] <== (in[0] - in[1]) * s + in[1];
}

// 메인 출금 회로
template Withdraw(levels) {
    // Public inputs
    signal input root;
    signal input nullifierHash;
    signal input recipient;
    signal input relayer;
    signal input fee;
    signal input refund;

    // Private inputs
    signal input nullifier;
    signal input secret;
    signal input pathElements[levels];
    signal input pathIndices[levels];

    // Commitment 계산
    component commitmentHasher = Poseidon(2);
    commitmentHasher.inputs[0] <== nullifier;
    commitmentHasher.inputs[1] <== secret;

    // Nullifier hash 검증
    component nullifierHasher = Poseidon(1);
    nullifierHasher.inputs[0] <== nullifier;
    nullifierHasher.out === nullifierHash;

    // Merkle tree 포함 증명
    component tree = MerkleTreeChecker(levels);
    tree.leaf <== commitmentHasher.out;
    tree.root <== root;
    for (var i = 0; i < levels; i++) {
        tree.pathElements[i] <== pathElements[i];
        tree.pathIndices[i] <== pathIndices[i];
    }

    // Public inputs 제곱 (unused 방지)
    signal recipientSquare;
    signal relayerSquare;
    signal feeSquare;
    signal refundSquare;

    recipientSquare <== recipient * recipient;
    relayerSquare <== relayer * relayer;
    feeSquare <== fee * fee;
    refundSquare <== refund * refund;
}

component main {public [root, nullifierHash, recipient, relayer, fee, refund]} = Withdraw(20);
```

### Tornado Cash 스마트 컨트랙트

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./MerkleTreeWithHistory.sol";
import "./IVerifier.sol";

/**
 * @title Tornado
 * @notice Tornado Cash 핵심 컨트랙트 구조 분석
 */
abstract contract Tornado is MerkleTreeWithHistory {
    IVerifier public immutable verifier;
    uint256 public immutable denomination;

    mapping(bytes32 => bool) public nullifierHashes;
    mapping(bytes32 => bool) public commitments;

    event Deposit(
        bytes32 indexed commitment,
        uint32 leafIndex,
        uint256 timestamp
    );
    event Withdrawal(
        address to,
        bytes32 nullifierHash,
        address indexed relayer,
        uint256 fee
    );

    constructor(
        IVerifier _verifier,
        uint256 _denomination,
        uint32 _merkleTreeHeight
    ) MerkleTreeWithHistory(_merkleTreeHeight) {
        require(_denomination > 0, "denomination must be > 0");
        verifier = _verifier;
        denomination = _denomination;
    }

    /**
     * @notice 고정 금액 입금
     * @param _commitment Poseidon(nullifier, secret)
     */
    function deposit(bytes32 _commitment) external payable nonReentrant {
        require(!commitments[_commitment], "Commitment already exists");
        require(msg.value == denomination, "Incorrect deposit amount");

        uint32 insertedIndex = _insert(_commitment);
        commitments[_commitment] = true;

        emit Deposit(_commitment, insertedIndex, block.timestamp);
    }

    /**
     * @notice ZK 증명으로 출금
     * @param _proof ZK-SNARK 증명
     * @param _root Merkle root (유효한 과거 root 중 하나)
     * @param _nullifierHash nullifier의 해시
     * @param _recipient 수령인 주소
     * @param _relayer 릴레이어 주소 (가스비 대납)
     * @param _fee 릴레이어 수수료
     * @param _refund 환불액 (ERC20 풀의 경우)
     */
    function withdraw(
        bytes calldata _proof,
        bytes32 _root,
        bytes32 _nullifierHash,
        address payable _recipient,
        address payable _relayer,
        uint256 _fee,
        uint256 _refund
    ) external payable nonReentrant {
        require(_fee <= denomination, "Fee exceeds denomination");
        require(!nullifierHashes[_nullifierHash], "Already spent");
        require(isKnownRoot(_root), "Invalid merkle root");

        // ZK 증명 검증
        require(
            verifier.verifyProof(
                _proof,
                [
                    uint256(_root),
                    uint256(_nullifierHash),
                    uint256(uint160(_recipient)),
                    uint256(uint160(_relayer)),
                    _fee,
                    _refund
                ]
            ),
            "Invalid proof"
        );

        nullifierHashes[_nullifierHash] = true;

        // ETH 전송
        _processWithdraw(_recipient, _relayer, _fee, _refund);

        emit Withdrawal(_recipient, _nullifierHash, _relayer, _fee);
    }

    function _processWithdraw(
        address payable _recipient,
        address payable _relayer,
        uint256 _fee,
        uint256 _refund
    ) internal virtual;
}

/**
 * @title ETHTornado
 * @notice ETH 전용 Tornado 구현
 */
contract ETHTornado is Tornado {
    constructor(
        IVerifier _verifier,
        uint256 _denomination,
        uint32 _merkleTreeHeight
    ) Tornado(_verifier, _denomination, _merkleTreeHeight) {}

    function _processWithdraw(
        address payable _recipient,
        address payable _relayer,
        uint256 _fee,
        uint256 /*_refund*/
    ) internal override {
        require(msg.value == 0, "ETH value must be 0");

        (bool successRecipient, ) = _recipient.call{value: denomination - _fee}("");
        require(successRecipient, "Recipient transfer failed");

        if (_fee > 0) {
            (bool successRelayer, ) = _relayer.call{value: _fee}("");
            require(successRelayer, "Relayer transfer failed");
        }
    }
}
```

### Merkle Tree 구현

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

/**
 * @title MerkleTreeWithHistory
 * @notice 히스토리를 유지하는 Merkle Tree (과거 root 검증 가능)
 */
contract MerkleTreeWithHistory {
    uint256 public constant FIELD_SIZE =
        21888242871839275222246405745257275088548364400416034343698204186575808495617;
    uint256 public constant ZERO_VALUE =
        21663839004416932945382355908790599225266501822907911457504978515578255421292;

    uint32 public levels;

    // 최근 ROOT_HISTORY_SIZE개의 root 저장
    uint32 public constant ROOT_HISTORY_SIZE = 30;
    bytes32[ROOT_HISTORY_SIZE] public roots;
    uint32 public currentRootIndex = 0;

    // 다음 삽입 위치
    uint32 public nextIndex = 0;

    // 각 레벨의 채워진 subtree
    bytes32[] public filledSubtrees;

    // Zero value들 (Poseidon 해시)
    bytes32[] public zeros;

    constructor(uint32 _levels) {
        require(_levels > 0, "Levels must be > 0");
        require(_levels < 32, "Levels must be < 32");
        levels = _levels;

        // Zero values 초기화
        bytes32 currentZero = bytes32(ZERO_VALUE);
        zeros.push(currentZero);
        filledSubtrees.push(currentZero);

        for (uint32 i = 1; i < _levels; i++) {
            currentZero = hashLeftRight(currentZero, currentZero);
            zeros.push(currentZero);
            filledSubtrees.push(currentZero);
        }

        roots[0] = hashLeftRight(currentZero, currentZero);
    }

    /**
     * @notice Poseidon 해시 (두 입력)
     */
    function hashLeftRight(bytes32 _left, bytes32 _right)
        public
        pure
        returns (bytes32)
    {
        // 실제로는 Poseidon 해시 사용
        // 여기서는 간단히 keccak256 사용 (데모용)
        require(
            uint256(_left) < FIELD_SIZE && uint256(_right) < FIELD_SIZE,
            "Values not in field"
        );
        return bytes32(uint256(keccak256(abi.encodePacked(_left, _right))) % FIELD_SIZE);
    }

    /**
     * @notice 리프 삽입
     */
    function _insert(bytes32 _leaf) internal returns (uint32 index) {
        uint32 _nextIndex = nextIndex;
        require(_nextIndex < uint32(2)**levels, "Merkle tree is full");

        uint32 currentIndex = _nextIndex;
        bytes32 currentLevelHash = _leaf;
        bytes32 left;
        bytes32 right;

        for (uint32 i = 0; i < levels; i++) {
            if (currentIndex % 2 == 0) {
                left = currentLevelHash;
                right = zeros[i];
                filledSubtrees[i] = currentLevelHash;
            } else {
                left = filledSubtrees[i];
                right = currentLevelHash;
            }

            currentLevelHash = hashLeftRight(left, right);
            currentIndex /= 2;
        }

        uint32 newRootIndex = (currentRootIndex + 1) % ROOT_HISTORY_SIZE;
        currentRootIndex = newRootIndex;
        roots[newRootIndex] = currentLevelHash;

        nextIndex = _nextIndex + 1;
        return _nextIndex;
    }

    /**
     * @notice 유효한 root인지 확인
     */
    function isKnownRoot(bytes32 _root) public view returns (bool) {
        if (_root == 0) return false;

        uint32 i = currentRootIndex;
        do {
            if (_root == roots[i]) return true;
            if (i == 0) i = ROOT_HISTORY_SIZE;
            i--;
        } while (i != currentRootIndex);

        return false;
    }

    /**
     * @notice 현재 root 반환
     */
    function getLastRoot() public view returns (bytes32) {
        return roots[currentRootIndex];
    }
}
```

### Tornado Cash 클라이언트

```typescript
import { ethers } from "ethers";
import { buildPoseidon } from "circomlibjs";
import { MerkleTree } from "fixed-merkle-tree";
import * as snarkjs from "snarkjs";

interface TornadoNote {
    currency: string;
    amount: string;
    netId: number;
    deposit: {
        secret: bigint;
        nullifier: bigint;
        commitment: string;
        nullifierHash: string;
    };
}

class TornadoClient {
    private poseidon: any;
    private contract: ethers.Contract;
    private tree: MerkleTree;
    private levels = 20;

    async initialize(contractAddress: string, provider: ethers.Provider) {
        this.poseidon = await buildPoseidon();

        this.contract = new ethers.Contract(
            contractAddress,
            tornadoAbi,
            provider
        );

        // Merkle tree 복원
        const events = await this.contract.queryFilter(
            this.contract.filters.Deposit()
        );

        const leaves = events.map(e => e.args!.commitment);

        this.tree = new MerkleTree(this.levels, leaves, {
            hashFunction: this.poseidonHash2.bind(this),
            zeroElement: "21663839004416932945382355908790599225266501822907911457504978515578255421292"
        });
    }

    poseidonHash2(left: string, right: string): string {
        return this.poseidon.F.toString(
            this.poseidon([BigInt(left), BigInt(right)])
        );
    }

    /**
     * 새 노트 생성 (입금 준비)
     */
    async createNote(): Promise<TornadoNote> {
        // 랜덤 값 생성
        const secret = BigInt("0x" + ethers.hexlify(ethers.randomBytes(31)).slice(2));
        const nullifier = BigInt("0x" + ethers.hexlify(ethers.randomBytes(31)).slice(2));

        // Commitment 계산
        const commitment = this.poseidon.F.toString(
            this.poseidon([nullifier, secret])
        );

        // Nullifier hash 계산
        const nullifierHash = this.poseidon.F.toString(
            this.poseidon([nullifier])
        );

        return {
            currency: "eth",
            amount: "0.1",
            netId: 1,
            deposit: {
                secret,
                nullifier,
                commitment: "0x" + BigInt(commitment).toString(16).padStart(64, "0"),
                nullifierHash: "0x" + BigInt(nullifierHash).toString(16).padStart(64, "0"),
            }
        };
    }

    /**
     * 입금 실행
     */
    async deposit(
        note: TornadoNote,
        signer: ethers.Signer
    ): Promise<ethers.ContractTransactionReceipt> {
        const contractWithSigner = this.contract.connect(signer);

        const tx = await contractWithSigner.deposit(note.deposit.commitment, {
            value: ethers.parseEther(note.amount)
        });

        return await tx.wait();
    }

    /**
     * 출금 증명 생성
     */
    async generateWithdrawProof(
        note: TornadoNote,
        recipient: string,
        relayer: string = ethers.ZeroAddress,
        fee: bigint = 0n,
        refund: bigint = 0n
    ): Promise<{ proof: any; publicSignals: any }> {
        // Merkle path 가져오기
        const leafIndex = this.tree.indexOf(note.deposit.commitment);
        if (leafIndex < 0) {
            throw new Error("Commitment not found in tree");
        }

        const { pathElements, pathIndices } = this.tree.path(leafIndex);

        // 회로 입력
        const input = {
            // Public
            root: this.tree.root,
            nullifierHash: note.deposit.nullifierHash,
            recipient: BigInt(recipient),
            relayer: BigInt(relayer),
            fee: fee,
            refund: refund,

            // Private
            nullifier: note.deposit.nullifier,
            secret: note.deposit.secret,
            pathElements: pathElements,
            pathIndices: pathIndices,
        };

        // 증명 생성
        const { proof, publicSignals } = await snarkjs.groth16.fullProve(
            input,
            "circuits/withdraw.wasm",
            "circuits/withdraw_final.zkey"
        );

        return { proof, publicSignals };
    }

    /**
     * 증명을 Solidity calldata로 변환
     */
    async formatProofForContract(
        proof: any,
        publicSignals: any
    ): Promise<{
        proof: string;
        args: any[];
    }> {
        const calldata = await snarkjs.groth16.exportSolidityCallData(
            proof,
            publicSignals
        );

        const argv = calldata
            .replace(/["[\]\s]/g, "")
            .split(",")
            .map((x: string) => BigInt(x).toString());

        const proofData = {
            a: [argv[0], argv[1]],
            b: [[argv[2], argv[3]], [argv[4], argv[5]]],
            c: [argv[6], argv[7]],
        };

        const proofBytes = ethers.AbiCoder.defaultAbiCoder().encode(
            ["uint256[2]", "uint256[2][2]", "uint256[2]"],
            [proofData.a, proofData.b, proofData.c]
        );

        return {
            proof: proofBytes,
            args: [
                argv[8],  // root
                argv[9],  // nullifierHash
                argv[10], // recipient
                argv[11], // relayer
                argv[12], // fee
                argv[13], // refund
            ]
        };
    }

    /**
     * 출금 실행
     */
    async withdraw(
        note: TornadoNote,
        recipient: string,
        signer: ethers.Signer,
        relayer?: string,
        fee?: bigint
    ): Promise<ethers.ContractTransactionReceipt> {
        const { proof, publicSignals } = await this.generateWithdrawProof(
            note,
            recipient,
            relayer || ethers.ZeroAddress,
            fee || 0n,
            0n
        );

        const { proof: proofBytes, args } = await this.formatProofForContract(
            proof,
            publicSignals
        );

        const contractWithSigner = this.contract.connect(signer);

        const tx = await contractWithSigner.withdraw(
            proofBytes,
            args[0], // root
            args[1], // nullifierHash
            args[2], // recipient
            args[3], // relayer
            args[4], // fee
            args[5]  // refund
        );

        return await tx.wait();
    }
}
```

---

## Zcash 프로토콜 분석

### Sapling 프로토콜

```
┌─────────────────────────────────────────────────────────────────┐
│                   Zcash Sapling Protocol                         │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  [Note Structure]                                               │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Note = (d, pk_d, v, rcm)                                │   │
│  │  • d: diversifier (11 bytes)                            │   │
│  │  • pk_d: diversified transmission key                   │   │
│  │  • v: value (64 bits)                                   │   │
│  │  • rcm: random commitment trapdoor                      │   │
│  └─────────────────────────────────────────────────────────┘   │
│                                                                  │
│  [Commitment]                                                   │
│  cm = PedersenHash(repr(g_d), repr(pk_d), v, rcm)              │
│                                                                  │
│  [Nullifier]                                                    │
│  nf = PRF^nf_nsk(repr(cm))                                     │
│                                                                  │
│  [Spend/Output Description]                                     │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Spend:                                                  │   │
│  │  • cv: value commitment                                  │   │
│  │  • anchor: Merkle root                                   │   │
│  │  • nullifier: nf                                        │   │
│  │  • rk: randomized public key                            │   │
│  │  • zkproof: Groth16 proof                               │   │
│  │  • spendAuthSig: authorization signature                │   │
│  └─────────────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │  Output:                                                 │   │
│  │  • cv: value commitment                                  │   │
│  │  • cmu: note commitment                                  │   │
│  │  • ephemeralKey: for encryption                         │   │
│  │  • encCiphertext: encrypted note                        │   │
│  │  • outCiphertext: encrypted memo                        │   │
│  │  • zkproof: Groth16 proof                               │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### Sapling 회로 개념

```rust
// Zcash Sapling Spend Circuit (Rust/Bellman)
use bellman::{Circuit, ConstraintSystem, SynthesisError};
use ff::PrimeField;

/// Sapling Spend 회로
pub struct SpendCircuit<F: PrimeField> {
    // Private inputs
    /// 소비할 노트의 값
    pub value: Option<u64>,
    /// diversifier
    pub diversifier: Option<[u8; 11]>,
    /// 수신 키
    pub pk_d: Option<jubjub::SubgroupPoint>,
    /// 랜덤 commitment trapdoor
    pub commitment_randomness: Option<F>,
    /// 증명 생성 키
    pub proof_generation_key: Option<ProofGenerationKey>,
    /// Merkle path
    pub auth_path: Vec<Option<(F, bool)>>,
    /// anchor (Merkle root)
    pub anchor: Option<F>,

    // 서명 관련
    /// authorization randomness
    pub ar: Option<F>,
}

impl<F: PrimeField> Circuit<F> for SpendCircuit<F> {
    fn synthesize<CS: ConstraintSystem<F>>(
        self,
        cs: &mut CS,
    ) -> Result<(), SynthesisError> {
        // 1. Value commitment 계산
        // cv = ValueCommit(value, rcv)
        let value_bits = boolean::u64_into_boolean_vec_le(
            cs.namespace(|| "value"),
            self.value
        )?;

        let cv = pedersen_hash::pedersen_hash(
            cs.namespace(|| "value commitment"),
            pedersen_hash::Personalization::ValueCommitmentValue,
            &value_bits,
        )?;

        // 2. Note commitment 계산
        // cm = NoteCommit(g_d, pk_d, value, rcm)
        let note_commitment = {
            let g_d = group_hash(
                cs.namespace(|| "g_d"),
                &diversifier_bits,
            )?;

            let cm_contents = [
                g_d.x,
                g_d.y,
                pk_d.x,
                pk_d.y,
                value_bits.clone(),
                rcm_bits,
            ].concat();

            pedersen_hash::pedersen_hash(
                cs.namespace(|| "note commitment"),
                pedersen_hash::Personalization::NoteCommitment,
                &cm_contents,
            )?
        };

        // 3. Nullifier 계산
        // nf = PRF^nf_nsk(cm)
        let nullifier = prf_nf(
            cs.namespace(|| "nullifier"),
            &nsk_bits,
            &note_commitment,
        )?;

        // nullifier를 public input으로 노출
        nullifier.inputize(cs.namespace(|| "nullifier public input"))?;

        // 4. Merkle path 검증
        let mut cur = note_commitment;
        for (i, layer) in self.auth_path.into_iter().enumerate() {
            let (sibling, is_right) = layer.ok_or(SynthesisError::AssignmentMissing)?;

            let (left, right) = if is_right {
                (sibling, cur)
            } else {
                (cur, sibling)
            };

            cur = pedersen_hash::pedersen_hash(
                cs.namespace(|| format!("merkle layer {}", i)),
                pedersen_hash::Personalization::MerkleTree(i),
                &[left.to_bits(), right.to_bits()].concat(),
            )?;
        }

        // anchor (Merkle root) 검증
        let anchor_var = num::AllocatedNum::alloc(
            cs.namespace(|| "anchor"),
            || self.anchor.ok_or(SynthesisError::AssignmentMissing)
        )?;
        anchor_var.inputize(cs.namespace(|| "anchor public input"))?;

        cs.enforce(
            || "merkle root check",
            |lc| lc + cur.get_variable(),
            |lc| lc + CS::one(),
            |lc| lc + anchor_var.get_variable(),
        );

        // 5. 서명 검증 키 계산
        // rk = SpendAuthSig.RandomizePublic(ak, ar)
        let ak = self.proof_generation_key
            .as_ref()
            .map(|k| k.ak.clone());

        let rk = {
            let ak_point = fixed_base_multiplication(
                cs.namespace(|| "ak"),
                &ak_bits,
            )?;

            let ar_point = fixed_base_multiplication(
                cs.namespace(|| "ar * G"),
                &ar_bits,
            )?;

            ak_point.add(
                cs.namespace(|| "rk = ak + ar * G"),
                &ar_point,
            )?
        };

        rk.inputize(cs.namespace(|| "rk public input"))?;

        Ok(())
    }
}
```

### Orchard 프로토콜 (최신)

```rust
// Zcash Orchard Protocol (Halo2 기반)
use halo2_proofs::{
    circuit::{Layouter, SimpleFloorPlanner, Value},
    plonk::{Circuit, ConstraintSystem, Error},
};
use pasta_curves::pallas;

/// Orchard Action 회로
/// Spend와 Output을 하나의 Action으로 통합
pub struct ActionCircuit {
    // Spend side
    pub spend_auth_path: Vec<MerkleNode>,
    pub spend_note: Option<Note>,
    pub alpha: Option<pallas::Scalar>,      // spend auth randomizer
    pub fvk: Option<FullViewingKey>,

    // Output side
    pub output_note: Option<Note>,
    pub rcv: Option<pallas::Scalar>,        // value commitment randomness
}

impl Circuit<pallas::Base> for ActionCircuit {
    type Config = ActionConfig;
    type FloorPlanner = SimpleFloorPlanner;

    fn configure(meta: &mut ConstraintSystem<pallas::Base>) -> Self::Config {
        // Sinsemilla 해시 설정 (Pedersen 대체)
        let sinsemilla_config = SinsemillaChip::configure(
            meta,
            advices[..5].try_into().unwrap(),
            advices[5],
            lagrange_coeffs,
            fixed_bases,
        );

        // Merkle tree 검증 설정
        let merkle_config = MerkleChip::configure(
            meta,
            sinsemilla_config.clone(),
        );

        // Note commitment 설정
        let note_commit_config = NoteCommitChip::configure(
            meta,
            advices,
            sinsemilla_config.clone(),
        );

        ActionConfig {
            sinsemilla_config,
            merkle_config,
            note_commit_config,
        }
    }

    fn synthesize(
        &self,
        config: Self::Config,
        mut layouter: impl Layouter<pallas::Base>,
    ) -> Result<(), Error> {
        // 칩 인스턴스화
        let sinsemilla_chip = SinsemillaChip::construct(config.sinsemilla_config);
        let merkle_chip = MerkleChip::construct(config.merkle_config);
        let note_commit_chip = NoteCommitChip::construct(config.note_commit_config);

        // === Spend 측 ===

        // 1. old note commitment 계산
        let old_cm = note_commit_chip.note_commit(
            layouter.namespace(|| "old note commitment"),
            self.spend_note.as_ref().map(|n| n.to_commitment_input()),
        )?;

        // 2. Nullifier 계산 (Poseidon 사용)
        let nf = {
            let nk = self.fvk.as_ref().map(|fvk| fvk.nk());
            let rho = self.spend_note.as_ref().map(|n| n.rho());

            poseidon_hash(
                layouter.namespace(|| "nullifier"),
                &[nk, rho, psi, old_cm],
            )?
        };

        // 3. Merkle path 검증
        let anchor = merkle_chip.verify_path(
            layouter.namespace(|| "merkle path verification"),
            old_cm,
            &self.spend_auth_path,
        )?;

        // 4. rk (randomized public key) 계산
        let rk = {
            let ak = self.fvk.as_ref().map(|fvk| fvk.ak());
            let alpha = self.alpha;

            // rk = ak + [alpha] * SpendAuthG
            point_add(
                layouter.namespace(|| "rk"),
                ak,
                scalar_mul(alpha, SPEND_AUTH_G),
            )?
        };

        // === Output 측 ===

        // 5. new note commitment 계산
        let new_cm = note_commit_chip.note_commit(
            layouter.namespace(|| "new note commitment"),
            self.output_note.as_ref().map(|n| n.to_commitment_input()),
        )?;

        // === Value balance ===

        // 6. Value commitment 계산
        // cv = [v] * V + [rcv] * R
        let cv = {
            let v_old = self.spend_note.as_ref().map(|n| n.value());
            let v_new = self.output_note.as_ref().map(|n| n.value());

            let cv_net = value_commit(
                layouter.namespace(|| "cv_net"),
                v_old.zip(v_new).map(|(old, new)| old - new),
                self.rcv,
            )?
        };

        // Public inputs로 노출
        layouter.constrain_instance(anchor.cell(), 0)?;
        layouter.constrain_instance(nf.cell(), 1)?;
        layouter.constrain_instance(rk.x().cell(), 2)?;
        layouter.constrain_instance(rk.y().cell(), 3)?;
        layouter.constrain_instance(new_cm.cell(), 4)?;
        layouter.constrain_instance(cv.x().cell(), 5)?;
        layouter.constrain_instance(cv.y().cell(), 6)?;

        Ok(())
    }
}
```

---

## Aztec Protocol

### Aztec Connect 아키텍처

```
┌─────────────────────────────────────────────────────────────────┐
│                  Aztec Protocol Architecture                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                    Noir Language                         │   │
│  │  • Domain-specific language for ZK circuits             │   │
│  │  • Rust-like syntax                                     │   │
│  │  • Compiles to ACIR (Abstract Circuit IR)               │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                  Barretenberg Backend                    │   │
│  │  • UltraPlonk proving system                            │   │
│  │  • GPU acceleration                                     │   │
│  │  • Recursive proofs                                     │   │
│  └─────────────────────────────────────────────────────────┘   │
│                              │                                  │
│                              ▼                                  │
│  ┌─────────────────────────────────────────────────────────┐   │
│  │                   Aztec Network                          │   │
│  │  • Encrypted state                                      │   │
│  │  • Private transactions                                 │   │
│  │  • DeFi bridge contracts                                │   │
│  └─────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────┘
```

### Noir 프라이버시 회로

```rust
// Noir 언어 - 프라이버시 보존 토큰 전송
use dep::std;

// Note 구조체
struct Note {
    owner: Field,           // 소유자 공개키
    value: u64,            // 토큰 양
    salt: Field,           // 랜덤 salt
    asset_id: Field,       // 자산 ID
}

impl Note {
    // Note commitment 계산
    fn commitment(self) -> Field {
        std::hash::pedersen_hash([
            self.owner,
            self.value as Field,
            self.salt,
            self.asset_id
        ])
    }

    // Nullifier 계산
    fn nullifier(self, nullifier_key: Field) -> Field {
        std::hash::poseidon::bn254::hash_2([
            nullifier_key,
            self.commitment()
        ])
    }
}

// 프라이빗 전송 회로
fn main(
    // Public inputs
    pub merkle_root: Field,
    pub nullifier1: Field,
    pub nullifier2: Field,
    pub output_commitment1: Field,
    pub output_commitment2: Field,
    pub public_value: u64,        // 공개 입출금 양

    // Private inputs
    sender_nullifier_key: Field,
    input_note1: Note,
    input_note2: Note,
    merkle_path1: [Field; 32],
    merkle_indices1: [u1; 32],
    merkle_path2: [Field; 32],
    merkle_indices2: [u1; 32],
    output_note1: Note,
    output_note2: Note,
) {
    // 1. Input note nullifier 검증
    assert(input_note1.nullifier(sender_nullifier_key) == nullifier1);
    assert(input_note2.nullifier(sender_nullifier_key) == nullifier2);

    // 2. Merkle tree 포함 증명
    let computed_root1 = compute_merkle_root(
        input_note1.commitment(),
        merkle_path1,
        merkle_indices1
    );
    assert(computed_root1 == merkle_root);

    let computed_root2 = compute_merkle_root(
        input_note2.commitment(),
        merkle_path2,
        merkle_indices2
    );
    assert(computed_root2 == merkle_root);

    // 3. Output commitment 검증
    assert(output_note1.commitment() == output_commitment1);
    assert(output_note2.commitment() == output_commitment2);

    // 4. Value balance 검증 (입력 = 출력 + 공개값)
    let input_sum = input_note1.value + input_note2.value;
    let output_sum = output_note1.value + output_note2.value;
    assert(input_sum == output_sum + public_value);

    // 5. Asset ID 일관성 검증
    assert(input_note1.asset_id == output_note1.asset_id);
    assert(input_note1.asset_id == output_note2.asset_id);
}

// Merkle root 계산
fn compute_merkle_root(
    leaf: Field,
    path: [Field; 32],
    indices: [u1; 32]
) -> Field {
    let mut current = leaf;

    for i in 0..32 {
        let sibling = path[i];
        let (left, right) = if indices[i] == 0 {
            (current, sibling)
        } else {
            (sibling, current)
        };

        current = std::hash::pedersen_hash([left, right]);
    }

    current
}
```

### Aztec.js SDK

```typescript
import {
    AztecSdk,
    EthAddress,
    GrumpkinAddress,
    createAztecSdk,
    AccountId,
    AztecSdkUser,
    TxSettlementTime,
} from "@aztec/sdk";
import { ethers } from "ethers";

class AztecPrivateTransfer {
    private sdk: AztecSdk;
    private user: AztecSdkUser;

    async initialize() {
        const ethereumProvider = new ethers.BrowserProvider(window.ethereum);

        this.sdk = await createAztecSdk(ethereumProvider, {
            serverUrl: "https://api.aztec.network/aztec-connect-prod/falafel",
            memoryDb: true,
            minConfirmation: 1,
        });

        await this.sdk.run();
        await this.sdk.awaitSynchronised();
    }

    /**
     * 새 Aztec 계정 생성
     */
    async createAccount(
        ethSigner: ethers.Signer
    ): Promise<AccountId> {
        const ethAddress = EthAddress.fromString(await ethSigner.getAddress());

        // 서명으로부터 Aztec 키 유도
        const { privateKey } = await this.sdk.generateAccountKeyPair(ethAddress);

        // 계정 등록
        const accountId = await this.sdk.addUser(privateKey);

        this.user = await this.sdk.getUser(accountId);

        return accountId;
    }

    /**
     * ETH를 Aztec으로 Shield (입금)
     */
    async shieldEth(
        amount: bigint,
        recipient: GrumpkinAddress
    ): Promise<string> {
        const assetId = this.sdk.getAssetIdBySymbol("ETH");

        // Shield 컨트롤러 생성
        const controller = this.sdk.createShieldController(
            assetId,
            this.user.id,
            amount,
            recipient,
            TxSettlementTime.INSTANT
        );

        // 수수료 계산
        const fee = await controller.getFee();
        console.log("Shield fee:", fee.toString());

        // 입금 증명 생성 및 전송
        await controller.createProof();
        await controller.depositFundsToContract();
        await controller.approveProof();

        const txId = await controller.send();
        console.log("Shield tx:", txId.toString());

        return txId.toString();
    }

    /**
     * 프라이빗 전송
     */
    async privateTransfer(
        amount: bigint,
        recipient: GrumpkinAddress
    ): Promise<string> {
        const assetId = this.sdk.getAssetIdBySymbol("ETH");

        // 전송 컨트롤러 생성
        const controller = this.sdk.createTransferController(
            assetId,
            this.user.id,
            amount,
            recipient,
            TxSettlementTime.INSTANT
        );

        // 증명 생성 (프라이버시 보존)
        await controller.createProof();

        const txId = await controller.send();
        console.log("Private transfer tx:", txId.toString());

        return txId.toString();
    }

    /**
     * Unshield (출금)
     */
    async unshieldEth(
        amount: bigint,
        recipient: EthAddress
    ): Promise<string> {
        const assetId = this.sdk.getAssetIdBySymbol("ETH");

        // Withdraw 컨트롤러
        const controller = this.sdk.createWithdrawController(
            assetId,
            this.user.id,
            amount,
            recipient,
            TxSettlementTime.INSTANT
        );

        await controller.createProof();
        const txId = await controller.send();

        console.log("Unshield tx:", txId.toString());

        return txId.toString();
    }

    /**
     * DeFi 브릿지 (프라이버시 보존 DeFi)
     */
    async defiInteraction(
        bridgeId: number,
        amount: bigint
    ): Promise<string> {
        // 예: Lido stETH 스테이킹
        const controller = this.sdk.createDefiController(
            bridgeId,
            this.user.id,
            amount,
            TxSettlementTime.INSTANT
        );

        await controller.createProof();
        const txId = await controller.send();

        console.log("DeFi interaction tx:", txId.toString());

        return txId.toString();
    }

    /**
     * 잔액 조회
     */
    async getBalance(): Promise<Map<string, bigint>> {
        const balances = new Map<string, bigint>();

        const assets = ["ETH", "DAI", "renBTC"];

        for (const symbol of assets) {
            const assetId = this.sdk.getAssetIdBySymbol(symbol);
            const balance = await this.user.getBalance(assetId);
            balances.set(symbol, balance);
        }

        return balances;
    }
}
```

---

## 프라이버시 프로토콜 비교

### 기술 스택 비교

| 특성 | Tornado Cash | Zcash (Sapling) | Zcash (Orchard) | Aztec |
|------|-------------|-----------------|-----------------|-------|
| **증명 시스템** | Groth16 | Groth16 | Halo2 | UltraPlonk |
| **해시 함수** | Poseidon | Pedersen | Sinsemilla | Poseidon |
| **플랫폼** | Ethereum | Zcash | Zcash | Ethereum |
| **금액 숨김** | 고정 금액 | 가능 | 가능 | 가능 |
| **수신자 익명성** | Relayer 사용 | 완전 | 완전 | 완전 |
| **Trusted Setup** | 필요 | 필요 | 불필요 | 필요 |

### 보안 고려사항

```typescript
// 프라이버시 프로토콜 보안 체크리스트
interface PrivacySecurityChecklist {
    // 암호학적 보안
    proofSoundness: boolean;           // 증명 건전성
    zeroKnowledge: boolean;            // 영지식 속성
    commitmentBinding: boolean;        // Commitment binding
    nullifierUniqueness: boolean;      // Nullifier 고유성

    // 프로토콜 보안
    frontRunningProtection: boolean;   // 선행 거래 방지
    replayProtection: boolean;         // 재전송 공격 방지
    timingAttackMitigation: boolean;   // 타이밍 공격 완화

    // 운영 보안
    relayerTrust: string;              // Relayer 신뢰 모델
    withdrawalPattern: string;         // 출금 패턴 분석 저항
    anonymitySetSize: number;          // 익명성 집합 크기
}

const tornadoSecurity: PrivacySecurityChecklist = {
    proofSoundness: true,
    zeroKnowledge: true,
    commitmentBinding: true,
    nullifierUniqueness: true,
    frontRunningProtection: false,      // Relayer가 선행 가능
    replayProtection: true,
    timingAttackMitigation: false,      // 사용자 주의 필요
    relayerTrust: "minimal",            // 검열만 가능
    withdrawalPattern: "time-based",    // 시간 지연 권장
    anonymitySetSize: 1000,             // 풀 크기에 따라 다름
};
```

---

## 실전 구현 가이드

### 프라이버시 보존 투표 시스템

```circom
// privacy_voting.circom
pragma circom 2.0.0;

include "poseidon.circom";
include "merkletree.circom";
include "comparators.circom";

/**
 * 프라이버시 보존 투표
 * - 투표자 익명성 보장
 * - 이중 투표 방지
 * - 자격 증명
 */
template PrivateVoting(levels, numChoices) {
    // Public inputs
    signal input voterMerkleRoot;       // 유권자 Merkle root
    signal input nullifierHash;          // 이중 투표 방지
    signal input proposalId;             // 제안 ID
    signal input voteChoice;             // 투표 선택 (0, 1, ..., numChoices-1)
    signal input voteCommitment;         // 투표 commitment

    // Private inputs
    signal input voterSecret;            // 유권자 비밀
    signal input voterNullifier;         // 유권자 nullifier
    signal input voterPathElements[levels];
    signal input voterPathIndices[levels];
    signal input voteRandomness;         // 투표 랜덤성

    // 1. 유권자 자격 증명
    component voterCommitmentHasher = Poseidon(2);
    voterCommitmentHasher.inputs[0] <== voterSecret;
    voterCommitmentHasher.inputs[1] <== voterNullifier;

    component voterTree = MerkleTreeChecker(levels);
    voterTree.leaf <== voterCommitmentHasher.out;
    voterTree.root <== voterMerkleRoot;
    for (var i = 0; i < levels; i++) {
        voterTree.pathElements[i] <== voterPathElements[i];
        voterTree.pathIndices[i] <== voterPathIndices[i];
    }

    // 2. Nullifier 검증 (proposal별 고유)
    component nullifierHasher = Poseidon(2);
    nullifierHasher.inputs[0] <== voterNullifier;
    nullifierHasher.inputs[1] <== proposalId;
    nullifierHasher.out === nullifierHash;

    // 3. 투표 선택 유효성 검증
    component validChoice = LessThan(8);
    validChoice.in[0] <== voteChoice;
    validChoice.in[1] <== numChoices;
    validChoice.out === 1;

    // 4. 투표 Commitment 검증
    component voteCommitmentHasher = Poseidon(3);
    voteCommitmentHasher.inputs[0] <== voteChoice;
    voteCommitmentHasher.inputs[1] <== proposalId;
    voteCommitmentHasher.inputs[2] <== voteRandomness;
    voteCommitmentHasher.out === voteCommitment;
}

component main {public [voterMerkleRoot, nullifierHash, proposalId, voteChoice, voteCommitment]} = PrivateVoting(20, 5);
```

### 프라이버시 투표 컨트랙트

```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "./IVerifier.sol";
import "./MerkleTreeWithHistory.sol";

contract PrivateVoting is MerkleTreeWithHistory {
    IVerifier public immutable verifier;

    struct Proposal {
        string description;
        uint256 deadline;
        uint256[] voteCounts;
        bool finalized;
    }

    mapping(uint256 => Proposal) public proposals;
    mapping(bytes32 => bool) public nullifierUsed;
    mapping(bytes32 => bool) public voteCommitments;

    uint256 public proposalCount;
    bytes32 public voterMerkleRoot;

    event ProposalCreated(uint256 indexed proposalId, string description);
    event VoteCast(uint256 indexed proposalId, bytes32 nullifierHash, bytes32 voteCommitment);
    event ProposalFinalized(uint256 indexed proposalId, uint256[] results);

    constructor(
        IVerifier _verifier,
        uint32 _merkleTreeHeight,
        bytes32 _voterMerkleRoot
    ) MerkleTreeWithHistory(_merkleTreeHeight) {
        verifier = _verifier;
        voterMerkleRoot = _voterMerkleRoot;
    }

    /**
     * @notice 새 제안 생성
     */
    function createProposal(
        string calldata description,
        uint256 duration,
        uint256 numChoices
    ) external returns (uint256) {
        uint256 proposalId = proposalCount++;

        proposals[proposalId] = Proposal({
            description: description,
            deadline: block.timestamp + duration,
            voteCounts: new uint256[](numChoices),
            finalized: false
        });

        emit ProposalCreated(proposalId, description);
        return proposalId;
    }

    /**
     * @notice 프라이빗 투표
     */
    function castVote(
        bytes calldata proof,
        uint256 proposalId,
        bytes32 nullifierHash,
        uint256 voteChoice,
        bytes32 voteCommitment
    ) external {
        Proposal storage proposal = proposals[proposalId];

        require(block.timestamp < proposal.deadline, "Voting ended");
        require(!nullifierUsed[nullifierHash], "Already voted");
        require(!voteCommitments[voteCommitment], "Vote commitment exists");
        require(voteChoice < proposal.voteCounts.length, "Invalid choice");

        // ZK 증명 검증
        require(
            verifier.verifyProof(
                proof,
                [
                    uint256(voterMerkleRoot),
                    uint256(nullifierHash),
                    proposalId,
                    voteChoice,
                    uint256(voteCommitment)
                ]
            ),
            "Invalid proof"
        );

        nullifierUsed[nullifierHash] = true;
        voteCommitments[voteCommitment] = true;
        proposal.voteCounts[voteChoice]++;

        emit VoteCast(proposalId, nullifierHash, voteCommitment);
    }

    /**
     * @notice 결과 집계 및 공개
     */
    function finalizeProposal(uint256 proposalId) external {
        Proposal storage proposal = proposals[proposalId];

        require(block.timestamp >= proposal.deadline, "Voting not ended");
        require(!proposal.finalized, "Already finalized");

        proposal.finalized = true;

        emit ProposalFinalized(proposalId, proposal.voteCounts);
    }

    /**
     * @notice 제안 결과 조회
     */
    function getResults(uint256 proposalId)
        external view returns (uint256[] memory)
    {
        require(proposals[proposalId].finalized, "Not finalized");
        return proposals[proposalId].voteCounts;
    }
}
```

---

## 요약

| 구분 | 핵심 내용 |
|------|----------|
| **Tornado Cash** | Ethereum 기반, 고정 금액 믹서, Poseidon + Merkle Tree |
| **Zcash Sapling** | Groth16, Pedersen commitment, JubJub 곡선 |
| **Zcash Orchard** | Halo2 (Trusted Setup 불필요), Sinsemilla 해시 |
| **Aztec** | Noir 언어, UltraPlonk, 프라이빗 DeFi 브릿지 |
| **핵심 패턴** | Commitment-Nullifier 스킴, Merkle 멤버십 증명 |
| **보안 고려** | 익명성 집합 크기, 타이밍 분석, Relayer 신뢰 |

다음 문서에서는 Production ZK 라이브러리 (gnark, bellman, arkworks, halo2) 분석을 다룹니다.
