# 2.2 R1CS (Rank-1 Constraint System)

## 개요

R1CS(Rank-1 Constraint System)는 계산 문제를 산술 회로(Arithmetic Circuit)로 표현하고, 이를 행렬 형태의 제약 조건으로 변환한 것이다. zkSNARK 시스템에서 증명하고자 하는 연산을 표현하는 표준 방식이다.

---

## 1. 산술 회로 (Arithmetic Circuit)

### 1.1 정의

산술 회로는 덧셈 게이트(+)와 곱셈 게이트(*)로 구성된 방향성 비순환 그래프(DAG)이다.

```
산술 회로의 구성 요소:

입력 와이어 (Input Wires):
- 공개 입력 (public inputs): 검증자도 알고 있는 값
- 비밀 입력 (private inputs/witness): 증명자만 아는 값

게이트 (Gates):
- 덧셈 게이트: c = a + b
- 곱셈 게이트: c = a * b
- 상수 곱셈: c = k * a (k는 상수)

출력 와이어 (Output Wires):
- 회로의 최종 결과
```

### 1.2 예시: x^3 + x + 5 계산

```
회로: y = x^3 + x + 5

┌───────────────────────────────────────────────────────────────┐
│                                                               │
│   x ─────┬─────────────────────────────────────┐             │
│          │                                     │             │
│          ▼                                     │             │
│        ┌───┐                                   │             │
│   x ──>│ * │──> v1 (= x^2)                     │             │
│        └───┘                                   │             │
│          │                                     │             │
│          ▼                                     ▼             │
│        ┌───┐                                 ┌───┐           │
│   x ──>│ * │──> v2 (= x^3)              x ──>│ + │──> v3     │
│        └───┘                                 └───┘           │
│          │                                     │             │
│          │                                     ▼             │
│          │                                   ┌───┐           │
│          └──────────────────────────────────>│ + │──> v4     │
│                                              └───┘           │
│                                                │             │
│                                                ▼             │
│                                              ┌───┐           │
│                                         5 ──>│ + │──> y      │
│                                              └───┘           │
│                                                              │
└───────────────────────────────────────────────────────────────┘

중간 변수:
v1 = x * x       (= x^2)
v2 = v1 * x      (= x^3)
v3 = x + 5
v4 = v2 + v3     (= x^3 + x + 5)
y = v4
```

### 1.3 왜 산술 회로인가?

```
ZKP에서 산술 회로를 사용하는 이유:

1. 유한체 위에서 동작
   - 모든 연산이 F_p 위에서 수행
   - 오버플로우 없음

2. 표현력
   - 모든 NP 문제를 표현 가능
   - 비교, 해시, 서명 검증 등 모두 가능

3. 다항식으로 변환 용이
   - R1CS -> QAP 변환
   - 다항식 기반 증명 시스템에 적합

4. 결정론적
   - 같은 입력에 대해 같은 출력
   - 검증 가능성 보장
```

---

## 2. R1CS 정의

### 2.1 수학적 정의

R1CS는 다음 형태의 제약 조건들의 집합이다.

```
R1CS 제약 조건:

(A * s) . (B * s) = (C * s)

여기서:
- s = (1, x_1, x_2, ..., x_n, w_1, w_2, ..., w_m)
  - 1: 상수 항
  - x_i: 공개 입력
  - w_j: witness (비밀 입력 및 중간 변수)

- A, B, C: 행렬 (각 행이 하나의 제약)
- .: 내적 (element-wise product 후 합)

각 제약에 대해:
(a_1*s_1 + a_2*s_2 + ... ) * (b_1*s_1 + b_2*s_2 + ... ) = (c_1*s_1 + c_2*s_2 + ...)
```

### 2.2 Rank-1의 의미

```
왜 "Rank-1"인가?

각 제약 조건은 다음 형태:
(linear combination) * (linear combination) = (linear combination)

이는 행렬로 표현하면 rank-1 행렬이 됨:
(A_i * s) * (B_i * s)^T 는 rank-1 행렬

제약: 각 제약에서 곱셈은 정확히 한 번만 허용
- 허용: a * b = c
- 불허: a * b * c = d (두 번의 곱셈)
```

---

## 3. 산술 회로에서 R1CS로 변환

### 3.1 변환 규칙

```
게이트 유형별 R1CS 변환:

1. 곱셈 게이트: c = a * b
   A: [..., 0, ..., 1 (at a), ..., 0, ...]
   B: [..., 0, ..., 1 (at b), ..., 0, ...]
   C: [..., 0, ..., 1 (at c), ..., 0, ...]

   제약: a * b = c


2. 덧셈 게이트: c = a + b
   직접적인 R1CS 제약이 필요 없음
   다른 제약에서 선형 결합으로 표현

   또는 인위적으로:
   A: [..., 1 (at a), 1 (at b), ...]
   B: [1, 0, 0, ...]  (상수 1)
   C: [..., 1 (at c), ...]

   제약: (a + b) * 1 = c


3. 상수 곱셈: c = k * a
   A: [..., k (at a), ...]
   B: [1, 0, 0, ...]
   C: [..., 1 (at c), ...]

   제약: (k * a) * 1 = c
```

### 3.2 예시: x^3 + x + 5 = y의 R1CS

```
변수 벡터 s:
s = [1, x, y, v1, v2]

여기서:
- 1: 상수
- x: 입력
- y: 출력
- v1 = x^2
- v2 = x^3

제약 조건들:

제약 1: x * x = v1
A_1 = [0, 1, 0, 0, 0]  (x)
B_1 = [0, 1, 0, 0, 0]  (x)
C_1 = [0, 0, 0, 1, 0]  (v1)

제약 2: v1 * x = v2
A_2 = [0, 0, 0, 1, 0]  (v1)
B_2 = [0, 1, 0, 0, 0]  (x)
C_2 = [0, 0, 0, 0, 1]  (v2)

제약 3: (v2 + x + 5) * 1 = y
A_3 = [5, 1, 0, 0, 1]  (5 + x + v2)
B_3 = [1, 0, 0, 0, 0]  (1)
C_3 = [0, 0, 1, 0, 0]  (y)

행렬 형태:
    s = [1, x, y, v1, v2]

A = [ [0, 1, 0, 0, 0],    # x
      [0, 0, 0, 1, 0],    # v1
      [5, 1, 0, 0, 1] ]   # 5 + x + v2

B = [ [0, 1, 0, 0, 0],    # x
      [0, 1, 0, 0, 0],    # x
      [1, 0, 0, 0, 0] ]   # 1

C = [ [0, 0, 0, 1, 0],    # v1
      [0, 0, 0, 0, 1],    # v2
      [0, 0, 1, 0, 0] ]   # y
```

### 3.3 Python 구현

```python
import numpy as np
from typing import List, Tuple

class R1CS:
    """R1CS 제약 시스템"""

    def __init__(self, num_variables: int, p: int):
        """
        num_variables: 변수 개수 (상수 1 포함)
        p: 유한체 크기
        """
        self.num_vars = num_variables
        self.p = p
        self.A: List[List[int]] = []
        self.B: List[List[int]] = []
        self.C: List[List[int]] = []

    def add_constraint(self, a: List[int], b: List[int], c: List[int]):
        """제약 조건 추가: (A*s) * (B*s) = (C*s)"""
        assert len(a) == len(b) == len(c) == self.num_vars
        self.A.append([x % self.p for x in a])
        self.B.append([x % self.p for x in b])
        self.C.append([x % self.p for x in c])

    def is_satisfied(self, witness: List[int]) -> bool:
        """witness가 모든 제약을 만족하는지 확인"""
        s = np.array(witness) % self.p

        for i in range(len(self.A)):
            a_s = np.dot(self.A[i], s) % self.p
            b_s = np.dot(self.B[i], s) % self.p
            c_s = np.dot(self.C[i], s) % self.p

            lhs = (a_s * b_s) % self.p
            rhs = c_s

            if lhs != rhs:
                print(f"Constraint {i} failed: {lhs} != {rhs}")
                return False

        return True


# 예시: x^3 + x + 5 = y
def example_cubic():
    p = 21888242871839275222246405745257275088548364400416034343698204186575808495617

    # 변수: [1, x, y, v1, v2]
    # v1 = x^2, v2 = x^3
    r1cs = R1CS(num_variables=5, p=p)

    # 제약 1: x * x = v1
    r1cs.add_constraint(
        a=[0, 1, 0, 0, 0],  # x
        b=[0, 1, 0, 0, 0],  # x
        c=[0, 0, 0, 1, 0]   # v1
    )

    # 제약 2: v1 * x = v2
    r1cs.add_constraint(
        a=[0, 0, 0, 1, 0],  # v1
        b=[0, 1, 0, 0, 0],  # x
        c=[0, 0, 0, 0, 1]   # v2
    )

    # 제약 3: (5 + x + v2) * 1 = y
    r1cs.add_constraint(
        a=[5, 1, 0, 0, 1],  # 5 + x + v2
        b=[1, 0, 0, 0, 0],  # 1
        c=[0, 0, 1, 0, 0]   # y
    )

    # 테스트: x = 3
    # v1 = 9, v2 = 27, y = 27 + 3 + 5 = 35
    x = 3
    v1 = (x * x) % p
    v2 = (v1 * x) % p
    y = (v2 + x + 5) % p

    witness = [1, x, y, v1, v2]
    print(f"Witness: {witness}")
    print(f"R1CS satisfied: {r1cs.is_satisfied(witness)}")

    # 잘못된 witness 테스트
    wrong_witness = [1, x, y + 1, v1, v2]  # y가 틀림
    print(f"Wrong witness satisfied: {r1cs.is_satisfied(wrong_witness)}")

example_cubic()
```

---

## 4. QAP (Quadratic Arithmetic Program)

### 4.1 R1CS에서 QAP로 변환

R1CS를 다항식 형태로 변환하면 QAP가 된다. 이는 증명 시스템에서 효율적인 검증을 가능하게 한다.

```
QAP 변환 과정:

1. R1CS 행렬 A, B, C가 있다고 가정 (m개 제약, n개 변수)

2. 도메인 H = {h_1, h_2, ..., h_m} 선택
   (보통 roots of unity 사용)

3. 각 변수 j에 대해 다항식 생성:
   - A_j(X): A 행렬의 j번째 열을 H에서 보간
   - B_j(X): B 행렬의 j번째 열을 H에서 보간
   - C_j(X): C 행렬의 j번째 열을 H에서 보간

4. QAP 만족 조건:
   A(X) * B(X) - C(X) = H(X) * Z_H(X)

   여기서:
   - A(X) = sum_j s_j * A_j(X)
   - B(X) = sum_j s_j * B_j(X)
   - C(X) = sum_j s_j * C_j(X)
   - Z_H(X) = vanishing polynomial on H
   - H(X) = quotient polynomial
```

### 4.2 시각적 이해

```
R1CS -> QAP 변환:

R1CS (행렬 형태):
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   제약 1: (A_1 * s) * (B_1 * s) = (C_1 * s)  at h_1            │
│   제약 2: (A_2 * s) * (B_2 * s) = (C_2 * s)  at h_2            │
│   ...                                                           │
│   제약 m: (A_m * s) * (B_m * s) = (C_m * s)  at h_m            │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
                              |
                              | 라그랑주 보간
                              v
QAP (다항식 형태):
┌─────────────────────────────────────────────────────────────────┐
│                                                                 │
│   A(X) * B(X) - C(X) = 0  for all X in H                       │
│                                                                 │
│   동치:                                                         │
│   A(X) * B(X) - C(X) = H(X) * Z_H(X)                           │
│                                                                 │
│   (Z_H는 H의 모든 점에서 0이므로, H의 점들에서 등식 성립)        │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
```

### 4.3 Python 구현

```python
from typing import List

class QAP:
    """R1CS를 QAP로 변환"""

    def __init__(self, r1cs: R1CS):
        self.r1cs = r1cs
        self.p = r1cs.p
        self.num_constraints = len(r1cs.A)
        self.num_vars = r1cs.num_vars

        # 도메인 H 설정 (여기서는 간단히 1, 2, ..., m 사용)
        self.H = list(range(1, self.num_constraints + 1))

        # 다항식 생성
        self.A_polys = self._interpolate_columns(r1cs.A)
        self.B_polys = self._interpolate_columns(r1cs.B)
        self.C_polys = self._interpolate_columns(r1cs.C)

        # Vanishing polynomial
        self.Z_H = self._vanishing_polynomial()

    def _interpolate_columns(self, matrix: List[List[int]]) -> List['Polynomial']:
        """행렬의 각 열을 다항식으로 보간"""
        num_cols = len(matrix[0])
        polys = []

        for j in range(num_cols):
            # j번째 열 추출
            column = [matrix[i][j] for i in range(len(matrix))]

            # (H[i], column[i]) 점들을 지나는 다항식
            points = list(zip(self.H, column))
            poly = lagrange_interpolation(points, self.p)
            polys.append(poly)

        return polys

    def _vanishing_polynomial(self) -> 'Polynomial':
        """Z_H(X) = (X - h_1)(X - h_2)...(X - h_m)"""
        return vanishing_polynomial(self.H, self.p)

    def compute_witness_polynomials(self, witness: List[int]):
        """
        witness로부터 A(X), B(X), C(X) 계산
        """
        A_poly = Polynomial([0], self.p)
        B_poly = Polynomial([0], self.p)
        C_poly = Polynomial([0], self.p)

        for j, s_j in enumerate(witness):
            A_poly = A_poly + scalar_mult_poly(self.A_polys[j], s_j)
            B_poly = B_poly + scalar_mult_poly(self.B_polys[j], s_j)
            C_poly = C_poly + scalar_mult_poly(self.C_polys[j], s_j)

        return A_poly, B_poly, C_poly

    def compute_h_polynomial(self, witness: List[int]) -> 'Polynomial':
        """
        H(X) = (A(X) * B(X) - C(X)) / Z_H(X)
        """
        A, B, C = self.compute_witness_polynomials(witness)

        # A * B - C
        numerator = A * B
        numerator = poly_sub(numerator, C)

        # 나눗셈
        H, remainder = poly_divmod(numerator, self.Z_H)

        # 나머지가 0이어야 함 (유효한 witness인 경우)
        assert all(c == 0 for c in remainder.coeffs), "Invalid witness"

        return H

    def verify(self, witness: List[int]) -> bool:
        """QAP 만족 검증"""
        try:
            H = self.compute_h_polynomial(witness)

            # 검증: A * B - C == H * Z_H
            A, B, C = self.compute_witness_polynomials(witness)
            lhs = poly_sub(A * B, C)
            rhs = H * self.Z_H

            return poly_equal(lhs, rhs)
        except AssertionError:
            return False
```

---

## 5. 실제 ZK 회로 작성

### 5.1 Circom 예시

Circom은 ZK 회로를 작성하는 DSL(Domain Specific Language)이다.

```circom
// factor.circom
// 두 수의 곱이 주어진 값과 같음을 증명

pragma circom 2.0.0;

template Multiplier() {
    // 입력 신호 (private)
    signal input a;
    signal input b;

    // 출력 신호 (public)
    signal output c;

    // 제약 조건
    c <== a * b;
}

// 메인 컴포넌트
component main = Multiplier();
```

```circom
// range_proof.circom
// 값이 특정 범위 내에 있음을 증명

pragma circom 2.0.0;

template RangeProof(n) {
    signal input in;
    signal bits[n];

    var sum = 0;

    // in을 n비트로 분해
    for (var i = 0; i < n; i++) {
        bits[i] <-- (in >> i) & 1;

        // 각 비트가 0 또는 1임을 보장
        bits[i] * (bits[i] - 1) === 0;

        sum += bits[i] * (1 << i);
    }

    // 비트 분해가 정확한지 확인
    sum === in;
}

component main = RangeProof(8);  // 0-255 범위
```

### 5.2 Circom에서 R1CS 생성

```bash
# Circom 컴파일
circom circuit.circom --r1cs --wasm --sym

# 생성되는 파일:
# - circuit.r1cs: R1CS 제약 조건
# - circuit.wasm: witness 계산용
# - circuit.sym: 심볼 테이블
```

### 5.3 복잡한 연산의 회로화

```circom
// hash_preimage.circom
// 해시 프리이미지 증명

pragma circom 2.0.0;

include "poseidon.circom";

template HashPreimage() {
    signal input preimage;      // private
    signal input hash;          // public

    // Poseidon 해시 계산
    component hasher = Poseidon(1);
    hasher.inputs[0] <== preimage;

    // 해시값 일치 확인
    hash === hasher.out;
}

component main {public [hash]} = HashPreimage();
```

---

## 6. 제약 최적화

### 6.1 제약 수 줄이기

R1CS 제약 수는 증명 크기와 생성 시간에 직접적인 영향을 미친다.

```
최적화 기법:

1. 선형 결합 병합
   - 여러 덧셈을 하나의 선형 결합으로
   - a + b + c + d를 하나의 제약으로

2. 상수 전파
   - 컴파일 타임에 알려진 값은 직접 대입
   - 런타임 제약 감소

3. 공통 부분식 제거
   - 중복 계산 식별 및 재사용
   - 중간 변수 공유

4. 비트 분해 최적화
   - 범위 증명에서 비트 수 최소화
   - 필요한 비트만 분해
```

### 6.2 예시: 비효율적 vs 효율적 회로

```circom
// 비효율적: 각 연산마다 중간 변수
template Inefficient() {
    signal input a, b, c, d;
    signal output out;

    signal t1;
    signal t2;
    signal t3;

    t1 <== a + b;      // 불필요한 제약
    t2 <== t1 + c;     // 불필요한 제약
    t3 <== t2 + d;     // 불필요한 제약
    out <== t3 * t3;   // 필요한 제약
}

// 효율적: 선형 결합 직접 사용
template Efficient() {
    signal input a, b, c, d;
    signal output out;

    signal sum;
    sum <== a + b + c + d;  // 선형 결합은 무료
    out <== sum * sum;      // 단 하나의 곱셈 제약
}
```

---

## 7. 고급 R1CS 패턴

### 7.1 조건부 로직

```circom
// 조건문 구현 (if-else)
template Conditional() {
    signal input condition;  // 0 또는 1
    signal input if_true;
    signal input if_false;
    signal output out;

    // condition이 0 또는 1임을 보장
    condition * (condition - 1) === 0;

    // out = condition ? if_true : if_false
    // out = condition * if_true + (1 - condition) * if_false
    out <== condition * (if_true - if_false) + if_false;
}
```

### 7.2 비교 연산

```circom
// a < b 증명 (n비트 수)
template LessThan(n) {
    signal input a;
    signal input b;
    signal output out;  // 1 if a < b, 0 otherwise

    // 핵심 아이디어:
    // a < b iff b - a - 1 >= 0 and b - a - 1 < 2^n

    signal diff;
    diff <== b - a - 1;

    // diff가 n비트로 표현 가능한지 확인
    component rangeCheck = RangeProof(n);
    rangeCheck.in <== diff + (1 << n);  // 음수 방지

    // 오버플로우 없으면 a < b
    out <== 1 - rangeCheck.overflow;
}
```

### 7.3 루프 언롤링

```circom
// 배열 합계 (루프 언롤링)
template ArraySum(n) {
    signal input arr[n];
    signal output sum;

    signal partial[n];

    partial[0] <== arr[0];
    for (var i = 1; i < n; i++) {
        partial[i] <== partial[i-1] + arr[i];
    }

    sum <== partial[n-1];
}

// 참고: 선형 연산이므로 실제로는 하나의 제약으로 최적화됨
```

---

## 8. 디버깅과 테스트

### 8.1 Witness 검증

```javascript
// snarkjs를 사용한 witness 생성 및 검증

const snarkjs = require("snarkjs");
const fs = require("fs");

async function testCircuit() {
    // 입력 정의
    const input = {
        a: 3,
        b: 11
    };

    // Witness 계산
    const { proof, publicSignals } = await snarkjs.groth16.fullProve(
        input,
        "circuit.wasm",
        "circuit_final.zkey"
    );

    console.log("Public signals:", publicSignals);

    // 증명 검증
    const vkey = JSON.parse(fs.readFileSync("verification_key.json"));
    const verified = await snarkjs.groth16.verify(vkey, publicSignals, proof);

    console.log("Verification:", verified);
}

testCircuit();
```

### 8.2 제약 조건 분석

```bash
# snarkjs로 R1CS 정보 출력
snarkjs r1cs info circuit.r1cs

# 출력 예시:
# [INFO]  snarkJS: Curve: bn-128
# [INFO]  snarkJS: # of Wires: 4
# [INFO]  snarkJS: # of Constraints: 1
# [INFO]  snarkJS: # of Private Inputs: 2
# [INFO]  snarkJS: # of Public Inputs: 0
# [INFO]  snarkJS: # of Labels: 5
# [INFO]  snarkJS: # of Outputs: 1
```

---

## 9. 정리

```
R1CS 핵심 요약:

1. 산술 회로
   - 덧셈과 곱셈 게이트로 구성
   - 모든 계산을 유한체 위에서 표현

2. R1CS 형식
   - (A * s) . (B * s) = (C * s)
   - 각 제약은 하나의 곱셈만 포함 (Rank-1)

3. QAP 변환
   - R1CS -> 다항식 형태
   - 효율적인 증명 시스템의 기반

4. 회로 작성
   - Circom 같은 DSL 사용
   - 제약 수 최적화 중요

5. 최적화
   - 선형 결합 활용 (무료)
   - 곱셈 제약 최소화
   - 공통 부분식 재사용
```

---

## 참고 자료

### 도구
- Circom: https://github.com/iden3/circom
- snarkjs: https://github.com/iden3/snarkjs
- arkworks-rs: https://github.com/arkworks-rs

### 학습 자료
- https://medium.com/@VitalikButerin/quadratic-arithmetic-programs-from-zero-to-hero-f6d558cea649
- https://learn.0xparc.org/materials/circom/
- https://www.rareskills.io/post/r1cs-zkp
