# 5.3 Fully Homomorphic Encryption (FHE)

## 개요

Fully Homomorphic Encryption (FHE)은 암호화된 데이터 상에서 직접 연산을 수행할 수 있는 암호화 방식입니다. 복호화 없이 계산이 가능하므로, 클라우드 컴퓨팅과 프라이버시 보존 애플리케이션에 혁신적인 가능성을 제공합니다.

## FHE 기본 개념

### 동형 암호의 종류

```
┌─────────────────────────────────────────────────────────────────────┐
│                 Homomorphic Encryption Taxonomy                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. PHE (Partially Homomorphic Encryption)                          │
│     ─────────────────────────────────────────────────────────────   │
│     한 종류의 연산만 무제한 지원                                    │
│                                                                      │
│     • RSA: 곱셈만 가능                                              │
│       E(m₁) · E(m₂) = E(m₁ · m₂)                                   │
│                                                                      │
│     • Paillier: 덧셈만 가능                                         │
│       E(m₁) · E(m₂) = E(m₁ + m₂)                                   │
│       E(m)^k = E(k · m)                                             │
│                                                                      │
│  2. SWHE (Somewhat Homomorphic Encryption)                          │
│     ─────────────────────────────────────────────────────────────   │
│     덧셈과 곱셈 모두 가능하지만, 제한된 깊이                        │
│     노이즈 누적으로 인한 한계                                       │
│                                                                      │
│  3. LHE (Leveled Homomorphic Encryption)                            │
│     ─────────────────────────────────────────────────────────────   │
│     사전에 정해진 깊이까지 연산 가능                                │
│     부트스트래핑 없음                                               │
│                                                                      │
│  4. FHE (Fully Homomorphic Encryption)                              │
│     ─────────────────────────────────────────────────────────────   │
│     무제한 덧셈과 곱셈 가능                                         │
│     부트스트래핑으로 노이즈 제거                                    │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │         계산 능력 vs 효율성 트레이드오프                     │   │
│  │                                                               │   │
│  │  PHE ◀────────────────────────────────────────────▶ FHE      │   │
│  │  효율적                                           강력       │   │
│  │  제한적                                           느림       │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

### FHE 핵심 속성

```
┌─────────────────────────────────────────────────────────────────────┐
│                    FHE Core Properties                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Correctness (정확성):                                              │
│  Dec(sk, Eval(f, Enc(pk, m₁), ..., Enc(pk, mₙ))) = f(m₁, ..., mₙ)  │
│                                                                      │
│  Semantic Security (의미론적 보안):                                  │
│  암호문에서 평문에 대한 정보를 얻을 수 없음                         │
│                                                                      │
│  Compactness (압축성):                                              │
│  암호문 크기가 연산 횟수에 독립적                                   │
│  (부트스트래핑으로 달성)                                            │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │                    FHE 연산 흐름                             │   │
│  │                                                               │   │
│  │   m₁ ──▶ Enc(pk) ──▶ c₁ ┐                                   │   │
│  │                         ├──▶ Eval(f) ──▶ c' ──▶ Dec(sk) ──▶ f(m₁,m₂)
│  │   m₂ ──▶ Enc(pk) ──▶ c₂ ┘                                   │   │
│  │                                                               │   │
│  │   서버는 m₁, m₂, f(m₁,m₂)를 모름!                           │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

---

## FHE 스킴 발전사

### 세대별 분류

```
┌─────────────────────────────────────────────────────────────────────┐
│                    FHE Generations                                   │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1세대 (2009): Gentry's FHE                                         │
│  ─────────────────────────────────────────────────────────────────  │
│  • 최초의 FHE 구현                                                  │
│  • Ideal Lattice 기반                                               │
│  • 부트스트래핑 개념 도입                                           │
│  • 실용적이지 않음 (매우 느림)                                      │
│                                                                      │
│  2세대 (2011-2013): BGV, BFV                                        │
│  ─────────────────────────────────────────────────────────────────  │
│  • Ring-LWE 기반                                                    │
│  • 모듈러 스위칭                                                    │
│  • 정수 연산에 최적화                                               │
│  • 실용적 응용 가능                                                 │
│                                                                      │
│  3세대 (2013-2016): GSW, FHEW, TFHE                                 │
│  ─────────────────────────────────────────────────────────────────  │
│  • GSW 암호화 도입                                                  │
│  • 빠른 부트스트래핑 (~0.1초)                                       │
│  • 비트 연산에 효율적                                               │
│  • 불리언 회로 평가                                                 │
│                                                                      │
│  4세대 (2017-현재): CKKS, Hybrid                                    │
│  ─────────────────────────────────────────────────────────────────  │
│  • 근사 연산 지원 (CKKS)                                            │
│  • 실수/복소수 연산                                                  │
│  • 머신러닝 친화적                                                  │
│  • 하이브리드 스킴                                                  │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 핵심 FHE 스킴

### BFV (Brakerski-Fan-Vercauteren)

```python
import numpy as np
from typing import Tuple

class BFVScheme:
    """
    BFV 암호화 스킴

    정수 연산에 최적화된 2세대 FHE
    Ring-LWE 문제 기반
    """

    def __init__(self, n: int = 4096, q: int = None, t: int = 256):
        """
        파라미터:
        - n: 다항식 차수 (2의 거듭제곱)
        - q: 암호문 모듈러스
        - t: 평문 모듈러스
        """
        self.n = n
        self.q = q or (1 << 60)  # 큰 모듈러스
        self.t = t  # 평문 공간

        # 다항식 링: Z[X] / (X^n + 1)
        self.poly_mod = np.array([1] + [0] * (n - 1) + [1])

        # 노이즈 분포 파라미터
        self.std_dev = 3.2

    def keygen(self) -> Tuple[np.ndarray, Tuple[np.ndarray, np.ndarray]]:
        """
        키 생성

        sk: 비밀키 (작은 다항식)
        pk = (b, a) where b = -a*sk + e (mod q)
        """
        # 비밀키: 작은 계수의 다항식
        sk = self._sample_ternary()

        # 공개키 생성
        a = self._sample_uniform()
        e = self._sample_gaussian()

        b = (-self._poly_mul(a, sk) + e) % self.q

        pk = (b, a)
        return sk, pk

    def encrypt(self, pk: Tuple[np.ndarray, np.ndarray], m: int) -> Tuple[np.ndarray, np.ndarray]:
        """
        암호화

        m: 평문 (0 ~ t-1)
        c = (c0, c1) = (b*u + e1 + Δm, a*u + e2)

        Δ = floor(q/t): 스케일링 팩터
        """
        b, a = pk

        # 랜덤 다항식
        u = self._sample_ternary()
        e1 = self._sample_gaussian()
        e2 = self._sample_gaussian()

        # 스케일링
        delta = self.q // self.t
        scaled_m = self._encode_message(m) * delta

        # 암호화
        c0 = (self._poly_mul(b, u) + e1 + scaled_m) % self.q
        c1 = (self._poly_mul(a, u) + e2) % self.q

        return (c0, c1)

    def decrypt(self, sk: np.ndarray, ct: Tuple[np.ndarray, np.ndarray]) -> int:
        """
        복호화

        m = round(t/q * (c0 + c1*sk)) mod t
        """
        c0, c1 = ct

        # 복호화: c0 + c1*sk
        decrypted = (c0 + self._poly_mul(c1, sk)) % self.q

        # 스케일링 해제
        scaled = (decrypted * self.t / self.q).round() % self.t

        return self._decode_message(scaled)

    def add(
        self,
        ct1: Tuple[np.ndarray, np.ndarray],
        ct2: Tuple[np.ndarray, np.ndarray]
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        동형 덧셈

        (c0, c1) + (c0', c1') = (c0 + c0', c1 + c1')
        """
        c0 = (ct1[0] + ct2[0]) % self.q
        c1 = (ct1[1] + ct2[1]) % self.q
        return (c0, c1)

    def multiply(
        self,
        ct1: Tuple[np.ndarray, np.ndarray],
        ct2: Tuple[np.ndarray, np.ndarray]
    ) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        동형 곱셈

        결과: 3개 요소로 확장됨
        리니어라이제이션 필요
        """
        c0_1, c1_1 = ct1
        c0_2, c1_2 = ct2

        # 텐서 곱
        d0 = self._poly_mul(c0_1, c0_2)
        d1 = self._poly_mul(c0_1, c1_2) + self._poly_mul(c1_1, c0_2)
        d2 = self._poly_mul(c1_1, c1_2)

        # 스케일링
        d0 = (d0 * self.t / self.q).round() % self.q
        d1 = (d1 * self.t / self.q).round() % self.q
        d2 = (d2 * self.t / self.q).round() % self.q

        return (d0, d1, d2)

    def relinearize(
        self,
        ct: Tuple[np.ndarray, np.ndarray, np.ndarray],
        rlk: np.ndarray
    ) -> Tuple[np.ndarray, np.ndarray]:
        """
        리니어라이제이션

        3요소 암호문을 2요소로 변환
        평가키(rlk) 사용
        """
        d0, d1, d2 = ct

        # rlk를 사용하여 d2 항 제거
        c0 = d0 + self._apply_rlk(d2, rlk, 0)
        c1 = d1 + self._apply_rlk(d2, rlk, 1)

        return (c0 % self.q, c1 % self.q)

    def _sample_ternary(self) -> np.ndarray:
        """삼진법 분포에서 샘플링 (-1, 0, 1)"""
        return np.random.choice([-1, 0, 1], size=self.n)

    def _sample_gaussian(self) -> np.ndarray:
        """가우시안 분포에서 샘플링"""
        return np.random.normal(0, self.std_dev, size=self.n).round().astype(int)

    def _sample_uniform(self) -> np.ndarray:
        """균등 분포에서 샘플링"""
        return np.random.randint(0, self.q, size=self.n)

    def _poly_mul(self, a: np.ndarray, b: np.ndarray) -> np.ndarray:
        """다항식 곱셈 (mod X^n + 1)"""
        result = np.convolve(a, b)
        # X^n + 1로 나눈 나머지
        while len(result) > self.n:
            result[:len(result) - self.n] -= result[self.n:]
            result = result[:self.n]
        return result % self.q

    def _encode_message(self, m: int) -> np.ndarray:
        """메시지를 다항식으로 인코딩"""
        result = np.zeros(self.n, dtype=int)
        result[0] = m
        return result

    def _decode_message(self, poly: np.ndarray) -> int:
        """다항식을 메시지로 디코딩"""
        return int(poly[0]) % self.t
```

### CKKS (Cheon-Kim-Kim-Song)

```python
import numpy as np
from typing import List, Tuple

class CKKSScheme:
    """
    CKKS 암호화 스킴

    근사 연산 지원 - 실수/복소수 계산
    머신러닝에 적합
    """

    def __init__(self, n: int = 8192, scale: float = 2**40, levels: int = 5):
        """
        파라미터:
        - n: 다항식 차수 (슬롯 수 = n/2)
        - scale: 정밀도 (Δ)
        - levels: 곱셈 가능 레벨
        """
        self.n = n
        self.slots = n // 2
        self.scale = scale
        self.levels = levels

        # 모듈러스 체인
        self.q_levels = self._generate_modulus_chain()

    def _generate_modulus_chain(self) -> List[int]:
        """모듈러스 체인 생성"""
        # 각 레벨의 모듈러스
        base_bits = 60
        return [1 << (base_bits + i * 40) for i in range(self.levels + 1)]

    def encode(self, values: np.ndarray) -> np.ndarray:
        """
        실수 벡터를 다항식으로 인코딩

        Canonical Embedding 사용:
        σ⁻¹: C^{n/2} → R[X]/(X^n + 1)
        """
        if len(values) > self.slots:
            raise ValueError(f"Too many values (max {self.slots})")

        # 패딩
        padded = np.zeros(self.slots, dtype=complex)
        padded[:len(values)] = values

        # 역 FFT (canonical embedding의 역)
        # 실제로는 더 복잡한 인코딩 사용
        roots = np.exp(2j * np.pi * np.arange(self.n) / (2 * self.n))

        poly = np.fft.ifft(padded, n=self.n) * self.scale
        return poly.real.round().astype(int)

    def decode(self, poly: np.ndarray) -> np.ndarray:
        """
        다항식을 실수 벡터로 디코딩

        Canonical Embedding:
        σ: R[X]/(X^n + 1) → C^{n/2}
        """
        # FFT
        values = np.fft.fft(poly / self.scale)
        return values[:self.slots]

    def encrypt(self, pk: Tuple, encoded: np.ndarray, level: int = None) -> dict:
        """
        인코딩된 평문 암호화

        BFV와 유사하지만 스케일 관리 필요
        """
        level = level or self.levels
        q = self.q_levels[level]

        # 암호화 (BFV와 유사)
        b, a = pk
        u = self._sample_ternary()
        e0 = self._sample_gaussian()
        e1 = self._sample_gaussian()

        c0 = (self._poly_mul(b, u, q) + e0 + encoded) % q
        c1 = (self._poly_mul(a, u, q) + e1) % q

        return {
            'c0': c0,
            'c1': c1,
            'scale': self.scale,
            'level': level
        }

    def add(self, ct1: dict, ct2: dict) -> dict:
        """
        동형 덧셈

        스케일 매칭 필요
        """
        assert ct1['level'] == ct2['level'], "Level mismatch"

        q = self.q_levels[ct1['level']]

        return {
            'c0': (ct1['c0'] + ct2['c0']) % q,
            'c1': (ct1['c1'] + ct2['c1']) % q,
            'scale': ct1['scale'],
            'level': ct1['level']
        }

    def multiply(self, ct1: dict, ct2: dict, rlk: np.ndarray) -> dict:
        """
        동형 곱셈

        스케일이 제곱됨 → 리스케일링 필요
        """
        level = ct1['level']
        q = self.q_levels[level]

        # 텐서 곱
        d0 = self._poly_mul(ct1['c0'], ct2['c0'], q)
        d1 = (self._poly_mul(ct1['c0'], ct2['c1'], q) +
              self._poly_mul(ct1['c1'], ct2['c0'], q)) % q
        d2 = self._poly_mul(ct1['c1'], ct2['c1'], q)

        # 리니어라이제이션
        c0, c1 = self._relinearize((d0, d1, d2), rlk, q)

        return {
            'c0': c0,
            'c1': c1,
            'scale': ct1['scale'] * ct2['scale'],  # 스케일 증가
            'level': level
        }

    def rescale(self, ct: dict) -> dict:
        """
        리스케일링

        스케일을 원래대로 줄이고 레벨 감소
        곱셈 후 필수
        """
        level = ct['level']
        if level == 0:
            raise ValueError("Cannot rescale at level 0")

        q_curr = self.q_levels[level]
        q_next = self.q_levels[level - 1]

        # 모듈러스 스위칭
        c0 = (ct['c0'] * q_next // q_curr) % q_next
        c1 = (ct['c1'] * q_next // q_curr) % q_next

        return {
            'c0': c0,
            'c1': c1,
            'scale': ct['scale'] / self.scale,  # 스케일 감소
            'level': level - 1
        }

    def bootstrap(self, ct: dict, bsk: np.ndarray) -> dict:
        """
        부트스트래핑

        레벨 새로고침 (노이즈 제거)
        가장 복잡한 연산
        """
        # 1. 모듈러스를 낮은 레벨로
        # 2. 복호화 회로를 동형으로 평가
        # 3. 새로운 암호문 획득

        # 실제 구현은 매우 복잡
        raise NotImplementedError("Bootstrapping requires complex implementation")


# 사용 예시: 근사 계산
def ckks_example():
    ckks = CKKSScheme()

    # 실수 벡터
    values = np.array([1.5, 2.3, 3.7, 4.2])

    # 인코딩 및 암호화
    encoded = ckks.encode(values)
    # ct = ckks.encrypt(pk, encoded)

    # 동형 연산 후 복호화
    # result = ckks.decode(ckks.decrypt(sk, ct))
    # print(f"Original: {values}")
    # print(f"Result: {result}")
```

### TFHE (Torus FHE)

```python
class TFHEScheme:
    """
    TFHE (Torus Fully Homomorphic Encryption)

    빠른 부트스트래핑 (~13ms)
    비트 단위 연산에 효율적
    """

    def __init__(self, n: int = 630, N: int = 1024):
        """
        파라미터:
        - n: LWE 차원
        - N: RLWE 차원
        """
        self.n = n  # LWE 파라미터
        self.N = N  # RLWE 파라미터

        # Torus 표현: 실수 [0, 1) → 정수 표현
        self.Msize = 2**32  # 토러스 이산화

    def keygen(self) -> Tuple[np.ndarray, np.ndarray, np.ndarray]:
        """
        키 생성

        - sk_LWE: LWE 비밀키
        - sk_RLWE: RLWE 비밀키
        - bsk: 부트스트래핑 키
        """
        # LWE 비밀키
        sk_lwe = np.random.choice([0, 1], size=self.n)

        # RLWE 비밀키
        sk_rlwe = np.random.choice([-1, 0, 1], size=self.N)

        # 부트스트래핑 키 (sk_lwe를 sk_rlwe로 암호화)
        bsk = self._generate_bootstrapping_key(sk_lwe, sk_rlwe)

        return sk_lwe, sk_rlwe, bsk

    def encrypt_bit(self, sk: np.ndarray, bit: int) -> Tuple[np.ndarray, int]:
        """
        단일 비트 LWE 암호화

        (a, b) where b = <a, s> + m/4 + e
        m = 0 또는 1
        """
        a = np.random.randint(0, self.Msize, size=self.n, dtype=np.uint32)
        e = int(np.random.normal(0, 3.2))

        # m을 토러스 값으로 인코딩 (0 → 0, 1 → 1/4)
        m_encoded = (bit * self.Msize // 4) % self.Msize

        b = (np.dot(a, sk) + m_encoded + e) % self.Msize

        return (a, b)

    def decrypt_bit(self, sk: np.ndarray, ct: Tuple[np.ndarray, int]) -> int:
        """
        비트 복호화

        m = round(4 * (b - <a, s>)) mod 2
        """
        a, b = ct
        phase = (b - np.dot(a, sk)) % self.Msize

        # 가장 가까운 1/4 배수로 반올림
        if phase < self.Msize // 8 or phase >= 7 * self.Msize // 8:
            return 0
        else:
            return 1

    def gate_bootstrapping_and(
        self,
        ct1: Tuple[np.ndarray, int],
        ct2: Tuple[np.ndarray, int],
        bsk: np.ndarray
    ) -> Tuple[np.ndarray, int]:
        """
        동형 AND 게이트 + 부트스트래핑

        TFHE의 핵심: 게이트 평가와 부트스트래핑 통합
        """
        # 1. 입력 결합
        a = (ct1[0] + ct2[0]) % self.Msize
        b = (ct1[1] + ct2[1] - self.Msize // 8) % self.Msize
        # -1/8 오프셋: AND 연산을 위한 조정

        # 2. 부트스트래핑
        return self._bootstrap((a, b), bsk)

    def gate_bootstrapping_or(
        self,
        ct1: Tuple[np.ndarray, int],
        ct2: Tuple[np.ndarray, int],
        bsk: np.ndarray
    ) -> Tuple[np.ndarray, int]:
        """동형 OR 게이트"""
        a = (ct1[0] + ct2[0]) % self.Msize
        b = (ct1[1] + ct2[1] + self.Msize // 8) % self.Msize
        return self._bootstrap((a, b), bsk)

    def gate_bootstrapping_xor(
        self,
        ct1: Tuple[np.ndarray, int],
        ct2: Tuple[np.ndarray, int],
        bsk: np.ndarray
    ) -> Tuple[np.ndarray, int]:
        """동형 XOR 게이트"""
        a = (2 * ct1[0] + 2 * ct2[0]) % self.Msize
        b = (2 * ct1[1] + 2 * ct2[1]) % self.Msize
        return self._bootstrap((a, b), bsk)

    def gate_bootstrapping_not(
        self,
        ct: Tuple[np.ndarray, int]
    ) -> Tuple[np.ndarray, int]:
        """동형 NOT 게이트 (부트스트래핑 불필요)"""
        a, b = ct
        return ((-a) % self.Msize, (self.Msize // 4 - b) % self.Msize)

    def _bootstrap(
        self,
        ct: Tuple[np.ndarray, int],
        bsk: np.ndarray
    ) -> Tuple[np.ndarray, int]:
        """
        부트스트래핑

        1. LWE → RLWE (BlindRotate)
        2. 키 스위칭
        3. RLWE → LWE
        """
        a, b = ct

        # BlindRotate: 복호화 함수를 동형으로 평가
        # 테스트 다항식을 b만큼 회전

        # 간소화된 구현
        # 실제로는 CMux 게이트 체인 사용
        rotated = self._blind_rotate(b, bsk)

        # 샘플 추출 및 키 스위칭
        return self._sample_extract(rotated)
```

---

## FHE 라이브러리

### Microsoft SEAL

```cpp
// Microsoft SEAL 예시 (C++)
#include "seal/seal.h"
using namespace seal;

void seal_bfv_example() {
    // 파라미터 설정
    EncryptionParameters parms(scheme_type::bfv);
    size_t poly_modulus_degree = 4096;
    parms.set_poly_modulus_degree(poly_modulus_degree);
    parms.set_coeff_modulus(CoeffModulus::BFVDefault(poly_modulus_degree));
    parms.set_plain_modulus(PlainModulus::Batching(poly_modulus_degree, 20));

    // 컨텍스트 생성
    SEALContext context(parms);

    // 키 생성
    KeyGenerator keygen(context);
    SecretKey secret_key = keygen.secret_key();
    PublicKey public_key;
    keygen.create_public_key(public_key);
    RelinKeys relin_keys;
    keygen.create_relin_keys(relin_keys);

    // 암호화/복호화 도구
    Encryptor encryptor(context, public_key);
    Evaluator evaluator(context);
    Decryptor decryptor(context, secret_key);

    // 배치 인코더 (SIMD 연산)
    BatchEncoder batch_encoder(context);
    size_t slot_count = batch_encoder.slot_count();

    // 평문 준비
    vector<uint64_t> pod_matrix(slot_count, 0ULL);
    pod_matrix[0] = 7;
    pod_matrix[1] = 11;

    Plaintext plain_matrix;
    batch_encoder.encode(pod_matrix, plain_matrix);

    // 암호화
    Ciphertext encrypted_matrix;
    encryptor.encrypt(plain_matrix, encrypted_matrix);

    // 동형 연산
    Ciphertext encrypted_result;
    evaluator.square(encrypted_matrix, encrypted_result);
    evaluator.relinearize_inplace(encrypted_result, relin_keys);

    // 복호화
    Plaintext plain_result;
    decryptor.decrypt(encrypted_result, plain_result);

    vector<uint64_t> result;
    batch_encoder.decode(plain_result, result);

    cout << "7^2 = " << result[0] << endl;  // 49
    cout << "11^2 = " << result[1] << endl; // 121
}

// CKKS 예시 (실수 연산)
void seal_ckks_example() {
    EncryptionParameters parms(scheme_type::ckks);
    size_t poly_modulus_degree = 8192;
    parms.set_poly_modulus_degree(poly_modulus_degree);
    parms.set_coeff_modulus(CoeffModulus::Create(
        poly_modulus_degree, { 60, 40, 40, 60 }));

    SEALContext context(parms);
    double scale = pow(2.0, 40);

    // 키 생성
    KeyGenerator keygen(context);
    auto secret_key = keygen.secret_key();
    PublicKey public_key;
    keygen.create_public_key(public_key);
    RelinKeys relin_keys;
    keygen.create_relin_keys(relin_keys);

    // 인코더
    CKKSEncoder encoder(context);

    // 실수 벡터
    vector<double> input = { 1.1, 2.2, 3.3, 4.4 };

    Plaintext plain;
    encoder.encode(input, scale, plain);

    // 암호화
    Ciphertext encrypted;
    Encryptor encryptor(context, public_key);
    encryptor.encrypt(plain, encrypted);

    // 제곱
    Evaluator evaluator(context);
    evaluator.square_inplace(encrypted);
    evaluator.relinearize_inplace(encrypted, relin_keys);
    evaluator.rescale_to_next_inplace(encrypted);

    // 복호화
    Plaintext decrypted;
    Decryptor decryptor(context, secret_key);
    decryptor.decrypt(encrypted, decrypted);

    vector<double> result;
    encoder.decode(decrypted, result);

    // 결과: [1.21, 4.84, 10.89, 19.36]
}
```

### OpenFHE

```cpp
// OpenFHE 예시 (C++)
#include "openfhe.h"
using namespace lbcrypto;

void openfhe_example() {
    // BFV 파라미터
    CCParams<CryptoContextBFVRNS> parameters;
    parameters.SetPlaintextModulus(65537);
    parameters.SetMultiplicativeDepth(2);

    CryptoContext<DCRTPoly> cc = GenCryptoContext(parameters);
    cc->Enable(PKE);
    cc->Enable(KEYSWITCH);
    cc->Enable(LEVELEDSHE);

    // 키 생성
    auto keyPair = cc->KeyGen();
    cc->EvalMultKeyGen(keyPair.secretKey);

    // 평문 패킹
    std::vector<int64_t> vec1 = {1, 2, 3, 4};
    std::vector<int64_t> vec2 = {5, 6, 7, 8};

    Plaintext pt1 = cc->MakePackedPlaintext(vec1);
    Plaintext pt2 = cc->MakePackedPlaintext(vec2);

    // 암호화
    auto ct1 = cc->Encrypt(keyPair.publicKey, pt1);
    auto ct2 = cc->Encrypt(keyPair.publicKey, pt2);

    // 동형 덧셈
    auto ctAdd = cc->EvalAdd(ct1, ct2);

    // 동형 곱셈
    auto ctMult = cc->EvalMult(ct1, ct2);

    // 복호화
    Plaintext resultAdd, resultMult;
    cc->Decrypt(keyPair.secretKey, ctAdd, &resultAdd);
    cc->Decrypt(keyPair.secretKey, ctMult, &resultMult);

    resultAdd->SetLength(4);
    resultMult->SetLength(4);

    std::cout << "Add: " << resultAdd << std::endl;   // [6, 8, 10, 12]
    std::cout << "Mult: " << resultMult << std::endl; // [5, 12, 21, 32]
}
```

### Concrete (Rust)

```rust
// Zama Concrete-ML 예시
use concrete::prelude::*;

fn concrete_example() -> Result<(), Box<dyn std::error::Error>> {
    // 설정
    let config = ConfigBuilder::default().build();

    // 키 생성
    let (client_key, server_key) = generate_keys(config);

    // 정수 암호화
    let clear_a = 5u8;
    let clear_b = 3u8;

    let a = FheUint8::encrypt(clear_a, &client_key);
    let b = FheUint8::encrypt(clear_b, &client_key);

    // 서버 키 설정
    set_server_key(server_key);

    // 동형 연산
    let sum = &a + &b;
    let product = &a * &b;
    let comparison = a.gt(&b);

    // 복호화
    let result_sum: u8 = sum.decrypt(&client_key);
    let result_product: u8 = product.decrypt(&client_key);
    let result_cmp: bool = comparison.decrypt(&client_key);

    println!("5 + 3 = {}", result_sum);      // 8
    println!("5 * 3 = {}", result_product);  // 15
    println!("5 > 3 = {}", result_cmp);      // true

    Ok(())
}
```

---

## FHE 응용

### 프라이버시 보존 머신러닝

```python
# FHE 기반 프라이버시 보존 추론
class PrivateMLInference:
    """
    클라이언트 데이터를 암호화한 채로 ML 모델 추론

    1. 클라이언트가 데이터 암호화
    2. 서버가 암호화된 데이터로 모델 평가
    3. 클라이언트가 결과 복호화
    """

    def __init__(self, fhe_scheme):
        self.fhe = fhe_scheme

    def encrypt_input(self, input_data, public_key):
        """입력 데이터 암호화"""
        return [self.fhe.encrypt(public_key, x) for x in input_data]

    def homomorphic_linear_layer(self, encrypted_input, weights, bias):
        """
        동형 선형 레이어

        y = Wx + b
        """
        result = []
        for i in range(len(weights)):
            # 가중합
            weighted_sum = self.fhe.multiply_plain(
                encrypted_input[0], weights[i][0]
            )
            for j in range(1, len(encrypted_input)):
                term = self.fhe.multiply_plain(
                    encrypted_input[j], weights[i][j]
                )
                weighted_sum = self.fhe.add(weighted_sum, term)

            # 바이어스 추가
            result.append(self.fhe.add_plain(weighted_sum, bias[i]))

        return result

    def homomorphic_relu(self, encrypted_input, comparison_key):
        """
        동형 ReLU (근사)

        ReLU는 비다항식이므로 다항식 근사 사용
        f(x) ≈ a₀ + a₁x + a₂x² + ...
        """
        # 저차 다항식 근사 (예: x * sigmoid(x) ≈ x/2 + x²/4)
        # 또는 비교 기반 구현 (TFHE)
        pass

    def homomorphic_softmax(self, encrypted_input):
        """
        동형 Softmax (근사)

        지수함수 → 다항식 근사 사용
        """
        # 다항식 근사: exp(x) ≈ 1 + x + x²/2 + x³/6 + ...
        pass


# 실제 예시: 암호화된 의료 데이터 분석
def privacy_preserving_diagnosis():
    """
    병원(서버)이 환자 데이터를 보지 않고 진단
    """
    # 환자: 증상 데이터 암호화
    symptoms = [0.8, 0.2, 0.6, 0.9]  # 증상 점수
    encrypted_symptoms = client.encrypt(symptoms)

    # 서버: 암호화된 데이터로 진단 모델 실행
    encrypted_result = server.run_diagnosis_model(encrypted_symptoms)

    # 환자: 결과 복호화
    diagnosis = client.decrypt(encrypted_result)
    print(f"진단 결과: {diagnosis}")
```

### 프라이버시 보존 데이터베이스 쿼리

```python
class PrivateDatabaseQuery:
    """
    암호화된 쿼리로 데이터베이스 검색

    PIR (Private Information Retrieval) 구현
    """

    def __init__(self, fhe_scheme, database_size: int):
        self.fhe = fhe_scheme
        self.db_size = database_size

    def create_query(self, index: int, public_key) -> list:
        """
        인덱스를 암호화된 쿼리로 변환

        one-hot 인코딩: [0, 0, ..., 1, ..., 0]
        """
        query = []
        for i in range(self.db_size):
            if i == index:
                query.append(self.fhe.encrypt(public_key, 1))
            else:
                query.append(self.fhe.encrypt(public_key, 0))
        return query

    def process_query(self, encrypted_query: list, database: list):
        """
        서버가 쿼리 처리

        응답 = Σ query[i] * database[i]
        """
        result = self.fhe.multiply(encrypted_query[0], database[0])

        for i in range(1, len(database)):
            term = self.fhe.multiply(encrypted_query[i], database[i])
            result = self.fhe.add(result, term)

        return result
```

---

## FHE + ZK 결합

### 검증 가능한 동형 연산

```python
class VerifiableHE:
    """
    ZK 증명을 통한 FHE 연산 검증

    서버가 정직하게 연산했음을 증명
    """

    def __init__(self, fhe_scheme, zk_prover):
        self.fhe = fhe_scheme
        self.zk = zk_prover

    def compute_with_proof(
        self,
        encrypted_inputs: list,
        computation: callable
    ):
        """
        동형 연산 수행 + ZK 증명 생성

        클라이언트가 복호화 전에 검증 가능
        """
        # 동형 연산 수행
        encrypted_result = computation(encrypted_inputs)

        # 연산 정확성에 대한 ZK 증명 생성
        proof = self.zk.prove_computation(
            encrypted_inputs,
            encrypted_result,
            computation
        )

        return encrypted_result, proof

    def verify_and_decrypt(
        self,
        encrypted_result,
        proof,
        secret_key
    ):
        """
        증명 검증 후 복호화
        """
        # 증명 검증
        if not self.zk.verify(proof):
            raise ValueError("Invalid computation proof")

        # 복호화
        return self.fhe.decrypt(secret_key, encrypted_result)
```

---

## 성능 비교

### 스킴별 성능

```
┌─────────────────────────────────────────────────────────────────────┐
│                    FHE Scheme Performance                            │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  스킴        덧셈       곱셈       부트스트랩   적합 용도           │
│  ─────────────────────────────────────────────────────────────────  │
│  BFV        ~10μs     ~100μs     ~1초        정수 연산             │
│  BGV        ~10μs     ~100μs     ~1초        정수, 배치 처리       │
│  CKKS       ~10μs     ~100μs     ~1초        실수, ML              │
│  TFHE       ~1μs      ~13ms      게이트 포함  비트 연산, 비교       │
│                                                                      │
│  암호문 크기:                                                        │
│  • BFV/BGV/CKKS: ~32KB - 1MB (파라미터 의존)                        │
│  • TFHE: ~1KB per bit                                               │
│                                                                      │
│  곱셈 깊이 (부트스트랩 없이):                                       │
│  • 일반적으로 5-15 레벨                                             │
│  • 머신러닝에는 충분 (작은 네트워크)                                │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 요약

| 스킴 | 특징 | 장점 | 단점 |
|-----|------|-----|-----|
| **BFV** | 정수 연산 | 정확한 결과, 배치 처리 | 실수 불가 |
| **BGV** | 정수, 모듈러 스위칭 | 효율적 | 복잡한 파라미터 |
| **CKKS** | 근사 실수 연산 | ML 친화적 | 정확도 손실 |
| **TFHE** | 비트 단위, 빠른 부트스트랩 | 비교 연산 가능 | 비트 연산만 효율적 |

### FHE vs MPC vs ZK 비교

| 특성 | FHE | MPC | ZK |
|-----|-----|-----|-----|
| **목적** | 암호화 연산 | 공동 계산 | 지식 증명 |
| **참가자** | 1 (서버) | 다수 | 2 (P, V) |
| **통신** | 단방향 | 다방향 | 단방향 |
| **보안 모델** | 계산 보안 | 정보이론/계산 | 계산 보안 |
| **속도** | 느림 | 중간 | 빠름 (검증) |
| **확장성** | 좋음 | 참가자 수 제한 | 좋음 |

다음 문서에서는 최신 ZK 연구 동향을 다룹니다.
