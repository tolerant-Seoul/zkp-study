# 2.6 Folding Schemes: Nova, SuperNova, HyperNova

## 개요

Folding Scheme은 두 개의 NP 인스턴스를 하나로 "접는(fold)" 기법으로, 기존 재귀적 SNARK보다 훨씬 효율적인 IVC(Incrementally Verifiable Computation)를 가능하게 한다. 2022년 Kothapalli, Setty, Tzialla가 제안한 Nova를 시작으로, SuperNova, HyperNova 등 다양한 확장이 개발되었다.

### 왜 Folding이 필요한가?

```
기존 Recursive SNARK의 문제:

IVC 한 단계 비용:
1. 기본 계산 증명: 10,000 constraints
2. Verifier 회로: 100,000+ constraints (SNARK-in-SNARK)
3. 총: 110,000 constraints per step

문제점:
- Verifier를 회로로 표현하는 비용이 지배적
- Pairing 연산 회로화: ~100,000 constraints
- 매 단계 이 비용 반복

Folding의 해결책:
1. 기본 계산 증명: 10,000 constraints
2. Folding 검증: ~10,000 constraints (pairing 없음!)
3. 총: ~20,000 constraints per step

개선: 5-10배 효율 향상
```

---

## 1. Relaxed R1CS

### 1.1 표준 R1CS 복습

```
표준 R1CS:

관계: A * z ⊙ B * z = C * z

여기서:
- A, B, C ∈ F^{m×n}: 행렬
- z ∈ F^n: witness 벡터 (1, public inputs, private inputs)
- ⊙: element-wise 곱셈

예시:
회로: x * y = z

A = | 1 0 0 |    B = | 0 1 0 |    C = | 0 0 1 |
    | ... |          | ... |          | ... |

z = (1, x, y, z)

조건: A*z ⊙ B*z = C*z
→ (x) * (y) = (z) ✓
```

### 1.2 Relaxed R1CS 정의

```
Relaxed R1CS:

관계: A * z ⊙ B * z = u * C * z + E

새로운 요소:
- u ∈ F: scalar (relaxation factor)
- E ∈ F^m: error vector

표준 R1CS와의 관계:
- u = 1, E = 0 이면 표준 R1CS와 동일
- u ≠ 1 또는 E ≠ 0 이면 "relaxed" 상태

Committed Relaxed R1CS:
- W = (E, rE, w, rW): witness
- U = (Com(E), u, Com(w), x): public instance

Com(E): E에 대한 commitment (hiding)
Com(w): witness에 대한 commitment

왜 Relaxation이 필요한가:
두 R1CS 인스턴스를 선형 결합할 때
→ 정확한 R1CS 만족 깨짐
→ Error term E로 "오차" 포착
→ 최종 검증 시 E = 0 확인
```

### 1.3 수학적 표현

```
Relaxed R1CS Instance-Witness 쌍:

Instance U = (Com_E, Com_W, u, x)
- Com_E: error commitment
- Com_W: witness commitment
- u: scalar
- x: public input

Witness W = (E, rE, W, rW)
- E: error vector
- rE: E commitment의 randomness
- W: witness vector
- rW: W commitment의 randomness

만족 조건:
1. Com_E = Commit(E, rE)
2. Com_W = Commit(W, rW)
3. A * z ⊙ B * z = u * C * z + E
   (z = (u, x, W))

Trivial Instance (초기값):
U_⊥ = (0, 0, 0, ⊥)  # 모든 것이 0
W_⊥ = (0, 0, 0, 0)

검증:
A * (0) ⊙ B * (0) = 0 * C * (0) + 0 ✓
```

---

## 2. Nova

### 2.1 개요

Nova는 Folding 기반 IVC의 기초를 제공하며, R1CS 구조를 위한 효율적인 folding scheme이다.

### 2.2 핵심 아이디어: Instance Folding

```
두 인스턴스 결합:

주어진 것:
(U_1, W_1): 첫 번째 relaxed R1CS instance-witness
(U_2, W_2): 두 번째 relaxed R1CS instance-witness

목표:
(U, W): 결합된 instance-witness
        U_1, U_2 모두 만족하면 U도 만족

Folding 연산:
랜덤 챌린지 r을 사용:

u = u_1 + r * u_2
x = x_1 + r * x_2
W = W_1 + r * W_2
E = E_1 + r * T + r² * E_2

T: cross-term (핵심!)

T = A*z_1 ⊙ B*z_2 + A*z_2 ⊙ B*z_1 - u_1*C*z_2 - u_2*C*z_1

Commitment:
Com_W = Com_W1 + r * Com_W2
Com_E = Com_E1 + r * Com_T + r² * Com_E2
```

### 2.3 Cross-term 분석

```
왜 Cross-term T가 필요한가?

z = z_1 + r * z_2로 정의하면:

A*z ⊙ B*z = A*(z_1 + r*z_2) ⊙ B*(z_1 + r*z_2)
           = A*z_1 ⊙ B*z_1           # u_1*C*z_1 + E_1
           + r * (A*z_1 ⊙ B*z_2 + A*z_2 ⊙ B*z_1)  # T
           + r² * A*z_2 ⊙ B*z_2      # u_2*C*z_2 + E_2

정리하면:
A*z ⊙ B*z = (u_1 + r*u_2) * C * (z_1 + r*z_2) + (E_1 + r*T + r²*E_2)

따라서:
새로운 u = u_1 + r * u_2
새로운 E = E_1 + r * T + r² * E_2

T는 "cross-product" 항을 포착
```

### 2.4 Nova IVC 프로토콜

```
Nova IVC 구조:

초기화:
U_0 = trivial instance (u=1, E=0)
W_0 = initial witness

i번째 단계:
입력: (U_{i-1}, W_{i-1}), 새 입력 x_i

1. 현재 계산 수행
   y_i = F(x_i, z_{i-1})

2. 새 R1CS instance 생성
   U_i^{new}: F 계산의 R1CS 표현
   W_i^{new}: 해당 witness

3. Fold
   (U_i, W_i) = Fold((U_{i-1}, W_{i-1}), (U_i^{new}, W_i^{new}))

4. Cross-term commit
   Com_T = Commit(T)

5. Challenge 생성 (Fiat-Shamir)
   r = Hash(U_{i-1}, U_i^{new}, Com_T)

출력: (U_i, W_i)

최종 검증:
1. U_n의 validity 확인
2. SNARK로 U_n에 대한 증명 생성 (선택적)
```

### 2.5 Nova 회로 (Augmented Function)

```
Nova Augmented Function F':

입력:
- vk: verification key (해시로 표현)
- U: 이전 누적 instance (또는 trivial)
- u: 현재 step의 instance
- (i, z_0, z_i): 상태 (step 수, 초기값, 현재값)

연산:
1. i = 0이면:
   - U == trivial instance 확인
   - u.x == (vk, z_0, z_0) 확인

2. i > 0이면:
   - u.x == (vk, i-1, z_0, z_{i-1}) 확인
   - U' = Fold(U, u) 계산 (회로 내)

3. z_i = F(z_{i-1}) 계산

4. x = H(vk, i, z_0, z_i) 출력

핵심:
- Folding 연산이 회로 내에서 수행
- Pairing 없음! (field ops + EC ops만)
- 회로 크기: O(|F| + folding overhead)
```

### 2.6 Python 구현 (개념적)

```python
from dataclasses import dataclass
from typing import Tuple, List, Optional

@dataclass
class RelaxedR1CSInstance:
    """Relaxed R1CS Public Instance"""
    com_e: 'G1Point'      # Commitment to error vector
    com_w: 'G1Point'      # Commitment to witness
    u: int                # Relaxation scalar
    x: List[int]          # Public inputs


@dataclass
class RelaxedR1CSWitness:
    """Relaxed R1CS Witness"""
    e: List[int]          # Error vector
    r_e: int              # E commitment randomness
    w: List[int]          # Witness vector
    r_w: int              # W commitment randomness


@dataclass
class NovaProof:
    """Nova IVC Proof"""
    # Final accumulated instance
    final_instance: RelaxedR1CSInstance

    # Commitments to cross-terms (per step)
    cross_term_commits: List['G1Point']

    # Final witness (for verification)
    final_witness: Optional[RelaxedR1CSWitness]


class NovaProver:
    """Nova IVC Prover"""

    def __init__(self,
                 r1cs: 'R1CS',
                 step_function: callable,
                 commitment_scheme: 'CommitmentScheme'):
        self.r1cs = r1cs
        self.step_function = step_function
        self.cs = commitment_scheme

        # Field modulus
        self.p = self._get_field_modulus()

    def prove_step(self,
                   prev_instance: RelaxedR1CSInstance,
                   prev_witness: RelaxedR1CSWitness,
                   new_input: List[int]) -> Tuple[RelaxedR1CSInstance,
                                                  RelaxedR1CSWitness,
                                                  'G1Point']:
        """
        Nova 한 단계 증명

        Returns:
            folded_instance: 결합된 instance
            folded_witness: 결합된 witness
            com_t: cross-term commitment
        """
        # 1. 새 계산 수행
        new_output = self.step_function(new_input)

        # 2. 새 R1CS witness 생성
        new_witness = self._compute_witness(new_input, new_output)

        # 3. 새 R1CS instance 생성 (relaxed, u=1, E=0)
        new_instance = self._create_fresh_instance(new_witness)

        # 4. Cross-term 계산
        cross_term = self._compute_cross_term(
            prev_instance, prev_witness,
            new_instance, new_witness
        )

        # 5. Cross-term commit
        r_t = self._random_scalar()
        com_t = self.cs.commit(cross_term, r_t)

        # 6. Challenge 생성 (Fiat-Shamir)
        r = self._hash_to_challenge([
            prev_instance.com_e, prev_instance.com_w,
            new_instance.com_e, new_instance.com_w,
            com_t
        ])

        # 7. Fold instances
        folded_instance = self._fold_instances(
            prev_instance, new_instance, com_t, r
        )

        # 8. Fold witnesses
        folded_witness = self._fold_witnesses(
            prev_witness, new_witness, cross_term, r_t, r
        )

        return folded_instance, folded_witness, com_t

    def _compute_cross_term(self,
                            u1: RelaxedR1CSInstance,
                            w1: RelaxedR1CSWitness,
                            u2: RelaxedR1CSInstance,
                            w2: RelaxedR1CSWitness) -> List[int]:
        """
        Cross-term T 계산

        T = A*z_1 ⊙ B*z_2 + A*z_2 ⊙ B*z_1 - u_1*C*z_2 - u_2*C*z_1
        """
        z1 = [u1.u] + u1.x + w1.w
        z2 = [u2.u] + u2.x + w2.w

        # A*z_1, B*z_1, C*z_1
        az1 = self.r1cs.multiply_a(z1)
        bz1 = self.r1cs.multiply_b(z1)
        cz1 = self.r1cs.multiply_c(z1)

        # A*z_2, B*z_2, C*z_2
        az2 = self.r1cs.multiply_a(z2)
        bz2 = self.r1cs.multiply_b(z2)
        cz2 = self.r1cs.multiply_c(z2)

        # T 계산
        t = []
        for i in range(len(az1)):
            term = (az1[i] * bz2[i] + az2[i] * bz1[i] -
                   u1.u * cz2[i] - u2.u * cz1[i]) % self.p
            t.append(term)

        return t

    def _fold_instances(self,
                        u1: RelaxedR1CSInstance,
                        u2: RelaxedR1CSInstance,
                        com_t: 'G1Point',
                        r: int) -> RelaxedR1CSInstance:
        """
        두 instance를 fold

        u = u_1 + r * u_2
        x = x_1 + r * x_2
        Com_E = Com_E1 + r * Com_T + r² * Com_E2
        Com_W = Com_W1 + r * Com_W2
        """
        # Scalar combination
        new_u = (u1.u + r * u2.u) % self.p

        # Public input combination
        new_x = [(u1.x[i] + r * u2.x[i]) % self.p
                 for i in range(len(u1.x))]

        # Commitment combination (EC arithmetic)
        r_sq = (r * r) % self.p

        # Com_E = Com_E1 + r * Com_T + r² * Com_E2
        new_com_e = self._ec_add(
            u1.com_e,
            self._ec_add(
                self._ec_scalar_mul(com_t, r),
                self._ec_scalar_mul(u2.com_e, r_sq)
            )
        )

        # Com_W = Com_W1 + r * Com_W2
        new_com_w = self._ec_add(
            u1.com_w,
            self._ec_scalar_mul(u2.com_w, r)
        )

        return RelaxedR1CSInstance(
            com_e=new_com_e,
            com_w=new_com_w,
            u=new_u,
            x=new_x
        )

    def _fold_witnesses(self,
                        w1: RelaxedR1CSWitness,
                        w2: RelaxedR1CSWitness,
                        t: List[int],
                        r_t: int,
                        r: int) -> RelaxedR1CSWitness:
        """
        두 witness를 fold

        E = E_1 + r * T + r² * E_2
        W = W_1 + r * W_2
        """
        r_sq = (r * r) % self.p

        # Error combination
        new_e = [(w1.e[i] + r * t[i] + r_sq * w2.e[i]) % self.p
                 for i in range(len(w1.e))]

        # Witness combination
        new_w = [(w1.w[i] + r * w2.w[i]) % self.p
                 for i in range(len(w1.w))]

        # Randomness combination
        new_r_e = (w1.r_e + r * r_t + r_sq * w2.r_e) % self.p
        new_r_w = (w1.r_w + r * w2.r_w) % self.p

        return RelaxedR1CSWitness(
            e=new_e,
            r_e=new_r_e,
            w=new_w,
            r_w=new_r_w
        )

    def prove_ivc(self,
                  steps: int,
                  initial_input: List[int],
                  inputs: List[List[int]]) -> NovaProof:
        """
        전체 IVC 증명 생성

        Args:
            steps: 실행 step 수
            initial_input: 초기 입력
            inputs: 각 step의 추가 입력

        Returns:
            NovaProof
        """
        # 초기화: trivial instance
        instance, witness = self._create_trivial()
        cross_commits = []

        for i in range(steps):
            instance, witness, com_t = self.prove_step(
                instance, witness,
                inputs[i] if i < len(inputs) else []
            )
            cross_commits.append(com_t)

        return NovaProof(
            final_instance=instance,
            cross_term_commits=cross_commits,
            final_witness=witness
        )

    # Helper methods
    def _create_trivial(self) -> Tuple[RelaxedR1CSInstance, RelaxedR1CSWitness]:
        """Trivial (identity) instance-witness pair"""
        pass

    def _create_fresh_instance(self, witness: List[int]) -> RelaxedR1CSInstance:
        """u=1, E=0인 새 instance"""
        pass

    def _compute_witness(self, input: List[int], output: List[int]) -> List[int]:
        """R1CS witness 계산"""
        pass

    def _random_scalar(self) -> int:
        pass

    def _hash_to_challenge(self, data: List) -> int:
        """Fiat-Shamir hash"""
        pass

    def _ec_add(self, p1: 'G1Point', p2: 'G1Point') -> 'G1Point':
        pass

    def _ec_scalar_mul(self, p: 'G1Point', s: int) -> 'G1Point':
        pass

    def _get_field_modulus(self) -> int:
        pass


class NovaVerifier:
    """Nova IVC Verifier"""

    def __init__(self, r1cs: 'R1CS', commitment_scheme: 'CommitmentScheme'):
        self.r1cs = r1cs
        self.cs = commitment_scheme

    def verify(self,
               proof: NovaProof,
               num_steps: int,
               initial_state: List[int],
               final_state: List[int]) -> bool:
        """
        Nova IVC 검증

        검증 내용:
        1. Final instance의 유효성
        2. Public input 일관성
        3. (선택) Relaxed R1CS 만족성
        """
        instance = proof.final_instance

        # 1. Public input 확인
        expected_x = self._compute_expected_public_input(
            num_steps, initial_state, final_state
        )
        if instance.x != expected_x:
            return False

        # 2. Final witness로 R1CS 검증 (전체 검증 시)
        if proof.final_witness is not None:
            if not self._verify_relaxed_r1cs(instance, proof.final_witness):
                return False

        # 3. 또는 SNARK로 위임 (succinct 검증)
        # return self._verify_with_snark(proof)

        return True

    def _verify_relaxed_r1cs(self,
                              instance: RelaxedR1CSInstance,
                              witness: RelaxedR1CSWitness) -> bool:
        """
        Relaxed R1CS 만족성 검증

        A * z ⊙ B * z == u * C * z + E
        """
        z = [instance.u] + instance.x + witness.w

        az = self.r1cs.multiply_a(z)
        bz = self.r1cs.multiply_b(z)
        cz = self.r1cs.multiply_c(z)

        for i in range(len(az)):
            lhs = (az[i] * bz[i]) % self.p
            rhs = (instance.u * cz[i] + witness.e[i]) % self.p
            if lhs != rhs:
                return False

        # Commitment 일관성
        if not self.cs.verify(instance.com_e, witness.e, witness.r_e):
            return False
        if not self.cs.verify(instance.com_w, witness.w, witness.r_w):
            return False

        return True
```

### 2.7 Nova 성능 분석

```
Nova Overhead 분석:

Prover (per step):
- Step function F: |F| constraints
- Folding computation: O(|constraints|) field ops
- Commitment (1 cross-term): O(n) EC ops
- Total: O(|F| + n)

비교 (vs Recursive SNARK):
| 항목 | Recursive SNARK | Nova |
|------|-----------------|------|
| Verifier 회로 | 100,000+ | 0 |
| Folding 회로 | - | 10,000 |
| 총 overhead | 100,000+ | 10,000 |
| 개선 | - | 10x |

Proof 크기:
- 1 accumulated instance: ~256 bytes
- n cross-term commits: n × 32 bytes
- 또는 SNARK로 압축: ~200 bytes

Verification:
- 재귀적 검증 없음
- 최종 단계에서만 SNARK
- O(1) 최종 검증
```

---

## 3. SuperNova

### 3.1 개요

SuperNova (2022)는 Nova의 확장으로, 다양한 종류의 step function을 지원한다. VM 구현에 특히 유용하다.

### 3.2 핵심 아이디어: Multi-function IVC

```
Nova의 한계:
- 단일 step function F만 지원
- 모든 step에서 동일한 회로

SuperNova 확장:
- k개의 서로 다른 function {F_1, F_2, ..., F_k}
- 각 step에서 어떤 F_i를 실행할지 선택

VM 적용:
- 각 F_i = 하나의 opcode 회로
- ADD, MUL, LOAD, STORE, JUMP 등
- 프로그램 실행: opcode 시퀀스

장점:
- 최대 회로만 고려 (평균 아님)
- Opcode별 최적화 가능
- Non-uniform computation 지원
```

### 3.3 프로토콜 구조

```
SuperNova 구조:

k개의 R1CS: {R_1, R_2, ..., R_k}
각 R_i: function F_i에 대응

Running Instances:
(U_1, W_1), (U_2, W_2), ..., (U_k, W_k)
각 (U_i, W_i): F_i에 대한 누적 instance

Step j에서:
1. pc_j 확인 (어떤 함수 실행?)
2. F_{pc_j}(x_j) 계산
3. U'_{pc_j} = Fold(U_{pc_j}, 새 instance)
4. 다른 U_i는 그대로 유지

최종 검증:
모든 k개의 (U_i, W_i)가 valid
```

### 3.4 Python 구현 (개념적)

```python
from dataclasses import dataclass
from typing import Dict, List, Tuple, Optional

@dataclass
class SuperNovaState:
    """SuperNova 상태"""
    # k개의 running instances
    instances: Dict[int, RelaxedR1CSInstance]
    witnesses: Dict[int, RelaxedR1CSWitness]

    # 현재 program counter
    pc: int

    # Execution state
    state: List[int]
    step_count: int


class SuperNovaProver:
    """SuperNova Prover"""

    def __init__(self,
                 circuits: Dict[int, 'R1CS'],
                 functions: Dict[int, callable],
                 commitment_scheme: 'CommitmentScheme'):
        """
        Args:
            circuits: opcode -> R1CS 매핑
            functions: opcode -> step function 매핑
        """
        self.circuits = circuits
        self.functions = functions
        self.cs = commitment_scheme
        self.k = len(circuits)

    def initialize(self, initial_state: List[int]) -> SuperNovaState:
        """초기 상태 생성"""
        instances = {}
        witnesses = {}

        for i in self.circuits.keys():
            inst, wit = self._create_trivial(i)
            instances[i] = inst
            witnesses[i] = wit

        return SuperNovaState(
            instances=instances,
            witnesses=witnesses,
            pc=0,
            state=initial_state,
            step_count=0
        )

    def prove_step(self,
                   state: SuperNovaState,
                   opcode: int,
                   input_data: List[int]) -> Tuple[SuperNovaState, 'G1Point']:
        """
        SuperNova 한 단계 증명

        Args:
            state: 현재 상태
            opcode: 실행할 opcode
            input_data: step 입력

        Returns:
            new_state: 업데이트된 상태
            com_t: cross-term commitment
        """
        # 1. Opcode 유효성 확인
        assert opcode in self.circuits, f"Unknown opcode: {opcode}"

        # 2. Step function 실행
        func = self.functions[opcode]
        new_computation_state = func(state.state, input_data)

        # 3. 새 R1CS instance 생성
        r1cs = self.circuits[opcode]
        new_witness = self._compute_witness(
            r1cs, state.state, input_data, new_computation_state
        )
        new_instance = self._create_fresh_instance(r1cs, new_witness)

        # 4. 해당 opcode의 running instance와 fold
        prev_instance = state.instances[opcode]
        prev_witness = state.witnesses[opcode]

        # Cross-term 계산 (해당 R1CS 기준)
        cross_term = self._compute_cross_term(
            r1cs,
            prev_instance, prev_witness,
            new_instance, new_witness
        )

        r_t = self._random_scalar()
        com_t = self.cs.commit(cross_term, r_t)

        # Challenge
        r = self._hash_to_challenge([
            opcode,
            prev_instance, new_instance,
            com_t
        ])

        # 5. Fold
        folded_instance = self._fold_instances(
            prev_instance, new_instance, com_t, r
        )
        folded_witness = self._fold_witnesses(
            prev_witness, new_witness, cross_term, r_t, r
        )

        # 6. 상태 업데이트
        new_instances = state.instances.copy()
        new_witnesses = state.witnesses.copy()
        new_instances[opcode] = folded_instance
        new_witnesses[opcode] = folded_witness

        new_state = SuperNovaState(
            instances=new_instances,
            witnesses=new_witnesses,
            pc=opcode,  # 또는 다음 PC 계산
            state=new_computation_state,
            step_count=state.step_count + 1
        )

        return new_state, com_t

    def prove_program(self,
                      initial_state: List[int],
                      program: List[Tuple[int, List[int]]]) -> 'SuperNovaProof':
        """
        전체 프로그램 실행 증명

        Args:
            initial_state: 초기 상태
            program: [(opcode, input), ...] 시퀀스
        """
        state = self.initialize(initial_state)
        cross_commits = []

        for opcode, input_data in program:
            state, com_t = self.prove_step(state, opcode, input_data)
            cross_commits.append((opcode, com_t))

        return SuperNovaProof(
            final_state=state,
            cross_term_commits=cross_commits
        )

    # Helper methods (Nova와 동일)
    def _create_trivial(self, opcode: int) -> Tuple[RelaxedR1CSInstance, RelaxedR1CSWitness]:
        pass

    def _create_fresh_instance(self, r1cs: 'R1CS', witness: List[int]) -> RelaxedR1CSInstance:
        pass

    def _compute_witness(self, r1cs: 'R1CS', state: List[int],
                         input: List[int], output: List[int]) -> List[int]:
        pass

    def _compute_cross_term(self, r1cs: 'R1CS',
                            u1: RelaxedR1CSInstance, w1: RelaxedR1CSWitness,
                            u2: RelaxedR1CSInstance, w2: RelaxedR1CSWitness) -> List[int]:
        pass

    def _fold_instances(self, u1: RelaxedR1CSInstance, u2: RelaxedR1CSInstance,
                        com_t: 'G1Point', r: int) -> RelaxedR1CSInstance:
        pass

    def _fold_witnesses(self, w1: RelaxedR1CSWitness, w2: RelaxedR1CSWitness,
                        t: List[int], r_t: int, r: int) -> RelaxedR1CSWitness:
        pass


# 사용 예시: 간단한 VM
def example_supernova_vm():
    """SuperNova로 간단한 VM 구현"""

    # Opcodes
    ADD = 0
    MUL = 1
    LOAD = 2
    STORE = 3

    # Step functions
    def add_fn(state, inputs):
        a, b = inputs[0], inputs[1]
        result = state.copy()
        result[inputs[2]] = (a + b) % FIELD_MOD
        return result

    def mul_fn(state, inputs):
        a, b = inputs[0], inputs[1]
        result = state.copy()
        result[inputs[2]] = (a * b) % FIELD_MOD
        return result

    # ... load, store 등

    functions = {
        ADD: add_fn,
        MUL: mul_fn,
        # ...
    }

    # R1CS 회로들 (각 opcode별)
    circuits = {
        ADD: create_add_r1cs(),
        MUL: create_mul_r1cs(),
        # ...
    }

    # Prover 생성
    prover = SuperNovaProver(circuits, functions, commitment_scheme)

    # 프로그램 실행
    # x = 3 + 5 = 8
    # y = x * 2 = 16
    program = [
        (ADD, [3, 5, 0]),   # reg[0] = 3 + 5
        (MUL, [8, 2, 1]),   # reg[1] = 8 * 2
    ]

    proof = prover.prove_program([0, 0, 0, 0], program)
```

### 3.5 SuperNova 성능

```
SuperNova vs Nova:

| 특성 | Nova | SuperNova |
|------|------|-----------|
| Function 수 | 1 | k |
| Running instances | 1 | k |
| Memory | O(1) | O(k) |
| Fold per step | 1 | 1 |
| 회로 크기 | 최대 | opcode별 |

Trade-off:
- 더 많은 메모리 (k개 instance 유지)
- 하지만 평균 회로 크기 감소 가능
- VM에 최적 (opcode 크기 다양)

실제 zkVM:
| opcode | 회로 크기 |
|--------|----------|
| ADD | 100 |
| MUL | 200 |
| SHA256 | 30,000 |

Nova: 매 step 30,000 constraints
SuperNova: 실제 사용 opcode 크기만
```

---

## 4. HyperNova

### 4.1 개요

HyperNova (2023)는 Nova를 CCS (Customizable Constraint System)로 일반화한 버전으로, 더 표현력 있는 제약 시스템을 지원한다.

### 4.2 CCS (Customizable Constraint System)

```
CCS 정의:

R1CS: A*z ⊙ B*z = C*z (3개 행렬, 1개 곱)

CCS: Σ_{i∈S} c_i * (⨂_{j∈M_i} M_j * z) = 0

여기서:
- M_1, ..., M_t: t개의 행렬
- S: 항들의 집합
- M_i ⊆ {1, ..., t}: 각 항에서 사용하는 행렬들
- c_i: 계수
- ⨂: Hadamard product (element-wise 곱)

예시:
R1CS는 CCS의 특수 경우:
- M_1 = A, M_2 = B, M_3 = C
- S = {1, 2}
- M_1 = {1, 2}, M_2 = {3}
- c_1 = 1, c_2 = -1

CCS: 1*(A*z ⊙ B*z) + (-1)*(C*z) = 0
   = A*z ⊙ B*z - C*z = 0 ✓

CCS 장점:
- 더 높은 차수 (degree) 지원
- 커스텀 게이트 자연스럽게 표현
- PLONK-style 회로 지원
```

### 4.3 Multi-folding

```
HyperNova Multi-folding:

Nova: 2개 instance → 1개 instance
HyperNova: μ개 instance → 1개 instance

장점:
- 더 많은 instance를 한 번에 fold
- Prover 효율 향상
- 병렬 증명 생성 후 집계

μ-folding 공식:
주어진 μ개 instance (U_1, ..., U_μ)

r_1, ..., r_{μ-1}: 랜덤 챌린지

U = U_1 + Σ_{i=2}^{μ} r_{i-1} * U_i

Cross-term: 더 복잡한 multi-linear 구조
```

### 4.4 성능 비교

```
Folding Schemes 비교:

| 특성 | Nova | SuperNova | HyperNova |
|------|------|-----------|-----------|
| Constraint | R1CS | R1CS | CCS |
| Functions | 1 | k | 1 (표현력↑) |
| Folding | 2→1 | 2→1 | μ→1 |
| 표현력 | 낮음 | 중간 | 높음 |
| 구현 복잡도 | 낮음 | 중간 | 높음 |

CCS 표현력:
- 고차 다항식 (R1CS는 2차만)
- Custom gates (PLONK-style)
- Lookup arguments 통합 가능

사용 사례:
- Nova: 단순한 반복 계산
- SuperNova: VM, 다중 opcode
- HyperNova: 복잡한 회로, 고급 최적화
```

---

## 5. 구현체와 프로젝트

### 5.1 주요 구현체

```
라이브러리:

1. nova-snark (Microsoft Research)
   - Rust 구현
   - Nova 원본 논문 저자들
   - https://github.com/microsoft/Nova

2. Nova Scotia
   - nova-snark + Circom 연동
   - 기존 회로 재사용
   - https://github.com/nalinbhardwaj/Nova-Scotia

3. Sonobe
   - 다중 folding scheme 지원
   - Nova, SuperNova, HyperNova
   - https://github.com/privacy-scaling-explorations/sonobe

4. Nexus
   - zkVM with Nova
   - RISC-V 지원
   - https://github.com/nexus-xyz/nexus-zkvm
```

### 5.2 프로덕션 사용

```
Nova 기반 프로젝트:

1. Nexus zkVM
   - RISC-V 기반 zkVM
   - Nova로 instruction 증명
   - 고성능 prover

2. Lurk
   - Lisp-like zkVM
   - Nova/SuperNova 사용
   - 표현력 있는 프로그래밍

3. Scroll zkEVM
   - HyperNova 연구 중
   - 복잡한 EVM opcode

4. Aztec
   - Goblin PLONK (Nova 영감)
   - Recursive proof aggregation
```

---

## 6. 고급 주제

### 6.1 Cyclefold

```
Cyclefold: Curve Cycle 활용

문제: Nova의 commitment 연산이 비쌈

해결: 두 curve를 번갈아 사용
- Primary curve: 메인 연산
- Secondary curve: commitment 연산

구조:
Step i (Primary):
- F 실행
- Fold U, 새 instance
- Secondary curve에서 commitment

Step i (Secondary):
- Commitment 검증
- Primary curve에서 commitment

장점:
- Commitment이 native field 연산
- 회로 overhead 감소
- ~2x 성능 향상
```

### 6.2 Sangria

```
Sangria: Folding + PLONK

PLONK의 장점:
- Universal setup
- Custom gates
- Lookup support

Sangria 접근:
- PLONK 구조를 folding에 적용
- Relaxed PLONKish 제약
- Accumulation scheme 통합

장점:
- PLONK 생태계 활용
- 더 효율적인 회로
- Lookup 지원
```

### 6.3 ProtoStar

```
ProtoStar: Non-uniform IVC

특징:
- Nova + PLONK 스타일
- Accumulation 없이 folding
- 더 간단한 구조

장점:
- 구현 단순
- 증명 크기 작음
- 빠른 검증
```

---

## 7. 실무 선택 가이드

### 7.1 언제 Folding을 사용?

```
Folding 적합:
✓ 반복 계산 (IVC)
✓ 긴 실행 trace
✓ Prover 효율 중요
✓ 점진적 증명 필요

Folding 부적합:
✗ 단일 회로 (한 번 실행)
✗ 매우 작은 계산
✗ 최소 proof size 필요
✗ 실시간 검증 필요
```

### 7.2 어떤 Folding?

```
결정 트리:

1. 단일 function?
   → Nova

2. 다중 function (VM)?
   → SuperNova

3. 복잡한 회로 (PLONK-style)?
   → HyperNova

4. 기존 Circom 회로 재사용?
   → Nova Scotia

5. 최대 성능?
   → Cyclefold + Nova

6. 최소 구현 복잡도?
   → ProtoStar
```

---

## 요약

```
Folding Schemes 핵심:

기본 원리:
- 두 NP instance를 하나로 "접기"
- Relaxed R1CS: error term으로 "오차" 허용
- Cross-term: 선형 결합 시 발생하는 추가항

Nova:
- 최초의 실용적 folding scheme
- R1CS 기반
- ~10x 효율 (vs recursive SNARK)
- 단일 step function

SuperNova:
- 다중 function 지원
- VM 구현에 최적
- k개의 running instance

HyperNova:
- CCS (일반화된 제약 시스템)
- 고차 다항식 지원
- Multi-folding (μ→1)

장점:
- Pairing 없는 재귀
- 작은 회로 overhead
- 효율적인 IVC

구현체:
- nova-snark (MS)
- Sonobe (다중 scheme)
- Nexus (zkVM)

선택 기준:
- 단일 함수: Nova
- 다중 함수: SuperNova
- 복잡한 회로: HyperNova
```
