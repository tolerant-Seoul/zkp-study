# 3.1 Circom을 활용한 ZK 회로 개발

## 개요

Circom은 Zero-Knowledge 회로를 작성하기 위한 DSL(Domain Specific Language)로, snarkjs와 함께 가장 널리 사용되는 ZK 개발 도구이다. 이 문서에서는 Circom의 문법부터 실전 회로 작성까지 개발자 관점에서 상세히 다룬다.

---

## 1. 개발 환경 설정

### 1.1 필수 도구 설치

```bash
# Node.js 설치 (v16+)
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs

# Rust 설치 (circom 빌드용)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh
source $HOME/.cargo/env

# Circom 설치 (소스 빌드)
git clone https://github.com/iden3/circom.git
cd circom
cargo build --release
sudo cp target/release/circom /usr/local/bin/

# 버전 확인
circom --version
# circom compiler 2.1.x

# snarkjs 설치
npm install -g snarkjs

# 버전 확인
snarkjs --version
```

### 1.2 프로젝트 구조

```
my-zk-project/
├── circuits/
│   ├── main.circom          # 메인 회로
│   ├── lib/                  # 재사용 컴포넌트
│   │   ├── comparators.circom
│   │   ├── poseidon.circom
│   │   └── merkle.circom
│   └── test/                 # 테스트 회로
├── build/                    # 컴파일 출력
│   ├── main.r1cs
│   ├── main.wasm
│   ├── main_js/
│   └── main.sym
├── keys/                     # 증명 키
│   ├── circuit_final.zkey
│   └── verification_key.json
├── inputs/                   # 입력 데이터
│   └── input.json
├── proofs/                   # 생성된 증명
│   └── proof.json
├── contracts/                # Solidity 검증자
│   └── Verifier.sol
├── scripts/                  # 빌드 스크립트
│   ├── compile.sh
│   ├── setup.sh
│   └── prove.sh
├── test/                     # 테스트 코드
│   └── circuit.test.js
└── package.json
```

### 1.3 package.json 설정

```json
{
  "name": "my-zk-project",
  "version": "1.0.0",
  "scripts": {
    "compile": "./scripts/compile.sh",
    "setup": "./scripts/setup.sh",
    "prove": "./scripts/prove.sh",
    "verify": "snarkjs groth16 verify keys/verification_key.json inputs/public.json proofs/proof.json",
    "test": "mocha test/**/*.test.js"
  },
  "devDependencies": {
    "circomlib": "^2.0.5",
    "circomlibjs": "^0.1.7",
    "snarkjs": "^0.7.0",
    "mocha": "^10.2.0",
    "chai": "^4.3.7"
  }
}
```

---

## 2. Circom 문법 기초

### 2.1 기본 구조

```circom
pragma circom 2.1.0;

// 템플릿 정의 (회로의 기본 단위)
template TemplateName(param1, param2) {
    // 신호 선언
    signal input a;           // 입력 신호
    signal input b;
    signal output c;          // 출력 신호
    signal intermediate;      // 중간 신호

    // 제약 조건
    intermediate <== a * b;   // 할당 + 제약
    c <== intermediate + 1;
}

// 메인 컴포넌트 (진입점)
component main {public [a]} = TemplateName(10, 20);
```

### 2.2 신호(Signal) 타입

```circom
pragma circom 2.1.0;

template SignalTypes() {
    // 입력 신호: 외부에서 제공
    signal input private_input;   // 비공개 입력 (기본값)
    signal input public_input;    // 공개 입력 (main에서 지정)

    // 출력 신호: 회로의 결과
    signal output result;

    // 중간 신호: 내부 계산용
    signal temp;

    // 배열 신호
    signal input arr[10];         // 크기 10 배열
    signal matrix[3][4];          // 3x4 행렬

    // 신호는 유한체 원소 (BN254: ~254비트)
    // 범위: 0 ~ p-1 (p는 필드 모듈러스)
}
```

### 2.3 연산자와 제약

```circom
pragma circom 2.1.0;

template Operators() {
    signal input a, b;
    signal output result;

    // === 제약 연산자 ===

    // <== : 할당 + 제약 (가장 많이 사용)
    signal temp1;
    temp1 <== a * b;     // temp1 = a*b 이고, 이 관계가 R1CS 제약으로 추가됨

    // === : 제약만 (할당 없음)
    signal temp2;
    temp2 <-- a * b;     // 할당만 (위험! 제약 없음)
    temp2 === a * b;     // 제약 추가

    // ==> : 역방향 (잘 안 씀)
    // a * b ==> temp3;

    // === 산술 연산 ===
    signal sum;
    sum <== a + b;       // 덧셈

    signal diff;
    diff <== a - b;      // 뺄셈

    signal prod;
    prod <== a * b;      // 곱셈

    // 나눗셈: 직접 지원 안 됨! 역원 계산 필요
    // div <== a / b;    // 에러!

    // 멱승
    signal sq;
    sq <== a * a;        // a^2
    signal cube;
    cube <== a * a * a;  // a^3

    // === 비교 연산 (제약 아님, 컴파일 타임) ===
    var x = 5;
    var y = 10;
    var isEqual = (x == y);   // 0 (false)
    var isLess = (x < y);     // 1 (true)

    result <== temp1;
}

// 중요: 제약은 "2차 다항식"만 허용!
// 유효: a * b
// 유효: a * b + c
// 무효: a * b * c  (3차)
// 해결: temp <== a * b; result <== temp * c;
```

### 2.4 제어 흐름

```circom
pragma circom 2.1.0;

template ControlFlow(n) {
    signal input arr[n];
    signal output sum;

    // === 반복문 (컴파일 타임 전개) ===
    signal sums[n + 1];
    sums[0] <== 0;

    for (var i = 0; i < n; i++) {
        sums[i + 1] <== sums[i] + arr[i];
    }
    sum <== sums[n];

    // === 조건문 (컴파일 타임) ===
    signal output evenSum;

    signal evenSums[n + 1];
    evenSums[0] <== 0;

    for (var i = 0; i < n; i++) {
        if (i % 2 == 0) {
            evenSums[i + 1] <== evenSums[i] + arr[i];
        } else {
            evenSums[i + 1] <== evenSums[i];
        }
    }
    evenSum <== evenSums[n];
}

// 런타임 조건 분기: 산술화 필요!
template RuntimeConditional() {
    signal input condition;  // 0 또는 1
    signal input a, b;
    signal output result;

    // if (condition) result = a; else result = b;
    // 회로로 표현:
    result <== condition * a + (1 - condition) * b;

    // condition이 boolean인지 검증
    condition * (1 - condition) === 0;
}
```

### 2.5 컴포넌트 사용

```circom
pragma circom 2.1.0;

// 재사용 가능한 컴포넌트
template Add() {
    signal input a, b;
    signal output c;
    c <== a + b;
}

template Multiply() {
    signal input a, b;
    signal output c;
    c <== a * b;
}

// 컴포넌트 조합
template Calculator() {
    signal input x, y, z;
    signal output result;

    // 컴포넌트 인스턴스화
    component adder = Add();
    component multiplier = Multiply();

    // 신호 연결
    adder.a <== x;
    adder.b <== y;

    multiplier.a <== adder.c;  // x + y
    multiplier.b <== z;

    result <== multiplier.c;   // (x + y) * z
}

// 배열로 컴포넌트 생성
template SumArray(n) {
    signal input arr[n];
    signal output sum;

    component adders[n - 1];

    signal partialSums[n];
    partialSums[0] <== arr[0];

    for (var i = 0; i < n - 1; i++) {
        adders[i] = Add();
        adders[i].a <== partialSums[i];
        adders[i].b <== arr[i + 1];
        partialSums[i + 1] <== adders[i].c;
    }

    sum <== partialSums[n - 1];
}
```

---

## 3. 핵심 회로 패턴

### 3.1 Boolean 검증

```circom
pragma circom 2.1.0;

// 값이 0 또는 1인지 검증
template IsBoolean() {
    signal input x;
    signal output out;

    // x * (1 - x) = 0 ⟺ x ∈ {0, 1}
    x * (1 - x) === 0;

    out <== x;
}

// 배열의 모든 원소가 boolean인지 검증
template AssertAllBoolean(n) {
    signal input bits[n];

    for (var i = 0; i < n; i++) {
        bits[i] * (1 - bits[i]) === 0;
    }
}
```

### 3.2 비트 분해

```circom
pragma circom 2.1.0;

// 숫자를 비트로 분해
template Num2Bits(n) {
    signal input in;
    signal output out[n];

    var lc = 0;

    for (var i = 0; i < n; i++) {
        out[i] <-- (in >> i) & 1;      // 비트 추출 (할당만)
        out[i] * (1 - out[i]) === 0;   // boolean 검증
        lc += out[i] * (1 << i);       // 재조합
    }

    // 재조합한 값이 원본과 같은지 검증
    lc === in;
}

// 비트를 숫자로 재조합
template Bits2Num(n) {
    signal input in[n];
    signal output out;

    var lc = 0;
    for (var i = 0; i < n; i++) {
        lc += in[i] * (1 << i);
    }

    out <== lc;
}

// 사용 예시
template BitDecomposeExample() {
    signal input number;       // 예: 42
    signal output bits[8];     // 8비트

    component n2b = Num2Bits(8);
    n2b.in <== number;

    for (var i = 0; i < 8; i++) {
        bits[i] <== n2b.out[i];
    }
    // bits = [0, 1, 0, 1, 0, 1, 0, 0] (42 = 0b00101010)
}
```

### 3.3 비교 연산

```circom
pragma circom 2.1.0;

include "circomlib/comparators.circom";

// 두 값이 같은지 검증
template IsEqual() {
    signal input a, b;
    signal output out;

    signal diff;
    diff <== a - b;

    // diff가 0인지 검증
    // diff * inv = 1 (diff ≠ 0) 또는 inv = 0 (diff = 0)
    signal inv;
    inv <-- diff != 0 ? 1 / diff : 0;

    signal isNonZero;
    isNonZero <== diff * inv;  // 0 또는 1

    out <== 1 - isNonZero;  // diff = 0이면 1, 아니면 0
}

// 범위 검증 (0 <= x < n)
template RangeCheck(n) {
    signal input x;

    // n비트로 표현 가능한지 검증
    component n2b = Num2Bits(n);
    n2b.in <== x;
    // Num2Bits가 성공하면 0 <= x < 2^n
}

// a < b 검증
template LessThan(n) {
    signal input a, b;
    signal output out;

    // a < b ⟺ b - a - 1 >= 0 ⟺ b - a - 1이 n비트로 표현 가능
    // (오버플로 없이)

    component n2b = Num2Bits(n + 1);
    n2b.in <== b + (1 << n) - a - 1;

    out <== 1 - n2b.out[n];  // 최상위 비트가 0이면 a < b
}
```

### 3.4 선택자 (Multiplexer)

```circom
pragma circom 2.1.0;

// 2:1 멀티플렉서
template Mux1() {
    signal input c[2];    // 선택할 값들
    signal input s;       // 선택자 (0 또는 1)
    signal output out;

    // s = 0이면 c[0], s = 1이면 c[1]
    out <== c[0] + s * (c[1] - c[0]);
    // = c[0] * (1 - s) + c[1] * s
}

// n:1 멀티플렉서
template Mux(n) {
    signal input c[n];       // 선택할 값들
    signal input s;          // 선택 인덱스
    signal output out;

    // s가 유효한 인덱스인지 검증
    component rangeCheck = RangeCheck(log2(n) + 1);
    rangeCheck.x <== s;

    // 선택 로직 (비효율적이지만 이해하기 쉬움)
    signal partials[n];
    partials[0] <== c[0] * (1 - s);

    // 실제로는 비트 분해 기반 구현 사용
    // circomlib의 Mux 시리즈 참고
}

// 조건부 선택 (if-else)
template IfThenElse() {
    signal input cond;     // boolean
    signal input ifTrue;
    signal input ifFalse;
    signal output out;

    out <== cond * ifTrue + (1 - cond) * ifFalse;
}
```

### 3.5 해시 함수 (Poseidon)

```circom
pragma circom 2.1.0;

include "circomlib/poseidon.circom";

// 단일 값 해시
template HashSingle() {
    signal input x;
    signal output hash;

    component hasher = Poseidon(1);
    hasher.inputs[0] <== x;
    hash <== hasher.out;
}

// 두 값 해시
template HashPair() {
    signal input left, right;
    signal output hash;

    component hasher = Poseidon(2);
    hasher.inputs[0] <== left;
    hasher.inputs[1] <== right;
    hash <== hasher.out;
}

// 배열 해시
template HashArray(n) {
    signal input arr[n];
    signal output hash;

    component hasher = Poseidon(n);
    for (var i = 0; i < n; i++) {
        hasher.inputs[i] <== arr[i];
    }
    hash <== hasher.out;
}
```

### 3.6 Merkle Tree

```circom
pragma circom 2.1.0;

include "circomlib/poseidon.circom";

// Merkle Proof 검증
template MerkleTreeVerifier(levels) {
    signal input leaf;                    // 증명할 리프
    signal input pathElements[levels];    // 경로상의 형제 노드들
    signal input pathIndices[levels];     // 경로 방향 (0=left, 1=right)
    signal input root;                    // 예상 루트

    signal hashes[levels + 1];
    hashes[0] <== leaf;

    component hashers[levels];
    component mux[levels][2];

    for (var i = 0; i < levels; i++) {
        // pathIndices[i]가 boolean인지 검증
        pathIndices[i] * (1 - pathIndices[i]) === 0;

        // 해시 순서 결정 (현재 vs 형제)
        mux[i][0] = Mux1();
        mux[i][0].c[0] <== hashes[i];
        mux[i][0].c[1] <== pathElements[i];
        mux[i][0].s <== pathIndices[i];

        mux[i][1] = Mux1();
        mux[i][1].c[0] <== pathElements[i];
        mux[i][1].c[1] <== hashes[i];
        mux[i][1].s <== pathIndices[i];

        // 해시 계산
        hashers[i] = Poseidon(2);
        hashers[i].inputs[0] <== mux[i][0].out;
        hashers[i].inputs[1] <== mux[i][1].out;

        hashes[i + 1] <== hashers[i].out;
    }

    // 계산된 루트가 예상 루트와 같은지 검증
    root === hashes[levels];
}

// Merkle Tree에 값 추가 검증
template MerkleTreeInsert(levels) {
    signal input oldRoot;
    signal input newRoot;
    signal input leaf;
    signal input pathElements[levels];
    signal input pathIndices[levels];

    // 기존 위치가 비어있음을 검증 (oldLeaf = 0)
    component oldVerifier = MerkleTreeVerifier(levels);
    oldVerifier.leaf <== 0;
    for (var i = 0; i < levels; i++) {
        oldVerifier.pathElements[i] <== pathElements[i];
        oldVerifier.pathIndices[i] <== pathIndices[i];
    }
    oldVerifier.root <== oldRoot;

    // 새 리프 추가 후 루트 검증
    component newVerifier = MerkleTreeVerifier(levels);
    newVerifier.leaf <== leaf;
    for (var i = 0; i < levels; i++) {
        newVerifier.pathElements[i] <== pathElements[i];
        newVerifier.pathIndices[i] <== pathIndices[i];
    }
    newVerifier.root <== newRoot;
}
```

### 3.7 EdDSA 서명 검증

```circom
pragma circom 2.1.0;

include "circomlib/eddsamimc.circom";
// 또는 include "circomlib/eddsaposeidon.circom";

template SignatureVerifier() {
    // 공개키
    signal input pubKeyX;
    signal input pubKeyY;

    // 서명
    signal input R8x;
    signal input R8y;
    signal input S;

    // 메시지
    signal input message;

    // 검증 결과
    signal output valid;

    component verifier = EdDSAMiMCVerifier();
    verifier.enabled <== 1;
    verifier.Ax <== pubKeyX;
    verifier.Ay <== pubKeyY;
    verifier.R8x <== R8x;
    verifier.R8y <== R8y;
    verifier.S <== S;
    verifier.M <== message;

    valid <== 1;  // 검증 실패시 회로 자체가 만족 불가
}
```

---

## 4. 실전 회로 예제

### 4.1 비밀 투표 시스템

```circom
pragma circom 2.1.0;

include "circomlib/poseidon.circom";
include "circomlib/comparators.circom";

/*
 * 비밀 투표 회로
 *
 * 공개 입력:
 * - merkleRoot: 유권자 목록 루트
 * - nullifierHash: 이중 투표 방지용
 * - voteHash: 투표 내용 해시
 *
 * 비공개 입력:
 * - secret: 유권자 비밀키
 * - vote: 투표 값 (0 또는 1)
 * - pathElements: Merkle 경로
 * - pathIndices: Merkle 인덱스
 */
template SecretVote(levels) {
    // Public inputs
    signal input merkleRoot;
    signal input nullifierHash;
    signal input voteHash;

    // Private inputs
    signal input secret;
    signal input vote;
    signal input pathElements[levels];
    signal input pathIndices[levels];

    // 1. vote가 유효한지 검증 (0 또는 1)
    vote * (1 - vote) === 0;

    // 2. commitment 계산 (secret -> commitment)
    component commitmentHasher = Poseidon(1);
    commitmentHasher.inputs[0] <== secret;
    signal commitment;
    commitment <== commitmentHasher.out;

    // 3. 유권자 목록에 포함되어 있는지 검증
    component merkleVerifier = MerkleTreeVerifier(levels);
    merkleVerifier.leaf <== commitment;
    for (var i = 0; i < levels; i++) {
        merkleVerifier.pathElements[i] <== pathElements[i];
        merkleVerifier.pathIndices[i] <== pathIndices[i];
    }
    merkleVerifier.root <== merkleRoot;

    // 4. nullifier 계산 (이중 투표 방지)
    component nullifierHasher = Poseidon(2);
    nullifierHasher.inputs[0] <== secret;
    nullifierHasher.inputs[1] <== merkleRoot;  // 투표 ID로 사용
    nullifierHasher.out === nullifierHash;

    // 5. 투표 해시 검증
    component voteHasher = Poseidon(2);
    voteHasher.inputs[0] <== vote;
    voteHasher.inputs[1] <== secret;
    voteHasher.out === voteHash;
}

component main {public [merkleRoot, nullifierHash, voteHash]} = SecretVote(20);
```

### 4.2 토큰 전송 증명

```circom
pragma circom 2.1.0;

include "circomlib/poseidon.circom";
include "circomlib/comparators.circom";

/*
 * 비공개 토큰 전송 회로
 *
 * UTXO 모델: 입력 UTXO들을 소비하고 출력 UTXO들을 생성
 */
template PrivateTransfer(nInputs, nOutputs, levels) {
    // Public inputs
    signal input merkleRoot;
    signal input nullifiers[nInputs];
    signal input commitments[nOutputs];

    // Private inputs - 입력 UTXOs
    signal input inputAmounts[nInputs];
    signal input inputSecrets[nInputs];
    signal input inputPaths[nInputs][levels];
    signal input inputIndices[nInputs][levels];

    // Private inputs - 출력 UTXOs
    signal input outputAmounts[nOutputs];
    signal input outputSecrets[nOutputs];

    // === 1. 입력 검증 ===
    signal totalInput;
    signal inputSums[nInputs + 1];
    inputSums[0] <== 0;

    for (var i = 0; i < nInputs; i++) {
        // 금액이 양수인지 검증
        component rangeCheck = RangeCheck(64);
        rangeCheck.x <== inputAmounts[i];

        // UTXO commitment 계산
        component inputCommitment = Poseidon(2);
        inputCommitment.inputs[0] <== inputAmounts[i];
        inputCommitment.inputs[1] <== inputSecrets[i];

        // Merkle proof 검증
        component merkleProof = MerkleTreeVerifier(levels);
        merkleProof.leaf <== inputCommitment.out;
        for (var j = 0; j < levels; j++) {
            merkleProof.pathElements[j] <== inputPaths[i][j];
            merkleProof.pathIndices[j] <== inputIndices[i][j];
        }
        merkleProof.root <== merkleRoot;

        // Nullifier 계산
        component nullifier = Poseidon(2);
        nullifier.inputs[0] <== inputSecrets[i];
        nullifier.inputs[1] <== inputCommitment.out;
        nullifier.out === nullifiers[i];

        // 합계 누적
        inputSums[i + 1] <== inputSums[i] + inputAmounts[i];
    }
    totalInput <== inputSums[nInputs];

    // === 2. 출력 검증 ===
    signal totalOutput;
    signal outputSums[nOutputs + 1];
    outputSums[0] <== 0;

    for (var i = 0; i < nOutputs; i++) {
        // 금액이 양수인지 검증
        component outputRangeCheck = RangeCheck(64);
        outputRangeCheck.x <== outputAmounts[i];

        // Commitment 계산
        component outputCommitment = Poseidon(2);
        outputCommitment.inputs[0] <== outputAmounts[i];
        outputCommitment.inputs[1] <== outputSecrets[i];
        outputCommitment.out === commitments[i];

        // 합계 누적
        outputSums[i + 1] <== outputSums[i] + outputAmounts[i];
    }
    totalOutput <== outputSums[nOutputs];

    // === 3. 잔액 검증 (입력 = 출력) ===
    totalInput === totalOutput;
}

component main {public [merkleRoot, nullifiers, commitments]} = PrivateTransfer(2, 2, 20);
```

### 4.3 나이 증명 (영지식 KYC)

```circom
pragma circom 2.1.0;

include "circomlib/poseidon.circom";
include "circomlib/comparators.circom";
include "circomlib/eddsaposeidon.circom";

/*
 * 나이 증명 회로
 *
 * 공개 입력:
 * - currentDate: 현재 날짜 (YYYYMMDD)
 * - minAge: 최소 나이 요구사항
 * - credentialHash: 신원 증명서 해시
 *
 * 증명 내용:
 * - 신원 증명서가 신뢰할 수 있는 발급자에 의해 서명됨
 * - 현재 날짜 기준 minAge 이상
 */
template AgeProof() {
    // Public inputs
    signal input currentDate;
    signal input minAge;
    signal input issuerPubKeyX;
    signal input issuerPubKeyY;

    // Private inputs
    signal input birthDate;          // YYYYMMDD 형식
    signal input credentialSecret;

    // 서명
    signal input sigR8x;
    signal input sigR8y;
    signal input sigS;

    // 1. 신원 증명서 해시 계산
    component credentialHash = Poseidon(2);
    credentialHash.inputs[0] <== birthDate;
    credentialHash.inputs[1] <== credentialSecret;

    // 2. 서명 검증 (발급자가 서명했는지)
    component sigVerifier = EdDSAPoseidonVerifier();
    sigVerifier.enabled <== 1;
    sigVerifier.Ax <== issuerPubKeyX;
    sigVerifier.Ay <== issuerPubKeyY;
    sigVerifier.R8x <== sigR8x;
    sigVerifier.R8y <== sigR8y;
    sigVerifier.S <== sigS;
    sigVerifier.M <== credentialHash.out;

    // 3. 나이 계산 및 검증
    // 간단화: (currentYear - birthYear) >= minAge
    // 실제로는 월/일 고려 필요

    signal currentYear;
    signal birthYear;

    // 연도 추출 (YYYYMMDD / 10000)
    currentYear <-- currentDate \ 10000;
    birthYear <-- birthDate \ 10000;

    // 연도가 올바르게 추출됐는지 검증
    signal currentRemainder;
    signal birthRemainder;
    currentRemainder <== currentDate - currentYear * 10000;
    birthRemainder <== birthDate - birthYear * 10000;

    // 나머지가 유효한 범위인지 (0101 ~ 1231)
    component currentValid = RangeCheck(14);
    currentValid.x <== currentRemainder;
    component birthValid = RangeCheck(14);
    birthValid.x <== birthRemainder;

    // 나이 계산
    signal age;
    age <== currentYear - birthYear;

    // 최소 나이 이상인지 검증
    component ageCheck = GreaterEqThan(8);
    ageCheck.in[0] <== age;
    ageCheck.in[1] <== minAge;
    ageCheck.out === 1;
}

component main {public [currentDate, minAge, issuerPubKeyX, issuerPubKeyY]} = AgeProof();
```

---

## 5. 테스트 및 디버깅

### 5.1 회로 테스트

```javascript
// test/circuit.test.js
const chai = require("chai");
const { wasm: wasmTester } = require("circom_tester");
const { buildPoseidon } = require("circomlibjs");

const expect = chai.expect;

describe("SecretVote Circuit", function () {
    let circuit;
    let poseidon;

    before(async function () {
        this.timeout(100000);

        // 회로 컴파일
        circuit = await wasmTester("circuits/secret_vote.circom");

        // Poseidon 해시 함수 초기화
        poseidon = await buildPoseidon();
    });

    it("should accept valid vote", async function () {
        // 테스트 입력 생성
        const secret = BigInt("123456789");
        const vote = 1;

        // commitment 계산
        const commitment = poseidon.F.toString(poseidon([secret]));

        // 간단한 Merkle tree (실제로는 라이브러리 사용)
        const pathElements = Array(20).fill("0");
        const pathIndices = Array(20).fill(0);

        // ... merkle root 계산 ...

        const input = {
            merkleRoot: merkleRoot,
            nullifierHash: nullifierHash,
            voteHash: voteHash,
            secret: secret.toString(),
            vote: vote,
            pathElements: pathElements,
            pathIndices: pathIndices
        };

        // 회로 실행
        const witness = await circuit.calculateWitness(input);

        // 출력 검증
        await circuit.checkConstraints(witness);
    });

    it("should reject invalid vote value", async function () {
        const input = {
            // ... vote: 2 (유효하지 않음) ...
        };

        try {
            await circuit.calculateWitness(input);
            expect.fail("Should have thrown an error");
        } catch (err) {
            expect(err.message).to.include("Assert Failed");
        }
    });
});
```

### 5.2 디버깅 기법

```circom
pragma circom 2.1.0;

// 디버깅용 로그 출력
template DebugExample() {
    signal input a, b;
    signal output c;

    // log() 함수로 값 출력 (개발 모드에서만)
    log("Input a:", a);
    log("Input b:", b);

    signal temp;
    temp <== a * b;
    log("a * b =", temp);

    c <== temp + 1;
    log("Result:", c);
}

// assert로 조건 검증 (실패시 에러)
template AssertExample() {
    signal input x;

    // x가 양수인지 확인
    assert(x > 0);

    // 범위 검증
    assert(x < 1000);
}
```

### 5.3 일반적인 오류와 해결

```
오류 1: "Non quadratic constraints are not allowed"
원인: 3개 이상의 신호 곱셈
해결:
// 잘못된 예
c <== a * b * c;

// 올바른 예
signal temp;
temp <== a * b;
c <== temp * c;

---

오류 2: "Signal assigned twice"
원인: 동일 신호에 두 번 할당
해결: 중간 신호 사용

---

오류 3: "Constraint does not contain an output signal"
원인: 제약이 출력에 영향을 미치지 않음
해결: 모든 제약이 출력으로 연결되는지 확인

---

오류 4: "Snarkjs: Invalid witness"
원인: 입력 값이 제약 조건을 만족하지 않음
해결: 입력 값 검증, 회로 로직 확인
```

---

## 6. 최적화 기법

### 6.1 Constraint 수 줄이기

```circom
pragma circom 2.1.0;

// 비효율적: 각 비교마다 많은 constraint
template Inefficient(n) {
    signal input arr[n];
    signal output max;

    // 각 비교: ~100 constraints
    // 총: O(n * 100)
}

// 효율적: 미리 정렬된 배열 검증
template Efficient(n) {
    signal input arr[n];
    signal input sortedArr[n];
    signal output max;

    // 정렬 검증: 연속 비교
    for (var i = 0; i < n - 1; i++) {
        // sortedArr[i] <= sortedArr[i+1] 검증
        // 단순 뺄셈 + range check
    }

    // arr과 sortedArr이 같은 원소인지 검증
    // (permutation argument 또는 해시 비교)

    max <== sortedArr[n - 1];
}
```

### 6.2 Lookup Table 활용

```circom
pragma circom 2.1.0;

// XOR 연산: 비트 분해 방식 (많은 constraints)
template XorBitwise() {
    signal input a, b;
    signal output c;

    // a, b를 비트로 분해
    component n2bA = Num2Bits(8);
    component n2bB = Num2Bits(8);
    n2bA.in <== a;
    n2bB.in <== b;

    // 비트별 XOR
    signal xorBits[8];
    for (var i = 0; i < 8; i++) {
        xorBits[i] <== n2bA.out[i] + n2bB.out[i] - 2 * n2bA.out[i] * n2bB.out[i];
    }

    // 재조합
    component b2n = Bits2Num(8);
    for (var i = 0; i < 8; i++) {
        b2n.in[i] <== xorBits[i];
    }
    c <== b2n.out;
}

// Lookup 방식 (PLONK/Halo2에서 더 효율적)
// Circom 자체에서는 직접 lookup 미지원
// 대신 circomlib의 최적화된 구현 사용 권장
```

### 6.3 병렬 구조 활용

```circom
pragma circom 2.1.0;

// 순차적 해싱 (느림)
template SequentialHash(n) {
    signal input arr[n];
    signal output hash;

    signal hashes[n];
    hashes[0] <== arr[0];

    for (var i = 1; i < n; i++) {
        component h = Poseidon(2);
        h.inputs[0] <== hashes[i - 1];
        h.inputs[1] <== arr[i];
        hashes[i] <== h.out;
    }
    hash <== hashes[n - 1];
}

// 병렬 해싱 (Merkle tree 구조)
template ParallelHash(levels) {  // n = 2^levels
    signal input arr[1 << levels];
    signal output hash;

    var n = 1 << levels;
    signal hashes[2 * n - 1];

    // 리프 복사
    for (var i = 0; i < n; i++) {
        hashes[n - 1 + i] <== arr[i];
    }

    // Bottom-up 해싱
    for (var i = n - 2; i >= 0; i--) {
        component h = Poseidon(2);
        h.inputs[0] <== hashes[2 * i + 1];
        h.inputs[1] <== hashes[2 * i + 2];
        hashes[i] <== h.out;
    }

    hash <== hashes[0];
}
```

---

## 7. circomlib 주요 컴포넌트

### 7.1 자주 사용하는 컴포넌트

```circom
// 비교 연산
include "circomlib/comparators.circom";
// IsZero, IsEqual, LessThan, GreaterThan, LessEqThan, GreaterEqThan

// 비트 연산
include "circomlib/bitify.circom";
// Num2Bits, Bits2Num, Num2BitsNeg

include "circomlib/gates.circom";
// AND, OR, NOT, XOR, NAND, NOR

// 선택자
include "circomlib/mux1.circom";
include "circomlib/mux2.circom";
include "circomlib/mux4.circom";

// 해시 함수
include "circomlib/poseidon.circom";
include "circomlib/mimc.circom";
include "circomlib/pedersen.circom";

// 서명
include "circomlib/eddsaposeidon.circom";
include "circomlib/eddsamimc.circom";

// 타원 곡선
include "circomlib/babyjub.circom";
include "circomlib/escalarmulfix.circom";

// 기타
include "circomlib/switcher.circom";
include "circomlib/sign.circom";
include "circomlib/aliascheck.circom";
```

---

## 요약

```
Circom 회로 개발 핵심:

기본 문법:
- signal: 입력/출력/중간 신호
- <== : 할당 + 제약 (가장 중요)
- component: 재사용 가능한 서브회로
- template: 파라미터화된 회로 정의

핵심 패턴:
- Boolean 검증: x * (1 - x) === 0
- 비트 분해: Num2Bits, Bits2Num
- 비교: LessThan, IsEqual
- 선택: Mux, IfThenElse
- 해시: Poseidon (ZK-friendly)
- Merkle: 멤버십 증명

개발 프로세스:
1. 회로 설계 (circom)
2. 컴파일 (circom compiler)
3. Trusted Setup (snarkjs)
4. 증명 생성 (snarkjs)
5. 검증 (snarkjs / on-chain)

최적화:
- 2차 제약만 허용
- 중간 신호로 분해
- circomlib 활용
- Lookup (PLONK) 고려

디버깅:
- log() 함수
- 단위 테스트
- 입력 값 검증
```
