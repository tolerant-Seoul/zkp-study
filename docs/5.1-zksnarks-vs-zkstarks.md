# 5.1 zkSNARKs vs zkSTARKs: Deep Comparison

## 개요

zkSNARKs와 zkSTARKs는 현대 영지식 증명 시스템의 두 가지 주요 패러다임입니다. 이 문서에서는 수학적 기초, 보안 가정, 성능 특성, 그리고 실제 사용 사례를 심층 비교합니다.

## 핵심 차이점 요약

```
┌─────────────────────────────────────────────────────────────────────┐
│              zkSNARKs vs zkSTARKs Overview                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  zkSNARKs                          zkSTARKs                         │
│  ─────────────────────────────     ─────────────────────────────    │
│  S: Succinct                       S: Scalable                      │
│  N: Non-interactive                T: Transparent                   │
│  ARK: ARgument of Knowledge        ARK: ARgument of Knowledge       │
│                                                                      │
│  ┌──────────────────────┐          ┌──────────────────────┐         │
│  │ Trusted Setup 필요   │          │ Trusted Setup 불필요 │         │
│  │ (Powers of Tau)      │          │ (공개 무작위성)      │         │
│  └──────────────────────┘          └──────────────────────┘         │
│                                                                      │
│  ┌──────────────────────┐          ┌──────────────────────┐         │
│  │ 타원 곡선 기반       │          │ 해시 함수 기반       │         │
│  │ (BN254, BLS12-381)   │          │ (SHA-256, Poseidon)  │         │
│  └──────────────────────┘          └──────────────────────┘         │
│                                                                      │
│  ┌──────────────────────┐          ┌──────────────────────┐         │
│  │ 작은 증명 크기       │          │ 큰 증명 크기         │         │
│  │ (~200 bytes)         │          │ (~40-200 KB)         │         │
│  └──────────────────────┘          └──────────────────────┘         │
│                                                                      │
│  ┌──────────────────────┐          ┌──────────────────────┐         │
│  │ 빠른 검증            │          │ 빠른 증명 생성       │         │
│  │ (상수 시간)          │          │ (준선형 시간)        │         │
│  └──────────────────────┘          └──────────────────────┘         │
│                                                                      │
│  양자 저항: 취약                    양자 저항: 가능                  │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 수학적 기초

### zkSNARKs 수학

```
┌─────────────────────────────────────────────────────────────────────┐
│                    zkSNARKs Mathematical Foundation                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. 타원 곡선 암호학 (Elliptic Curve Cryptography)                  │
│     • 이산 로그 문제 (DLP) 기반                                     │
│     • 페어링 기반 곡선 (BN254, BLS12-381)                          │
│                                                                      │
│  2. 이중선형 페어링 (Bilinear Pairing)                              │
│     e: G₁ × G₂ → G_T                                                │
│     e(aP, bQ) = e(P, Q)^(ab)                                        │
│                                                                      │
│  3. 다항식 약속 (Polynomial Commitment)                              │
│     • KZG (Kate-Zaverucha-Goldberg)                                 │
│     • C = [p(τ)]₁ where τ is toxic waste                           │
│                                                                      │
│  4. R1CS / QAP 산술화                                                │
│     A(x) · B(x) - C(x) = H(x) · Z(x)                                │
│                                                                      │
│  보안 가정:                                                          │
│  • DLP (Discrete Log Problem)                                       │
│  • CDH (Computational Diffie-Hellman)                               │
│  • Knowledge of Exponent                                            │
└─────────────────────────────────────────────────────────────────────┘
```

#### Groth16 수학적 구조

```python
# Groth16 증명 구조 (개념적)
class Groth16:
    """
    증명: π = (A, B, C) ∈ G₁ × G₂ × G₁

    검증 방정식:
    e(A, B) = e(α, β) · e(∑ aᵢ·Lᵢ(τ), γ) · e(C, δ)

    여기서:
    - α, β, γ, δ: Trusted Setup에서 생성된 독성 폐기물
    - Lᵢ(τ): 공개 입력에 대한 라그랑주 기저
    - τ: 비밀 (삭제되어야 함)
    """

    def __init__(self, curve="bn254"):
        self.curve = curve
        self.field_size = 21888242871839275222246405745257275088548364400416034343698204186575808495617

    def setup(self, circuit):
        """
        Trusted Setup: τ, α, β, γ, δ 생성
        공개 파라미터: [τⁱ]₁, [τⁱ]₂, [α·τⁱ]₁, [β·τⁱ]₁, [β·τⁱ]₂
        """
        # τ는 MPC 후 삭제되어야 함
        tau = random_field_element()
        alpha = random_field_element()
        beta = random_field_element()
        gamma = random_field_element()
        delta = random_field_element()

        # 증명 키, 검증 키 생성
        pk = self._generate_proving_key(circuit, tau, alpha, beta, gamma, delta)
        vk = self._generate_verifying_key(circuit, alpha, beta, gamma, delta)

        return pk, vk

    def prove(self, pk, witness):
        """
        증명 생성: O(n log n) 연산
        주요 연산: MSM (Multi-Scalar Multiplication)
        """
        # A = α + ∑ aᵢ·Aᵢ(τ) + r·δ
        # B = β + ∑ aᵢ·Bᵢ(τ) + s·δ
        # C = (∑ aᵢ·(β·Aᵢ(τ) + α·Bᵢ(τ) + Cᵢ(τ))/δ + H(τ)·T(τ)/δ + A·s + B·r - r·s·δ

        r, s = random_field_element(), random_field_element()

        A = self._compute_A(pk, witness, r)
        B = self._compute_B(pk, witness, s)
        C = self._compute_C(pk, witness, r, s)

        return Proof(A, B, C)

    def verify(self, vk, public_inputs, proof):
        """
        검증: O(1) 페어링 연산 (상수 시간)
        3개의 페어링 검사
        """
        # 공개 입력 선형 결합
        vk_x = vk.ic[0]
        for i, inp in enumerate(public_inputs):
            vk_x = vk_x + inp * vk.ic[i + 1]

        # 페어링 검증
        # e(A, B) = e(α, β) · e(vk_x, γ) · e(C, δ)
        lhs = pairing(proof.A, proof.B)
        rhs = (
            pairing(vk.alpha, vk.beta) *
            pairing(vk_x, vk.gamma) *
            pairing(proof.C, vk.delta)
        )

        return lhs == rhs
```

### zkSTARKs 수학

```
┌─────────────────────────────────────────────────────────────────────┐
│                    zkSTARKs Mathematical Foundation                  │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. 충돌 저항 해시 함수 (Collision-Resistant Hash)                  │
│     • 암호학적 해시 (SHA-256, Blake2)                               │
│     • ZK-친화적 해시 (Poseidon, Rescue)                            │
│                                                                      │
│  2. AIR (Algebraic Intermediate Representation)                      │
│     • 실행 추적 (Execution Trace)                                   │
│     • 다항식 제약 조건                                              │
│                                                                      │
│  3. FRI (Fast Reed-Solomon IOP)                                      │
│     • Low-degree 테스트                                             │
│     • 다항식 약속 (해시 기반)                                       │
│                                                                      │
│  4. Fiat-Shamir 휴리스틱                                            │
│     • Interactive → Non-interactive 변환                            │
│     • 랜덤 오라클 모델                                              │
│                                                                      │
│  보안 가정:                                                          │
│  • 충돌 저항 해시 함수                                              │
│  • 랜덤 오라클 모델                                                  │
│  • (양자 컴퓨터에도 안전하다고 가정)                                │
└─────────────────────────────────────────────────────────────────────┘
```

#### STARK 증명 시스템 구조

```python
# STARK 증명 구조 (개념적)
class STARK:
    """
    투명한 설정 (Transparent Setup)
    해시 함수만 필요, 비밀 파라미터 없음
    """

    def __init__(self, field_size=2**64 - 2**32 + 1):  # Goldilocks field
        self.field = GoldilocksField(field_size)
        self.hash = Poseidon(self.field)

    def arithmetize(self, computation):
        """
        AIR (Algebraic Intermediate Representation)로 변환

        실행 추적: T = [t₀, t₁, ..., t_{n-1}]
        제약 조건: C(tᵢ, tᵢ₊₁) = 0 for all i
        """
        trace = []
        state = computation.initial_state()

        for step in range(computation.num_steps):
            trace.append(state)
            state = computation.transition(state)

        return ExecutionTrace(trace)

    def commit(self, trace):
        """
        Merkle 트리로 추적 커밋
        루트 해시가 공개 커밋먼트
        """
        # 다항식 보간
        trace_polys = self._interpolate_trace(trace)

        # LDE (Low Degree Extension)
        # 보안을 위해 도메인 확장
        extended = self._low_degree_extend(trace_polys, blowup_factor=8)

        # Merkle 트리 구축
        merkle_tree = MerkleTree(extended, hash_fn=self.hash)

        return merkle_tree.root, trace_polys, merkle_tree

    def prove(self, computation, public_inputs):
        """
        STARK 증명 생성

        1. 실행 추적 생성
        2. 추적 다항식 커밋
        3. 제약 조건 다항식 계산
        4. DEEP-ALI 구성
        5. FRI 증명 생성
        """
        # 1. 실행 추적
        trace = self.arithmetize(computation)

        # 2. 추적 커밋
        trace_root, trace_polys, trace_tree = self.commit(trace)

        # 3. 제약 조건 다항식
        # C(x) = sum_i α^i · Cᵢ(T(x), T(g·x))
        constraint_poly = self._compute_constraint_polynomial(
            trace_polys, computation.constraints
        )

        # 4. 합성 다항식 (Composition Polynomial)
        # D(x) = C(x) / Z_H(x)  where Z_H is vanishing polynomial
        composition_poly = constraint_poly / self._vanishing_polynomial()

        # 5. DEEP 구성 (Domain Extension for Eliminating Preprocessing)
        deep_poly = self._deep_composition(trace_polys, composition_poly)

        # 6. FRI 증명
        fri_proof = self._fri_prove(deep_poly)

        return STARKProof(
            trace_root=trace_root,
            composition_root=self._commit_poly(composition_poly),
            fri_proof=fri_proof,
            query_proofs=self._generate_query_proofs(trace_tree)
        )

    def _fri_prove(self, polynomial):
        """
        FRI (Fast Reed-Solomon IOP of Proximity)

        다항식이 낮은 차수임을 증명
        각 라운드에서 차수를 절반으로 줄임
        """
        layers = []
        current_poly = polynomial

        while current_poly.degree > self.fri_stop_degree:
            # Fiat-Shamir로 랜덤 챌린지 생성
            alpha = self.hash(current_poly.commitment)

            # 폴딩: p(x) → p_even(x²) + α · p_odd(x²)
            next_poly = self._fold_polynomial(current_poly, alpha)

            layers.append(FRILayer(
                commitment=current_poly.commitment,
                alpha=alpha
            ))

            current_poly = next_poly

        return FRIProof(layers, final_poly=current_poly.coefficients)

    def verify(self, public_inputs, proof):
        """
        STARK 검증

        시간 복잡도: O(log²n) 해시 연산
        공간 복잡도: O(log n)
        """
        # 1. FRI 검증
        if not self._verify_fri(proof.fri_proof):
            return False

        # 2. 쿼리 검증 (랜덤 위치 샘플링)
        for query in proof.query_proofs:
            if not self._verify_query(query, proof):
                return False

        # 3. 경계 조건 검증
        if not self._verify_boundary_conditions(public_inputs, proof):
            return False

        return True
```

---

## 성능 비교

### 복잡도 분석

```
┌─────────────────────────────────────────────────────────────────────┐
│                      Complexity Comparison                           │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Operation         zkSNARKs (Groth16)      zkSTARKs                 │
│  ─────────────────────────────────────────────────────────────────  │
│  Prover Time       O(n log n)              O(n log² n)              │
│  Verifier Time     O(1)                    O(log² n)                │
│  Proof Size        O(1) ~200 bytes         O(log² n) ~40-200 KB     │
│  Setup             O(n) trusted            O(1) transparent         │
│                                                                      │
│  n = 제약조건 수                                                     │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │              증명 크기 vs 제약조건 수                       │   │
│  │  Proof Size                                                  │   │
│  │  (KB)                                                        │   │
│  │  100 ┤                           ╭─────── STARK             │   │
│  │   80 ┤                    ╭──────╯                          │   │
│  │   60 ┤             ╭──────╯                                 │   │
│  │   40 ┤      ╭──────╯                                        │   │
│  │   20 ┤╭─────╯                                               │   │
│  │    0.2├──────────────────────────────────────── SNARK       │   │
│  │      └┴────────┴────────┴────────┴────────┴─────            │   │
│  │       10³     10⁴      10⁵      10⁶      10⁷  constraints   │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

### 실제 벤치마크

```typescript
// 벤치마크 결과 (참고용, 실제 하드웨어/구현에 따라 다름)
interface BenchmarkResult {
    system: string;
    constraints: number;
    proveTime: string;
    verifyTime: string;
    proofSize: string;
    setupTime: string;
}

const benchmarks: BenchmarkResult[] = [
    // 10만 제약조건 기준
    {
        system: "Groth16 (gnark)",
        constraints: 100_000,
        proveTime: "1.5s",
        verifyTime: "3ms",
        proofSize: "192 bytes",
        setupTime: "30s (trusted)",
    },
    {
        system: "Groth16 (snarkjs)",
        constraints: 100_000,
        proveTime: "15s",
        verifyTime: "5ms",
        proofSize: "192 bytes",
        setupTime: "60s (trusted)",
    },
    {
        system: "PLONK (gnark)",
        constraints: 100_000,
        proveTime: "2s",
        verifyTime: "5ms",
        proofSize: "600 bytes",
        setupTime: "Universal SRS",
    },
    {
        system: "STARK (Stone)",
        constraints: 100_000,
        proveTime: "5s",
        verifyTime: "50ms",
        proofSize: "80 KB",
        setupTime: "None",
    },
    {
        system: "STARK (Winterfell)",
        constraints: 100_000,
        proveTime: "8s",
        verifyTime: "80ms",
        proofSize: "100 KB",
        setupTime: "None",
    },

    // 100만 제약조건 기준
    {
        system: "Groth16 (gnark)",
        constraints: 1_000_000,
        proveTime: "20s",
        verifyTime: "3ms",
        proofSize: "192 bytes",
        setupTime: "5min (trusted)",
    },
    {
        system: "STARK (Stone)",
        constraints: 1_000_000,
        proveTime: "60s",
        verifyTime: "100ms",
        proofSize: "120 KB",
        setupTime: "None",
    },
];

// 크로스오버 포인트 분석
function analyzeTradeoffs(constraints: number): {
    recommendation: string;
    reason: string;
} {
    // 증명 크기가 중요한 경우 (온체인 검증)
    const onChainGasCostSNARK = 300_000;  // ~300K gas
    const onChainGasCostSTARK = 1_000_000 + Math.log2(constraints) * 50_000;

    // 증명 생성 시간이 중요한 경우
    const proveTimeSNARK = constraints * 0.00001;  // 대략적
    const proveTimeSTARK = constraints * 0.00005 * Math.log2(constraints);

    if (constraints < 100_000) {
        return {
            recommendation: "SNARK",
            reason: "작은 회로에서는 SNARK의 증명 크기/검증 시간 이점이 큼"
        };
    } else if (constraints > 10_000_000) {
        return {
            recommendation: "STARK",
            reason: "대규모 회로에서는 STARK의 준선형 증명 시간이 유리"
        };
    } else {
        return {
            recommendation: "Use case dependent",
            reason: "검증 비용 vs 증명 비용 트레이드오프 고려 필요"
        };
    }
}
```

---

## 보안 분석

### 보안 가정 비교

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Security Assumptions                              │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  zkSNARKs:                                                          │
│  ─────────────────────────────────────────────────────────────────  │
│  1. 이산 로그 문제 (DLP)                                            │
│     • 타원 곡선에서 g^x가 주어졌을 때 x를 찾기 어려움              │
│     • 양자 컴퓨터로 깨질 수 있음 (Shor's algorithm)                │
│                                                                      │
│  2. 지식 추출 가정 (Knowledge of Exponent)                          │
│     • 비표준 가정, 일부 학자들이 우려                               │
│                                                                      │
│  3. Trusted Setup 보안                                               │
│     • "toxic waste"가 유출되면 위조 증명 가능                       │
│     • MPC로 완화하지만 완전히 제거되지 않음                         │
│                                                                      │
│  zkSTARKs:                                                           │
│  ─────────────────────────────────────────────────────────────────  │
│  1. 충돌 저항 해시 함수                                              │
│     • 표준 가정, 잘 연구됨                                          │
│     • 양자 저항 가능 (Grover's algorithm은 제곱근만 약화)          │
│                                                                      │
│  2. 랜덤 오라클 모델                                                 │
│     • 이론적 모델, 실제 해시와 차이 가능                            │
│     • Fiat-Shamir 변환의 기초                                       │
│                                                                      │
│  3. 투명한 설정                                                      │
│     • 비밀 파라미터 없음                                            │
│     • 공개 무작위성만 사용                                          │
└─────────────────────────────────────────────────────────────────────┘
```

### 양자 저항성

```python
# 양자 컴퓨터 위협 분석
class QuantumThreatAnalysis:
    """
    양자 컴퓨터가 암호 시스템에 미치는 영향 분석
    """

    @staticmethod
    def analyze_snark_security():
        """
        zkSNARKs의 양자 취약성

        Shor's Algorithm:
        - 다항 시간에 이산 로그 문제 해결
        - 타원 곡선 암호 완전 파괴
        - 2048비트 RSA: 약 4,000 논리 큐비트 필요
        - 256비트 ECC: 약 2,500 논리 큐비트 필요

        현재 상태 (2024):
        - IBM: 1,121 물리 큐비트
        - Google: 72 물리 큐비트 (Bristlecone)
        - 오류 정정 필요: 물리 큐비트 수천 개 → 논리 큐비트 1개

        예상 시간선:
        - 2030년대: 암호학적으로 의미있는 양자 컴퓨터 가능
        - "Harvest now, decrypt later" 공격 위험
        """
        return {
            "vulnerable": True,
            "attack": "Shor's algorithm",
            "timeline": "2030s (estimated)",
            "mitigation": "Post-quantum SNARKs 연구 중",
        }

    @staticmethod
    def analyze_stark_security():
        """
        zkSTARKs의 양자 저항성

        Grover's Algorithm:
        - 해시 충돌 찾기: O(√N) 복잡도
        - 256비트 해시 → 128비트 보안 수준

        대응:
        - 해시 출력 크기 2배로 증가
        - 256비트 → 512비트 해시 사용
        - 증명 크기 약간 증가

        현재 상태:
        - 양자 저항 가능
        - 파라미터 조정으로 보안 수준 유지
        """
        return {
            "vulnerable": False,
            "attack": "Grover's algorithm (limited impact)",
            "mitigation": "Double hash size",
            "impact": "Proof size ~2x larger",
        }
```

### Trusted Setup 문제

```typescript
// Trusted Setup 리스크 분석
interface TrustedSetupRisk {
    scenario: string;
    probability: string;
    impact: string;
    mitigation: string;
}

const trustedSetupRisks: TrustedSetupRisk[] = [
    {
        scenario: "단일 참가자 악의적 행동",
        probability: "Medium",
        impact: "Critical - 위조 증명 생성 가능",
        mitigation: "MPC (다수 참가자 협력 필요)",
    },
    {
        scenario: "모든 MPC 참가자 공모",
        probability: "Very Low",
        impact: "Critical",
        mitigation: "다양한 참가자 (기관, 개인, 익명)",
    },
    {
        scenario: "Toxic waste 메모리 유출",
        probability: "Low",
        impact: "Critical",
        mitigation: "안전한 삭제, HSM 사용",
    },
    {
        scenario: "구현 버그로 인한 유출",
        probability: "Low",
        impact: "Critical",
        mitigation: "코드 감사, 형식 검증",
    },
];

// Zcash Powers of Tau 예시
const zcashCeremony = {
    participants: 87,
    duration: "2 years",
    security: "1명만 정직하면 안전",
    verification: "공개 검증 가능",
};
```

---

## 사용 사례 분석

### 적합한 사용 사례

```
┌─────────────────────────────────────────────────────────────────────┐
│                    Use Case Recommendations                          │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  zkSNARKs가 적합한 경우:                                            │
│  ─────────────────────────────────────────────────────────────────  │
│  ✓ 온체인 검증 (가스 비용 민감)                                     │
│  ✓ 작은 증명 크기 필요 (대역폭 제한)                                │
│  ✓ 실시간 검증 필요                                                 │
│  ✓ Trusted Setup을 수용할 수 있는 경우                              │
│                                                                      │
│  예시:                                                               │
│  • Zcash (프라이버시 결제)                                          │
│  • Tornado Cash (믹서)                                               │
│  • zkSync Era (ZK-Rollup)                                           │
│  • Polygon zkEVM                                                     │
│                                                                      │
│  zkSTARKs가 적합한 경우:                                            │
│  ─────────────────────────────────────────────────────────────────  │
│  ✓ Trusted Setup 불가능/원치 않는 경우                              │
│  ✓ 양자 저항성 필요                                                 │
│  ✓ 대규모 계산 증명                                                 │
│  ✓ 오프체인 검증 (증명 크기 덜 중요)                                │
│  ✓ 투명성/탈중앙화 극대화                                          │
│                                                                      │
│  예시:                                                               │
│  • StarkNet (ZK-Rollup)                                             │
│  • StarkEx (거래소 증명)                                            │
│  • Cairo 프로그램 증명                                               │
│  • 대규모 계산 무결성 증명                                          │
└─────────────────────────────────────────────────────────────────────┘
```

### 하이브리드 접근법

```rust
// SNARK + STARK 하이브리드 시스템
// STARK으로 대규모 계산 증명, SNARK으로 재귀 압축

struct HybridProver {
    stark_prover: StarkProver,
    snark_prover: SnarkProver,
}

impl HybridProver {
    /// 대규모 계산을 STARK으로 증명
    fn prove_computation(&self, computation: &Computation) -> StarkProof {
        // STARK: 빠른 증명 생성, 큰 증명 크기
        self.stark_prover.prove(computation)
    }

    /// STARK 증명을 SNARK으로 재귀 압축
    fn compress_proof(&self, stark_proof: StarkProof) -> SnarkProof {
        // STARK 검증 회로를 SNARK으로 증명
        // 결과: 작은 증명 크기, 빠른 온체인 검증
        let verification_circuit = StarkVerificationCircuit::new(stark_proof);
        self.snark_prover.prove(verification_circuit)
    }

    /// 전체 파이프라인
    fn prove_and_compress(&self, computation: &Computation) -> SnarkProof {
        let stark_proof = self.prove_computation(computation);
        self.compress_proof(stark_proof)
    }
}

// 실제 사용 예: Polygon Miden
// 1. Cairo/Miden VM에서 프로그램 실행
// 2. STARK으로 실행 증명 생성
// 3. 재귀 STARK으로 여러 증명 집계
// 4. 최종적으로 SNARK (PLONK)으로 압축하여 Ethereum 제출
```

---

## 구현 라이브러리 비교

### SNARK 라이브러리

```typescript
// SNARK 라이브러리 비교
const snarkLibraries = [
    {
        name: "snarkjs",
        language: "JavaScript/WASM",
        systems: ["Groth16", "PLONK", "FFLONK"],
        curves: ["BN254", "BLS12-381"],
        features: ["브라우저 지원", "Circom 통합"],
        performance: "보통",
        production: ["Tornado Cash", "Semaphore"],
    },
    {
        name: "gnark",
        language: "Go",
        systems: ["Groth16", "PLONK"],
        curves: ["BN254", "BLS12-381", "BLS24-315"],
        features: ["최고 성능", "Go 생태계"],
        performance: "최고",
        production: ["Linea", "ConsenSys"],
    },
    {
        name: "arkworks",
        language: "Rust",
        systems: ["Groth16", "Marlin", "PLONK"],
        curves: ["다양함"],
        features: ["모듈화", "연구용"],
        performance: "높음",
        production: ["Aleo", "Mina"],
    },
    {
        name: "bellman",
        language: "Rust",
        systems: ["Groth16"],
        curves: ["BLS12-381"],
        features: ["Zcash 표준"],
        performance: "높음",
        production: ["Zcash"],
    },
    {
        name: "halo2",
        language: "Rust",
        systems: ["PLONK (IPA/KZG)"],
        curves: ["Pasta", "BN254"],
        features: ["Trusted Setup 선택적", "Lookup"],
        performance: "중간",
        production: ["Zcash Orchard", "Scroll"],
    },
];
```

### STARK 라이브러리

```typescript
// STARK 라이브러리 비교
const starkLibraries = [
    {
        name: "Stone",
        language: "C++",
        developer: "StarkWare",
        features: ["프로덕션 검증", "GPU 가속"],
        field: "Goldilocks (64-bit)",
        production: ["StarkNet", "StarkEx"],
    },
    {
        name: "Winterfell",
        language: "Rust",
        developer: "Facebook/Polygon",
        features: ["모듈화", "오픈소스"],
        field: "다양함",
        production: ["Polygon Miden"],
    },
    {
        name: "ethSTARK",
        language: "Rust/Python",
        developer: "StarkWare",
        features: ["교육용", "참조 구현"],
        field: "252-bit prime",
        production: [],
    },
    {
        name: "Plonky2",
        language: "Rust",
        developer: "Polygon",
        features: ["재귀 증명", "매우 빠름"],
        field: "Goldilocks",
        production: ["Polygon Zero"],
    },
    {
        name: "Risc0",
        language: "Rust",
        developer: "Risc Zero",
        features: ["RISC-V zkVM", "범용 계산"],
        field: "Baby Bear",
        production: ["Bonsai"],
    },
];
```

---

## 선택 가이드

### 의사결정 트리

```
┌─────────────────────────────────────────────────────────────────────┐
│                    SNARK vs STARK Decision Tree                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  Start                                                               │
│    │                                                                 │
│    ▼                                                                 │
│  온체인 검증 필요?                                                   │
│    ├─ YES ─▶ 가스 비용 민감?                                        │
│    │          ├─ YES ─▶ zkSNARKs (Groth16)                          │
│    │          │         ~300K gas                                   │
│    │          │                                                      │
│    │          └─ NO ──▶ 투명성 필요?                                │
│    │                    ├─ YES ─▶ zkSTARKs + SNARK 압축            │
│    │                    └─ NO ──▶ zkSNARKs (PLONK)                  │
│    │                                                                 │
│    └─ NO ──▶ 양자 저항성 필요?                                      │
│               ├─ YES ─▶ zkSTARKs                                    │
│               │                                                      │
│               └─ NO ──▶ 계산 크기?                                  │
│                         ├─ 작음 (<100K) ─▶ zkSNARKs                 │
│                         ├─ 중간 ─▶ 둘 다 가능                       │
│                         └─ 큼 (>10M) ─▶ zkSTARKs                    │
│                                                                      │
│  추가 고려사항:                                                      │
│  • 개발 생태계/언어 선호도                                          │
│  • 팀 경험                                                          │
│  • 장기 유지보수                                                     │
│  • 규제/컴플라이언스 요구사항                                       │
└─────────────────────────────────────────────────────────────────────┘
```

---

## 요약

| 특성 | zkSNARKs | zkSTARKs |
|------|----------|----------|
| **증명 크기** | ~200 bytes (상수) | ~40-200 KB (로그) |
| **검증 시간** | ~3ms (상수) | ~50-100ms (로그) |
| **증명 시간** | O(n log n) | O(n log² n) |
| **Trusted Setup** | 필요 | 불필요 |
| **양자 저항** | 취약 | 가능 |
| **온체인 가스** | ~300K | ~1M+ |
| **수학적 가정** | DLP, 페어링 | 해시 함수 |
| **투명성** | 낮음 | 높음 |
| **적합 사례** | 온체인 검증, 작은 회로 | 대규모 계산, 투명성 |

### 미래 전망

1. **하이브리드 시스템**: STARK 증명 + SNARK 압축
2. **Post-Quantum SNARKs**: 격자 기반 암호로 이동
3. **Hardware 가속**: GPU/FPGA/ASIC 최적화
4. **재귀 증명**: 무한 확장성 달성
5. **표준화**: 상호 운용성 증가

다음 문서에서는 MPC (Multi-Party Computation)를 다룹니다.
