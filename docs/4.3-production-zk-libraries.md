# 4.3 Production ZK Libraries

## 개요

프로덕션 환경에서 사용되는 주요 ZK 라이브러리들을 분석합니다. 각 라이브러리의 특징, API, 성능 특성을 이해하고 적절한 선택 기준을 제시합니다.

## 라이브러리 개요

### 주요 라이브러리 비교

```
┌────────────────────────────────────────────────────────────────────┐
│                    Production ZK Libraries                          │
├────────────────────────────────────────────────────────────────────┤
│                                                                     │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌───────────┐ │
│  │   gnark     │  │  bellman    │  │  arkworks   │  │   halo2   │ │
│  │   (Go)      │  │   (Rust)    │  │   (Rust)    │  │  (Rust)   │ │
│  └──────┬──────┘  └──────┬──────┘  └──────┬──────┘  └─────┬─────┘ │
│         │                │                │                │       │
│         ▼                ▼                ▼                ▼       │
│  ┌─────────────┐  ┌─────────────┐  ┌─────────────┐  ┌───────────┐ │
│  │ Groth16     │  │ Groth16     │  │ Groth16     │  │ PLONKish  │ │
│  │ PLONK       │  │             │  │ Marlin      │  │ Lookups   │ │
│  │             │  │             │  │ PLONK       │  │ Custom    │ │
│  └─────────────┘  └─────────────┘  └─────────────┘  └───────────┘ │
│                                                                     │
│  Performance:    Performance:     Performance:      Performance:   │
│  Very Fast       Fast             Fast              Moderate       │
│  (Go + ASM)      (Rust)           (Rust)            (Flexibility)  │
└────────────────────────────────────────────────────────────────────┘
```

### 선택 기준 매트릭스

| 특성 | gnark | bellman | arkworks | halo2 |
|------|-------|---------|----------|-------|
| **언어** | Go | Rust | Rust | Rust |
| **증명 시스템** | Groth16, PLONK | Groth16 | Groth16, Marlin, PLONK | PLONKish |
| **성능** | 최고 | 높음 | 높음 | 중간 |
| **유연성** | 중간 | 낮음 | 높음 | 최고 |
| **문서화** | 우수 | 보통 | 우수 | 우수 |
| **생태계** | 성장중 | 성숙 | 활발 | 활발 |
| **Trusted Setup** | 필요 | 필요 | 옵션 | 불필요 |

---

## gnark (Go)

### 특징

gnark은 ConsenSys가 개발한 Go 기반 ZK 라이브러리로, 뛰어난 성능과 깔끔한 API를 제공합니다.

```go
// gnark 설치
// go get github.com/consensys/gnark
// go get github.com/consensys/gnark-crypto
```

### 기본 회로 정의

```go
package main

import (
    "github.com/consensys/gnark/frontend"
    "github.com/consensys/gnark/frontend/cs/r1cs"
    "github.com/consensys/gnark/backend/groth16"
    "github.com/consensys/gnark-crypto/ecc"
)

// 기본 회로 구조체
type SimpleCircuit struct {
    // Public inputs (태그로 지정)
    X frontend.Variable `gnark:"x,public"`
    Y frontend.Variable `gnark:"y,public"`

    // Private inputs (기본값)
    Secret frontend.Variable
}

// Define - 회로 제약조건 정의
func (circuit *SimpleCircuit) Define(api frontend.API) error {
    // Secret * Secret = X
    square := api.Mul(circuit.Secret, circuit.Secret)
    api.AssertIsEqual(square, circuit.X)

    // Secret + 1 = Y
    sum := api.Add(circuit.Secret, 1)
    api.AssertIsEqual(sum, circuit.Y)

    return nil
}

func main() {
    // 1. 회로 컴파일
    var circuit SimpleCircuit
    ccs, err := frontend.Compile(ecc.BN254.ScalarField(), r1cs.NewBuilder, &circuit)
    if err != nil {
        panic(err)
    }

    // 2. Trusted Setup
    pk, vk, err := groth16.Setup(ccs)
    if err != nil {
        panic(err)
    }

    // 3. Witness 생성
    assignment := SimpleCircuit{
        X:      25,
        Y:      6,
        Secret: 5,
    }

    witness, err := frontend.NewWitness(&assignment, ecc.BN254.ScalarField())
    if err != nil {
        panic(err)
    }

    // 4. 증명 생성
    proof, err := groth16.Prove(ccs, pk, witness)
    if err != nil {
        panic(err)
    }

    // 5. 검증
    publicWitness, err := witness.Public()
    if err != nil {
        panic(err)
    }

    err = groth16.Verify(proof, vk, publicWitness)
    if err != nil {
        panic("verification failed")
    }

    fmt.Println("Proof verified successfully!")
}
```

### 고급 기능: Merkle Tree

```go
package main

import (
    "github.com/consensys/gnark/frontend"
    "github.com/consensys/gnark/std/hash/mimc"
)

// Merkle Tree 검증 회로
type MerkleProofCircuit struct {
    // Public
    Root     frontend.Variable   `gnark:"root,public"`

    // Private
    Leaf     frontend.Variable
    Path     [32]frontend.Variable
    PathBits [32]frontend.Variable
}

func (circuit *MerkleProofCircuit) Define(api frontend.API) error {
    // MiMC 해시 인스턴스
    hFunc, err := mimc.NewMiMC(api)
    if err != nil {
        return err
    }

    current := circuit.Leaf

    for i := 0; i < 32; i++ {
        // PathBits[i]가 0 또는 1인지 확인
        api.AssertIsBoolean(circuit.PathBits[i])

        // 조건부 스왑
        left := api.Select(circuit.PathBits[i], circuit.Path[i], current)
        right := api.Select(circuit.PathBits[i], current, circuit.Path[i])

        // 해시 계산
        hFunc.Reset()
        hFunc.Write(left, right)
        current = hFunc.Sum()
    }

    // 루트 검증
    api.AssertIsEqual(current, circuit.Root)

    return nil
}
```

### Poseidon 해시

```go
package main

import (
    "github.com/consensys/gnark/frontend"
    "github.com/consensys/gnark/std/hash/poseidon"
)

// Poseidon 기반 Commitment
type CommitmentCircuit struct {
    // Public
    Commitment frontend.Variable `gnark:"commitment,public"`

    // Private
    Secret     frontend.Variable
    Nullifier  frontend.Variable
}

func (circuit *CommitmentCircuit) Define(api frontend.API) error {
    // Poseidon 해시: H(secret, nullifier)
    h := poseidon.NewPoseidon(api)
    h.Write(circuit.Secret, circuit.Nullifier)
    computed := h.Sum()

    api.AssertIsEqual(computed, circuit.Commitment)

    return nil
}

// ECDSA 서명 검증
type ECDSACircuit struct {
    PublicKey ecdsa.PublicKey[emulated.Secp256k1Fp, emulated.Secp256k1Fr] `gnark:",public"`
    Message   emulated.Element[emulated.Secp256k1Fr]                      `gnark:",public"`
    Signature ecdsa.Signature[emulated.Secp256k1Fr]
}

func (circuit *ECDSACircuit) Define(api frontend.API) error {
    // ECDSA 검증기
    circuit.PublicKey.Verify(api, sw_emulated.GetCurveParams[emulated.Secp256k1Fp](), &circuit.Message, &circuit.Signature)
    return nil
}
```

### PLONK 사용

```go
package main

import (
    "github.com/consensys/gnark/frontend"
    "github.com/consensys/gnark/frontend/cs/scs"
    "github.com/consensys/gnark/backend/plonk"
    "github.com/consensys/gnark/test"
)

func main() {
    var circuit SimpleCircuit

    // PLONK용 SCS (Sparse Constraint System) 컴파일
    ccs, err := frontend.Compile(ecc.BN254.ScalarField(), scs.NewBuilder, &circuit)
    if err != nil {
        panic(err)
    }

    // SRS (Structured Reference String) 생성
    srs, err := test.NewKZGSRS(ccs)
    if err != nil {
        panic(err)
    }

    // PLONK Setup
    pk, vk, err := plonk.Setup(ccs, srs)
    if err != nil {
        panic(err)
    }

    // Witness
    assignment := SimpleCircuit{
        X:      25,
        Y:      6,
        Secret: 5,
    }

    witness, err := frontend.NewWitness(&assignment, ecc.BN254.ScalarField())
    if err != nil {
        panic(err)
    }

    // PLONK Prove
    proof, err := plonk.Prove(ccs, pk, witness)
    if err != nil {
        panic(err)
    }

    // PLONK Verify
    publicWitness, err := witness.Public()
    if err != nil {
        panic(err)
    }

    err = plonk.Verify(proof, vk, publicWitness)
    if err != nil {
        panic("PLONK verification failed")
    }

    fmt.Println("PLONK proof verified!")
}
```

### Solidity Verifier 생성

```go
package main

import (
    "os"

    "github.com/consensys/gnark/backend/groth16"
)

func exportVerifier() {
    // ... setup code ...

    // Solidity 검증자 생성
    f, err := os.Create("Verifier.sol")
    if err != nil {
        panic(err)
    }
    defer f.Close()

    err = vk.ExportSolidity(f)
    if err != nil {
        panic(err)
    }

    fmt.Println("Solidity verifier exported to Verifier.sol")
}
```

---

## bellman (Rust)

### 특징

bellman은 Zcash 팀이 개발한 Rust 라이브러리로, Groth16에 최적화되어 있습니다.

```toml
# Cargo.toml
[dependencies]
bellman = "0.14"
bls12_381 = "0.8"
ff = "0.13"
group = "0.13"
rand = "0.8"
```

### 기본 회로 정의

```rust
use bellman::{
    Circuit, ConstraintSystem, SynthesisError,
    groth16::{
        create_random_proof, generate_random_parameters,
        prepare_verifying_key, verify_proof,
    },
};
use bls12_381::{Bls12, Scalar};
use ff::PrimeField;
use rand::thread_rng;

// 기본 회로: x^3 + x + 5 = y
struct CubeCircuit<F: PrimeField> {
    pub x: Option<F>,
}

impl<F: PrimeField> Circuit<F> for CubeCircuit<F> {
    fn synthesize<CS: ConstraintSystem<F>>(
        self,
        cs: &mut CS,
    ) -> Result<(), SynthesisError> {
        // x 할당
        let x = cs.alloc(
            || "x",
            || self.x.ok_or(SynthesisError::AssignmentMissing)
        )?;

        // x^2 계산
        let x_squared = cs.alloc(
            || "x^2",
            || {
                let x = self.x.ok_or(SynthesisError::AssignmentMissing)?;
                Ok(x.square())
            }
        )?;

        // x * x = x^2 제약
        cs.enforce(
            || "x * x = x^2",
            |lc| lc + x,
            |lc| lc + x,
            |lc| lc + x_squared,
        );

        // x^3 계산
        let x_cubed = cs.alloc(
            || "x^3",
            || {
                let x = self.x.ok_or(SynthesisError::AssignmentMissing)?;
                Ok(x.square() * x)
            }
        )?;

        // x^2 * x = x^3 제약
        cs.enforce(
            || "x^2 * x = x^3",
            |lc| lc + x_squared,
            |lc| lc + x,
            |lc| lc + x_cubed,
        );

        // y = x^3 + x + 5 계산
        let y = cs.alloc_input(
            || "y",
            || {
                let x = self.x.ok_or(SynthesisError::AssignmentMissing)?;
                let x_cubed = x.square() * x;
                Ok(x_cubed + x + F::from(5u64))
            }
        )?;

        // x^3 + x + 5 = y 제약
        cs.enforce(
            || "x^3 + x + 5 = y",
            |lc| lc + x_cubed + x + (F::from(5u64), CS::one()),
            |lc| lc + CS::one(),
            |lc| lc + y,
        );

        Ok(())
    }
}

fn main() {
    let rng = &mut thread_rng();

    // 1. 파라미터 생성 (Trusted Setup)
    let params = {
        let c = CubeCircuit::<Scalar> { x: None };
        generate_random_parameters::<Bls12, _, _>(c, rng).unwrap()
    };

    // 2. 검증 키 준비
    let pvk = prepare_verifying_key(&params.vk);

    // 3. Witness와 함께 증명 생성
    let proof = {
        let c = CubeCircuit {
            x: Some(Scalar::from(3u64)), // x = 3
        };
        create_random_proof(c, &params, rng).unwrap()
    };

    // 4. 공개 입력 준비 (y = 3^3 + 3 + 5 = 35)
    let public_inputs = vec![Scalar::from(35u64)];

    // 5. 검증
    assert!(verify_proof(&pvk, &proof, &public_inputs).is_ok());
    println!("Proof verified successfully!");
}
```

### 복잡한 회로: SHA256

```rust
use bellman::gadgets::sha256::sha256;
use bellman::gadgets::boolean::{AllocatedBit, Boolean};

struct Sha256Circuit {
    pub preimage: Option<Vec<u8>>,
    pub hash: Option<[u8; 32]>,
}

impl<F: PrimeField> Circuit<F> for Sha256Circuit {
    fn synthesize<CS: ConstraintSystem<F>>(
        self,
        cs: &mut CS,
    ) -> Result<(), SynthesisError> {
        // Preimage를 비트로 변환
        let preimage_bits: Vec<Boolean> = self.preimage
            .as_ref()
            .map(|p| {
                p.iter()
                    .flat_map(|byte| (0..8).rev().map(move |i| (*byte >> i) & 1 == 1))
                    .collect()
            })
            .unwrap_or_else(|| vec![false; 512]); // 64 bytes

        let preimage_bits: Vec<Boolean> = preimage_bits
            .into_iter()
            .enumerate()
            .map(|(i, bit)| {
                Boolean::from(
                    AllocatedBit::alloc(
                        cs.namespace(|| format!("preimage bit {}", i)),
                        Some(bit),
                    ).unwrap()
                )
            })
            .collect();

        // SHA256 계산
        let hash_bits = sha256(
            cs.namespace(|| "sha256"),
            &preimage_bits,
        )?;

        // 해시를 공개 입력으로 노출
        for (i, bit) in hash_bits.iter().enumerate() {
            bit.inputize(cs.namespace(|| format!("hash bit {}", i)))?;
        }

        Ok(())
    }
}
```

---

## arkworks (Rust)

### 특징

arkworks는 모듈화된 Rust ZK 라이브러리 생태계로, 다양한 증명 시스템을 지원합니다.

```toml
# Cargo.toml
[dependencies]
ark-ff = "0.4"
ark-ec = "0.4"
ark-bn254 = "0.4"
ark-groth16 = "0.4"
ark-relations = "0.4"
ark-r1cs-std = "0.4"
ark-snark = "0.4"
ark-std = "0.4"
```

### R1CS 회로

```rust
use ark_ff::Field;
use ark_relations::{
    lc,
    r1cs::{ConstraintSynthesizer, ConstraintSystemRef, SynthesisError},
};
use ark_bn254::{Bn254, Fr};
use ark_groth16::Groth16;
use ark_snark::SNARK;
use ark_std::rand::thread_rng;

// x * y = z 회로
#[derive(Clone)]
struct MultiplyCircuit<F: Field> {
    pub x: Option<F>,
    pub y: Option<F>,
}

impl<F: Field> ConstraintSynthesizer<F> for MultiplyCircuit<F> {
    fn generate_constraints(
        self,
        cs: ConstraintSystemRef<F>,
    ) -> Result<(), SynthesisError> {
        // Private: x, y
        let x = cs.new_witness_variable(|| {
            self.x.ok_or(SynthesisError::AssignmentMissing)
        })?;

        let y = cs.new_witness_variable(|| {
            self.y.ok_or(SynthesisError::AssignmentMissing)
        })?;

        // Public: z = x * y
        let z_val = self.x.and_then(|x| self.y.map(|y| x * y));
        let z = cs.new_input_variable(|| {
            z_val.ok_or(SynthesisError::AssignmentMissing)
        })?;

        // 제약: x * y = z
        cs.enforce_constraint(lc!() + x, lc!() + y, lc!() + z)?;

        Ok(())
    }
}

fn main() {
    let rng = &mut thread_rng();

    // 빈 회로로 파라미터 생성
    let empty_circuit = MultiplyCircuit::<Fr> { x: None, y: None };

    // Setup
    let (pk, vk) = Groth16::<Bn254>::circuit_specific_setup(
        empty_circuit,
        rng,
    ).unwrap();

    // Witness 회로
    let circuit = MultiplyCircuit {
        x: Some(Fr::from(3u64)),
        y: Some(Fr::from(11u64)),
    };

    // 증명 생성
    let proof = Groth16::prove(&pk, circuit, rng).unwrap();

    // 공개 입력: z = 3 * 11 = 33
    let public_inputs = vec![Fr::from(33u64)];

    // 검증
    let valid = Groth16::verify(&vk, &public_inputs, &proof).unwrap();
    assert!(valid);
    println!("arkworks proof verified!");
}
```

### R1CS Gadgets

```rust
use ark_r1cs_std::{
    prelude::*,
    fields::fp::FpVar,
    eq::EqGadget,
    boolean::Boolean,
};
use ark_relations::r1cs::{ConstraintSynthesizer, ConstraintSystemRef, SynthesisError};

// Merkle Tree 검증 회로
struct MerkleTreeCircuit<F: Field> {
    pub leaf: Option<F>,
    pub root: Option<F>,
    pub path: Vec<Option<F>>,
    pub path_bits: Vec<Option<bool>>,
}

impl<F: PrimeFieldField> ConstraintSynthesizer<F> for MerkleTreeCircuit<F> {
    fn generate_constraints(
        self,
        cs: ConstraintSystemRef<F>,
    ) -> Result<(), SynthesisError> {
        // 리프 할당
        let leaf_var = FpVar::new_witness(cs.clone(), || {
            self.leaf.ok_or(SynthesisError::AssignmentMissing)
        })?;

        // 루트 (공개 입력)
        let root_var = FpVar::new_input(cs.clone(), || {
            self.root.ok_or(SynthesisError::AssignmentMissing)
        })?;

        let mut current = leaf_var;

        for (i, (sibling, bit)) in self.path.iter().zip(self.path_bits.iter()).enumerate() {
            // 형제 노드
            let sibling_var = FpVar::new_witness(cs.clone(), || {
                sibling.ok_or(SynthesisError::AssignmentMissing)
            })?;

            // 방향 비트
            let bit_var = Boolean::new_witness(cs.clone(), || {
                bit.ok_or(SynthesisError::AssignmentMissing)
            })?;

            // 조건부 스왑
            let (left, right) = bit_var.select(&sibling_var, &current)?
                .zip(bit_var.select(&current, &sibling_var)?);

            // 해시 계산 (Poseidon 사용 권장)
            current = poseidon_hash(&[left, right])?;
        }

        // 루트 일치 확인
        current.enforce_equal(&root_var)?;

        Ok(())
    }
}
```

### Marlin 증명 시스템

```rust
use ark_marlin::{Marlin, SimpleHashFiatShamirRng};
use ark_poly::univariate::DensePolynomial;
use ark_poly_commit::marlin_pc::MarlinKZG10;
use ark_bn254::Bn254;
use blake2::Blake2s256;

type MarlinInst = Marlin<
    Fr,
    MarlinKZG10<Bn254, DensePolynomial<Fr>>,
    SimpleHashFiatShamirRng<Blake2s256, ChaChaRng>,
>;

fn marlin_example() {
    let rng = &mut thread_rng();

    // Universal SRS 생성
    let universal_srs = MarlinInst::universal_setup(
        100000,  // max_degree
        50000,   // max_constraints
        100000,  // max_variables
        rng,
    ).unwrap();

    let circuit = MultiplyCircuit {
        x: Some(Fr::from(3u64)),
        y: Some(Fr::from(11u64)),
    };

    // Index (회로별 설정)
    let (index_pk, index_vk) = MarlinInst::index(
        &universal_srs,
        circuit.clone(),
    ).unwrap();

    // 증명 생성
    let proof = MarlinInst::prove(&index_pk, circuit, rng).unwrap();

    // 검증
    let public_inputs = vec![Fr::from(33u64)];
    let valid = MarlinInst::verify(&index_vk, &public_inputs, &proof, rng).unwrap();
    assert!(valid);

    println!("Marlin proof verified!");
}
```

---

## halo2 (Rust)

### 특징

halo2는 Zcash가 개발한 PLONKish 기반 라이브러리로, Trusted Setup 없이 사용 가능합니다.

```toml
# Cargo.toml
[dependencies]
halo2_proofs = "0.3"
ff = "0.13"
group = "0.13"
pasta_curves = "0.5"
```

### 기본 회로 구조

```rust
use halo2_proofs::{
    circuit::{Layouter, SimpleFloorPlanner, Value},
    plonk::{Advice, Circuit, Column, ConstraintSystem, Error, Selector},
    poly::Rotation,
};
use pasta_curves::pallas;

// 설정 구조체
#[derive(Clone, Debug)]
struct SimpleConfig {
    advice: [Column<Advice>; 2],
    selector: Selector,
}

// 회로 구조체
#[derive(Default)]
struct SimpleCircuit {
    pub a: Value<pallas::Base>,
    pub b: Value<pallas::Base>,
}

impl Circuit<pallas::Base> for SimpleCircuit {
    type Config = SimpleConfig;
    type FloorPlanner = SimpleFloorPlanner;

    fn without_witnesses(&self) -> Self {
        Self::default()
    }

    fn configure(meta: &mut ConstraintSystem<pallas::Base>) -> Self::Config {
        let advice = [meta.advice_column(), meta.advice_column()];
        let selector = meta.selector();

        // 게이트 정의: a * b = c
        meta.create_gate("mul", |meta| {
            let s = meta.query_selector(selector);
            let a = meta.query_advice(advice[0], Rotation::cur());
            let b = meta.query_advice(advice[1], Rotation::cur());
            let c = meta.query_advice(advice[0], Rotation::next());

            // s * (a * b - c) = 0
            vec![s * (a * b - c)]
        });

        SimpleConfig { advice, selector }
    }

    fn synthesize(
        &self,
        config: Self::Config,
        mut layouter: impl Layouter<pallas::Base>,
    ) -> Result<(), Error> {
        layouter.assign_region(
            || "multiply",
            |mut region| {
                config.selector.enable(&mut region, 0)?;

                // a 할당
                region.assign_advice(
                    || "a",
                    config.advice[0],
                    0,
                    || self.a,
                )?;

                // b 할당
                region.assign_advice(
                    || "b",
                    config.advice[1],
                    0,
                    || self.b,
                )?;

                // c = a * b 할당
                let c = self.a.and_then(|a| self.b.map(|b| a * b));
                region.assign_advice(
                    || "c",
                    config.advice[0],
                    1,
                    || c,
                )?;

                Ok(())
            },
        )
    }
}
```

### Chip 패턴

```rust
use halo2_proofs::{
    circuit::{AssignedCell, Chip, Layouter, Value},
    plonk::{Advice, Column, ConstraintSystem, Error, Instance, Selector},
    poly::Rotation,
};

// Field 연산 Chip
#[derive(Clone, Debug)]
struct FieldConfig {
    advice: [Column<Advice>; 2],
    s_mul: Selector,
    s_add: Selector,
    instance: Column<Instance>,
}

struct FieldChip<F: Field> {
    config: FieldConfig,
    _marker: std::marker::PhantomData<F>,
}

impl<F: Field> Chip<F> for FieldChip<F> {
    type Config = FieldConfig;
    type Loaded = ();

    fn config(&self) -> &Self::Config {
        &self.config
    }

    fn loaded(&self) -> &Self::Loaded {
        &()
    }
}

impl<F: Field> FieldChip<F> {
    fn construct(config: FieldConfig) -> Self {
        Self {
            config,
            _marker: std::marker::PhantomData,
        }
    }

    fn configure(
        meta: &mut ConstraintSystem<F>,
        advice: [Column<Advice>; 2],
        instance: Column<Instance>,
    ) -> FieldConfig {
        meta.enable_equality(advice[0]);
        meta.enable_equality(advice[1]);
        meta.enable_equality(instance);

        let s_mul = meta.selector();
        let s_add = meta.selector();

        // 곱셈 게이트
        meta.create_gate("mul", |meta| {
            let s = meta.query_selector(s_mul);
            let lhs = meta.query_advice(advice[0], Rotation::cur());
            let rhs = meta.query_advice(advice[1], Rotation::cur());
            let out = meta.query_advice(advice[0], Rotation::next());
            vec![s * (lhs * rhs - out)]
        });

        // 덧셈 게이트
        meta.create_gate("add", |meta| {
            let s = meta.query_selector(s_add);
            let lhs = meta.query_advice(advice[0], Rotation::cur());
            let rhs = meta.query_advice(advice[1], Rotation::cur());
            let out = meta.query_advice(advice[0], Rotation::next());
            vec![s * (lhs + rhs - out)]
        });

        FieldConfig {
            advice,
            s_mul,
            s_add,
            instance,
        }
    }

    // 변수 로드
    fn load_private(
        &self,
        mut layouter: impl Layouter<F>,
        value: Value<F>,
    ) -> Result<AssignedCell<F, F>, Error> {
        layouter.assign_region(
            || "load private",
            |mut region| {
                region.assign_advice(|| "private input", self.config.advice[0], 0, || value)
            },
        )
    }

    // 곱셈
    fn mul(
        &self,
        mut layouter: impl Layouter<F>,
        a: AssignedCell<F, F>,
        b: AssignedCell<F, F>,
    ) -> Result<AssignedCell<F, F>, Error> {
        layouter.assign_region(
            || "mul",
            |mut region| {
                self.config.s_mul.enable(&mut region, 0)?;

                a.copy_advice(|| "lhs", &mut region, self.config.advice[0], 0)?;
                b.copy_advice(|| "rhs", &mut region, self.config.advice[1], 0)?;

                let value = a.value().copied() * b.value();
                region.assign_advice(|| "out", self.config.advice[0], 1, || value)
            },
        )
    }

    // 덧셈
    fn add(
        &self,
        mut layouter: impl Layouter<F>,
        a: AssignedCell<F, F>,
        b: AssignedCell<F, F>,
    ) -> Result<AssignedCell<F, F>, Error> {
        layouter.assign_region(
            || "add",
            |mut region| {
                self.config.s_add.enable(&mut region, 0)?;

                a.copy_advice(|| "lhs", &mut region, self.config.advice[0], 0)?;
                b.copy_advice(|| "rhs", &mut region, self.config.advice[1], 0)?;

                let value = a.value().copied() + b.value();
                region.assign_advice(|| "out", self.config.advice[0], 1, || value)
            },
        )
    }

    // 공개 입력과 비교
    fn expose_public(
        &self,
        mut layouter: impl Layouter<F>,
        cell: AssignedCell<F, F>,
        row: usize,
    ) -> Result<(), Error> {
        layouter.constrain_instance(cell.cell(), self.config.instance, row)
    }
}
```

### Lookup Table

```rust
use halo2_proofs::plonk::{TableColumn, Expression};

#[derive(Clone, Debug)]
struct RangeCheckConfig {
    value: Column<Advice>,
    table: TableColumn,
    q_lookup: Selector,
}

impl<F: Field> RangeCheckChip<F> {
    fn configure(
        meta: &mut ConstraintSystem<F>,
        value: Column<Advice>,
    ) -> RangeCheckConfig {
        let table = meta.lookup_table_column();
        let q_lookup = meta.complex_selector();

        // Lookup 게이트: value가 테이블에 있는지 확인
        meta.lookup("range check", |meta| {
            let q = meta.query_selector(q_lookup);
            let v = meta.query_advice(value, Rotation::cur());

            vec![(q * v, table)]
        });

        RangeCheckConfig { value, table, q_lookup }
    }

    // 테이블 로드 (예: 0-255 범위)
    fn load_table(
        &self,
        mut layouter: impl Layouter<F>,
    ) -> Result<(), Error> {
        layouter.assign_table(
            || "range table",
            |mut table| {
                for i in 0..256 {
                    table.assign_cell(
                        || format!("row {}", i),
                        self.config.table,
                        i,
                        || Value::known(F::from(i as u64)),
                    )?;
                }
                Ok(())
            },
        )
    }

    // 범위 체크 적용
    fn range_check(
        &self,
        mut layouter: impl Layouter<F>,
        value: AssignedCell<F, F>,
    ) -> Result<(), Error> {
        layouter.assign_region(
            || "range check",
            |mut region| {
                self.config.q_lookup.enable(&mut region, 0)?;
                value.copy_advice(|| "value", &mut region, self.config.value, 0)?;
                Ok(())
            },
        )
    }
}
```

### 증명 및 검증

```rust
use halo2_proofs::{
    dev::MockProver,
    plonk::{create_proof, keygen_pk, keygen_vk, verify_proof},
    poly::commitment::ParamsProver,
    transcript::{Blake2bRead, Blake2bWrite, Challenge255},
};
use pasta_curves::{pallas, vesta};
use rand::rngs::OsRng;

fn prove_and_verify() {
    let k = 4; // 2^k rows

    let circuit = MyCircuit {
        a: Value::known(pallas::Base::from(3)),
        b: Value::known(pallas::Base::from(4)),
    };

    // Mock prover로 테스트
    let prover = MockProver::run(k, &circuit, vec![]).unwrap();
    prover.assert_satisfied();

    // 실제 증명
    let params = halo2_proofs::poly::ipa::commitment::ParamsIPA::<vesta::Affine>::new(k);

    let vk = keygen_vk(&params, &circuit).unwrap();
    let pk = keygen_pk(&params, vk.clone(), &circuit).unwrap();

    let mut transcript = Blake2bWrite::<_, _, Challenge255<_>>::init(vec![]);
    create_proof::<_, _, _, _, Blake2bWrite<_, _, _>, _>(
        &params,
        &pk,
        &[circuit],
        &[&[]],
        OsRng,
        &mut transcript,
    ).unwrap();

    let proof = transcript.finalize();

    // 검증
    let strategy = SingleVerifier::new(&params);
    let mut transcript = Blake2bRead::<_, _, Challenge255<_>>::init(&proof[..]);

    verify_proof(
        &params,
        &vk,
        strategy,
        &[&[]],
        &mut transcript,
    ).unwrap();

    println!("halo2 proof verified!");
}
```

---

## 라이브러리 선택 가이드

### 사용 사례별 권장

```
┌─────────────────────────────────────────────────────────────────┐
│                   라이브러리 선택 가이드                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  성능이 최우선?                                                  │
│  ├─ YES ─▶ gnark (Go)                                           │
│  │         • 가장 빠른 증명 생성                                 │
│  │         • 프로덕션 검증됨                                     │
│  │                                                               │
│  └─ NO ──▶ Trusted Setup 없이?                                  │
│            ├─ YES ─▶ halo2 (Rust)                               │
│            │         • PLONKish, IPA commitment                 │
│            │         • 높은 유연성                               │
│            │                                                     │
│            └─ NO ──▶ 모듈화 / 연구 목적?                        │
│                      ├─ YES ─▶ arkworks (Rust)                  │
│                      │         • 다양한 증명 시스템              │
│                      │         • 학술 연구에 적합                │
│                      │                                           │
│                      └─ NO ──▶ Zcash 호환?                      │
│                                ├─ YES ─▶ bellman (Rust)          │
│                                │         • Zcash 표준            │
│                                │                                 │
│                                └─ NO ──▶ gnark 또는 arkworks    │
└─────────────────────────────────────────────────────────────────┘
```

### 성능 비교 (참고용)

```typescript
// 대략적인 성능 비교 (BN254, 100K constraints 기준)
interface PerformanceMetrics {
    library: string;
    proofGeneration: string;  // 증명 생성 시간
    verification: string;      // 검증 시간
    proofSize: string;         // 증명 크기
    memoryUsage: string;       // 메모리 사용량
}

const performanceComparison: PerformanceMetrics[] = [
    {
        library: "gnark (Groth16)",
        proofGeneration: "~1.5s",
        verification: "~3ms",
        proofSize: "~200 bytes",
        memoryUsage: "~2GB",
    },
    {
        library: "bellman (Groth16)",
        proofGeneration: "~3s",
        verification: "~5ms",
        proofSize: "~200 bytes",
        memoryUsage: "~3GB",
    },
    {
        library: "arkworks (Groth16)",
        proofGeneration: "~2.5s",
        verification: "~4ms",
        proofSize: "~200 bytes",
        memoryUsage: "~2.5GB",
    },
    {
        library: "halo2 (IPA)",
        proofGeneration: "~5s",
        verification: "~50ms",
        proofSize: "~5KB",
        memoryUsage: "~4GB",
    },
];
```

---

## 요약

| 라이브러리 | 장점 | 단점 | 적합한 사용 사례 |
|-----------|------|------|-----------------|
| **gnark** | 최고 성능, 깔끔한 API | Go 언어 한정 | 프로덕션 시스템 |
| **bellman** | 성숙한 생태계, Zcash 호환 | 유연성 부족 | Zcash 기반 프로젝트 |
| **arkworks** | 모듈화, 다양한 시스템 | 학습 곡선 | 연구, 커스텀 시스템 |
| **halo2** | Trusted Setup 불필요, 유연성 | 성능 오버헤드 | 롤업, 재귀 증명 |

다음 문서에서는 성능 최적화 및 확장성 전략을 다룹니다.
