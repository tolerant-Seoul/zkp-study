# 2.1 유한체(Finite Fields), 다항식, 페어링(Pairings)

## 개요

ZKP 시스템의 모든 연산은 유한체(Finite Field) 위에서 수행된다. 이 문서에서는 ZK 개발자가 반드시 이해해야 하는 수학적 기초를 다룬다.

---

## 1. 유한체 (Finite Fields)

### 1.1 정의

유한체(Finite Field 또는 Galois Field)는 유한한 개수의 원소를 가지며, 덧셈과 곱셈이 정의되어 체(Field)의 공리를 만족하는 대수적 구조이다.

```
체(Field)의 공리:

덧셈에 대해:
- 결합법칙: (a + b) + c = a + (b + c)
- 교환법칙: a + b = b + a
- 항등원: a + 0 = a
- 역원: a + (-a) = 0

곱셈에 대해:
- 결합법칙: (a * b) * c = a * (b * c)
- 교환법칙: a * b = b * a
- 항등원: a * 1 = a
- 역원: a * a^(-1) = 1 (a != 0)

분배법칙:
- a * (b + c) = a * b + a * c
```

### 1.2 소수체 (Prime Field) F_p

가장 기본적인 유한체로, 소수 p에 대해 {0, 1, 2, ..., p-1}의 원소를 갖는다.

```
F_p = Z/pZ = {0, 1, 2, ..., p-1}

연산:
- 덧셈: (a + b) mod p
- 뺄셈: (a - b) mod p
- 곱셈: (a * b) mod p
- 나눗셈: a * b^(-1) mod p  (b의 곱셈 역원 사용)
```

#### 예시: F_7 (p = 7)

```
F_7 = {0, 1, 2, 3, 4, 5, 6}

덧셈 예시:
5 + 4 = 9 mod 7 = 2

곱셈 예시:
5 * 4 = 20 mod 7 = 6

역원 계산 (곱셈):
3의 역원 찾기: 3 * x = 1 (mod 7)
3 * 5 = 15 mod 7 = 1
따라서 3^(-1) = 5 in F_7
```

### 1.3 곱셈 역원 계산: 확장 유클리드 알고리즘

```python
def extended_gcd(a: int, b: int) -> tuple[int, int, int]:
    """
    확장 유클리드 알고리즘
    Returns (gcd, x, y) such that a*x + b*y = gcd
    """
    if a == 0:
        return b, 0, 1

    gcd, x1, y1 = extended_gcd(b % a, a)
    x = y1 - (b // a) * x1
    y = x1

    return gcd, x, y

def mod_inverse(a: int, p: int) -> int:
    """
    a의 곱셈 역원을 F_p에서 계산
    a * result = 1 (mod p)
    """
    gcd, x, _ = extended_gcd(a % p, p)
    if gcd != 1:
        raise ValueError(f"{a} has no inverse mod {p}")
    return x % p

# 예시
p = 7
a = 3
inv = mod_inverse(a, p)
print(f"{a}^(-1) = {inv} in F_{p}")  # 3^(-1) = 5 in F_7
print(f"검증: {a} * {inv} mod {p} = {(a * inv) % p}")  # 15 mod 7 = 1
```

### 1.4 페르마의 소정리를 이용한 역원 계산

```
페르마의 소정리:
p가 소수이고 gcd(a, p) = 1이면,
a^(p-1) = 1 (mod p)

따라서:
a^(-1) = a^(p-2) (mod p)
```

```python
def mod_inverse_fermat(a: int, p: int) -> int:
    """
    페르마의 소정리를 이용한 역원 계산
    a^(-1) = a^(p-2) mod p
    """
    return pow(a, p - 2, p)

# 큰 소수에서 효율적
p = 21888242871839275222246405745257275088548364400416034343698204186575808495617
a = 12345678901234567890
inv = mod_inverse_fermat(a, p)
```

### 1.5 확장체 (Extension Field) F_{p^k}

F_p 위에서 k차 기약다항식(irreducible polynomial)을 사용하여 확장한 체이다.

```
F_{p^2} 구성 예시:

기약다항식: f(x) = x^2 + 1 (F_p에서 기약)
F_{p^2}의 원소: a + b*i where a, b in F_p and i^2 = -1

연산:
(a + bi) + (c + di) = (a+c) + (b+d)i
(a + bi) * (c + di) = (ac - bd) + (ad + bc)i
```

#### BLS12-381의 확장체 타워

```
BLS12-381 확장체 구조:

F_p (베이스 필드, 381비트)
  |
  v
F_{p^2} = F_p[u] / (u^2 + 1)
  |
  v
F_{p^6} = F_{p^2}[v] / (v^3 - (u + 1))
  |
  v
F_{p^12} = F_{p^6}[w] / (w^2 - v)

이 구조는 효율적인 페어링 계산을 위해 설계됨
```

### 1.6 ZKP에서 사용되는 주요 유한체

| 곡선/시스템 | 필드 크기 (비트) | 소수 p |
|------------|-----------------|--------|
| BN254 | 254 | 21888242871839275222246405745257275088548364400416034343698204186575808495617 |
| BLS12-381 | 381 | 0x1a0111ea397fe69a4b1ba7b6434bacd764774b84f38512bf6730d2a0f6b0f6241eabfffeb153ffffb9feffffffffaaab |
| Pasta (Pallas) | 255 | 0x40000000000000000000000000000000224698fc094cf91b992d30ed00000001 |
| Pasta (Vesta) | 255 | 0x40000000000000000000000000000000224698fc0994a8dd8c46eb2100000001 |

---

## 2. 다항식 (Polynomials)

### 2.1 유한체 위의 다항식

```
F_p[X]에서의 다항식:

P(X) = a_0 + a_1*X + a_2*X^2 + ... + a_n*X^n

여기서 모든 계수 a_i in F_p
```

### 2.2 다항식 기본 연산

```python
class Polynomial:
    """유한체 F_p 위의 다항식"""

    def __init__(self, coeffs: list[int], p: int):
        """
        coeffs: [a_0, a_1, a_2, ...] for a_0 + a_1*X + a_2*X^2 + ...
        p: 소수 (체의 크기)
        """
        self.coeffs = [c % p for c in coeffs]
        self.p = p
        self._normalize()

    def _normalize(self):
        """최고차 계수가 0인 항 제거"""
        while len(self.coeffs) > 1 and self.coeffs[-1] == 0:
            self.coeffs.pop()

    def degree(self) -> int:
        """다항식의 차수"""
        return len(self.coeffs) - 1

    def evaluate(self, x: int) -> int:
        """P(x) 계산 - Horner's method"""
        result = 0
        for coeff in reversed(self.coeffs):
            result = (result * x + coeff) % self.p
        return result

    def __add__(self, other: 'Polynomial') -> 'Polynomial':
        """다항식 덧셈"""
        max_len = max(len(self.coeffs), len(other.coeffs))
        result = []
        for i in range(max_len):
            a = self.coeffs[i] if i < len(self.coeffs) else 0
            b = other.coeffs[i] if i < len(other.coeffs) else 0
            result.append((a + b) % self.p)
        return Polynomial(result, self.p)

    def __mul__(self, other: 'Polynomial') -> 'Polynomial':
        """다항식 곱셈"""
        result = [0] * (len(self.coeffs) + len(other.coeffs) - 1)
        for i, a in enumerate(self.coeffs):
            for j, b in enumerate(other.coeffs):
                result[i + j] = (result[i + j] + a * b) % self.p
        return Polynomial(result, self.p)

    def __repr__(self):
        terms = []
        for i, c in enumerate(self.coeffs):
            if c != 0:
                if i == 0:
                    terms.append(str(c))
                elif i == 1:
                    terms.append(f"{c}*X")
                else:
                    terms.append(f"{c}*X^{i}")
        return " + ".join(terms) if terms else "0"
```

### 2.3 라그랑주 보간법 (Lagrange Interpolation)

n+1개의 점 {(x_0, y_0), (x_1, y_1), ..., (x_n, y_n)}을 지나는 유일한 n차 다항식을 구한다.

```
라그랑주 보간 공식:

P(X) = sum_{i=0}^{n} y_i * L_i(X)

여기서 라그랑주 기저 다항식:
L_i(X) = product_{j!=i} (X - x_j) / (x_i - x_j)
```

```python
def lagrange_interpolation(points: list[tuple[int, int]], p: int) -> Polynomial:
    """
    라그랑주 보간법으로 다항식 구성
    points: [(x_0, y_0), (x_1, y_1), ...]
    p: 소수
    """
    n = len(points)
    result_coeffs = [0] * n

    for i, (xi, yi) in enumerate(points):
        # L_i(X) 계산
        numerator = Polynomial([1], p)  # 1
        denominator = 1

        for j, (xj, _) in enumerate(points):
            if i != j:
                # numerator *= (X - xj)
                numerator = numerator * Polynomial([-xj % p, 1], p)
                # denominator *= (xi - xj)
                denominator = (denominator * (xi - xj)) % p

        # L_i(X) = numerator / denominator
        inv_denom = mod_inverse(denominator, p)

        # result += yi * L_i(X)
        for k, c in enumerate(numerator.coeffs):
            result_coeffs[k] = (result_coeffs[k] + yi * c * inv_denom) % p

    return Polynomial(result_coeffs, p)

# 예시: F_17에서 점 (1, 3), (2, 5), (4, 11)을 지나는 다항식
p = 17
points = [(1, 3), (2, 5), (4, 11)]
poly = lagrange_interpolation(points, p)
print(f"P(X) = {poly}")

# 검증
for x, y in points:
    assert poly.evaluate(x) == y, f"P({x}) should be {y}"
```

### 2.4 다항식 나눗셈과 나머지

```
다항식 나눗셈:

A(X)를 B(X)로 나눌 때:
A(X) = Q(X) * B(X) + R(X)

여기서:
- Q(X): 몫 (quotient)
- R(X): 나머지 (remainder), deg(R) < deg(B)
```

```python
def poly_divmod(dividend: Polynomial, divisor: Polynomial) -> tuple[Polynomial, Polynomial]:
    """
    다항식 나눗셈: dividend = quotient * divisor + remainder
    """
    p = dividend.p

    if divisor.degree() == 0 and divisor.coeffs[0] == 0:
        raise ValueError("Division by zero polynomial")

    # 피제수 복사
    remainder = list(dividend.coeffs)
    divisor_coeffs = divisor.coeffs
    divisor_lead = divisor_coeffs[-1]
    divisor_deg = len(divisor_coeffs) - 1

    quotient = [0] * (len(remainder) - divisor_deg)

    for i in range(len(remainder) - divisor_deg, -1, -1):
        if i + divisor_deg < len(remainder):
            # 최고차항의 계수 나눗셈
            coeff = (remainder[i + divisor_deg] * mod_inverse(divisor_lead, p)) % p
            quotient[i] = coeff

            # 빼기
            for j in range(divisor_deg + 1):
                remainder[i + j] = (remainder[i + j] - coeff * divisor_coeffs[j]) % p

    return Polynomial(quotient, p), Polynomial(remainder[:divisor_deg], p)
```

### 2.5 Vanishing Polynomial

특정 점들에서 0이 되는 다항식으로, ZKP에서 핵심적인 역할을 한다.

```
Vanishing Polynomial 정의:

점 집합 H = {h_1, h_2, ..., h_n}에 대해:
Z_H(X) = (X - h_1)(X - h_2)...(X - h_n)

속성:
- Z_H(h_i) = 0 for all h_i in H
- deg(Z_H) = |H| = n
```

```python
def vanishing_polynomial(domain: list[int], p: int) -> Polynomial:
    """
    domain의 모든 점에서 0이 되는 다항식 생성
    Z_H(X) = (X - h_1)(X - h_2)...(X - h_n)
    """
    result = Polynomial([1], p)  # 1
    for h in domain:
        # (X - h) 곱하기
        result = result * Polynomial([-h % p, 1], p)
    return result

# 예시: H = {1, 2, 3}
H = [1, 2, 3]
p = 17
Z_H = vanishing_polynomial(H, p)
print(f"Z_H(X) = {Z_H}")

# 검증: H의 모든 점에서 0
for h in H:
    assert Z_H.evaluate(h) == 0
```

### 2.6 FFT와 NTT (Number Theoretic Transform)

대규모 다항식 연산의 효율성을 위해 FFT/NTT를 사용한다.

```
NTT의 핵심 아이디어:

일반 다항식 곱셈: O(n^2)
NTT 기반 곱셈: O(n log n)

과정:
1. 계수 표현 -> 점값 표현 (NTT)
2. 점별 곱셈 (O(n))
3. 점값 표현 -> 계수 표현 (INTT)
```

```python
def ntt(coeffs: list[int], p: int, omega: int) -> list[int]:
    """
    Number Theoretic Transform
    omega: n-th primitive root of unity in F_p
    """
    n = len(coeffs)
    if n == 1:
        return coeffs

    # 짝수/홀수 인덱스 분리
    even = ntt(coeffs[0::2], p, pow(omega, 2, p))
    odd = ntt(coeffs[1::2], p, pow(omega, 2, p))

    result = [0] * n
    w = 1
    for i in range(n // 2):
        result[i] = (even[i] + w * odd[i]) % p
        result[i + n // 2] = (even[i] - w * odd[i]) % p
        w = (w * omega) % p

    return result

def find_primitive_root(n: int, p: int) -> int:
    """
    n-th primitive root of unity in F_p 찾기
    조건: n | (p - 1)
    """
    # p-1의 primitive root g 찾기
    g = 2
    while pow(g, (p - 1) // 2, p) == 1:
        g += 1

    # n-th root of unity
    return pow(g, (p - 1) // n, p)
```

---

## 3. 타원곡선 (Elliptic Curves)

### 3.1 정의

유한체 F_p 위의 타원곡선은 다음 방정식을 만족하는 점들의 집합이다.

```
Short Weierstrass Form:
y^2 = x^3 + ax + b (mod p)

조건: 4a^3 + 27b^2 != 0 (mod p)  (특이점 없음)
```

### 3.2 타원곡선 위의 점 연산

```
점 덧셈 공식 (P != Q):

P = (x1, y1), Q = (x2, y2)
P + Q = (x3, y3)

lambda = (y2 - y1) / (x2 - x1)
x3 = lambda^2 - x1 - x2
y3 = lambda * (x1 - x3) - y1


점 더블링 (P = Q):

lambda = (3*x1^2 + a) / (2*y1)
x3 = lambda^2 - 2*x1
y3 = lambda * (x1 - x3) - y1


항등원:
O (무한원점, point at infinity)
P + O = P
```

```python
class EllipticCurve:
    """F_p 위의 타원곡선 y^2 = x^3 + ax + b"""

    def __init__(self, a: int, b: int, p: int):
        self.a = a % p
        self.b = b % p
        self.p = p

        # 특이점 체크
        if (4 * a**3 + 27 * b**2) % p == 0:
            raise ValueError("Singular curve")

    def is_on_curve(self, point: tuple) -> bool:
        """점이 곡선 위에 있는지 확인"""
        if point is None:  # 무한원점
            return True
        x, y = point
        lhs = (y * y) % self.p
        rhs = (x**3 + self.a * x + self.b) % self.p
        return lhs == rhs

    def add(self, P: tuple, Q: tuple) -> tuple:
        """점 덧셈 P + Q"""
        if P is None:
            return Q
        if Q is None:
            return P

        x1, y1 = P
        x2, y2 = Q

        if x1 == x2 and y1 == (-y2) % self.p:
            return None  # P + (-P) = O

        if P == Q:
            # Point doubling
            if y1 == 0:
                return None
            lam = (3 * x1**2 + self.a) * mod_inverse(2 * y1, self.p) % self.p
        else:
            # Point addition
            lam = (y2 - y1) * mod_inverse(x2 - x1, self.p) % self.p

        x3 = (lam**2 - x1 - x2) % self.p
        y3 = (lam * (x1 - x3) - y1) % self.p

        return (x3, y3)

    def scalar_mult(self, k: int, P: tuple) -> tuple:
        """스칼라 곱셈 k * P (double-and-add)"""
        if k == 0 or P is None:
            return None

        if k < 0:
            k = -k
            P = (P[0], (-P[1]) % self.p)

        result = None
        addend = P

        while k:
            if k & 1:
                result = self.add(result, addend)
            addend = self.add(addend, addend)
            k >>= 1

        return result
```

### 3.3 ZKP에서 사용되는 주요 타원곡선

```
BN254 (alt_bn128):
- 방정식: y^2 = x^3 + 3
- 페어링 지원
- Ethereum precompile 지원
- 보안: ~100비트 (페어링 보안)

BLS12-381:
- 방정식: y^2 = x^3 + 4
- 페어링 지원
- 더 높은 보안: ~128비트
- Ethereum 2.0에서 사용

Grumpkin (BN254와 사이클):
- 방정식: y^2 = x^3 - 17
- 페어링 미지원
- BN254와 곡선 사이클 형성
- Aztec에서 사용

Pasta (Pallas/Vesta):
- 곡선 사이클
- 페어링 미지원
- Halo2, Mina에서 사용
```

---

## 4. 페어링 (Pairings)

### 4.1 Bilinear Pairing 정의

페어링은 두 개의 타원곡선 그룹에서 하나의 곱셈 그룹으로 가는 특별한 맵이다.

```
페어링 함수:
e: G_1 x G_2 -> G_T

여기서:
- G_1, G_2: 타원곡선 위의 점 그룹 (덧셈 연산)
- G_T: 유한체의 곱셈 그룹

모두 동일한 소수 차수 r을 가짐
```

### 4.2 Bilinearity 속성

페어링의 가장 중요한 속성이다.

```
Bilinearity:
e(aP, bQ) = e(P, Q)^(ab)

또는 동등하게:
e(P + P', Q) = e(P, Q) * e(P', Q)
e(P, Q + Q') = e(P, Q) * e(P, Q')
```

### 4.3 페어링의 응용

```
1. 서명 검증 (BLS 서명):

   서명 생성: sigma = sk * H(m)  (sk: 비밀키, H: 해시를 곡선 점으로)
   공개키: pk = sk * G

   검증: e(sigma, G) == e(H(m), pk)

   증명:
   e(sk * H(m), G) = e(H(m), G)^sk = e(H(m), sk * G) = e(H(m), pk)


2. Groth16 증명 검증:

   e(A, B) = e(alpha, beta) * e(L, gamma) * e(C, delta)

   하나의 페어링 방정식으로 전체 증명 검증
```

### 4.4 페어링 계산 (개념적)

실제 페어링 계산은 매우 복잡하지만, 개념적 이해를 위한 설명이다.

```
Tate/Ate 페어링의 핵심 단계:

1. Miller Loop:
   - 특정 점에서 함수 f를 계산
   - Double-and-add 방식으로 반복

2. Final Exponentiation:
   - Miller loop 결과를 G_T로 매핑
   - (p^k - 1) / r 승 계산
```

```python
# 페어링 사용 예시 (라이브러리 사용)
# 실제로는 py_ecc 같은 라이브러리 사용

from py_ecc.bn128 import (
    G1, G2,
    multiply, add,
    pairing,
    curve_order
)

# G1, G2는 생성원
# a, b는 스칼라

a = 1234567890
b = 9876543210

# 페어링 bilinearity 검증
aG1 = multiply(G1, a)
bG2 = multiply(G2, b)
abG1 = multiply(G1, (a * b) % curve_order)

# e(aG1, bG2) should equal e(G1, G2)^(ab)
e1 = pairing(bG2, aG1)
e2 = pairing(G2, abG1)  # e(abG1, G2)

# 두 값이 같아야 함
assert e1 == e2, "Bilinearity check failed"
```

### 4.5 Type I, II, III 페어링

```
Type I (Symmetric):
- G_1 = G_2
- e: G x G -> G_T
- 예: Supersingular curves

Type II:
- G_1 != G_2
- 효율적인 동형사상 phi: G_2 -> G_1 존재
- 예: 일부 MNT curves

Type III (Asymmetric):
- G_1 != G_2
- G_1과 G_2 사이에 효율적인 동형사상 없음
- 가장 효율적
- 예: BN curves, BLS curves
```

### 4.6 페어링 기반 암호의 보안

```
보안 가정:

1. Decisional Bilinear Diffie-Hellman (DBDH):
   (g, g^a, g^b, g^c, Z)에서 Z = e(g,g)^(abc)인지
   Z = random인지 구분하기 어려움

2. Knowledge of Exponent Assumption (KEA):
   (g, g^a, h, h^a)가 주어졌을 때,
   A가 (C, C^a)를 출력하면, A는 c such that C = g^c를 알고 있음

이러한 가정들이 zkSNARK의 soundness를 보장
```

---

## 5. 다항식 커밋먼트 (Polynomial Commitment)

### 5.1 개념

다항식 커밋먼트는 다항식에 "약속"하고, 나중에 특정 점에서의 값을 증명하는 방식이다.

```
Polynomial Commitment Scheme:

1. Commit(P(X)) -> C
   - 다항식 P에 대한 커밋먼트 C 생성
   - C만으로 P를 복원할 수 없음 (hiding)
   - 같은 C에 대해 다른 P를 열 수 없음 (binding)

2. Open(P, z) -> (y, proof)
   - z에서의 값 y = P(z)와 증명 생성

3. Verify(C, z, y, proof) -> bool
   - 커밋먼트 C에 대해 P(z) = y임을 검증
```

### 5.2 KZG Commitment (Kate Commitment)

가장 널리 사용되는 다항식 커밋먼트 스킴이다.

```
KZG Setup (Trusted Setup):

비밀 tau를 선택하고 다음을 계산하여 공개:
[1]_1, [tau]_1, [tau^2]_1, ..., [tau^n]_1
[1]_2, [tau]_2

여기서 [x]_1 = x * G_1, [x]_2 = x * G_2
(tau는 이후 폐기되어야 함 - toxic waste)


KZG Commit:

P(X) = a_0 + a_1*X + ... + a_n*X^n

C = [P(tau)]_1 = a_0*[1]_1 + a_1*[tau]_1 + ... + a_n*[tau^n]_1


KZG Open:

P(z) = y를 증명하려면:
Q(X) = (P(X) - y) / (X - z)  (나머지가 0이어야 함)

pi = [Q(tau)]_1  (증명)


KZG Verify:

e(C - [y]_1, [1]_2) == e(pi, [tau]_2 - [z]_2)

이는 다음과 동치:
e([P(tau) - y]_1, [1]_2) == e([Q(tau)]_1, [tau - z]_2)
e([P(tau) - y], [1]) == e([Q(tau)], [tau - z])
P(tau) - y == Q(tau) * (tau - z)
```

```python
# KZG 커밋먼트 개념적 구현

class KZGCommitment:
    def __init__(self, srs_g1: list, srs_g2: tuple, curve):
        """
        srs_g1: [G1, tau*G1, tau^2*G1, ...]
        srs_g2: (G2, tau*G2)
        """
        self.srs_g1 = srs_g1
        self.srs_g2 = srs_g2
        self.curve = curve

    def commit(self, poly_coeffs: list) -> 'G1Point':
        """다항식 커밋먼트 생성"""
        commitment = None
        for i, coeff in enumerate(poly_coeffs):
            term = self.curve.scalar_mult(coeff, self.srs_g1[i])
            commitment = self.curve.add(commitment, term)
        return commitment

    def open(self, poly_coeffs: list, z: int) -> tuple:
        """
        P(z) = y와 증명 pi 생성
        """
        # y = P(z) 계산
        y = evaluate_polynomial(poly_coeffs, z)

        # Q(X) = (P(X) - y) / (X - z)
        quotient_coeffs = polynomial_division(
            poly_coeffs,
            [-z, 1],  # X - z
            subtract_constant=y
        )

        # pi = Commit(Q)
        pi = self.commit(quotient_coeffs)

        return y, pi

    def verify(self, commitment, z: int, y: int, pi) -> bool:
        """검증: e(C - [y], G2) == e(pi, [tau - z])"""
        # 실제 구현은 페어링 라이브러리 사용
        pass
```

### 5.3 다른 Polynomial Commitment Schemes

| 스킴 | Setup | 증명 크기 | 검증 시간 | 특징 |
|------|-------|----------|----------|------|
| KZG | Trusted | O(1) | O(1) 페어링 | 가장 간결 |
| FRI (STARK) | Transparent | O(log^2 n) | O(log^2 n) | 양자 내성 |
| Bulletproofs | Transparent | O(log n) | O(n) | 범용적 |
| DARK | Transparent | O(log n) | O(log n) | 숨겨진 차수 가정 |

---

## 6. 실습 예제

### 6.1 유한체 연산 실습

```python
# F_p에서의 기본 연산 실습

p = 21888242871839275222246405745257275088548364400416034343698204186575808495617  # BN254 scalar field

class FieldElement:
    def __init__(self, value: int, p: int = p):
        self.value = value % p
        self.p = p

    def __add__(self, other):
        return FieldElement((self.value + other.value) % self.p)

    def __sub__(self, other):
        return FieldElement((self.value - other.value) % self.p)

    def __mul__(self, other):
        return FieldElement((self.value * other.value) % self.p)

    def __truediv__(self, other):
        return self * other.inv()

    def __pow__(self, exp):
        return FieldElement(pow(self.value, exp, self.p))

    def inv(self):
        return FieldElement(pow(self.value, self.p - 2, self.p))

    def __eq__(self, other):
        return self.value == other.value

    def __repr__(self):
        return f"F({self.value})"

# 사용 예시
a = FieldElement(12345)
b = FieldElement(67890)

print(f"a + b = {a + b}")
print(f"a * b = {a * b}")
print(f"a / b = {a / b}")
print(f"a^(-1) = {a.inv()}")
print(f"검증: a * a^(-1) = {a * a.inv()}")
```

---

## 7. 정리

```
ZKP 수학 기초 핵심 요약:

1. 유한체 (Finite Fields)
   - 모든 ZKP 연산의 기반
   - F_p: 모듈러 연산
   - 역원 계산: 확장 유클리드 or 페르마 소정리

2. 다항식
   - 라그랑주 보간: 점에서 다항식 복원
   - Vanishing Polynomial: 특정 점에서 0
   - NTT: 효율적인 다항식 연산

3. 타원곡선
   - 점 덧셈과 스칼라 곱셈
   - 이산로그 문제의 어려움이 보안 기반

4. 페어링
   - Bilinearity: e(aP, bQ) = e(P,Q)^(ab)
   - zkSNARK 검증의 핵심

5. 다항식 커밋먼트
   - KZG: 가장 간결한 증명
   - Trusted Setup 필요
```

---

## 참고 자료

### 필수 읽기
- "Pairings for Beginners" - Craig Costello
- "Why and How zk-SNARK Works" - Maksym Petkus

### 구현 라이브러리
- arkworks (Rust): https://github.com/arkworks-rs
- gnark (Go): https://github.com/ConsenSys/gnark
- py_ecc (Python): https://github.com/ethereum/py_ecc
- blst (C): https://github.com/supranational/blst

### 온라인 자료
- https://vitalik.ca/general/2017/01/14/exploring_ecp.html
- https://www.zkdocs.com
