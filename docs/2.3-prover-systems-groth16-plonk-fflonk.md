# 2.3 Prover Systems: Groth16, PLONK, FFLONK

## 개요

zkSNARK 시스템의 핵심은 Prover와 Verifier 간의 효율적인 증명 프로토콜이다. 이 문서에서는 실무에서 가장 널리 사용되는 세 가지 증명 시스템인 Groth16, PLONK, FFLONK의 구조와 동작 원리를 상세히 분석한다.

### 증명 시스템 비교 요약

| 특성 | Groth16 | PLONK | FFLONK |
|------|---------|-------|--------|
| Setup | Circuit-specific | Universal | Universal |
| Proof Size | 3 G1 + 3 G2 (~192B) | ~400B | ~256B |
| Verification | 3 pairings | ~10 G1 ops + 2 pairings | 2 pairings |
| Prover Time | O(n log n) | O(n log n) | O(n log n) |
| Trusted Setup | Required | Required (Universal) | Required (Universal) |
| Lookup Tables | No | Yes (PLONK+Plookup) | Yes |

---

## 1. Groth16

### 1.1 개요

Groth16은 2016년 Jens Groth가 제안한 증명 시스템으로, 현재까지 가장 효율적인 proof size와 verification time을 제공한다. Zcash, Filecoin 등 많은 프로젝트에서 채택되었다.

### 1.2 시스템 구성 요소

#### 1.2.1 QAP (Quadratic Arithmetic Program)

R1CS에서 QAP로의 변환은 Groth16의 핵심이다.

```
R1CS: (A, B, C) 행렬과 witness w에 대해
      (A * w) ⊙ (B * w) = C * w

QAP: 다항식 {u_i(x), v_i(x), w_i(x)}로 변환
      A(x) = Σ a_i * u_i(x)
      B(x) = Σ a_i * v_i(x)
      C(x) = Σ a_i * w_i(x)

      A(x) * B(x) - C(x) = H(x) * Z(x)

여기서:
- a_i: witness의 i번째 요소
- Z(x) = Π(x - ω^i): vanishing polynomial
- H(x): quotient polynomial
```

#### 1.2.2 Setup Phase (Trusted Setup)

```
Powers of Tau Ceremony:

1. Toxic Waste 생성
   τ, α, β, γ, δ ← 랜덤 샘플링 (이후 파기되어야 함)

2. CRS (Common Reference String) 생성

   Proving Key (pk):
   - {[τ^i]_1}_{i=0}^{n-1}: G1에서의 tau powers
   - {[τ^i]_2}_{i=0}^{n-1}: G2에서의 tau powers
   - {[α * τ^i]_1}: alpha shifted powers
   - {[β * τ^i]_1}: beta shifted powers
   - {[(β * u_i(τ) + α * v_i(τ) + w_i(τ)) / γ]_1}: gamma elements
   - {[(β * u_i(τ) + α * v_i(τ) + w_i(τ)) / δ]_1}: delta elements

   Verification Key (vk):
   - [α]_1, [β]_2, [γ]_2, [δ]_2
   - {[(β * u_i(τ) + α * v_i(τ) + w_i(τ)) / γ]_1}: public input terms

주의: τ, α, β, γ, δ가 노출되면 가짜 증명 생성 가능
     → Multi-Party Computation (MPC)으로 안전성 확보
```

#### 1.2.3 Proving Phase

```
Prover 알고리즘:

입력: pk, public input x, private witness w

1. QAP 다항식 계산
   A(τ) = Σ a_i * u_i(τ)
   B(τ) = Σ a_i * v_i(τ)
   C(τ) = Σ a_i * w_i(τ)

2. Quotient 다항식 계산
   H(x) = (A(x) * B(x) - C(x)) / Z(x)

3. 랜덤 블라인딩 팩터
   r, s ← 랜덤 샘플링

4. Proof 요소 계산
   [A]_1 = [α]_1 + Σ a_i * [u_i(τ)]_1 + r * [δ]_1
   [B]_2 = [β]_2 + Σ a_i * [v_i(τ)]_2 + s * [δ]_2
   [B]_1 = [β]_1 + Σ a_i * [v_i(τ)]_1 + s * [δ]_1
   [C]_1 = Σ a_i * [(β*u_i(τ) + α*v_i(τ) + w_i(τ))/δ]_1
          + [H(τ) * Z(τ) / δ]_1 + s * [A]_1 + r * [B]_1 - r * s * [δ]_1

5. Proof 출력
   π = ([A]_1, [B]_2, [C]_1)
```

#### 1.2.4 Verification Phase

```
Verifier 알고리즘:

입력: vk, public input x, proof π = ([A]_1, [B]_2, [C]_1)

1. Public Input 항 계산
   [PI]_1 = Σ x_i * [(β*u_i(τ) + α*v_i(τ) + w_i(τ))/γ]_1

2. Pairing 검증
   e([A]_1, [B]_2) = e([α]_1, [β]_2) * e([PI]_1, [γ]_2) * e([C]_1, [δ]_2)

3. 검증 결과
   등식이 성립하면 Accept, 아니면 Reject
```

### 1.3 수학적 정확성 증명

```
Pairing 등식 전개:

좌변: e([A]_1, [B]_2)
    = e([α + A(τ) + r*δ], [β + B(τ) + s*δ])

우변: e([α], [β]) * e([PI], [γ]) * e([C], [δ])

전개하면:
e(α, β) + e(α, B(τ)) + e(A(τ), β) + e(A(τ), B(τ)) + ...
= e(α, β) + e(public_terms/γ, γ) + e(private_terms/δ + H*Z/δ, δ)

양변이 같으려면:
A(τ) * B(τ) - C(τ) = H(τ) * Z(τ)

이는 QAP 조건과 동일 → R1CS 만족 증명
```

### 1.4 Python 구현 (개념적)

```python
from dataclasses import dataclass
from typing import List, Tuple
import hashlib

@dataclass
class G1Point:
    """BN254 G1 점"""
    x: int
    y: int

@dataclass
class G2Point:
    """BN254 G2 점 (extension field 위)"""
    x: Tuple[int, int]  # a + bi 형태
    y: Tuple[int, int]

@dataclass
class Groth16ProvingKey:
    """Groth16 Proving Key"""
    # G1 elements
    alpha_g1: G1Point
    beta_g1: G1Point
    delta_g1: G1Point
    tau_powers_g1: List[G1Point]  # [τ^0, τ^1, ..., τ^n]

    # G2 elements
    beta_g2: G2Point
    delta_g2: G2Point
    tau_powers_g2: List[G2Point]

    # Circuit-specific elements
    l_g1: List[G1Point]  # [(β*u_i + α*v_i + w_i)/δ] for private inputs
    h_g1: List[G1Point]  # [τ^i * Z(τ)/δ] for H polynomial

@dataclass
class Groth16VerifyingKey:
    """Groth16 Verification Key"""
    alpha_g1: G1Point
    beta_g2: G2Point
    gamma_g2: G2Point
    delta_g2: G2Point
    ic: List[G1Point]  # [(β*u_i + α*v_i + w_i)/γ] for public inputs

@dataclass
class Groth16Proof:
    """Groth16 증명"""
    a: G1Point   # [A]_1
    b: G2Point   # [B]_2
    c: G1Point   # [C]_1

class Groth16Prover:
    """Groth16 Prover 구현"""

    def __init__(self, pk: Groth16ProvingKey):
        self.pk = pk

    def prove(self,
              public_inputs: List[int],
              private_witness: List[int],
              qap_coeffs: 'QAPCoefficients') -> Groth16Proof:
        """
        Groth16 증명 생성

        Args:
            public_inputs: 공개 입력값
            private_witness: 비공개 witness
            qap_coeffs: QAP 다항식 계수
        """
        # 전체 witness
        witness = [1] + public_inputs + private_witness

        # 1. QAP 다항식 평가
        a_poly = self._evaluate_qap_a(witness, qap_coeffs)
        b_poly = self._evaluate_qap_b(witness, qap_coeffs)
        c_poly = self._evaluate_qap_c(witness, qap_coeffs)

        # 2. H(x) 계산: (A*B - C) / Z
        h_poly = self._compute_h(a_poly, b_poly, c_poly, qap_coeffs.z_poly)

        # 3. 랜덤 블라인딩
        r = self._random_scalar()
        s = self._random_scalar()

        # 4. Proof 요소 계산
        proof_a = self._compute_proof_a(witness, r, qap_coeffs)
        proof_b = self._compute_proof_b(witness, s, qap_coeffs)
        proof_c = self._compute_proof_c(witness, h_poly, r, s, qap_coeffs)

        return Groth16Proof(a=proof_a, b=proof_b, c=proof_c)

    def _compute_proof_a(self, witness: List[int], r: int,
                         qap_coeffs: 'QAPCoefficients') -> G1Point:
        """[A]_1 = [α]_1 + Σ w_i * [u_i(τ)]_1 + r * [δ]_1"""
        result = self.pk.alpha_g1

        for i, w_i in enumerate(witness):
            # u_i(τ) at G1
            u_i_g1 = qap_coeffs.u_at_tau_g1[i]
            result = self._g1_add(result, self._g1_scalar_mul(u_i_g1, w_i))

        # r * δ
        result = self._g1_add(result, self._g1_scalar_mul(self.pk.delta_g1, r))

        return result

    def _compute_h(self, a: 'Polynomial', b: 'Polynomial',
                   c: 'Polynomial', z: 'Polynomial') -> 'Polynomial':
        """H(x) = (A(x) * B(x) - C(x)) / Z(x)"""
        # A * B
        ab = a.multiply(b)
        # A * B - C
        ab_minus_c = ab.subtract(c)
        # (A * B - C) / Z
        h, remainder = ab_minus_c.divide(z)

        assert remainder.is_zero(), "Invalid witness: R1CS not satisfied"

        return h

    # 타원 곡선 연산 (실제로는 라이브러리 사용)
    def _g1_add(self, p1: G1Point, p2: G1Point) -> G1Point:
        """G1 점 덧셈"""
        # 실제 구현은 복잡한 타원 곡선 연산
        pass

    def _g1_scalar_mul(self, p: G1Point, s: int) -> G1Point:
        """G1 스칼라 곱"""
        pass

    def _random_scalar(self) -> int:
        """암호학적으로 안전한 랜덤 스칼라"""
        pass


class Groth16Verifier:
    """Groth16 Verifier 구현"""

    def __init__(self, vk: Groth16VerifyingKey):
        self.vk = vk

    def verify(self, public_inputs: List[int], proof: Groth16Proof) -> bool:
        """
        Groth16 증명 검증

        Args:
            public_inputs: 공개 입력값
            proof: Groth16 증명

        Returns:
            True if valid, False otherwise
        """
        # 1. Public Input 항 계산
        # [PI]_1 = Σ x_i * ic[i+1]
        pi = self.vk.ic[0]  # ic[0] = constant term

        for i, x_i in enumerate(public_inputs):
            ic_term = self._g1_scalar_mul(self.vk.ic[i + 1], x_i)
            pi = self._g1_add(pi, ic_term)

        # 2. Pairing 검증
        # e(A, B) == e(α, β) * e(PI, γ) * e(C, δ)

        lhs = self._pairing(proof.a, proof.b)

        rhs = self._pairing(self.vk.alpha_g1, self.vk.beta_g2)
        rhs = self._gt_mul(rhs, self._pairing(pi, self.vk.gamma_g2))
        rhs = self._gt_mul(rhs, self._pairing(proof.c, self.vk.delta_g2))

        return lhs == rhs

    def _pairing(self, g1: G1Point, g2: G2Point):
        """Bilinear pairing: e(G1, G2) -> GT"""
        # 실제로는 Miller loop + final exponentiation
        pass

    def _gt_mul(self, a, b):
        """GT 그룹에서의 곱셈"""
        pass

    def _g1_add(self, p1: G1Point, p2: G1Point) -> G1Point:
        pass

    def _g1_scalar_mul(self, p: G1Point, s: int) -> G1Point:
        pass
```

### 1.5 Trusted Setup의 보안

```
Multi-Party Computation (MPC) Setup:

Phase 1: Powers of Tau
1. 참가자 P1이 τ_1 선택, [τ_1^i] 계산
2. 참가자 P2가 τ_2 선택, [τ_1^i * τ_2^i] 계산
3. ... N명 참가
4. 최종: τ = τ_1 * τ_2 * ... * τ_N

보안 가정:
- N명 중 1명만 정직해도 τ는 안전
- 각 참가자는 자신의 toxic waste만 파기하면 됨

Phase 2: Circuit-Specific
1. Phase 1 결과를 입력으로 사용
2. Circuit에 특화된 CRS 생성
3. 동일한 MPC 절차 수행

Known Ceremony Examples:
- Zcash Sapling: 100+ 참가자
- Hermez (Polygon): Perpetual Powers of Tau
- Aztec Ignition: 176 참가자
```

### 1.6 Groth16의 한계

```
1. Circuit-Specific Setup
   - 회로 변경 시 새로운 setup 필요
   - 대규모 시스템에서 비효율적

2. Trusted Setup 요구
   - MPC 의존성
   - Setup 결과의 영구 보관 필요

3. Updatability 없음
   - 한번 생성된 CRS 수정 불가
   - 새 기능 추가 시 전체 재설정

4. 상대적으로 느린 Prover
   - 대규모 회로에서 증명 생성 시간 증가
```

---

## 2. PLONK

### 2.1 개요

PLONK (Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge)는 2019년 Ariel Gabizon, Zachary J. Williamson, Oana Ciobotaru가 제안한 범용 zkSNARK 시스템이다.

### 2.2 핵심 혁신

```
PLONK의 주요 특징:

1. Universal Setup (SRS)
   - 한 번의 setup으로 모든 회로에 사용
   - Circuit 크기 제한만 있음

2. Custom Gates
   - 표준 게이트 외 커스텀 게이트 정의 가능
   - 회로 최적화 용이

3. Permutation Argument
   - Wire 연결을 permutation으로 표현
   - Copy constraint 효율적 검증

4. Plookup (확장)
   - Lookup table 지원
   - Range check, 비트 연산 등 효율화
```

### 2.3 Arithmetization

#### 2.3.1 Gate Equation

```
PLONK Gate 형태:

q_L * a + q_R * b + q_O * c + q_M * (a * b) + q_C = 0

여기서:
- a, b: 왼쪽, 오른쪽 입력 와이어
- c: 출력 와이어
- q_L, q_R, q_O: 선택자 (덧셈 게이트용)
- q_M: 곱셈 선택자
- q_C: 상수항

예시:

덧셈 게이트: a + b = c
→ q_L=1, q_R=1, q_O=-1, q_M=0, q_C=0
→ 1*a + 1*b + (-1)*c + 0*(a*b) + 0 = 0 ✓

곱셈 게이트: a * b = c
→ q_L=0, q_R=0, q_O=-1, q_M=1, q_C=0
→ 0*a + 0*b + (-1)*c + 1*(a*b) + 0 = 0 ✓

상수 게이트: a = 5
→ q_L=1, q_R=0, q_O=0, q_M=0, q_C=-5
→ 1*a + 0 + 0 + 0 + (-5) = 0 ✓
```

#### 2.3.2 Trace Table

```
PLONK Trace Table:

| row | a (Left) | b (Right) | c (Output) | q_L | q_R | q_O | q_M | q_C |
|-----|----------|-----------|------------|-----|-----|-----|-----|-----|
|  0  |   x_1    |   x_2     |    x_3     |  1  |  1  | -1  |  0  |  0  |  (x_1 + x_2 = x_3)
|  1  |   x_3    |   x_4     |    x_5     |  0  |  0  | -1  |  1  |  0  |  (x_3 * x_4 = x_5)
|  2  |   x_5    |    1      |    x_6     |  1  |  1  | -1  |  0  |  0  |  (x_5 + 1 = x_6)
| ... |   ...    |   ...     |    ...     | ... | ... | ... | ... | ... |

와이어 값들을 다항식으로 인코딩:
- a(X): 왼쪽 와이어 다항식
- b(X): 오른쪽 와이어 다항식
- c(X): 출력 와이어 다항식
- q_*(X): 선택자 다항식들

evaluation domain: H = {ω^0, ω^1, ..., ω^{n-1}}
```

### 2.4 Copy Constraints (Permutation Argument)

```
Wire Connectivity 문제:

게이트 0의 출력 x_3가 게이트 1의 입력으로 사용됨
→ 이 연결을 어떻게 검증?

Permutation 접근:

1. 모든 와이어 위치에 인덱스 부여
   - a_0, b_0, c_0, a_1, b_1, c_1, ...

2. Copy constraint를 permutation σ로 표현
   - c_0 = a_1 이면 σ(c_0) = a_1, σ(a_1) = c_0

3. Grand Product Argument
   위치 i의 값을 f_i, 순열된 위치의 값을 g_i라 하면:

   Π(f_i + β * i + γ) / Π(g_i + β * σ(i) + γ) = 1

   β, γ: 랜덤 챌린지

4. Accumulator 다항식 Z(X)
   Z(ω^0) = 1
   Z(ω^{i+1}) = Z(ω^i) * (f_i + β * i + γ) / (g_i + β * σ(i) + γ)
   Z(ω^n) = 1 (순환 완료)
```

### 2.5 Protocol 상세

#### 2.5.1 Setup (Universal)

```
Universal Setup (Powers of Tau):

1. SRS 생성
   srs = {[τ^i]_1}_{i=0}^{d} ∪ {[τ^i]_2}_{i=0}^{d}

   d: 최대 지원 회로 크기

2. Circuit Preprocessing
   각 회로에 대해:
   - 선택자 다항식 commit: [q_L(τ)]_1, [q_R(τ)]_1, ...
   - Permutation 다항식 commit: [S_σ1(τ)]_1, [S_σ2(τ)]_1, [S_σ3(τ)]_1

주의: τ는 여전히 toxic waste이지만,
     동일 SRS로 다양한 회로 지원
```

#### 2.5.2 Proving

```
PLONK Prover 단계:

Round 1: Wire Polynomials
1. Blinding 추가한 wire 다항식 생성
   a(X) = a'(X) + (b_1*X + b_2) * Z_H(X)
   b(X) = b'(X) + (b_3*X + b_4) * Z_H(X)
   c(X) = c'(X) + (b_5*X + b_6) * Z_H(X)

   Z_H(X) = X^n - 1: vanishing polynomial
   b_i: 랜덤 블라인딩 계수

2. Commit
   [a]_1 = Commit(a(X))
   [b]_1 = Commit(b(X))
   [c]_1 = Commit(c(X))

Round 2: Permutation Polynomial
1. β, γ 챌린지 수신 (Fiat-Shamir)

2. Accumulator 다항식 Z(X) 계산
   Z(ω^0) = 1
   Z(ω^{i+1}) = Z(ω^i) *
     [(a_i + β*ω^i + γ)(b_i + β*k_1*ω^i + γ)(c_i + β*k_2*ω^i + γ)] /
     [(a_i + β*S_σ1(ω^i) + γ)(b_i + β*S_σ2(ω^i) + γ)(c_i + β*S_σ3(ω^i) + γ)]

3. Commit
   [z]_1 = Commit(Z(X))

Round 3: Quotient Polynomial
1. α 챌린지 수신

2. Quotient polynomial t(X) 계산
   t(X) = [gate(X) + α * perm(X) + α^2 * boundary(X)] / Z_H(X)

   - gate(X): 게이트 제약 조건
   - perm(X): permutation 제약 조건
   - boundary(X): 경계 조건 (Z(1) = 1)

3. t(X)를 조각으로 분할
   t(X) = t_lo(X) + X^n * t_mid(X) + X^{2n} * t_hi(X)

4. Commit
   [t_lo]_1, [t_mid]_1, [t_hi]_1

Round 4: Opening Evaluations
1. ζ (zeta) 챌린지 수신

2. 평가값 계산
   a_ζ = a(ζ), b_ζ = b(ζ), c_ζ = c(ζ)
   S_σ1_ζ = S_σ1(ζ), S_σ2_ζ = S_σ2(ζ)
   z_ωζ = Z(ω * ζ)

3. 평가값 전송

Round 5: Opening Proofs
1. ν 챌린지 수신

2. Linearized polynomial r(X) 계산

3. Opening proof 생성
   - W_ζ(X): ζ에서의 opening proof
   - W_ωζ(X): ωζ에서의 opening proof
```

#### 2.5.3 Verification

```
PLONK Verifier:

1. 챌린지 재생성 (Fiat-Shamir)
   β, γ, α, ζ, ν, μ 계산

2. Public Input 처리
   PI(ζ) = Σ w_i * L_i(ζ)
   L_i: Lagrange basis

3. Gate Constraint 검증
   r_0 = PI(ζ) - L_1(ζ) * α^2
       - α * (c_ζ + γ)(a_ζ + β*S_σ1_ζ + γ)(b_ζ + β*S_σ2_ζ + γ) * z_ωζ

4. Pairing 검증
   e([W_ζ]_1 + μ*[W_ωζ]_1, [τ]_2)
   = e(ζ*[W_ζ]_1 + μ*ω*ζ*[W_ωζ]_1 + [F]_1 - [E]_1, [1]_2)

   F, E: linearized polynomial과 evaluation의 조합

5. 등식 성립 시 Accept
```

### 2.6 Python 구현 (개념적)

```python
from dataclasses import dataclass
from typing import List, Tuple, Optional
from abc import ABC, abstractmethod

@dataclass
class PLONKCircuit:
    """PLONK 회로 표현"""
    n: int  # 게이트 수 (2의 거듭제곱)

    # Selector polynomials
    q_l: 'Polynomial'  # Left wire selector
    q_r: 'Polynomial'  # Right wire selector
    q_o: 'Polynomial'  # Output wire selector
    q_m: 'Polynomial'  # Multiplication selector
    q_c: 'Polynomial'  # Constant selector

    # Permutation polynomials
    s_sigma_1: 'Polynomial'
    s_sigma_2: 'Polynomial'
    s_sigma_3: 'Polynomial'

    # Coset generators
    k1: int
    k2: int


@dataclass
class PLONKProof:
    """PLONK 증명 구조"""
    # Round 1: Wire commitments
    a_commit: 'G1Point'
    b_commit: 'G1Point'
    c_commit: 'G1Point'

    # Round 2: Permutation commitment
    z_commit: 'G1Point'

    # Round 3: Quotient commitments
    t_lo_commit: 'G1Point'
    t_mid_commit: 'G1Point'
    t_hi_commit: 'G1Point'

    # Round 4: Evaluations
    a_eval: int
    b_eval: int
    c_eval: int
    s_sigma_1_eval: int
    s_sigma_2_eval: int
    z_omega_eval: int

    # Round 5: Opening proofs
    w_zeta: 'G1Point'
    w_omega_zeta: 'G1Point'


class PLONKProver:
    """PLONK Prover 구현"""

    def __init__(self, circuit: PLONKCircuit, srs: 'SRS'):
        self.circuit = circuit
        self.srs = srs
        self.n = circuit.n
        self.omega = self._get_root_of_unity(self.n)

    def prove(self,
              public_inputs: List[int],
              private_witness: List[int]) -> PLONKProof:
        """PLONK 증명 생성"""

        # Witness 배치
        witness = self._arrange_witness(public_inputs, private_witness)

        # === Round 1: Wire Polynomials ===
        a_poly = self._interpolate_with_blinding(witness['a'])
        b_poly = self._interpolate_with_blinding(witness['b'])
        c_poly = self._interpolate_with_blinding(witness['c'])

        a_commit = self._commit(a_poly)
        b_commit = self._commit(b_poly)
        c_commit = self._commit(c_poly)

        # === Round 2: Permutation Polynomial ===
        # Fiat-Shamir로 β, γ 생성
        transcript = self._init_transcript()
        transcript.append(a_commit, b_commit, c_commit)
        beta = transcript.challenge('beta')
        gamma = transcript.challenge('gamma')

        # Z(X) 계산
        z_poly = self._compute_permutation_polynomial(
            a_poly, b_poly, c_poly, beta, gamma)
        z_commit = self._commit(z_poly)

        # === Round 3: Quotient Polynomial ===
        transcript.append(z_commit)
        alpha = transcript.challenge('alpha')

        t_poly = self._compute_quotient_polynomial(
            a_poly, b_poly, c_poly, z_poly, alpha, beta, gamma)

        # t(X) 분할
        t_lo, t_mid, t_hi = self._split_polynomial(t_poly, self.n)

        t_lo_commit = self._commit(t_lo)
        t_mid_commit = self._commit(t_mid)
        t_hi_commit = self._commit(t_hi)

        # === Round 4: Evaluations ===
        transcript.append(t_lo_commit, t_mid_commit, t_hi_commit)
        zeta = transcript.challenge('zeta')

        a_eval = a_poly.evaluate(zeta)
        b_eval = b_poly.evaluate(zeta)
        c_eval = c_poly.evaluate(zeta)
        s_sigma_1_eval = self.circuit.s_sigma_1.evaluate(zeta)
        s_sigma_2_eval = self.circuit.s_sigma_2.evaluate(zeta)
        z_omega_eval = z_poly.evaluate(zeta * self.omega)

        # === Round 5: Opening Proofs ===
        transcript.append(a_eval, b_eval, c_eval,
                         s_sigma_1_eval, s_sigma_2_eval, z_omega_eval)
        nu = transcript.challenge('nu')

        # Linearization polynomial
        r_poly = self._compute_linearization(
            a_poly, b_poly, c_poly, z_poly,
            a_eval, b_eval, c_eval, s_sigma_1_eval, s_sigma_2_eval, z_omega_eval,
            alpha, beta, gamma, zeta)

        # Opening proofs
        w_zeta = self._compute_opening_proof(
            [a_poly, b_poly, c_poly, self.circuit.s_sigma_1,
             self.circuit.s_sigma_2, r_poly],
            zeta, nu)

        w_omega_zeta = self._compute_opening_proof([z_poly], zeta * self.omega, 1)

        return PLONKProof(
            a_commit=a_commit, b_commit=b_commit, c_commit=c_commit,
            z_commit=z_commit,
            t_lo_commit=t_lo_commit, t_mid_commit=t_mid_commit, t_hi_commit=t_hi_commit,
            a_eval=a_eval, b_eval=b_eval, c_eval=c_eval,
            s_sigma_1_eval=s_sigma_1_eval, s_sigma_2_eval=s_sigma_2_eval,
            z_omega_eval=z_omega_eval,
            w_zeta=w_zeta, w_omega_zeta=w_omega_zeta
        )

    def _compute_permutation_polynomial(self, a: 'Polynomial', b: 'Polynomial',
                                        c: 'Polynomial', beta: int,
                                        gamma: int) -> 'Polynomial':
        """
        Accumulator polynomial Z(X) 계산

        Z(ω^0) = 1
        Z(ω^{i+1}) = Z(ω^i) *
            [(a_i + β*ω^i + γ)(b_i + β*k1*ω^i + γ)(c_i + β*k2*ω^i + γ)] /
            [(a_i + β*S1_i + γ)(b_i + β*S2_i + γ)(c_i + β*S3_i + γ)]
        """
        z_values = [1]  # Z(1) = 1

        for i in range(self.n - 1):
            omega_i = pow(self.omega, i, self.field_modulus)

            a_i = a.evaluate(omega_i)
            b_i = b.evaluate(omega_i)
            c_i = c.evaluate(omega_i)

            s1_i = self.circuit.s_sigma_1.evaluate(omega_i)
            s2_i = self.circuit.s_sigma_2.evaluate(omega_i)
            s3_i = self.circuit.s_sigma_3.evaluate(omega_i)

            # Numerator
            num = (a_i + beta * omega_i + gamma) * \
                  (b_i + beta * self.circuit.k1 * omega_i + gamma) * \
                  (c_i + beta * self.circuit.k2 * omega_i + gamma)

            # Denominator
            den = (a_i + beta * s1_i + gamma) * \
                  (b_i + beta * s2_i + gamma) * \
                  (c_i + beta * s3_i + gamma)

            z_next = (z_values[-1] * num * pow(den, -1, self.field_modulus)) % self.field_modulus
            z_values.append(z_next)

        return self._interpolate(z_values)

    def _compute_quotient_polynomial(self, a: 'Polynomial', b: 'Polynomial',
                                     c: 'Polynomial', z: 'Polynomial',
                                     alpha: int, beta: int,
                                     gamma: int) -> 'Polynomial':
        """
        Quotient polynomial t(X) 계산

        t(X) = [gate(X) + α*perm(X) + α²*boundary(X)] / Z_H(X)
        """
        # Gate constraint
        gate = self.circuit.q_l * a + self.circuit.q_r * b + \
               self.circuit.q_o * c + self.circuit.q_m * (a * b) + \
               self.circuit.q_c

        # Permutation constraint (simplified)
        # 실제로는 더 복잡한 수식
        perm = self._compute_permutation_constraint(a, b, c, z, beta, gamma)

        # Boundary constraint: (Z(X) - 1) * L_1(X)
        l1 = self._lagrange_basis(0)
        boundary = (z - 1) * l1

        # Combine with powers of alpha
        numerator = gate + alpha * perm + (alpha ** 2) * boundary

        # Divide by vanishing polynomial
        z_h = self._vanishing_polynomial()
        quotient, _ = numerator.divide(z_h)

        return quotient

    def _commit(self, poly: 'Polynomial') -> 'G1Point':
        """KZG commitment"""
        return self.srs.commit(poly)

    def _interpolate_with_blinding(self, values: List[int]) -> 'Polynomial':
        """Blinding factor를 포함한 다항식 보간"""
        base_poly = self._interpolate(values)

        # Add blinding: (b1*X + b2) * Z_H(X)
        b1 = self._random_scalar()
        b2 = self._random_scalar()
        z_h = self._vanishing_polynomial()
        blinding = Polynomial([b2, b1]) * z_h

        return base_poly + blinding

    # Helper methods (실제 구현 필요)
    def _interpolate(self, values: List[int]) -> 'Polynomial':
        pass

    def _vanishing_polynomial(self) -> 'Polynomial':
        """Z_H(X) = X^n - 1"""
        pass

    def _lagrange_basis(self, index: int) -> 'Polynomial':
        pass

    def _get_root_of_unity(self, n: int) -> int:
        pass

    def _random_scalar(self) -> int:
        pass


class PLONKVerifier:
    """PLONK Verifier 구현"""

    def __init__(self, circuit: PLONKCircuit, srs: 'SRS'):
        self.circuit = circuit
        self.srs = srs

    def verify(self, public_inputs: List[int], proof: PLONKProof) -> bool:
        """PLONK 증명 검증"""

        # 1. Transcript 재구성 및 챌린지 생성
        transcript = self._init_transcript()
        transcript.append(proof.a_commit, proof.b_commit, proof.c_commit)
        beta = transcript.challenge('beta')
        gamma = transcript.challenge('gamma')

        transcript.append(proof.z_commit)
        alpha = transcript.challenge('alpha')

        transcript.append(proof.t_lo_commit, proof.t_mid_commit, proof.t_hi_commit)
        zeta = transcript.challenge('zeta')

        transcript.append(proof.a_eval, proof.b_eval, proof.c_eval,
                         proof.s_sigma_1_eval, proof.s_sigma_2_eval,
                         proof.z_omega_eval)
        nu = transcript.challenge('nu')
        mu = transcript.challenge('mu')

        # 2. Public Input 평가
        pi_eval = self._evaluate_public_input(public_inputs, zeta)

        # 3. Vanishing polynomial 평가
        z_h_eval = pow(zeta, self.circuit.n, self.field_modulus) - 1

        # 4. Lagrange basis L_1(ζ) 평가
        l1_eval = self._evaluate_l1(zeta)

        # 5. Quotient 다항식 평가 검증
        t_eval = (proof.t_lo_commit.eval +
                  pow(zeta, self.circuit.n, self.field_modulus) * proof.t_mid_commit.eval +
                  pow(zeta, 2 * self.circuit.n, self.field_modulus) * proof.t_hi_commit.eval)

        # 6. 게이트 제약 검증
        gate_eval = self._verify_gate_constraint(proof, zeta)

        # 7. Permutation 제약 검증
        perm_eval = self._verify_permutation_constraint(proof, alpha, beta, gamma, zeta)

        # 8. Boundary 제약 검증
        boundary_eval = (proof.z_omega_eval - 1) * l1_eval * (alpha ** 2)

        # 9. 전체 제약 검증
        lhs = gate_eval + perm_eval + boundary_eval
        rhs = t_eval * z_h_eval

        if lhs != rhs:
            return False

        # 10. Pairing 검증 (KZG opening)
        return self._verify_opening_proofs(proof, zeta, nu, mu)

    def _verify_opening_proofs(self, proof: PLONKProof,
                               zeta: int, nu: int, mu: int) -> bool:
        """KZG opening proof 검증"""
        # Batched pairing check
        # e([W_ζ] + μ[W_ωζ], [τ]_2) = e(ζ[W_ζ] + μωζ[W_ωζ] + [F] - [E], [1]_2)

        lhs = self._pairing(
            self._g1_add(proof.w_zeta, self._g1_scalar_mul(proof.w_omega_zeta, mu)),
            self.srs.tau_g2
        )

        # F, E 계산 (linearized commitment와 evaluation commitment)
        f_commit = self._compute_f_commitment(proof, nu)
        e_commit = self._compute_e_commitment(proof, nu, zeta)

        rhs_g1 = self._g1_add(
            self._g1_add(
                self._g1_scalar_mul(proof.w_zeta, zeta),
                self._g1_scalar_mul(proof.w_omega_zeta, mu * self.omega * zeta)
            ),
            self._g1_add(f_commit, self._g1_neg(e_commit))
        )

        rhs = self._pairing(rhs_g1, self.srs.one_g2)

        return lhs == rhs

    # Helper methods
    def _evaluate_public_input(self, public_inputs: List[int], zeta: int) -> int:
        pass

    def _evaluate_l1(self, zeta: int) -> int:
        pass

    def _verify_gate_constraint(self, proof: PLONKProof, zeta: int) -> int:
        pass

    def _verify_permutation_constraint(self, proof: PLONKProof,
                                       alpha: int, beta: int,
                                       gamma: int, zeta: int) -> int:
        pass
```

### 2.7 Custom Gates

```
PLONK의 강력한 기능: Custom Gates

표준 게이트:
q_L * a + q_R * b + q_O * c + q_M * ab + q_C = 0

확장 가능:
q_L * a + q_R * b + q_O * c + q_M * ab + q_C +
q_bool * a(1-a) +           # Boolean constraint: a ∈ {0, 1}
q_range * (a)(a-1)(a-2)... + # Range constraint
q_ecc * (elliptic curve) +  # ECC operations
... = 0

예시: Range Check (0 ≤ a < 4)

q_range = 1일 때:
a(a-1)(a-2)(a-3) = 0

이 등식이 성립하려면 a ∈ {0, 1, 2, 3}

효율성:
- 비트 분해 없이 직접 범위 검증
- 게이트 수 대폭 감소
```

### 2.8 Plookup (Lookup Arguments)

```
Plookup: Lookup Table을 이용한 최적화

개념:
- 미리 계산된 테이블 T에서 값을 조회
- 모든 조회가 테이블에 있는 값임을 증명

사용 사례:
1. Range Proofs
   T = {0, 1, 2, ..., 255} (8비트 범위)
   → 값이 0-255 사이임을 한 번의 lookup으로 증명

2. Bitwise Operations
   T = {(a, b, a XOR b) | a, b ∈ {0..255}}
   → XOR 연산 결과를 테이블 조회로 검증

3. Hash Functions
   T = {(input_chunk, round, output) | ...}
   → SHA256 등의 라운드 함수 최적화

수학적 구조:
f: 조회하려는 값들
t: 테이블 값들
s: 정렬된 f ∪ t

Grand Product:
Π(1 + β)(f_i + γ) * Π(1 + β)(t_i + γ)
─────────────────────────────────────
Π((s_i + γ) + β(s_{i+1} + γ))

이 비율이 1이면 모든 f_i가 t에 존재함을 증명
```

---

## 3. FFLONK

### 3.1 개요

FFLONK (Fast-Fourier PLONK)는 Polygon에서 개발한 PLONK의 최적화 버전으로, 더 작은 proof size와 빠른 검증 시간을 제공한다.

### 3.2 핵심 최적화

```
FFLONK vs PLONK:

1. Proof Size 감소
   PLONK: ~400 bytes
   FFLONK: ~256 bytes (약 36% 감소)

2. Verification Pairings 감소
   PLONK: 2 pairings + 여러 G1 연산
   FFLONK: 2 pairings (최소화)

3. Polynomial Batching
   여러 다항식을 하나로 결합하여 opening 횟수 감소
```

### 3.3 기술적 차이점

#### 3.3.1 Opening Batching

```
PLONK의 Opening 문제:

ζ에서 열어야 하는 다항식들:
- a(ζ), b(ζ), c(ζ)
- S_σ1(ζ), S_σ2(ζ)
- t(ζ)

ωζ에서 열어야 하는 다항식:
- z(ωζ)

→ 2개의 opening point, 여러 다항식

FFLONK의 해결책:

1. Shplonk 스타일 batching
   모든 다항식을 하나의 combined polynomial로 결합

2. 단일 opening proof
   F(X) = Σ ν^i * [f_i(X) - f_i(ζ)] / (X - ζ)

   ν: 랜덤 챌린지
   f_i: 개별 다항식들
   ζ: evaluation point

3. Commitment 결합
   [F]_1 = Σ ν^i * [f_i]_1 - Σ ν^i * f_i(ζ) * [1]_1
```

#### 3.3.2 Verification 최적화

```
PLONK Verification:

Step 1: 여러 스칼라 곱셈 (MSM)
Step 2: 2개의 pairing 검증
Step 3: 추가 G1 연산

FFLONK Verification:

Step 1: 최소한의 스칼라 곱셈
Step 2: 2개의 pairing만 (최적화된 batching)

Pairing 등식:
e([W], [τ]_2) = e([P] + ζ[W], [1]_2)

여기서:
- W: 단일 opening proof
- P: 결합된 polynomial commitment
- ζ: evaluation point
```

### 3.4 구현 고려사항

```python
@dataclass
class FFLONKProof:
    """FFLONK 최적화된 증명 구조"""
    # Wire commitments (PLONK과 동일)
    c1: 'G1Point'  # Combined commitment 1
    c2: 'G1Point'  # Combined commitment 2

    # Evaluations (batched)
    evaluations: List[int]

    # Single opening proof
    w: 'G1Point'


class FFLONKProver:
    """FFLONK Prover"""

    def __init__(self, circuit: 'Circuit', srs: 'SRS'):
        self.circuit = circuit
        self.srs = srs

    def prove(self, witness: List[int]) -> FFLONKProof:
        # 1. PLONK과 유사한 라운드 진행
        # ...

        # 2. Polynomial Batching
        combined_poly = self._batch_polynomials(
            all_polynomials,
            challenges
        )

        # 3. Single opening proof 생성
        w = self._compute_opening_proof(combined_poly, zeta)

        return FFLONKProof(
            c1=c1, c2=c2,
            evaluations=batched_evals,
            w=w
        )

    def _batch_polynomials(self, polys: List['Polynomial'],
                           challenges: List[int]) -> 'Polynomial':
        """다항식들을 하나로 결합"""
        result = Polynomial([0])
        for i, poly in enumerate(polys):
            result = result + poly * (challenges[0] ** i)
        return result


class FFLONKVerifier:
    """FFLONK Verifier - 최적화된 검증"""

    def verify(self, public_inputs: List[int], proof: FFLONKProof) -> bool:
        # 1. 챌린지 재생성
        challenges = self._generate_challenges(proof)

        # 2. Combined commitment 계산
        p = self._compute_combined_commitment(proof, challenges)

        # 3. 단일 pairing check
        #    e([W], [τ - ζ]_2) = e([P], [1]_2)
        #    또는 동등하게:
        #    e([W], [τ]_2) * e(-[P] - ζ[W], [1]_2) = 1

        lhs = self._pairing(proof.w, self.srs.tau_minus_zeta_g2(challenges['zeta']))
        rhs = self._pairing(p, self.srs.one_g2)

        return lhs == rhs
```

### 3.5 성능 비교

```
벤치마크 (100만 constraints 기준):

| 메트릭 | Groth16 | PLONK | FFLONK |
|--------|---------|-------|--------|
| Proof Size | 192B | 400B | 256B |
| Prover Time | 15s | 20s | 18s |
| Verifier Time | 4ms | 8ms | 5ms |
| Setup | Circuit-specific | Universal | Universal |

가스 비용 (Ethereum):
| 시스템 | 검증 가스 |
|--------|----------|
| Groth16 | ~220K |
| PLONK | ~300K |
| FFLONK | ~250K |
```

---

## 4. 고급 주제

### 4.1 Recursive Proofs

```
Recursive SNARK:

개념:
- 증명 A가 증명 B의 유효성을 검증
- 무한 체인의 압축 가능

구조:
proof_1: "transaction 1 is valid"
proof_2: "transaction 2 is valid AND proof_1 is valid"
proof_3: "transaction 3 is valid AND proof_2 is valid"
...
proof_n: "최신 상태 + 이전 모든 증명 유효"

구현 과제:
1. Verifier를 회로로 표현 (expensive)
2. Pairing 연산의 회로화
3. 필드 호환성 (cycle of curves)

해결책:
- Pasta curves (Halo 2)
- BN254/BLS12-381 cycle
- Accumulation schemes
```

### 4.2 Lookup Tables 심화

```
현대적 Lookup Schemes:

1. Plookup (기본)
   - Grand product argument
   - 정렬 필요

2. Halo2 Lookup
   - 더 유연한 구조
   - 다중 테이블 지원

3. cq/Lasso
   - Sublinear prover time
   - 대규모 테이블에 효율적

4. LogUp
   - Logarithmic lookup
   - 더 작은 증명 크기

적용 분야:
- Keccak/SHA256 해시
- ECDSA 서명 검증
- Range proofs
- Merkle tree 연산
```

### 4.3 Folding Schemes

```
Nova/SuperNova:

개념:
- IVC (Incrementally Verifiable Computation)
- Recursive proof 없이 accumulation

Nova 구조:
1. Relaxed R1CS
   A * Z ⊙ B * Z = u * C * Z + E

   u: relaxation factor
   E: error vector

2. Folding
   두 인스턴스 (u_1, E_1), (u_2, E_2)를
   단일 인스턴스 (u, E)로 결합

   r: random challenge
   u = u_1 + r * u_2
   E = E_1 + r * T + r^2 * E_2

   T: cross-term

장점:
- Prover overhead 최소화
- 증명 크기 일정
- Parallel folding 가능
```

---

## 5. 실무 선택 가이드

### 5.1 시스템 선택 기준

```
Groth16 선택 시:
✓ 최소 proof size 필요 (on-chain 비용 최적화)
✓ 최소 검증 시간 필요
✓ 회로가 자주 변경되지 않음
✓ Trusted setup 수용 가능
✗ 회로 변경이 잦은 경우 부적합

PLONK 선택 시:
✓ 다양한 회로를 하나의 setup으로 지원
✓ Custom gates로 최적화 필요
✓ Lookup tables 활용 필요
✓ 유연한 개발 환경 필요
✗ 최소 proof size가 중요한 경우

FFLONK 선택 시:
✓ PLONK의 유연성 + 최적화된 성능
✓ Polygon zkEVM 호환 필요
✓ 균형 잡힌 성능 요구
✗ 특수한 최적화가 필요한 경우
```

### 5.2 프로젝트별 권장 시스템

```
| 프로젝트 유형 | 권장 시스템 | 이유 |
|--------------|-------------|------|
| Privacy Coins | Groth16 | 최소 tx size |
| General L2 | PLONK/FFLONK | 유연성 |
| zkEVM | FFLONK | Polygon 호환 |
| zkVM | PLONK + Custom | 복잡한 opcode |
| DeFi Privacy | Groth16 | 검증 비용 |
| Identity | PLONK | 다양한 credential |
```

---

## 6. 참고 자료

### 학술 논문
- Groth16: "On the Size of Pairing-based Non-interactive Arguments" (Jens Groth, 2016)
- PLONK: "PLONK: Permutations over Lagrange-bases for Oecumenical Noninteractive arguments of Knowledge" (Gabizon et al., 2019)
- Marlin: "Marlin: Preprocessing zkSNARKs with Universal and Updatable SRS" (Chiesa et al., 2020)
- Nova: "Nova: Recursive Zero-Knowledge Arguments from Folding Schemes" (Kothapalli et al., 2022)

### 구현체
- arkworks (Rust): https://github.com/arkworks-rs
- bellman (Rust): https://github.com/zkcrypto/bellman
- snarkjs (JavaScript): https://github.com/iden3/snarkjs
- gnark (Go): https://github.com/ConsenSys/gnark
- halo2 (Rust): https://github.com/zcash/halo2

### 온라인 자료
- ZK-Learning.org: https://zk-learning.org
- ZKHack: https://zkhack.dev
- Polygon zkEVM: https://polygon.technology/polygon-zkevm

---

## 요약

```
Prover Systems 핵심 비교:

Groth16:
- Circuit-specific trusted setup
- 최소 proof size (192B)
- 최소 검증 시간 (3 pairings)
- R1CS → QAP 변환 기반

PLONK:
- Universal trusted setup
- Custom gates 지원
- Permutation argument로 wire 연결 검증
- Plookup 확장으로 lookup table 지원

FFLONK:
- PLONK 최적화 버전
- Polynomial batching으로 proof size 감소
- 2 pairings만으로 검증
- Polygon zkEVM의 핵심 기술

선택 기준:
- On-chain 비용 최적화: Groth16
- 개발 유연성: PLONK
- 균형 잡힌 성능: FFLONK

모든 시스템의 공통점:
- Polynomial commitment (KZG) 기반
- Fiat-Shamir로 비대화식 변환
- Pairing 기반 검증
- 다항 시간 prover, 상수 시간 verifier
```
