# 2.4 Recursive Proofs (재귀적 증명)

## 개요

Recursive Proof(재귀적 증명)는 하나의 SNARK 증명이 다른 SNARK 증명의 유효성을 검증하는 구조이다. 이를 통해 무한한 계산을 유한한 크기의 증명으로 압축할 수 있으며, 블록체인 확장성의 핵심 기술이다.

### 왜 Recursive Proof가 필요한가?

```
문제 상황:

1. 블록체인 상태 검증
   - 100만 개의 트랜잭션 검증 필요
   - 각 트랜잭션마다 증명 생성 → 100만 개 증명
   - On-chain 검증 비용: 100만 × 검증비용

2. 단순 배칭의 한계
   - 모든 트랜잭션을 하나의 회로로 → 회로 크기 폭발
   - Prover 메모리/시간 한계

해결책: Recursive Proof
   - proof_1 검증 + 새 계산 → proof_2 생성
   - proof_2 검증 + 새 계산 → proof_3 생성
   - ...
   - 최종 proof_n 하나로 모든 것 검증
```

---

## 1. 기본 개념

### 1.1 IVC (Incrementally Verifiable Computation)

```
IVC 정의:

계산 f를 n번 반복 적용:
z_0 → f → z_1 → f → z_2 → ... → f → z_n

각 단계에서 증명 생성:
π_i: "z_i = f^i(z_0) 이고, 이전 증명 π_{i-1}이 유효하다"

최종 증명 π_n:
- 크기: O(1) (상수)
- 검증 시간: O(1)
- 증명 내용: 전체 n번 계산이 올바름

IVC 속성:
1. Completeness: 올바른 계산은 항상 유효한 증명 생성
2. Soundness: 잘못된 계산은 유효한 증명 생성 불가
3. Succinctness: 증명 크기가 n에 독립적
```

### 1.2 PCD (Proof-Carrying Data)

```
PCD: IVC의 일반화

IVC: 단일 체인 (순차적 계산)
z_0 → z_1 → z_2 → ... → z_n

PCD: DAG 구조 (병렬 계산)
     z_0 ─┐
          ├→ z_2 ─┐
     z_1 ─┘       │
                  ├→ z_4 → ...
     z_3 ─────────┘

PCD의 특징:
- 여러 증명을 동시에 검증하고 결합
- 분산 시스템에 적합
- Rollup aggregation에 활용
```

### 1.3 수학적 구조

```
Recursive SNARK의 관계 정의:

기본 관계 R_base(x, w):
- 실제 계산을 표현
- 예: "트랜잭션 tx가 유효하다"

재귀 관계 R_rec(x, w, π):
- R_base(x', w') = 1 (현재 계산 유효)
- Verify(vk, x_prev, π) = 1 (이전 증명 유효)

전체 관계:
R((x_curr, x_prev), (w, π)) =
    R_base(x_curr, w) ∧ Verify(vk, x_prev, π)
```

---

## 2. 핵심 기술적 도전

### 2.1 Verifier의 회로 표현

```
문제:
SNARK Verifier를 회로로 표현해야 함

Verifier 연산:
1. Field 연산 (modular arithmetic)
2. Elliptic curve 연산
3. Pairing 연산 (매우 비쌈)

비용 분석 (BN254 기준):

| 연산 | 회로 크기 (constraints) |
|------|------------------------|
| Field 덧셈 | 1 |
| Field 곱셈 | 1 |
| Field 역원 | ~100 |
| EC 덧셈 | ~20 |
| EC 스칼라 곱 | ~2,000 |
| Pairing | ~100,000+ |

Groth16 Verifier (3 pairings):
→ ~300,000+ constraints just for verification!
```

### 2.2 필드 불일치 문제

```
Native Field vs Non-Native Field:

SNARK 시스템은 특정 필드 F_p에서 동작
- BN254: p = 21888242871839275222246405745257275088548364400416034343698204186575808495617
- BLS12-381: p = 0x73eda753299d7d483339d80809a1d80553bda402fffe5bfeffffffff00000001

문제:
- 외부 SNARK가 필드 F_q에서 동작
- p ≠ q인 경우, F_q 연산을 F_p에서 시뮬레이션 필요

Non-native field arithmetic:
- F_q 원소를 F_p 원소들의 tuple로 표현
- 각 연산마다 range check 필요
- 비용: O(log q / log p)^2 배 증가

해결 접근:
1. Same-field recursion (같은 필드 사용)
2. Cycle of curves (두 곡선이 서로의 scalar field 사용)
3. Two-chain approach (두 증명 시스템 교차 사용)
```

### 2.3 Cycle of Elliptic Curves

```
Cycle 정의:
두 타원 곡선 E_1, E_2가 cycle을 형성:
- E_1의 scalar field = E_2의 base field
- E_2의 scalar field = E_1의 base field

     E_1 (base: F_p, scalar: F_q)
         ↕
     E_2 (base: F_q, scalar: F_p)

대표적 Cycle:

1. MNT Cycle (역사적)
   - MNT4, MNT6 curves
   - 보안 수준 낮음, 현재 미사용

2. Pasta Curves (Halo 2)
   - Pallas: y² = x³ + 5 over F_p
   - Vesta: y² = x³ + 5 over F_q
   - p와 q가 서로의 scalar field
   - Zcash Orchard에서 사용

3. BN254 + Grumpkin
   - BN254: pairing-friendly curve
   - Grumpkin: BN254의 scalar field 위
   - Aztec에서 사용

활용:
E_1에서 증명 생성 → E_2에서 검증 (native)
E_2에서 증명 생성 → E_1에서 검증 (native)
```

---

## 3. Recursive Proof 구현 방식

### 3.1 Full Recursion (전체 재귀)

```
방식:
Verifier 전체를 회로로 구현

장점:
- 개념적으로 단순
- 완전한 재귀

단점:
- 매우 큰 회로 크기
- Pairing 비용 높음

예시 구현 (Groth16 on Groth16):

Circuit RecursiveVerify(vk, public_input, proof):
    # 1. Public input 해시 검증
    pi_hash = Poseidon(public_input)

    # 2. Proof 요소 파싱
    A = parse_g1(proof.a)
    B = parse_g2(proof.b)
    C = parse_g1(proof.c)

    # 3. Pairing 계산 (회로 내)
    # e(A, B) == e(α, β) * e(PI, γ) * e(C, δ)

    lhs = miller_loop(A, B)
    rhs = miller_loop(vk.alpha, vk.beta)
    rhs = rhs * miller_loop(pi_point, vk.gamma)
    rhs = rhs * miller_loop(C, vk.delta)

    # 4. Final exponentiation
    lhs = final_exp(lhs)
    rhs = final_exp(rhs)

    assert lhs == rhs
```

### 3.2 Accumulation Schemes

```
핵심 아이디어:
Pairing을 회로 내에서 수행하지 않음
대신 "accumulator"를 유지하고 마지막에 한 번만 pairing

Accumulator 구조:
acc = (C, U, E)

여기서:
- C: commitment
- U: instance
- E: error term

Folding:
두 인스턴스 (π_1, acc_1), (π_2, acc_2)를
단일 인스턴스 (π, acc)로 결합

acc = Fold(acc_1, acc_2)

최종 검증:
- 축적된 acc에 대해 한 번의 pairing 수행
- 전체 체인 유효성 확인

장점:
- 회로 내 pairing 불필요
- 훨씬 작은 재귀 회로
```

### 3.3 Split Accumulation

```
Two-phase Verification:

Phase 1 (회로 내 - cheap):
- Algebraic checks
- Field operations
- Commitment 검증

Phase 2 (회로 외 - expensive):
- Pairing 연산
- Final verification

구현:

struct AccumulatedProof {
    // Phase 1에서 검증된 데이터
    algebraic_checks: Vec<FieldElement>,

    // Phase 2를 위해 축적된 데이터
    pairing_inputs: Vec<(G1Point, G2Point)>,
}

// 회로 내에서
fn verify_in_circuit(proof: &Proof) -> AccumulatedProof {
    // Cheap checks만 수행
    let checks = verify_algebraic(proof);

    // Pairing 입력 축적
    let pairs = accumulate_pairing_inputs(proof);

    AccumulatedProof { checks, pairing_inputs: pairs }
}

// 회로 외에서 (최종)
fn final_verification(acc: &AccumulatedProof) -> bool {
    // 모든 축적된 pairing 한 번에 검증
    multi_pairing(&acc.pairing_inputs)
}
```

---

## 4. 주요 구현체

### 4.1 Halo 2 (Zcash)

```
Halo 2 특징:
- Trusted setup 없음 (IPA 기반)
- Pasta curves cycle 사용
- Accumulation scheme 적용

핵심 혁신: IPA (Inner Product Argument)

IPA 기반 Polynomial Commitment:
- KZG 대신 Pedersen commitment 확장
- Pairing 불필요
- Transparent setup

Accumulator 구조:
- 각 증명에서 commitment와 evaluation 축적
- Folding으로 하나의 accumulator로 병합
- 최종적으로 단일 IPA 검증

Zcash Orchard:
- Halo 2 기반 shielded 트랜잭션
- Pallas/Vesta curves
- 재귀적 증명으로 블록 압축
```

### 4.2 Pickles (Mina)

```
Pickles 특징:
- Mina Protocol의 핵심 기술
- 전체 블록체인을 ~22KB 증명으로 압축
- Kimchi (개선된 PLONK) 기반

구조:
Proof_{block_n} =
    Verify(Proof_{block_{n-1}}) ∧
    Valid(transactions in block_n)

Mina의 "Succinct Blockchain":
- 전체 체인 상태를 상수 크기 증명으로 표현
- 새 노드는 genesis부터 검증 불필요
- 22KB 증명만 검증하면 현재 상태 신뢰 가능

Pasta Curves 활용:
- Pallas에서 메인 연산
- Vesta에서 재귀 검증
- 효율적인 cycle 활용
```

### 4.3 Aztec (Noir/Barretenberg)

```
Aztec의 Recursive Proof:

아키텍처:
Client Proof → Rollup Proof → Root Proof

1. Client Proof:
   - 사용자 트랜잭션 증명
   - UltraPlonk 기반
   - Grumpkin curve 활용

2. Rollup Proof:
   - 여러 client proof 배치 검증
   - 재귀적으로 이전 rollup proof 포함
   - BN254에서 검증

3. Root Proof:
   - 최종 L1 제출용
   - Ethereum에서 검증 가능
   - Groth16으로 래핑 (최소 가스비)

Grumpkin + BN254 Cycle:
- Grumpkin: BN254의 scalar field 위 정의
- 효율적인 non-native arithmetic
- Inner circuits: Grumpkin
- Outer circuits: BN254
```

---

## 5. Python 개념적 구현

### 5.1 기본 재귀 구조

```python
from dataclasses import dataclass
from typing import Optional, List, Tuple
from abc import ABC, abstractmethod

@dataclass
class RecursiveCircuitInput:
    """재귀 회로의 입력"""
    # 현재 계산의 입력
    current_state: List[int]
    current_witness: List[int]

    # 이전 증명 (첫 단계에서는 None)
    previous_proof: Optional['SNARKProof']
    previous_public_input: Optional[List[int]]


@dataclass
class SNARKProof:
    """SNARK 증명 (추상화)"""
    data: bytes


@dataclass
class VerificationKey:
    """검증 키"""
    data: bytes


class RecursiveSNARK(ABC):
    """재귀 SNARK 인터페이스"""

    @abstractmethod
    def setup(self, circuit_size: int) -> Tuple['ProvingKey', VerificationKey]:
        """Setup phase"""
        pass

    @abstractmethod
    def prove(self,
              pk: 'ProvingKey',
              input: RecursiveCircuitInput) -> SNARKProof:
        """재귀 증명 생성"""
        pass

    @abstractmethod
    def verify(self,
               vk: VerificationKey,
               public_input: List[int],
               proof: SNARKProof) -> bool:
        """증명 검증"""
        pass


class IVCProver:
    """Incrementally Verifiable Computation Prover"""

    def __init__(self,
                 snark: RecursiveSNARK,
                 step_function: callable,
                 vk: VerificationKey):
        self.snark = snark
        self.step_function = step_function
        self.vk = vk

        # 현재 상태
        self.current_state: List[int] = []
        self.current_proof: Optional[SNARKProof] = None
        self.step_count: int = 0

    def initialize(self, initial_state: List[int]):
        """초기 상태 설정"""
        self.current_state = initial_state
        self.current_proof = None
        self.step_count = 0

    def step(self, witness: List[int]) -> SNARKProof:
        """
        한 단계 계산 수행 및 증명 생성

        증명 내용:
        1. step_function(prev_state, witness) = new_state
        2. (이전 증명이 있다면) 이전 증명이 유효함
        """
        # 새 상태 계산
        new_state = self.step_function(self.current_state, witness)

        # 재귀 회로 입력 구성
        circuit_input = RecursiveCircuitInput(
            current_state=new_state,
            current_witness=witness,
            previous_proof=self.current_proof,
            previous_public_input=self.current_state if self.current_proof else None
        )

        # 증명 생성
        new_proof = self.snark.prove(self.pk, circuit_input)

        # 상태 업데이트
        self.current_state = new_state
        self.current_proof = new_proof
        self.step_count += 1

        return new_proof

    def get_final_proof(self) -> Tuple[List[int], SNARKProof]:
        """최종 상태와 증명 반환"""
        return self.current_state, self.current_proof


class IVCVerifier:
    """IVC 검증자"""

    def __init__(self, snark: RecursiveSNARK, vk: VerificationKey):
        self.snark = snark
        self.vk = vk

    def verify(self,
               final_state: List[int],
               proof: SNARKProof) -> bool:
        """
        최종 증명 검증

        이 단일 검증으로 전체 계산 체인의 유효성 확인
        """
        return self.snark.verify(self.vk, final_state, proof)
```

### 5.2 Accumulator 기반 구현

```python
from dataclasses import dataclass
from typing import List, Tuple

@dataclass
class Accumulator:
    """축적된 검증 데이터"""
    commitment: 'G1Point'
    evaluation: int
    challenge: int
    error: 'G1Point'  # error term


@dataclass
class FoldedProof:
    """Folding 후의 증명"""
    accumulator: Accumulator
    instance: List[int]


class AccumulationScheme:
    """Accumulation 기반 재귀"""

    def __init__(self, inner_snark: 'SNARK'):
        self.inner_snark = inner_snark

    def fold(self,
             acc1: Accumulator,
             acc2: Accumulator,
             r: int) -> Accumulator:
        """
        두 accumulator를 하나로 결합

        r: random challenge (Fiat-Shamir로 생성)
        """
        # Linear combination
        new_commitment = self._g1_add(
            acc1.commitment,
            self._g1_scalar_mul(acc2.commitment, r)
        )

        new_evaluation = (acc1.evaluation + r * acc2.evaluation) % self.field_modulus

        # Cross term 계산
        cross_term = self._compute_cross_term(acc1, acc2, r)

        new_error = self._g1_add(
            self._g1_add(acc1.error, self._g1_scalar_mul(acc2.error, r * r)),
            cross_term
        )

        return Accumulator(
            commitment=new_commitment,
            evaluation=new_evaluation,
            challenge=(acc1.challenge + r * acc2.challenge) % self.field_modulus,
            error=new_error
        )

    def decide(self, acc: Accumulator) -> bool:
        """
        최종 accumulator 검증

        이 단계에서만 expensive 연산 (pairing) 수행
        """
        # Commitment과 evaluation의 일관성 검증
        # 실제로는 pairing check 수행
        return self._final_pairing_check(acc)

    def prove_step(self,
                   current_acc: Accumulator,
                   new_instance: List[int],
                   witness: List[int]) -> Tuple[Accumulator, 'StepProof']:
        """
        한 단계 증명 및 축적

        1. 새 인스턴스에 대한 inner proof 생성
        2. 현재 accumulator와 fold
        """
        # Inner SNARK로 새 증명 생성
        inner_proof = self.inner_snark.prove(new_instance, witness)

        # 새 accumulator 생성
        new_acc = self._proof_to_accumulator(inner_proof)

        # Fold
        r = self._fiat_shamir_challenge([current_acc, new_acc])
        folded_acc = self.fold(current_acc, new_acc, r)

        return folded_acc, inner_proof

    def verify_step_in_circuit(self,
                               prev_acc: Accumulator,
                               new_instance: List[int],
                               step_proof: 'StepProof') -> Accumulator:
        """
        회로 내에서 step 검증 (cheap operations만)

        Pairing 없이 algebraic 검증만 수행
        """
        # 1. Instance 검증 (field ops)
        assert self._verify_instance_format(new_instance)

        # 2. Step proof의 algebraic 부분 검증
        new_acc = self._verify_algebraic(step_proof)

        # 3. Fold (field + EC ops, no pairing)
        r = self._fiat_shamir_challenge([prev_acc, new_acc])
        folded = self.fold(prev_acc, new_acc, r)

        return folded

    # Helper methods
    def _proof_to_accumulator(self, proof: 'SNARKProof') -> Accumulator:
        """증명을 accumulator로 변환"""
        pass

    def _compute_cross_term(self, acc1: Accumulator,
                            acc2: Accumulator, r: int) -> 'G1Point':
        """Cross term 계산"""
        pass

    def _final_pairing_check(self, acc: Accumulator) -> bool:
        """최종 pairing 검증"""
        pass

    def _fiat_shamir_challenge(self, data: List) -> int:
        """Fiat-Shamir challenge 생성"""
        pass

    def _g1_add(self, p1: 'G1Point', p2: 'G1Point') -> 'G1Point':
        pass

    def _g1_scalar_mul(self, p: 'G1Point', s: int) -> 'G1Point':
        pass
```

### 5.3 Tree-based Recursion

```python
from typing import List, Optional
from dataclasses import dataclass

@dataclass
class TreeNode:
    """재귀 트리의 노드"""
    proof: Optional['SNARKProof']
    public_input: List[int]
    left: Optional['TreeNode']
    right: Optional['TreeNode']


class TreeRecursion:
    """
    Tree 구조 재귀 증명

    장점:
    - 병렬화 가능
    - log(n) depth
    - 분산 증명 생성
    """

    def __init__(self, snark: 'RecursiveSNARK'):
        self.snark = snark

    def aggregate(self, proofs: List['SNARKProof']) -> 'SNARKProof':
        """
        여러 증명을 트리 구조로 집계

        예: 8개 증명

            Layer 0:  p0  p1  p2  p3  p4  p5  p6  p7
                       \  /    \  /    \  /    \  /
            Layer 1:   p01     p23     p45     p67
                         \     /         \     /
            Layer 2:      p0123          p4567
                             \            /
            Layer 3:           final_proof
        """
        if len(proofs) == 0:
            raise ValueError("No proofs to aggregate")

        if len(proofs) == 1:
            return proofs[0]

        # 2의 거듭제곱으로 패딩
        padded = self._pad_to_power_of_2(proofs)

        # Bottom-up aggregation
        current_layer = padded

        while len(current_layer) > 1:
            next_layer = []

            for i in range(0, len(current_layer), 2):
                left = current_layer[i]
                right = current_layer[i + 1]

                # 두 증명을 하나로 결합
                combined = self._combine_proofs(left, right)
                next_layer.append(combined)

            current_layer = next_layer

        return current_layer[0]

    def aggregate_parallel(self, proofs: List['SNARKProof']) -> 'SNARKProof':
        """
        병렬 트리 집계

        같은 layer의 노드들은 병렬로 처리 가능
        """
        import concurrent.futures

        padded = self._pad_to_power_of_2(proofs)
        current_layer = padded

        while len(current_layer) > 1:
            pairs = [(current_layer[i], current_layer[i+1])
                     for i in range(0, len(current_layer), 2)]

            # 병렬 처리
            with concurrent.futures.ProcessPoolExecutor() as executor:
                next_layer = list(executor.map(
                    lambda p: self._combine_proofs(p[0], p[1]),
                    pairs
                ))

            current_layer = next_layer

        return current_layer[0]

    def _combine_proofs(self,
                        left: 'SNARKProof',
                        right: 'SNARKProof') -> 'SNARKProof':
        """
        두 증명을 검증하고 결합하는 새 증명 생성

        회로 내용:
        1. Verify(vk, left.public_input, left.proof) = 1
        2. Verify(vk, right.public_input, right.proof) = 1
        3. combined_input = Hash(left.public_input || right.public_input)
        """
        combined_input = self._hash_combine(
            left.public_input,
            right.public_input
        )

        # 재귀 회로에서 두 증명 검증
        combined_witness = {
            'left_proof': left,
            'right_proof': right
        }

        return self.snark.prove(combined_input, combined_witness)

    def _pad_to_power_of_2(self, proofs: List['SNARKProof']) -> List['SNARKProof']:
        """2의 거듭제곱 크기로 패딩 (dummy proof 추가)"""
        n = len(proofs)
        target = 1
        while target < n:
            target *= 2

        # Dummy proofs 추가
        dummy = self._create_dummy_proof()
        return proofs + [dummy] * (target - n)

    def _create_dummy_proof(self) -> 'SNARKProof':
        """항상 유효한 dummy proof 생성"""
        pass

    def _hash_combine(self,
                      left_input: List[int],
                      right_input: List[int]) -> List[int]:
        """두 입력을 해시로 결합"""
        pass
```

---

## 6. 실제 응용 사례

### 6.1 zkRollup

```
zkRollup에서의 Recursive Proof:

L2 Transaction 처리:
tx_1, tx_2, ..., tx_1000 (배치)
    ↓
Batch Proof (1000개 tx 유효성)
    ↓
Recursive Aggregation (여러 배치 결합)
    ↓
Final Proof (L1에 제출)

효율성:
- L1 제출: 단일 증명 (가스비 최소화)
- L2 처리: 병렬 증명 생성 가능
- 검증: O(1) 시간

Polygon zkEVM:
- FFLONK 기반
- 재귀로 여러 배치 압축
- L1 호환 증명 생성
```

### 6.2 zkBridge

```
Cross-chain Recursive Proofs:

Chain A                    Chain B
   |                          |
   | tx on A                  |
   ↓                          |
proof_A: "tx valid on A"      |
   |                          |
   |     (relay proof)        |
   +------------------------→ |
                              ↓
            proof_B: "proof_A valid ∧ state updated on B"
                              |
                              ↓
                        Execute on B

장점:
- Trust-minimized bridging
- Light client 불필요
- 즉각적인 최종성 증명
```

### 6.3 zkVM

```
zkVM Recursion 패턴:

프로그램 실행:
instruction_1 → instruction_2 → ... → instruction_n
    ↓              ↓                      ↓
 proof_1        proof_2    ...        proof_n
    ↓              ↓                      ↓
    └──────────────┴──────────────────────┘
                   ↓
              final_proof

RISC Zero:
- RISC-V 명령어 세트 지원
- Segment 단위 증명 생성
- Recursive composition으로 전체 실행 증명

SP1 (Succinct):
- Plonky3 기반
- 고성능 재귀
- Rust 프로그램 직접 증명
```

---

## 7. 성능 분석

### 7.1 Overhead 분석

```
Recursive Proof Overhead:

Non-recursive (base):
- Prover: T_base
- Proof size: S_base
- Verifier: V_base

Recursive (각 단계):
- Prover: T_base + T_verify_circuit
- Proof size: S_recursive (보통 S_base와 유사)
- Verifier: V_base (최종 검증만)

T_verify_circuit 비용:
| 시스템 | 추가 constraints |
|--------|-----------------|
| Groth16 in Groth16 | ~300,000 |
| PLONK in PLONK | ~100,000 |
| Accumulation | ~10,000-30,000 |
| Nova folding | ~1,000-5,000 |

Trade-off:
- 더 많은 단계 = 더 많은 prover 비용
- 하지만 최종 증명 크기/검증 시간 일정
```

### 7.2 최적화 전략

```
1. Batching Before Recursion
   - 최대한 많은 계산을 base proof에 포함
   - 재귀 횟수 최소화

2. Parallel Tree Aggregation
   - 독립 증명들을 병렬 처리
   - depth = log(n)

3. Accumulation Scheme 활용
   - Pairing을 최종 단계로 지연
   - 중간 단계는 가벼운 연산만

4. Specialized Circuits
   - 재귀 전용 최적화 회로
   - 불필요한 검증 요소 제거

5. Hardware Acceleration
   - GPU/FPGA로 MSM 가속
   - 병렬 증명 생성
```

---

## 8. 보안 고려사항

### 8.1 Soundness 보존

```
재귀 Soundness:

요구사항:
- 기본 SNARK가 sound
- 재귀 회로가 올바르게 검증 구현
- Fiat-Shamir 변환이 안전

위험:
1. Verifier 회로 버그
   - 잘못된 검증 로직 → 가짜 증명 가능

2. Field 오버플로우
   - Non-native arithmetic 오류

3. Hashing 충돌
   - Public input 해싱 시 충돌 공격

방어:
- 형식 검증 (Formal verification)
- 다중 구현 교차 검증
- 보안 감사
```

### 8.2 Known Attacks

```
1. Recursion Depth Attack
   문제: 매우 깊은 재귀로 DoS
   해결: 최대 깊이 제한, 비용 부과

2. Malformed Proof Attack
   문제: 파싱 오류로 인한 취약점
   해결: 엄격한 입력 검증

3. Timing Attack
   문제: 증명 생성 시간으로 witness 유추
   해결: 상수 시간 구현

4. Grinding Attack
   문제: Fiat-Shamir challenge 조작
   해결: 충분한 엔트로피, 강한 해시
```

---

## 요약

```
Recursive Proofs 핵심:

기본 개념:
- 증명이 증명을 검증
- 무한 계산 → 유한 증명
- IVC, PCD 패러다임

기술적 도전:
- Verifier의 회로 표현 (비용)
- 필드 불일치 (Non-native arithmetic)
- Cycle of curves로 해결

구현 방식:
1. Full Recursion: 완전하지만 비쌈
2. Accumulation: Pairing 지연
3. Tree Recursion: 병렬화 가능

주요 시스템:
- Halo 2: IPA 기반, transparent
- Pickles (Mina): 22KB 블록체인
- Aztec: Grumpkin + BN254 cycle

응용:
- zkRollup 압축
- zkBridge
- zkVM 실행 증명

성능:
- Prover overhead: 10,000-300,000 constraints
- Accumulation으로 대폭 절감 가능
- 최종 증명 크기/검증 시간: O(1)
```
