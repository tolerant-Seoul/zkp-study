# 5.2 Multi-Party Computation (MPC)

## 개요

Multi-Party Computation (MPC)은 여러 참가자가 각자의 비밀 입력을 공개하지 않고 공동으로 함수를 계산할 수 있게 하는 암호학적 프로토콜입니다. ZK와 결합하여 더 강력한 프라이버시 보장 시스템을 구축할 수 있습니다.

## MPC 기본 개념

### 핵심 정의

```
┌─────────────────────────────────────────────────────────────────────┐
│                Multi-Party Computation Overview                      │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  정의: n명의 참가자 P₁, P₂, ..., Pₙ이 각자의 비밀 입력              │
│       x₁, x₂, ..., xₙ을 사용하여 f(x₁, ..., xₙ)을 계산              │
│                                                                      │
│  보안 속성:                                                          │
│  ─────────────────────────────────────────────────────────────────  │
│  1. Correctness (정확성)                                            │
│     • 정직한 참가자는 올바른 출력을 받음                            │
│                                                                      │
│  2. Privacy (프라이버시)                                            │
│     • 참가자는 다른 참가자의 입력을 알 수 없음                      │
│     • 오직 최종 출력만 알 수 있음                                   │
│                                                                      │
│  3. Input Independence (입력 독립성)                                 │
│     • 부정직한 참가자도 정직한 참가자의 입력에                      │
│       의존하는 입력을 선택할 수 없음                                │
│                                                                      │
│  ┌─────────────────────────────────────────────────────────────┐   │
│  │    P₁(x₁)         P₂(x₂)         P₃(x₃)                     │   │
│  │       │              │              │                        │   │
│  │       ▼              ▼              ▼                        │   │
│  │    ┌──────────────────────────────────────┐                  │   │
│  │    │           MPC Protocol               │                  │   │
│  │    │    f(x₁, x₂, x₃) 계산               │                  │   │
│  │    └──────────────────────────────────────┘                  │   │
│  │                      │                                       │   │
│  │                      ▼                                       │   │
│  │              결과 y = f(x₁, x₂, x₃)                         │   │
│  │         (모든 참가자가 y만 알 수 있음)                       │   │
│  └─────────────────────────────────────────────────────────────┘   │
└─────────────────────────────────────────────────────────────────────┘
```

### 보안 모델

```
┌─────────────────────────────────────────────────────────────────────┐
│                    MPC Security Models                               │
├─────────────────────────────────────────────────────────────────────┤
│                                                                      │
│  1. Semi-Honest (Honest-but-Curious) Model                          │
│     ─────────────────────────────────────────────────────────────   │
│     • 참가자는 프로토콜을 정확히 따름                               │
│     • 단, 수신된 메시지로부터 정보 추론 시도                        │
│     • 실제 공격은 하지 않음                                         │
│     • 구현이 더 간단하고 효율적                                     │
│                                                                      │
│  2. Malicious Model                                                  │
│     ─────────────────────────────────────────────────────────────   │
│     • 참가자가 프로토콜에서 임의로 이탈 가능                        │
│     • 잘못된 메시지 전송, 중단 등 가능                              │
│     • 더 강력한 보안, 더 복잡한 구현                                │
│                                                                      │
│  3. Covert Model                                                     │
│     ─────────────────────────────────────────────────────────────   │
│     • 부정행위 시 일정 확률로 탐지됨                                │
│     • Semi-Honest와 Malicious의 중간                                │
│                                                                      │
│  Threshold 설정:                                                     │
│  • t-out-of-n: n명 중 최대 t명이 악의적이어도 안전                  │
│  • Honest Majority: t < n/2                                         │
│  • Dishonest Majority: t < n (모두 악의적일 수 있음)               │
└─────────────────────────────────────────────────────────────────────┘
```

---

## MPC 기본 프로토콜

### Secret Sharing

```python
# Shamir's Secret Sharing
from typing import List, Tuple
import random

class ShamirSecretSharing:
    """
    (t, n) 임계값 비밀 공유

    - n개의 share 생성
    - 최소 t개의 share로 비밀 복원 가능
    - t-1개 이하의 share로는 정보 없음
    """

    def __init__(self, prime: int):
        self.prime = prime  # 유한체 크기

    def share(self, secret: int, threshold: int, num_shares: int) -> List[Tuple[int, int]]:
        """
        비밀을 n개의 share로 분할

        다항식: f(x) = secret + a₁x + a₂x² + ... + a_{t-1}x^{t-1}
        share_i = (i, f(i))
        """
        if threshold > num_shares:
            raise ValueError("Threshold cannot exceed number of shares")

        # 무작위 다항식 계수 생성
        coefficients = [secret] + [
            random.randint(0, self.prime - 1)
            for _ in range(threshold - 1)
        ]

        # 각 참가자의 share 계산
        shares = []
        for i in range(1, num_shares + 1):
            y = self._evaluate_polynomial(coefficients, i)
            shares.append((i, y))

        return shares

    def reconstruct(self, shares: List[Tuple[int, int]], threshold: int) -> int:
        """
        t개의 share로 비밀 복원 (라그랑주 보간)

        f(0) = Σ yᵢ · Πⱼ≠ᵢ (0 - xⱼ) / (xᵢ - xⱼ)
        """
        if len(shares) < threshold:
            raise ValueError(f"Need at least {threshold} shares")

        secret = 0
        for i, (x_i, y_i) in enumerate(shares[:threshold]):
            # 라그랑주 기저 다항식
            numerator = 1
            denominator = 1

            for j, (x_j, _) in enumerate(shares[:threshold]):
                if i != j:
                    numerator = (numerator * (0 - x_j)) % self.prime
                    denominator = (denominator * (x_i - x_j)) % self.prime

            # 모듈러 역원
            lagrange = (numerator * pow(denominator, -1, self.prime)) % self.prime
            secret = (secret + y_i * lagrange) % self.prime

        return secret

    def _evaluate_polynomial(self, coefficients: List[int], x: int) -> int:
        """Horner's method로 다항식 평가"""
        result = 0
        for coef in reversed(coefficients):
            result = (result * x + coef) % self.prime
        return result


# 사용 예시
def demo_secret_sharing():
    prime = 2**127 - 1  # Mersenne prime
    sss = ShamirSecretSharing(prime)

    secret = 12345678
    threshold = 3
    num_shares = 5

    # 비밀 분할
    shares = sss.share(secret, threshold, num_shares)
    print(f"Secret: {secret}")
    print(f"Shares: {shares}")

    # 복원 (3개의 share 사용)
    recovered = sss.reconstruct(shares[:3], threshold)
    print(f"Recovered: {recovered}")
    assert recovered == secret

    # 2개의 share로는 복원 불가 (정보 이론적으로 안전)
    try:
        sss.reconstruct(shares[:2], threshold)
    except ValueError as e:
        print(f"Expected error: {e}")
```

### Additive Secret Sharing

```python
# 가법적 비밀 공유 (2-party)
class AdditiveSecretSharing:
    """
    가법적 비밀 공유

    s = s₁ + s₂ (mod p)

    장점: 덧셈이 매우 효율적
    단점: 모든 share가 필요
    """

    def __init__(self, prime: int):
        self.prime = prime

    def share(self, secret: int, num_parties: int) -> List[int]:
        """비밀을 n개의 가법 share로 분할"""
        shares = [
            random.randint(0, self.prime - 1)
            for _ in range(num_parties - 1)
        ]

        # 마지막 share는 합이 secret이 되도록
        last_share = (secret - sum(shares)) % self.prime
        shares.append(last_share)

        return shares

    def reconstruct(self, shares: List[int]) -> int:
        """모든 share를 더해서 복원"""
        return sum(shares) % self.prime

    def add(self, shares_a: List[int], shares_b: List[int]) -> List[int]:
        """
        로컬 덧셈: 통신 없이 수행 가능!

        [a] + [b] = [a + b]
        각 참가자가 자신의 share끼리 더함
        """
        return [
            (a + b) % self.prime
            for a, b in zip(shares_a, shares_b)
        ]

    def scalar_mul(self, shares: List[int], scalar: int) -> List[int]:
        """
        스칼라 곱셈: 통신 없이 수행 가능!

        c · [a] = [c · a]
        """
        return [(s * scalar) % self.prime for s in shares]
```

### Beaver Triples를 이용한 곱셈

```python
class BeaverTripleMPC:
    """
    Beaver Triple을 이용한 효율적인 MPC 곱셈

    사전에 랜덤 triple (a, b, c)를 생성하여 공유
    c = a · b

    이를 사용하여 [x] · [y] 계산:
    1. [d] = [x] - [a], [e] = [y] - [b] 계산 및 공개
    2. [xy] = d·e + d·[b] + e·[a] + [c]
    """

    def __init__(self, prime: int, num_parties: int):
        self.prime = prime
        self.num_parties = num_parties
        self.ass = AdditiveSecretSharing(prime)

    def generate_triple(self) -> Tuple[List[int], List[int], List[int]]:
        """
        Beaver Triple 생성 (오프라인 단계)
        실제로는 OT (Oblivious Transfer) 등으로 안전하게 생성
        """
        a = random.randint(0, self.prime - 1)
        b = random.randint(0, self.prime - 1)
        c = (a * b) % self.prime

        shares_a = self.ass.share(a, self.num_parties)
        shares_b = self.ass.share(b, self.num_parties)
        shares_c = self.ass.share(c, self.num_parties)

        return shares_a, shares_b, shares_c

    def multiply(
        self,
        shares_x: List[int],
        shares_y: List[int],
        triple: Tuple[List[int], List[int], List[int]]
    ) -> List[int]:
        """
        온라인 곱셈

        1. d = x - a, e = y - b 계산 및 공개
        2. xy = d·e + d·b + e·a + c
        """
        shares_a, shares_b, shares_c = triple

        # Step 1: [d] = [x] - [a], [e] = [y] - [b]
        shares_d = [
            (x - a) % self.prime
            for x, a in zip(shares_x, shares_a)
        ]
        shares_e = [
            (y - b) % self.prime
            for y, b in zip(shares_y, shares_b)
        ]

        # Step 2: 공개 (실제로는 통신 필요)
        d = sum(shares_d) % self.prime
        e = sum(shares_e) % self.prime

        # Step 3: [xy] = d·e + d·[b] + e·[a] + [c]
        # 첫 번째 참가자만 d·e 항 추가
        shares_xy = []
        for i in range(self.num_parties):
            term = (
                (d * shares_b[i]) +
                (e * shares_a[i]) +
                shares_c[i]
            ) % self.prime

            if i == 0:
                term = (term + d * e) % self.prime

            shares_xy.append(term)

        return shares_xy


# 사용 예시: 두 비밀 값의 곱 계산
def demo_beaver_multiplication():
    prime = 2**61 - 1
    num_parties = 3

    mpc = BeaverTripleMPC(prime, num_parties)
    ass = AdditiveSecretSharing(prime)

    # 비밀 입력
    x, y = 7, 11

    # Share 생성
    shares_x = ass.share(x, num_parties)
    shares_y = ass.share(y, num_parties)

    # 오프라인: triple 생성
    triple = mpc.generate_triple()

    # 온라인: 곱셈
    shares_xy = mpc.multiply(shares_x, shares_y, triple)

    # 결과 복원
    result = ass.reconstruct(shares_xy)
    print(f"{x} * {y} = {result}")
    assert result == (x * y) % prime
```

---

## Garbled Circuits

### Yao's Garbled Circuits

```python
import hashlib
from typing import Dict, Tuple, List

class GarbledCircuit:
    """
    Yao's Garbled Circuits

    2-party MPC의 고전적 방법
    - Garbler: 회로를 "garble"하여 암호화
    - Evaluator: garbled circuit을 평가

    각 와이어는 두 개의 랜덤 레이블을 가짐:
    - k⁰: 값 0에 대응
    - k¹: 값 1에 대응
    """

    def __init__(self, security_param: int = 128):
        self.security_param = security_param
        self.key_size = security_param // 8

    def generate_labels(self) -> Tuple[bytes, bytes]:
        """와이어 레이블 쌍 생성"""
        k0 = self._random_bytes(self.key_size)
        k1 = self._random_bytes(self.key_size)
        return k0, k1

    def garble_and_gate(
        self,
        input_labels_a: Tuple[bytes, bytes],
        input_labels_b: Tuple[bytes, bytes],
        output_labels: Tuple[bytes, bytes]
    ) -> List[bytes]:
        """
        AND 게이트 garbling

        진리표:
        a=0, b=0 → 0
        a=0, b=1 → 0
        a=1, b=0 → 0
        a=1, b=1 → 1

        각 행을 두 입력 레이블로 암호화
        """
        k_a0, k_a1 = input_labels_a
        k_b0, k_b1 = input_labels_b
        k_out0, k_out1 = output_labels

        # 4개의 암호화된 엔트리
        table = [
            self._encrypt(k_a0, k_b0, k_out0),  # 0 AND 0 = 0
            self._encrypt(k_a0, k_b1, k_out0),  # 0 AND 1 = 0
            self._encrypt(k_a1, k_b0, k_out0),  # 1 AND 0 = 0
            self._encrypt(k_a1, k_b1, k_out1),  # 1 AND 1 = 1
        ]

        # 테이블 셔플 (어떤 행이 어떤 입력에 대응하는지 숨김)
        random.shuffle(table)

        return table

    def garble_xor_gate(
        self,
        input_labels_a: Tuple[bytes, bytes],
        input_labels_b: Tuple[bytes, bytes],
        output_labels: Tuple[bytes, bytes]
    ) -> None:
        """
        XOR 게이트 - Free XOR 최적화

        출력 레이블 = 입력 레이블들의 XOR
        garbled table 불필요!
        """
        # Free XOR: k_out = k_a XOR k_b
        # 글로벌 오프셋 Δ 사용
        # k¹ = k⁰ XOR Δ for all wires
        pass

    def evaluate_gate(
        self,
        garbled_table: List[bytes],
        input_label_a: bytes,
        input_label_b: bytes
    ) -> bytes:
        """
        Garbled gate 평가

        올바른 입력 레이블로 테이블의 한 항목만 복호화 가능
        """
        for encrypted_output in garbled_table:
            try:
                output = self._decrypt(input_label_a, input_label_b, encrypted_output)
                return output
            except:
                continue

        raise ValueError("Decryption failed - invalid labels")

    def _encrypt(self, key1: bytes, key2: bytes, plaintext: bytes) -> bytes:
        """이중 암호화: E_{k1}(E_{k2}(plaintext))"""
        combined_key = hashlib.sha256(key1 + key2).digest()
        # 실제로는 AES-GCM 등 사용
        return bytes(a ^ b for a, b in zip(plaintext, combined_key[:len(plaintext)]))

    def _decrypt(self, key1: bytes, key2: bytes, ciphertext: bytes) -> bytes:
        """이중 복호화"""
        combined_key = hashlib.sha256(key1 + key2).digest()
        plaintext = bytes(a ^ b for a, b in zip(ciphertext, combined_key[:len(ciphertext)]))

        # 유효성 검사 (실제로는 MAC 사용)
        if not self._is_valid_label(plaintext):
            raise ValueError("Invalid decryption")

        return plaintext

    def _random_bytes(self, n: int) -> bytes:
        return bytes(random.getrandbits(8) for _ in range(n))

    def _is_valid_label(self, data: bytes) -> bool:
        # 실제로는 point-and-permute 등 사용
        return True
```

### Oblivious Transfer (OT)

```python
class ObliviousTransfer:
    """
    1-out-of-2 Oblivious Transfer

    Sender: 두 메시지 m₀, m₁ 보유
    Receiver: 선택 비트 b 보유

    결과:
    - Receiver: m_b 획득
    - Sender: b를 알 수 없음
    - Receiver: m_{1-b}를 알 수 없음
    """

    def __init__(self, prime: int):
        self.prime = prime
        # 실제로는 타원 곡선 사용
        self.g = 2  # generator

    def sender_setup(self) -> Tuple[int, int]:
        """Sender 초기 설정"""
        # 랜덤 a 선택
        a = random.randint(2, self.prime - 2)
        A = pow(self.g, a, self.prime)  # A = g^a
        return a, A

    def receiver_choose(self, A: int, choice: int) -> Tuple[int, int]:
        """
        Receiver가 선택 수행

        choice = 0: B = g^b
        choice = 1: B = A * g^b = g^(a+b)
        """
        b = random.randint(2, self.prime - 2)

        if choice == 0:
            B = pow(self.g, b, self.prime)
        else:
            B = (A * pow(self.g, b, self.prime)) % self.prime

        return b, B

    def sender_encrypt(
        self,
        a: int,
        B: int,
        m0: bytes,
        m1: bytes
    ) -> Tuple[bytes, bytes]:
        """
        Sender가 두 메시지 암호화

        k₀ = B^a = g^(ab)           (if choice=0)
        k₁ = (B/A)^a = g^((b-a+a)a) = g^(ab)  (if choice=1)

        실제로는 하나만 맞음
        """
        k0 = pow(B, a, self.prime)
        k1 = pow((B * pow(A, -1, self.prime)) % self.prime, a, self.prime)

        e0 = self._xor_encrypt(m0, k0)
        e1 = self._xor_encrypt(m1, k1)

        return e0, e1

    def receiver_decrypt(
        self,
        b: int,
        A: int,
        choice: int,
        e0: bytes,
        e1: bytes
    ) -> bytes:
        """
        Receiver가 선택한 메시지 복호화

        k = A^b = g^(ab)
        """
        k = pow(A, b, self.prime)

        if choice == 0:
            return self._xor_encrypt(e0, k)
        else:
            return self._xor_encrypt(e1, k)

    def _xor_encrypt(self, message: bytes, key: int) -> bytes:
        key_bytes = hashlib.sha256(str(key).encode()).digest()
        return bytes(m ^ k for m, k in zip(message, key_bytes[:len(message)]))


# OT Extension (효율성 향상)
class OTExtension:
    """
    OT Extension

    소수의 기본 OT로부터 많은 OT를 효율적으로 생성
    - κ개의 기본 OT → n개의 OT
    - 통신 복잡도: O(n) 대칭키 연산
    """

    def extend(self, base_ots: int, target_ots: int):
        """
        κ개의 기본 OT를 n개로 확장

        핵심 아이디어:
        1. Receiver가 n×κ 랜덤 행렬 T 선택
        2. 각 열에 대해 OT 수행
        3. 행렬 전치로 n개의 OT 획득
        """
        # IKNP OT Extension 또는 KOS Extension 구현
        pass
```

---

## MPC 프레임워크

### MP-SPDZ

```python
# MP-SPDZ 사용 예시 (의사 코드)
"""
MP-SPDZ: 다양한 MPC 프로토콜 구현 프레임워크

지원 프로토콜:
- MASCOT (malicious, dishonest majority)
- SPDZ (malicious, preprocessing)
- Semi-honest protocols
- Shamir-based protocols
"""

# secret_sharing.mpc
program.use_triples(True)

# 각 참가자의 비밀 입력
x = sint.get_input_from(0)  # Party 0의 입력
y = sint.get_input_from(1)  # Party 1의 입력

# MPC 연산
sum_xy = x + y          # 통신 없음
product_xy = x * y      # Beaver triple 사용

# 조건부 연산
result = (x < y).if_else(x, y)  # min(x, y)

# 결과 공개
print_ln("Sum: %s", sum_xy.reveal())
print_ln("Product: %s", product_xy.reveal())
```

### 실제 MP-SPDZ 프로그램

```python
# private_auction.mpc - 비밀 입찰 경매
"""
Sealed-bid 경매를 MPC로 구현
- 각 입찰자는 자신의 입찰가만 알고 있음
- 최고 입찰자와 가격만 공개
- 다른 입찰 정보는 비공개 유지
"""

from Compiler.types import sint, cint, regint, Array

# 참가자 수
NUM_BIDDERS = 4

# 입찰 수집
bids = Array(NUM_BIDDERS, sint)
for i in range(NUM_BIDDERS):
    bids[i] = sint.get_input_from(i)

# 최고 입찰 찾기
max_bid = bids[0]
winner = sint(0)

for i in range(1, NUM_BIDDERS):
    is_higher = bids[i] > max_bid
    max_bid = is_higher.if_else(bids[i], max_bid)
    winner = is_higher.if_else(sint(i), winner)

# 결과 공개
print_ln("Winner: Party %s", winner.reveal())
print_ln("Winning bid: %s", max_bid.reveal())

# 두 번째 가격 경매 (Vickrey)
second_price = sint(0)
for i in range(NUM_BIDDERS):
    is_not_winner = winner != sint(i)
    is_higher = bids[i] > second_price
    update = is_not_winner & is_higher
    second_price = update.if_else(bids[i], second_price)

print_ln("Second price (payment): %s", second_price.reveal())
```

### JIFF (JavaScript)

```javascript
// JIFF: JavaScript MPC 프레임워크
const JIFFClient = require('jiff-mpc');

// 클라이언트 설정
const jiffClient = new JIFFClient('http://localhost:8080', 'auction', {
    party_count: 4,
    crypto_provider: true,
    onConnect: runAuction,
});

async function runAuction() {
    // 비밀 입찰 공유
    const myBid = 100;  // 나의 입찰가
    const shares = jiffClient.share(myBid);

    // 모든 참가자의 share 수집
    const allShares = [];
    for (let i = 1; i <= 4; i++) {
        allShares.push(shares[i]);
    }

    // 최대값 찾기 (MPC)
    let maxShare = allShares[0];
    let winnerShare = jiffClient.share(1)[1];

    for (let i = 1; i < allShares.length; i++) {
        const isGreater = allShares[i].gt(maxShare);
        maxShare = isGreater.if_else(allShares[i], maxShare);
        winnerShare = isGreater.if_else(
            jiffClient.share(i + 1)[1],
            winnerShare
        );
    }

    // 결과 공개
    const winner = await jiffClient.open(winnerShare);
    const winningBid = await jiffClient.open(maxShare);

    console.log(`Winner: Party ${winner}, Bid: ${winningBid}`);

    jiffClient.disconnect();
}
```

---

## MPC + ZK 결합

### ZK-Friendly MPC

```python
class ZKFriendlyMPC:
    """
    ZK와 MPC의 결합

    사용 사례:
    1. MPC 출력의 정확성을 ZK로 증명
    2. ZK Trusted Setup을 MPC로 수행
    3. 프라이버시 보존 스마트 컨트랙트
    """

    def mpc_then_zk(self, parties_inputs):
        """
        Pattern 1: MPC 계산 후 ZK 증명

        1. MPC로 공동 계산 수행
        2. 결과에 대한 ZK 증명 생성
        3. 검증자는 MPC 참여 없이 결과 검증
        """
        # MPC 단계
        mpc_result = self.run_mpc(parties_inputs)

        # ZK 단계 - 결과가 올바르게 계산되었음을 증명
        proof = self.generate_zk_proof(mpc_result)

        return mpc_result, proof

    def mpc_in_the_head(self, statement, witness):
        """
        Pattern 2: MPC-in-the-Head (MitH)

        가상의 MPC를 "머릿속에서" 시뮬레이션
        일부 참가자의 뷰를 공개하여 정확성 증명

        예: ZKBoo, Ligero, KKW
        """
        num_parties = 3

        # 가상 MPC 시뮬레이션
        views = []
        for i in range(num_parties):
            view = self.simulate_party(i, witness)
            views.append(view)

        # Fiat-Shamir로 챌린지 생성
        challenge = hash(views)  # 어떤 뷰를 공개할지

        # 선택된 뷰 공개 (n-1개)
        opened_views = [views[i] for i in range(num_parties) if i != challenge % num_parties]

        return MitHProof(views=opened_views, challenge=challenge)

    def zk_trusted_setup_mpc(self, circuit):
        """
        Pattern 3: ZK Trusted Setup을 MPC로 수행

        Powers of Tau 세레모니
        - 각 참가자가 τ의 일부를 제공
        - 한 명만 정직하면 안전
        """
        # 각 참가자의 기여
        contributions = []
        for party in self.parties:
            tau_share = party.sample_tau()
            contributions.append(tau_share)

        # 기여 결합 (곱셈)
        tau = 1
        for share in contributions:
            tau = (tau * share) % self.prime

        # SRS 생성
        srs = self.generate_srs(tau)

        # tau 삭제 (각 참가자가 자신의 share 삭제)
        for party in self.parties:
            party.delete_tau_share()

        return srs
```

### Collaborative zkSNARK

```rust
// 협력적 zkSNARK 생성
// 여러 참가자가 공동으로 증명 생성

struct CollaborativeProver {
    parties: Vec<Party>,
    mpc_backend: MPCBackend,
}

impl CollaborativeProver {
    /// 분산 witness로 공동 증명 생성
    fn collaborative_prove(
        &self,
        circuit: &Circuit,
        distributed_witness: &DistributedWitness,
    ) -> Proof {
        // 1. 각 참가자의 witness share 수집
        let witness_shares: Vec<_> = self.parties.iter()
            .map(|p| p.get_witness_share())
            .collect();

        // 2. MPC로 witness 다항식 계산
        let witness_poly_shares = self.mpc_backend
            .compute_witness_polynomial(witness_shares);

        // 3. 분산 MSM으로 commitment 계산
        let commitments = self.distributed_msm(witness_poly_shares);

        // 4. MPC로 증명 요소 계산
        let proof_elements = self.mpc_backend
            .compute_proof_elements(commitments);

        // 5. 증명 조합
        self.combine_proof(proof_elements)
    }

    fn distributed_msm(&self, poly_shares: Vec<PolyShare>) -> Commitment {
        // 각 참가자가 자신의 share에 대해 부분 MSM 수행
        let partial_results: Vec<_> = self.parties.iter()
            .zip(poly_shares.iter())
            .map(|(party, share)| party.partial_msm(share))
            .collect();

        // 결과 결합
        partial_results.iter().fold(Commitment::identity(), |acc, p| acc + p)
    }
}
```

---

## 실용적 응용

### Threshold Signatures

```python
class ThresholdECDSA:
    """
    (t, n) 임계값 ECDSA

    - n명의 서명자
    - 최소 t명이 협력해야 서명 생성
    - 개인키는 어느 단일 참가자도 알 수 없음
    """

    def __init__(self, threshold: int, num_parties: int):
        self.t = threshold
        self.n = num_parties
        self.curve = secp256k1

    def distributed_key_gen(self) -> Tuple[List[int], int]:
        """
        분산 키 생성 (DKG)

        각 참가자가 비밀 share를 보유
        공개키만 공개됨
        """
        # 각 참가자가 다항식 생성
        polynomials = []
        for i in range(self.n):
            poly = self._random_polynomial(self.t - 1)
            polynomials.append(poly)

        # Share 교환
        shares = []
        for i in range(self.n):
            my_share = sum(
                self._evaluate_poly(poly, i + 1)
                for poly in polynomials
            ) % self.curve.n
            shares.append(my_share)

        # 공개키 계산
        public_key = sum(poly[0] for poly in polynomials) % self.curve.n
        public_key_point = self.curve.G * public_key

        return shares, public_key_point

    def threshold_sign(
        self,
        message: bytes,
        signers: List[int],
        shares: List[int]
    ) -> Tuple[int, int]:
        """
        임계값 서명 생성

        1. 각 서명자가 nonce share 생성
        2. R 포인트 공동 계산
        3. s 값 공동 계산
        """
        if len(signers) < self.t:
            raise ValueError(f"Need at least {self.t} signers")

        # Step 1: Nonce shares
        k_shares = [random.randint(1, self.curve.n - 1) for _ in signers]

        # Step 2: R 계산 (MPC 또는 commitment scheme 사용)
        R_shares = [self.curve.G * k for k in k_shares]
        R = sum(R_shares, self.curve.identity())
        r = R.x % self.curve.n

        # Step 3: s 계산
        z = int.from_bytes(hashlib.sha256(message).digest(), 'big')

        s_shares = []
        for i, (signer_idx, share, k_share) in enumerate(zip(signers, shares, k_shares)):
            # λ: 라그랑주 계수
            lambda_i = self._lagrange_coefficient(signer_idx, signers)

            # s_i = k_i^(-1) * (z + r * x_i * λ_i)
            k_inv = pow(k_share, -1, self.curve.n)
            s_i = (k_inv * (z + r * share * lambda_i)) % self.curve.n
            s_shares.append(s_i)

        # s = Σ s_i
        s = sum(s_shares) % self.curve.n

        return (r, s)
```

### Private Set Intersection (PSI)

```python
class PrivateSetIntersection:
    """
    Private Set Intersection

    두 참가자가 각자의 집합을 공개하지 않고
    교집합만 계산
    """

    def __init__(self, hash_fn=hashlib.sha256):
        self.hash = hash_fn

    def psi_based_on_ot(
        self,
        set_a: List[bytes],
        set_b: List[bytes]
    ) -> List[bytes]:
        """
        OT 기반 PSI (간단한 버전)

        1. 각 원소를 해시
        2. OT로 매칭 확인
        """
        # 간단한 구현 (실제로는 더 복잡한 프로토콜 사용)
        hashed_a = {self.hash(x).digest(): x for x in set_a}
        hashed_b = {self.hash(x).digest() for x in set_b}

        intersection = []
        for h, original in hashed_a.items():
            if h in hashed_b:
                intersection.append(original)

        return intersection

    def psi_cardinality(
        self,
        set_a: List[bytes],
        set_b: List[bytes]
    ) -> int:
        """
        교집합 크기만 반환 (원소는 비공개)
        """
        # 실제로는 Bloom filter + OT 등 사용
        pass
```

---

## 요약

| 구성요소 | 설명 |
|---------|------|
| **Secret Sharing** | 비밀을 여러 share로 분할, threshold만큼 모아야 복원 |
| **Beaver Triples** | 사전 계산된 곱셈 트리플로 효율적인 MPC 곱셈 |
| **Garbled Circuits** | 2-party MPC의 고전적 방법, 회로를 암호화 |
| **Oblivious Transfer** | 선택적 정보 전송, 선택 자체를 숨김 |
| **MPC + ZK** | 협력적 계산 + 검증 가능성 결합 |

### MPC vs ZK 비교

| 특성 | MPC | ZK |
|-----|-----|-----|
| **목적** | 여러 참가자 공동 계산 | 단일 증명자의 지식 증명 |
| **참가자** | 다수 (n ≥ 2) | 증명자 1명 + 검증자 |
| **통신** | 참가자 간 상호작용 | 단방향 (증명자 → 검증자) |
| **입력** | 각자 비밀 입력 | 증명자만 witness 보유 |
| **결과** | 모두 출력 획득 | 검증자는 참/거짓만 알음 |

다음 문서에서는 FHE (Fully Homomorphic Encryption)를 다룹니다.
