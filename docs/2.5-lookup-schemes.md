# 2.5 Lookup Schemes: Plookup, LogUp, Lasso

## 개요

Lookup Argument(룩업 인자)는 ZK 시스템에서 "값이 특정 테이블에 존재한다"는 것을 효율적으로 증명하는 기법이다. 복잡한 연산(비트 연산, 해시 함수, 범위 검증 등)을 미리 계산된 테이블 조회로 대체하여 회로 크기를 대폭 줄일 수 있다.

### 왜 Lookup이 필요한가?

```
문제: 비트 연산의 회로 표현

XOR 연산 a ^ b = c를 산술 회로로 표현:

방법 1: 비트 분해
- a, b를 각각 8비트로 분해: 16개 변수
- 각 비트가 0 또는 1 검증: 16개 constraints
- 비트별 XOR: 8개 constraints
- 결과 재조립: 1개 constraint
- 총: ~25 constraints per XOR

방법 2: Lookup Table
- T = {(0,0,0), (0,1,1), (1,0,1), (1,1,0)} (XOR 테이블)
- "a, b, c가 T에 존재" 증명: ~1-3 constraints
- 효율: 8-25배 개선

실제 사례:
| 연산 | 산술 회로 | Lookup |
|------|----------|--------|
| 8-bit XOR | ~25 | ~3 |
| SHA256 라운드 | ~30,000 | ~3,000 |
| Keccak 라운드 | ~50,000 | ~5,000 |
| Range (n bits) | n | ~1-2 |
```

---

## 1. Lookup의 기본 원리

### 1.1 문제 정의

```
Lookup Argument:

주어진 것:
- Table T = {t_1, t_2, ..., t_N}: 허용된 값들의 집합
- Witness f = {f_1, f_2, ..., f_m}: 조회하려는 값들

증명 목표:
∀i ∈ [1, m]: f_i ∈ T

즉, 모든 조회 값이 테이블에 존재함을 증명

성질:
1. Completeness: 모든 f_i가 T에 있으면 검증 통과
2. Soundness: f_i 중 하나라도 T에 없으면 검증 실패
3. Zero-Knowledge: f가 무엇인지 노출하지 않음
```

### 1.2 Multiset Equality

```
핵심 아이디어: Multiset (다중집합) 동등성

f ⊆ T를 증명하려면:
1. f의 각 원소가 T에 있음
2. T의 각 원소가 f에서 사용된 횟수 추적

정렬된 병합:
s = sort(f ∪ T)

s는 f와 T의 모든 원소를 포함하며 정렬됨

유효성 조건:
- s의 연속된 원소들: s_i = s_{i+1} 또는 s_{i+1} ∈ T
- 새 값이 나타나면 반드시 T의 원소여야 함

예시:
T = {1, 2, 3}
f = {2, 1, 2, 3, 1}
s = sort(f ∪ T) = {1, 1, 1, 2, 2, 2, 3, 3}

검증:
- 1→1: 같음 ✓
- 1→1: 같음 ✓
- 1→2: 다름, 2 ∈ T ✓
- 2→2: 같음 ✓
- 2→2: 같음 ✓
- 2→3: 다름, 3 ∈ T ✓
- 3→3: 같음 ✓
```

### 1.3 Grand Product Argument

```
다항식 동등성으로 multiset 검증:

두 집합 A, B가 같다 ⟺
∏(X - a_i) = ∏(X - b_j) for all a_i ∈ A, b_j ∈ B

랜덤 γ를 사용한 확률적 검증:
∏(γ - a_i) / ∏(γ - b_j) = 1

Schwartz-Zippel lemma에 의해:
- 등식이 성립할 확률 ≈ 1 (두 집합이 같으면)
- 등식이 성립할 확률 ≈ 0 (두 집합이 다르면)
```

---

## 2. Plookup

### 2.1 개요

Plookup (2020, Gabizon & Williamson)은 PLONK 기반 ZK 시스템을 위한 최초의 실용적 lookup argument이다.

### 2.2 프로토콜 구조

```
Plookup 관계:

입력:
- f = (f_1, ..., f_n): 조회 값들 (다항식)
- t = (t_1, ..., t_d): 테이블 (다항식)

정렬된 집합:
s = (s_1, ..., s_{n+d}): f와 t의 정렬된 병합

증명 목표:
1. s는 f ∪ t의 정렬
2. s의 원소들이 연속적으로 같거나, 변경점이 t에 존재

Grand Product:
Z(X) 정의:

Z(1) = 1
Z(ω^{i+1}) = Z(ω^i) * [(1+β) * f_i + γ] * [(1+β) * t_i + γ] /
                      [(s_i + β*s_{i+1} + γ) * (1 + β)]

최종 검증:
Z(ω^n) = 1
```

### 2.3 수학적 상세

```
Plookup 다항식 관계:

정의:
β, γ: 랜덤 챌린지
f(X): 조회 다항식
t(X): 테이블 다항식
s(X): 정렬된 다항식

Accumulator Z(X):

Z(ω^{i+1}) / Z(ω^i) =
    [(1 + β) * (γ + f(ω^i)) * (γ(1+β) + t(ω^i) + β*t(ω^{i+1}))] /
    [(γ(1+β) + s(ω^i) + β*s(ω^{i+1})) * (γ(1+β) + s(ω^{i+n}) + β*s(ω^{i+n+1}))]

분자 설명:
- (1 + β)(γ + f_i): 조회 값 기여
- (γ(1+β) + t_i + β*t_{i+1}): 테이블 쌍 기여

분모 설명:
- 두 개의 s 쌍 (정렬된 집합에서)
- 연속성 검증

경계 조건:
- Z(1) = 1 (시작)
- Z(ω^n) = 1 (순환 완료)
```

### 2.4 Python 구현

```python
from dataclasses import dataclass
from typing import List, Tuple
import random

@dataclass
class PlookupProof:
    """Plookup 증명 구조"""
    # Commitments
    f_commit: 'G1Point'      # 조회 다항식
    s_commit: 'G1Point'      # 정렬된 다항식
    z_commit: 'G1Point'      # Accumulator

    # Evaluations at zeta
    f_eval: int
    t_eval: int
    t_next_eval: int  # t(ω*ζ)
    s_eval: int
    s_next_eval: int  # s(ω*ζ)
    z_eval: int
    z_next_eval: int  # z(ω*ζ)

    # Opening proofs
    w_zeta: 'G1Point'
    w_omega_zeta: 'G1Point'


class PlookupProver:
    """Plookup Prover"""

    def __init__(self, srs: 'SRS', table: List[int]):
        self.srs = srs
        self.table = sorted(table)  # 테이블 정렬
        self.n = len(table)
        self.omega = self._get_root_of_unity(self.n * 2)  # f + t 크기
        self.field_modulus = self._get_field_modulus()

    def prove(self, lookups: List[int]) -> PlookupProof:
        """
        Plookup 증명 생성

        Args:
            lookups: 테이블에서 조회할 값들

        Returns:
            PlookupProof
        """
        # 1. 정렬된 다중집합 생성
        s = self._create_sorted_multiset(lookups, self.table)

        # 2. 다항식 보간
        f_poly = self._interpolate(lookups)
        t_poly = self._interpolate(self.table)
        s_poly = self._interpolate(s)

        # 3. Commitments
        f_commit = self.srs.commit(f_poly)
        s_commit = self.srs.commit(s_poly)

        # 4. Challenge 생성 (Fiat-Shamir)
        transcript = self._init_transcript()
        transcript.append(f_commit, s_commit)
        beta = transcript.challenge('beta')
        gamma = transcript.challenge('gamma')

        # 5. Accumulator Z(X) 계산
        z_poly = self._compute_accumulator(f_poly, t_poly, s_poly, beta, gamma)
        z_commit = self.srs.commit(z_poly)

        # 6. Quotient 및 opening
        transcript.append(z_commit)
        zeta = transcript.challenge('zeta')

        # 7. Evaluations
        f_eval = f_poly.evaluate(zeta)
        t_eval = t_poly.evaluate(zeta)
        t_next_eval = t_poly.evaluate(zeta * self.omega)
        s_eval = s_poly.evaluate(zeta)
        s_next_eval = s_poly.evaluate(zeta * self.omega)
        z_eval = z_poly.evaluate(zeta)
        z_next_eval = z_poly.evaluate(zeta * self.omega)

        # 8. Opening proofs
        w_zeta, w_omega_zeta = self._compute_openings(
            [f_poly, t_poly, s_poly, z_poly], zeta)

        return PlookupProof(
            f_commit=f_commit, s_commit=s_commit, z_commit=z_commit,
            f_eval=f_eval, t_eval=t_eval, t_next_eval=t_next_eval,
            s_eval=s_eval, s_next_eval=s_next_eval,
            z_eval=z_eval, z_next_eval=z_next_eval,
            w_zeta=w_zeta, w_omega_zeta=w_omega_zeta
        )

    def _create_sorted_multiset(self,
                                 lookups: List[int],
                                 table: List[int]) -> List[int]:
        """
        f와 t의 정렬된 병합 생성

        조건: s에서 연속된 쌍 (s_i, s_{i+1})은
              같거나, s_{i+1}이 t에서 처음 나타나는 값
        """
        # Multiset 생성
        combined = lookups + table

        # 정렬
        s = sorted(combined)

        # 유효성 검증
        for i in range(len(s) - 1):
            if s[i] != s[i + 1]:
                # 변경점은 테이블에 있어야 함
                assert s[i + 1] in table, f"Invalid lookup: {s[i+1]} not in table"

        return s

    def _compute_accumulator(self,
                              f: 'Polynomial',
                              t: 'Polynomial',
                              s: 'Polynomial',
                              beta: int,
                              gamma: int) -> 'Polynomial':
        """
        Accumulator Z(X) 계산

        Z(ω^{i+1}) = Z(ω^i) * numerator / denominator
        """
        z_values = [1]  # Z(1) = 1

        for i in range(self.n - 1):
            omega_i = pow(self.omega, i, self.field_modulus)
            omega_i_next = pow(self.omega, i + 1, self.field_modulus)

            f_i = f.evaluate(omega_i)
            t_i = t.evaluate(omega_i)
            t_i_next = t.evaluate(omega_i_next)
            s_i = s.evaluate(omega_i)
            s_i_next = s.evaluate(omega_i_next)

            # Numerator
            num1 = (1 + beta) * (gamma + f_i)
            num2 = gamma * (1 + beta) + t_i + beta * t_i_next
            numerator = (num1 * num2) % self.field_modulus

            # Denominator
            denom1 = gamma * (1 + beta) + s_i + beta * s_i_next
            # s의 후반부 (n 이후)
            s_i_n = s.evaluate(pow(self.omega, i + self.n, self.field_modulus))
            s_i_n_next = s.evaluate(pow(self.omega, i + self.n + 1, self.field_modulus))
            denom2 = gamma * (1 + beta) + s_i_n + beta * s_i_n_next
            denominator = (denom1 * denom2) % self.field_modulus

            # 다음 Z 값
            z_next = (z_values[-1] * numerator *
                      pow(denominator, -1, self.field_modulus)) % self.field_modulus
            z_values.append(z_next)

        # 마지막 값은 1이어야 함 (순환)
        assert z_values[-1] == 1, "Accumulator cycle failed"

        return self._interpolate(z_values)

    # Helper methods
    def _interpolate(self, values: List[int]) -> 'Polynomial':
        """다항식 보간"""
        pass

    def _get_root_of_unity(self, n: int) -> int:
        """n차 단위근"""
        pass

    def _get_field_modulus(self) -> int:
        """필드 모듈러스"""
        pass

    def _init_transcript(self) -> 'Transcript':
        pass

    def _compute_openings(self, polys: List['Polynomial'],
                          zeta: int) -> Tuple['G1Point', 'G1Point']:
        pass


class PlookupVerifier:
    """Plookup Verifier"""

    def __init__(self, srs: 'SRS', table_commit: 'G1Point'):
        self.srs = srs
        self.table_commit = table_commit

    def verify(self, proof: PlookupProof) -> bool:
        """Plookup 증명 검증"""

        # 1. Transcript 재구성
        transcript = self._init_transcript()
        transcript.append(proof.f_commit, proof.s_commit)
        beta = transcript.challenge('beta')
        gamma = transcript.challenge('gamma')

        transcript.append(proof.z_commit)
        zeta = transcript.challenge('zeta')

        # 2. Accumulator 관계 검증
        # Z(ω*ζ) / Z(ζ) = numerator / denominator

        one_plus_beta = 1 + beta
        gamma_one_plus_beta = gamma * one_plus_beta

        numerator = (one_plus_beta * (gamma + proof.f_eval) *
                    (gamma_one_plus_beta + proof.t_eval + beta * proof.t_next_eval))

        denominator = ((gamma_one_plus_beta + proof.s_eval + beta * proof.s_next_eval) *
                      (gamma_one_plus_beta + proof.s_eval + beta * proof.s_next_eval))

        expected_ratio = (numerator * pow(denominator, -1, self.field_modulus)) % self.field_modulus
        actual_ratio = (proof.z_next_eval * pow(proof.z_eval, -1, self.field_modulus)) % self.field_modulus

        if expected_ratio != actual_ratio:
            return False

        # 3. Boundary check: Z(1) = 1, Z(ω^n) = 1
        # (Lagrange basis로 검증)

        # 4. Opening proof 검증
        return self._verify_openings(proof, zeta)

    def _verify_openings(self, proof: PlookupProof, zeta: int) -> bool:
        """KZG opening 검증"""
        pass

    def _init_transcript(self) -> 'Transcript':
        pass
```

### 2.5 Plookup 비용 분석

```
Plookup Overhead:

Prover 비용:
- 정렬: O((n + d) log(n + d))
- 다항식 보간: O(n log n) FFT
- Commitment: O(n) MSM
- 총: O(n log n)

Proof 크기:
- 3 commitments (f, s, z)
- 7 field elements (evaluations)
- 2 opening proofs
- ~400 bytes 추가

Verifier 비용:
- 2-3 pairing checks
- O(1) field operations
- ~2ms 추가

Trade-off:
| 시나리오 | 산술 회로 | Plookup | 절감 |
|----------|----------|---------|------|
| 8-bit range | 8 constraints | 1 lookup | 8x |
| 16-bit range | 16 constraints | 1 lookup | 16x |
| SHA256 | ~30K constraints | ~3K | 10x |
| Keccak | ~50K constraints | ~5K | 10x |
```

---

## 3. LogUp

### 3.1 개요

LogUp (Logarithmic Lookup, 2022, Haboeck)은 Plookup의 개선 버전으로, 로그 미분(logarithmic derivative)을 사용하여 더 효율적인 lookup을 제공한다.

### 3.2 핵심 아이디어

```
Logarithmic Derivative 접근:

기본 관찰:
∏(X - a_i) = ∏(X - b_j)

양변에 로그 미분:
Σ 1/(X - a_i) = Σ 1/(X - b_j)

장점:
- 곱셈 → 덧셈 (더 간단한 회로)
- Multiplicity 자연스럽게 처리
- 여러 테이블 동시 처리 용이

Multiplicity 처리:
테이블 원소 t가 m번 조회되면:
Σ m_i / (X - t_i) = Σ 1 / (X - f_j)

왼쪽: 테이블 기여 (multiplicity m_i)
오른쪽: 조회 기여
```

### 3.3 프로토콜 상세

```
LogUp 관계:

입력:
- f = {f_1, ..., f_n}: 조회 값들
- t = {t_1, ..., t_d}: 테이블
- m = {m_1, ..., m_d}: multiplicity (각 t_i가 조회된 횟수)

랜덤 챌린지: β

검증 등식:
Σ_{i=1}^{d} m_i / (β - t_i) = Σ_{j=1}^{n} 1 / (β - f_j)

다항식 형태:
m(X): multiplicity 다항식 (t의 evaluation domain)
f(X): 조회 다항식

Σ m(ω^i) / (β - t(ω^i)) = Σ 1 / (β - f(ω^j))

Accumulator 다항식:
h(X) = Σ m_i * L_i(X) / (β - t_i)

여기서 L_i는 Lagrange basis
```

### 3.4 Python 구현

```python
from dataclasses import dataclass
from typing import List, Dict, Tuple

@dataclass
class LogUpProof:
    """LogUp 증명 구조"""
    # Commitments
    m_commit: 'G1Point'      # Multiplicity 다항식
    h_commit: 'G1Point'      # Accumulator

    # Evaluations
    m_eval: int
    h_eval: int
    f_eval: int
    t_eval: int

    # Opening proof
    opening: 'G1Point'


class LogUpProver:
    """LogUp Prover"""

    def __init__(self, srs: 'SRS', table: List[int]):
        self.srs = srs
        self.table = table
        self.d = len(table)
        self.field_modulus = self._get_field_modulus()

    def prove(self, lookups: List[int]) -> LogUpProof:
        """
        LogUp 증명 생성

        Args:
            lookups: 조회 값들

        Returns:
            LogUpProof
        """
        n = len(lookups)

        # 1. Multiplicity 계산
        multiplicity = self._compute_multiplicity(lookups)

        # 2. Challenge 생성
        transcript = self._init_transcript()
        beta = transcript.challenge('beta')

        # 3. 등식 검증 (내부)
        # Σ m_i / (β - t_i) = Σ 1 / (β - f_j)

        lhs = sum(
            multiplicity.get(t, 0) * pow(beta - t, -1, self.field_modulus)
            for t in self.table
        ) % self.field_modulus

        rhs = sum(
            pow(beta - f, -1, self.field_modulus)
            for f in lookups
        ) % self.field_modulus

        assert lhs == rhs, "Lookup verification failed"

        # 4. Multiplicity 다항식
        m_values = [multiplicity.get(t, 0) for t in self.table]
        m_poly = self._interpolate(m_values)
        m_commit = self.srs.commit(m_poly)

        # 5. Accumulator 다항식 h(X)
        # h(X) = Σ m_i / (β - t_i) 를 부분합으로 표현
        h_poly = self._compute_logup_accumulator(m_values, beta)
        h_commit = self.srs.commit(h_poly)

        # 6. Evaluations
        zeta = transcript.challenge('zeta')
        m_eval = m_poly.evaluate(zeta)
        h_eval = h_poly.evaluate(zeta)

        # 7. Opening proof
        opening = self._compute_opening([m_poly, h_poly], zeta)

        return LogUpProof(
            m_commit=m_commit, h_commit=h_commit,
            m_eval=m_eval, h_eval=h_eval,
            f_eval=0,  # simplified
            t_eval=0,
            opening=opening
        )

    def _compute_multiplicity(self, lookups: List[int]) -> Dict[int, int]:
        """각 테이블 원소가 몇 번 조회되었는지 계산"""
        multiplicity = {}
        for f in lookups:
            if f not in self.table:
                raise ValueError(f"Lookup value {f} not in table")
            multiplicity[f] = multiplicity.get(f, 0) + 1
        return multiplicity

    def _compute_logup_accumulator(self,
                                    multiplicities: List[int],
                                    beta: int) -> 'Polynomial':
        """
        LogUp accumulator 계산

        h_i = Σ_{j≤i} m_j / (β - t_j)
        """
        h_values = []
        running_sum = 0

        for i, (m_i, t_i) in enumerate(zip(multiplicities, self.table)):
            if m_i > 0:
                running_sum += m_i * pow(beta - t_i, -1, self.field_modulus)
                running_sum %= self.field_modulus
            h_values.append(running_sum)

        return self._interpolate(h_values)

    # Helper methods
    def _interpolate(self, values: List[int]) -> 'Polynomial':
        pass

    def _get_field_modulus(self) -> int:
        pass

    def _init_transcript(self) -> 'Transcript':
        pass

    def _compute_opening(self, polys: List['Polynomial'],
                         point: int) -> 'G1Point':
        pass


class LogUpVerifier:
    """LogUp Verifier"""

    def verify(self, proof: LogUpProof, table_info: dict) -> bool:
        """
        LogUp 증명 검증

        핵심: Σ m_i / (β - t_i) = Σ 1 / (β - f_j)
        """
        # 1. Challenge 재생성
        transcript = self._init_transcript()
        beta = transcript.challenge('beta')
        zeta = transcript.challenge('zeta')

        # 2. Accumulator 관계 검증
        # h(ω^{i+1}) - h(ω^i) = m_i / (β - t_i)

        # 3. 최종 합계 검증
        # h(ω^{d-1}) = Σ 1 / (β - f_j)

        # 4. Opening 검증
        return self._verify_opening(proof)
```

### 3.5 LogUp vs Plookup

```
비교 분석:

| 특성 | Plookup | LogUp |
|------|---------|-------|
| 기반 기술 | Grand Product | Log Derivative |
| 정렬 필요 | Yes | No |
| Multiplicity | 암시적 | 명시적 |
| 다중 테이블 | 복잡 | 간단 |
| Prover 비용 | O(n log n) | O(n) |
| 회로 복잡도 | 높음 | 낮음 |

LogUp 장점:
1. 정렬 불필요 → Prover 효율 향상
2. 다중 테이블 자연스럽게 지원
3. 덧셈 기반 → 회로 친화적
4. Multiplicity 명시적 → 디버깅 용이

Plookup 장점:
1. 더 성숙한 구현체
2. PLONK과의 통합 용이
3. 작은 테이블에서 효율적
```

---

## 4. Lasso

### 4.1 개요

Lasso (2023, Setty et al.)는 "Lookup Arguments with Sublinear prover time"의 약자로, 대규모 테이블에서도 서브리니어 prover 시간을 달성하는 혁신적인 lookup scheme이다.

### 4.2 핵심 혁신: Sparse Polynomial Commitment

```
문제: 대규모 테이블

기존 방식:
- 테이블 크기 N
- Prover 시간: O(N)
- 테이블이 크면 비효율적

예시:
- 2^32 엔트리 테이블 (4GB)
- 하지만 실제 조회는 1000번만
- 전체 테이블 처리 불필요

Lasso 접근:
- Sparse representation
- 조회된 엔트리만 처리
- Prover 시간: O(m * log N)
  (m: 조회 수, N: 테이블 크기)

구조화된 테이블:
- 테이블을 다차원 구조로 분해
- Tensor product 활용
- 서브테이블 조합으로 대규모 테이블 표현
```

### 4.3 Tensor 구조

```
테이블 분해:

크기 N = c^k 테이블을 k개의 크기 c 서브테이블로 분해

예시: N = 256 = 4^4

T = T_1 ⊗ T_2 ⊗ T_3 ⊗ T_4

각 T_i: 크기 4

전체 테이블 T의 엔트리:
T[i_1, i_2, i_3, i_4] = combine(T_1[i_1], T_2[i_2], T_3[i_3], T_4[i_4])

combine 함수:
- XOR: T_1[i_1] ^ T_2[i_2] ^ T_3[i_3] ^ T_4[i_4]
- AND: T_1[i_1] & T_2[i_2] & T_3[i_3] & T_4[i_4]
- Range: i_1 * 64 + i_2 * 16 + i_3 * 4 + i_4

효율:
- 저장: O(k * c) 대신 O(c^k)
- 조회: O(k) 대신 O(N)
```

### 4.4 Surge 프로토콜

```
Lasso의 핵심 프로토콜: Surge

1. Decomposition
   조회 값 v를 k개 컴포넌트로 분해:
   v = (v_1, v_2, ..., v_k)

2. Subtable Lookup
   각 서브테이블에서 개별 조회:
   r_i = T_i[v_i] for i = 1, ..., k

3. Combination Proof
   결과 조합이 올바른지 증명:
   result = combine(r_1, r_2, ..., r_k)

4. Sparse Commitment
   실제 조회된 엔트리만 commit
   → 서브리니어 prover

증명 크기:
- O(k) commitments
- O(k) evaluations
- 테이블 크기와 무관
```

### 4.5 Python 구현 (개념적)

```python
from dataclasses import dataclass
from typing import List, Tuple, Callable
from functools import reduce

@dataclass
class LassoProof:
    """Lasso 증명 구조"""
    # Subtable proofs
    subtable_proofs: List['SubtableProof']

    # Combination proof
    combination_proof: 'CombinationProof'

    # Sparse commitment to actual lookups
    sparse_commit: 'G1Point'


@dataclass
class SubtableProof:
    """서브테이블 lookup 증명"""
    index_commit: 'G1Point'
    value_commit: 'G1Point'
    multiplicity: List[int]


class LassoProver:
    """Lasso Prover"""

    def __init__(self,
                 subtables: List[List[int]],
                 combine_fn: Callable[[List[int]], int]):
        """
        Args:
            subtables: k개의 서브테이블, 각각 크기 c
            combine_fn: 서브테이블 결과 조합 함수
        """
        self.subtables = subtables
        self.combine_fn = combine_fn
        self.k = len(subtables)
        self.c = len(subtables[0])

    def prove(self, lookups: List[int]) -> LassoProof:
        """
        Lasso 증명 생성

        핵심: O(m * k) 복잡도 (m: 조회 수)
        """
        m = len(lookups)

        # 1. 각 lookup을 k개 인덱스로 분해
        decomposed = [self._decompose(v) for v in lookups]

        # 2. 각 서브테이블에 대한 lookup 증명
        subtable_proofs = []
        for i in range(self.k):
            # i번째 컴포넌트의 모든 인덱스
            indices_i = [d[i] for d in decomposed]

            # 서브테이블 lookup 증명
            proof_i = self._prove_subtable_lookup(
                self.subtables[i],
                indices_i
            )
            subtable_proofs.append(proof_i)

        # 3. Combination 증명
        # combine(T_1[v_1], ..., T_k[v_k]) = result
        combination_proof = self._prove_combination(
            decomposed,
            lookups
        )

        # 4. Sparse commitment (조회된 값들만)
        sparse_commit = self._sparse_commit(lookups)

        return LassoProof(
            subtable_proofs=subtable_proofs,
            combination_proof=combination_proof,
            sparse_commit=sparse_commit
        )

    def _decompose(self, value: int) -> Tuple[int, ...]:
        """
        값을 k개의 서브테이블 인덱스로 분해

        예: 값 173, c=16, k=2
        → (173 // 16, 173 % 16) = (10, 13)
        """
        indices = []
        remaining = value

        for _ in range(self.k):
            indices.append(remaining % self.c)
            remaining //= self.c

        return tuple(reversed(indices))

    def _prove_subtable_lookup(self,
                                subtable: List[int],
                                indices: List[int]) -> SubtableProof:
        """
        단일 서브테이블에 대한 lookup 증명

        크기 c의 테이블에서 indices 조회
        """
        # Multiplicity 계산
        multiplicity = [0] * len(subtable)
        for idx in indices:
            multiplicity[idx] += 1

        # Index polynomial
        index_poly = self._interpolate(indices)
        index_commit = self.srs.commit(index_poly)

        # Value polynomial (subtable[index])
        values = [subtable[idx] for idx in indices]
        value_poly = self._interpolate(values)
        value_commit = self.srs.commit(value_poly)

        return SubtableProof(
            index_commit=index_commit,
            value_commit=value_commit,
            multiplicity=multiplicity
        )

    def _prove_combination(self,
                           decomposed: List[Tuple[int, ...]],
                           expected: List[int]) -> 'CombinationProof':
        """
        서브테이블 결과 조합이 올바른지 증명

        combine(subtable_values) = expected
        """
        for i, (indices, exp) in enumerate(zip(decomposed, expected)):
            # 각 서브테이블에서 값 조회
            subtable_values = [
                self.subtables[j][indices[j]]
                for j in range(self.k)
            ]

            # 조합 결과 검증
            actual = self.combine_fn(subtable_values)
            assert actual == exp, f"Combination mismatch at {i}"

        return self._create_combination_proof(decomposed, expected)

    def _sparse_commit(self, values: List[int]) -> 'G1Point':
        """
        Sparse polynomial commitment

        실제 조회된 값들만 commit
        O(m) 복잡도 (m: 조회 수)
        """
        # 일반 commitment: O(N)
        # Sparse commitment: O(m)

        poly = self._interpolate(values)
        return self.srs.commit(poly)

    # Helper methods
    def _interpolate(self, values: List[int]) -> 'Polynomial':
        pass

    def _create_combination_proof(self,
                                   decomposed: List[Tuple[int, ...]],
                                   expected: List[int]) -> 'CombinationProof':
        pass


# 사용 예시
def example_lasso():
    """Lasso 사용 예시: 16-bit XOR 테이블"""

    # 16비트 XOR을 4비트 × 4개로 분해
    c = 16  # 4비트 = 16 값
    k = 4   # 4개 서브테이블

    # 서브테이블: 각각 0-15
    subtables = [[i for i in range(c)] for _ in range(k)]

    # XOR 조합 함수
    def xor_combine(values: List[int]) -> int:
        return reduce(lambda x, y: x ^ y, values)

    prover = LassoProver(subtables, xor_combine)

    # 조회: 여러 16-bit 값
    lookups = [0x1234, 0x5678, 0xABCD, 0xFFFF]

    proof = prover.prove(lookups)

    print(f"Proof for {len(lookups)} lookups in 2^16 table")
    print(f"Subtable proofs: {len(proof.subtable_proofs)}")
```

### 4.6 Lasso 성능 분석

```
복잡도 비교:

| 특성 | Plookup/LogUp | Lasso |
|------|---------------|-------|
| Prover Time | O(N + m) | O(m * log N) |
| Proof Size | O(1) | O(log N) |
| Verifier | O(1) | O(log N) |

N: 테이블 크기, m: 조회 수

실제 성능 (2^32 테이블, 10K 조회):

| 방식 | Prover Time | Proof Size |
|------|-------------|------------|
| Plookup | ~10 min | ~500 B |
| Lasso | ~100 ms | ~2 KB |

Trade-off:
- Lasso: Prover 빠름, Proof 약간 큼
- Plookup: Proof 작음, Prover 느림

적합한 사용 사례:
- Lasso: 대규모 테이블 (2^20+), 적은 조회
- Plookup: 중소규모 테이블, 많은 조회
```

---

## 5. 실용적 응용

### 5.1 Range Proofs

```
범위 증명: 0 ≤ x < 2^n

방법 1: 비트 분해 (비효율)
- n개의 비트 변수
- n개의 boolean constraint
- 총: 2n constraints

방법 2: Lookup (효율)
테이블 T = {0, 1, ..., 2^n - 1}
단일 lookup으로 범위 검증

최적화: 청크 분할
- 32비트 범위 = 4 × 8비트 lookup
- 테이블 크기: 256 (작음)
- Lookup 수: 4 (관리 가능)

구현:
def range_check_32bit(x):
    # 8비트 테이블
    table = list(range(256))

    # 4개 바이트로 분해
    b0 = x & 0xFF
    b1 = (x >> 8) & 0xFF
    b2 = (x >> 16) & 0xFF
    b3 = (x >> 24) & 0xFF

    # 각각 테이블에서 조회
    assert lookup(b0, table)
    assert lookup(b1, table)
    assert lookup(b2, table)
    assert lookup(b3, table)

    # 재조합 검증
    assert x == b0 + b1*256 + b2*65536 + b3*16777216
```

### 5.2 비트 연산

```
XOR, AND, OR 테이블:

8-bit XOR 테이블:
T_xor = {(a, b, a^b) | 0 ≤ a, b < 256}
크기: 256 × 256 = 65536 엔트리

사용:
xor_result = lookup((input_a, input_b), T_xor)

최적화: Lasso 분해
16-bit XOR를 4-bit × 4로:
T_4bit = {(a, b, a^b) | 0 ≤ a, b < 16}
크기: 16 × 16 = 256 엔트리

a XOR b = combine(
    T_4bit[(a & 0xF), (b & 0xF)],
    T_4bit[(a >> 4) & 0xF, (b >> 4) & 0xF],
    ...
)
```

### 5.3 해시 함수

```
Keccak/SHA256 최적화:

SHA256 구성:
- 비트 연산 (XOR, AND, NOT, ROT)
- 덧셈 모듈러 2^32

Lookup 적용:
1. 비트 연산 → 테이블 조회
2. 덧셈 → 분해 후 carry 처리

성능 비교 (SHA256 per block):
| 방식 | Constraints |
|------|-------------|
| 순수 산술 | ~30,000 |
| Lookup 기반 | ~3,000 |
| 개선율 | 10x |

Poseidon 해시:
- ZK-friendly 설계
- 테이블 불필요
- 하지만 큰 필드 연산
- 용도에 따라 선택
```

### 5.4 ECDSA/EdDSA 서명

```
서명 검증에서 Lookup 활용:

ECDSA 연산:
1. Scalar multiplication: kG
2. Field 역원
3. 모듈러 연산

Lookup 최적화:
- 고정 베이스 scalar mul: 미리 계산된 테이블
- Field 연산: 청크 단위 처리

성능 (secp256k1):
| 방식 | Constraints |
|------|-------------|
| 순수 회로 | ~500,000 |
| Lookup 기반 | ~50,000 |
| 개선율 | 10x |
```

---

## 6. Lookup Scheme 선택 가이드

### 6.1 결정 트리

```
어떤 Lookup Scheme을 사용할까?

1. 테이블 크기 확인
   - < 2^16: Plookup 또는 LogUp
   - 2^16 ~ 2^24: LogUp
   - > 2^24: Lasso

2. 조회 패턴 분석
   - 동일 값 반복 조회 많음: LogUp (명시적 multiplicity)
   - 균등 분포: Plookup

3. 다중 테이블 필요
   - Yes: LogUp (자연스러운 다중 테이블 지원)
   - No: 아무거나

4. 구조화된 테이블 가능
   - XOR/AND/Range 등: Lasso (tensor 분해)
   - 임의 테이블: Plookup/LogUp

5. Prover 성능 우선
   - Yes: Lasso (서브리니어)
   - No: Plookup/LogUp (작은 증명)
```

### 6.2 구현체

```
주요 구현체:

| 시스템 | Lookup 방식 | 특징 |
|--------|-------------|------|
| PLONK | Plookup | 표준 |
| Halo 2 | Halo2 lookup | IPA 기반 |
| Polygon zkEVM | LogUp | 다중 테이블 |
| Jolt | Lasso | 대규모 테이블 |
| SP1 | LogUp + Lasso | 하이브리드 |

라이브러리:
- arkworks-rs: plookup, logup
- halo2: 커스텀 lookup
- nova-scotia: 실험적 지원
```

---

## 요약

```
Lookup Schemes 핵심:

기본 원리:
- 값이 테이블에 존재함을 증명
- Grand Product 또는 Log Derivative
- 복잡한 연산 → 테이블 조회

Plookup:
- PLONK 기반 최초의 실용적 lookup
- 정렬된 multiset equality
- Grand Product argument
- 중소규모 테이블에 적합

LogUp:
- Logarithmic derivative 사용
- 정렬 불필요
- 명시적 multiplicity
- 다중 테이블 지원 우수

Lasso:
- Sublinear prover time
- Sparse polynomial commitment
- Tensor 구조 테이블
- 대규모 테이블에 적합

응용:
- Range proofs: 8-25x 개선
- 비트 연산: 테이블 조회로 대체
- 해시 함수: 10x 개선
- ECDSA: 10x 개선

선택 기준:
- 테이블 크기
- 조회 패턴
- Prover vs Proof size 우선순위
- 구조화 가능 여부
```
