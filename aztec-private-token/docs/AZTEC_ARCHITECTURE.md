# Aztec Protocol 완전 가이드

> Zero Knowledge Proof를 사용한 프라이버시 블록체인의 동작 원리

## 목차

1. [기초 용어 이해하기](#1-기초-용어-이해하기)
2. [왜 프라이버시가 어려운가?](#2-왜-프라이버시가-어려운가)
3. [Aztec의 해결책: UTXO + ZKP](#3-aztec의-해결책-utxo--zkp)
4. [전체 아키텍처](#4-전체-아키텍처)
5. [실제 전송 과정 상세 분석](#5-실제-전송-과정-상세-분석)
6. [자주 묻는 질문](#6-자주-묻는-질문)

---

## 1. 기초 용어 이해하기

### 1.1 UTXO (Unspent Transaction Output)

**한 줄 정의**: "아직 쓰지 않은 돈뭉치"

#### 계정 모델 vs UTXO 모델

우리가 익숙한 은행 계좌 방식(계정 모델)과 비교해봅시다.

```
┌─────────────────────────────────────────────────────────────────┐
│  은행 계좌 방식 (계정 모델) - Ethereum이 사용                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  데이터베이스:                                                    │
│    ┌──────────────────────────┐                                 │
│    │ 계좌번호  │  잔액        │                                 │
│    ├──────────────────────────┤                                 │
│    │ Alice    │  1,000원     │                                 │
│    │ Bob      │    500원     │                                 │
│    └──────────────────────────┘                                 │
│                                                                  │
│  Alice → Bob 300원 전송 시:                                      │
│    Alice 잔액: 1,000 - 300 = 700원                              │
│    Bob 잔액:   500 + 300 = 800원                                │
│                                                                  │
│  → 단순하지만, 모든 잔액이 공개됨!                                 │
└─────────────────────────────────────────────────────────────────┘
```

```
┌─────────────────────────────────────────────────────────────────┐
│  지갑 속 현금 방식 (UTXO 모델) - Bitcoin, Aztec이 사용            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Alice의 지갑 (물리적 현금처럼 생각):                              │
│    ┌─────────────────┐                                          │
│    │ 500원짜리 지폐  │ ← 이것이 "노트(Note)" 또는 "UTXO"          │
│    │ 300원짜리 지폐  │                                          │
│    │ 200원짜리 지폐  │                                          │
│    └─────────────────┘                                          │
│    총 잔액: 1,000원                                              │
│                                                                  │
│  Alice → Bob 400원 전송 시:                                      │
│    1. 500원짜리 지폐를 꺼냄 (파괴)                                │
│    2. Bob에게 400원짜리 새 지폐 생성                              │
│    3. Alice에게 100원짜리 거스름돈 지폐 생성                       │
│                                                                  │
│  전송 후 Alice 지갑:                                             │
│    ┌─────────────────┐                                          │
│    │ 300원짜리 지폐  │                                          │
│    │ 200원짜리 지폐  │                                          │
│    │ 100원짜리 지폐  │ ← 새로 생긴 거스름돈                       │
│    └─────────────────┘                                          │
│    총 잔액: 600원                                                │
│                                                                  │
│  Bob 지갑:                                                       │
│    ┌─────────────────┐                                          │
│    │ 400원짜리 지폐  │ ← 새로 받은 지폐                           │
│    └─────────────────┘                                          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**UTXO의 핵심 특징:**
- 잔액 = 내가 가진 모든 "지폐(노트)"의 합
- 전송 = 기존 지폐 파괴 + 새 지폐 생성
- 부분 사용 불가 (500원 지폐로 400원 결제하면 100원 거스름돈 필요)

---

### 1.2 Note (노트)

**한 줄 정의**: "암호화된 디지털 지폐"

Aztec에서 Note는 UTXO를 암호화한 것입니다.

```
┌─────────────────────────────────────────────────────────────────┐
│  Note의 구조                                                     │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Note = {                                                        │
│    amount: 500,           // 금액                                │
│    owner: Alice의 공개키,  // 소유자                              │
│    secret: 랜덤값,         // 무작위 비밀값 (유일성 보장)           │
│    ... 기타 메타데이터                                            │
│  }                                                               │
│                                                                  │
│  이 Note는 Alice의 공개키로 암호화됨                               │
│  → Alice만 복호화해서 내용을 볼 수 있음                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**Note의 두 가지 상태:**
1. **Unspent (미사용)**: 아직 쓸 수 있는 노트
2. **Spent (사용됨)**: 이미 사용해서 더 이상 못 쓰는 노트

---

### 1.3 Commitment (커밋먼트)

**한 줄 정의**: "봉인된 봉투" - 내용을 숨기면서도 내용이 있음을 증명

```
┌─────────────────────────────────────────────────────────────────┐
│  Commitment 이해하기                                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  실생활 비유: 경매                                                │
│                                                                  │
│  1. 봉인 입찰 경매에서:                                           │
│     - 각자 입찰가를 종이에 적어 봉투에 넣고 봉인                    │
│     - 봉투를 제출 (이것이 Commitment)                             │
│     - 나중에 봉투를 열어 확인 (이것이 Reveal)                      │
│                                                                  │
│  2. 누구도 봉투를 열기 전에는 금액을 모름                          │
│  3. 하지만 봉투를 열면 "이것이 내가 처음 적은 금액"임을 증명 가능    │
│  4. 한번 봉인하면 내용 변경 불가능                                 │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Aztec에서의 Commitment:                                         │
│                                                                  │
│  Note = { amount: 500, owner: Alice, secret: xyz }              │
│                    ↓                                             │
│         Hash 함수 (Poseidon)                                     │
│                    ↓                                             │
│  Commitment = 0x7f3a8b2c...  (32바이트 해시값)                   │
│                                                                  │
│  특징:                                                           │
│  - Commitment만 보고는 원래 Note 내용을 알 수 없음                 │
│  - 같은 Note는 항상 같은 Commitment 생성                          │
│  - 다른 Note는 (거의 확실히) 다른 Commitment 생성                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 1.4 Nullifier (널리파이어)

**한 줄 정의**: "사용 완료 도장" - 노트가 이미 쓰였음을 표시

```
┌─────────────────────────────────────────────────────────────────┐
│  Nullifier 이해하기                                              │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  문제 상황: 이중 지불 (Double Spending)                           │
│                                                                  │
│  만약 Alice가 같은 500원짜리 Note를:                              │
│    - Bob에게도 보내고                                            │
│    - Charlie에게도 보내면?                                       │
│                                                                  │
│  → 이것을 막아야 함!                                             │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  해결책: Nullifier                                               │
│                                                                  │
│  Note를 사용할 때:                                               │
│    1. Note의 고유 ID인 Nullifier를 계산                          │
│       Nullifier = Hash(Note + 소유자의 비밀키)                   │
│                                                                  │
│    2. 이 Nullifier를 온체인에 공개                                │
│                                                                  │
│    3. 같은 Note를 다시 쓰려고 하면?                               │
│       → 같은 Nullifier가 이미 존재 → 거부!                        │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  핵심 포인트: Nullifier와 Commitment는 연결되지 않음!              │
│                                                                  │
│  Note A → Commitment_A = 0x1234...                              │
│        → Nullifier_A  = 0xabcd...                               │
│                                                                  │
│  외부 관찰자는:                                                   │
│  - Commitment_A와 Nullifier_A가 같은 Note에서 나왔다는 것을       │
│  - 알 수 없음! (수학적으로 연결 불가능)                            │
│                                                                  │
│  오직 Note 소유자만 이 둘의 관계를 알 수 있음                      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**비유:**
- Commitment = 복권 번호 (구매 시 발급)
- Nullifier = 당첨금 수령 영수증 (수령 시 발급)
- 둘을 연결하려면 원본 복권이 필요 (소유자만 가능)

---

### 1.5 Note Hash Tree (Merkle Tree)

**한 줄 정의**: "모든 노트 커밋먼트를 저장하는 효율적인 데이터 구조"

```
┌─────────────────────────────────────────────────────────────────┐
│  Merkle Tree 이해하기                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  문제: 1억 개의 Note가 있을 때,                                   │
│        "내 Note가 정말 존재하는가?"를 어떻게 증명?                  │
│                                                                  │
│  순진한 방법: 1억 개 전부 검사 → 너무 느림!                        │
│                                                                  │
│  해결책: Merkle Tree                                             │
│                                                                  │
│                      [Root Hash]                                 │
│                     0xfinal...                                   │
│                    /          \                                  │
│              [Hash AB]      [Hash CD]                            │
│             0xab12...      0xcd34...                             │
│             /      \        /      \                             │
│        [Hash A] [Hash B] [Hash C] [Hash D]                       │
│        0xa1... 0xb2...  0xc3...  0xd4...                         │
│           │       │        │        │                            │
│        Note A  Note B   Note C   Note D                          │
│        (Alice) (Bob)   (Carol)  (Dave)                           │
│                                                                  │
│  "Note B가 존재함"을 증명하려면:                                   │
│    - Note B의 Hash                                               │
│    - Hash A (형제 노드)                                          │
│    - Hash CD (삼촌 노드)                                         │
│    → 이 3개만 있으면 Root Hash를 재계산 가능!                      │
│    → Root Hash가 맞으면 Note B가 Tree에 존재함을 증명!             │
│                                                                  │
│  장점: 1억 개 중 1개를 증명하는데 ~27개 해시만 필요                 │
│        (log2(100,000,000) ≈ 27)                                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**Aztec의 Note Hash Tree:**
- 모든 Note의 Commitment를 저장
- Root Hash만 L1 Ethereum에 저장
- "이 노트가 존재한다"를 효율적으로 증명 가능

---

### 1.6 PXE (Private Execution Environment)

**한 줄 정의**: "내 컴퓨터에서 돌아가는 비밀 금고"

```
┌─────────────────────────────────────────────────────────────────┐
│  PXE 이해하기                                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  일반 블록체인:                                                   │
│    - 모든 실행이 온체인에서 발생                                   │
│    - 모든 노드가 같은 연산을 수행                                  │
│    - 결과가 투명하게 공개                                         │
│                                                                  │
│  Aztec의 PXE:                                                    │
│    - 민감한 연산은 내 로컬 컴퓨터에서 실행                         │
│    - 결과만 (암호화해서) 온체인에 제출                             │
│    - 아무도 내 연산 과정을 볼 수 없음                              │
│                                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────────────────────────────────┐                    │
│  │         Alice의 컴퓨터                   │                    │
│  │  ┌───────────────────────────────────┐  │                    │
│  │  │            PXE                     │  │                    │
│  │  │  ┌─────────────────────────────┐  │  │                    │
│  │  │  │  내 비밀키                    │  │  │                    │
│  │  │  │  내가 가진 Note들 (복호화됨)  │  │  │                    │
│  │  │  │  트랜잭션 시뮬레이션          │  │  │                    │
│  │  │  │  ZK Proof 생성               │  │  │                    │
│  │  │  └─────────────────────────────┘  │  │                    │
│  │  └───────────────────────────────────┘  │                    │
│  └─────────────────────────────────────────┘                    │
│                         │                                        │
│                         │ 암호화된 결과 + ZK Proof                │
│                         ▼                                        │
│  ┌─────────────────────────────────────────┐                    │
│  │            Aztec Network                 │                    │
│  │  (공개 데이터만: Commitment, Nullifier)   │                    │
│  └─────────────────────────────────────────┘                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**PXE의 역할:**
1. **비밀키 관리**: 내 개인키를 안전하게 보관
2. **노트 관리**: 내가 가진 Note들을 복호화해서 보관
3. **로컬 실행**: 트랜잭션을 로컬에서 먼저 시뮬레이션
4. **증명 생성**: ZK Proof를 생성해서 네트워크에 제출

---

### 1.7 Zero Knowledge Proof (ZKP)

**한 줄 정의**: "비밀을 밝히지 않고 비밀을 알고 있음을 증명"

```
┌─────────────────────────────────────────────────────────────────┐
│  ZKP 동굴 비유 (알리바바 동굴)                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                    입구                                          │
│                     │                                            │
│              ┌──────┴──────┐                                    │
│              │             │                                    │
│           A 통로        B 통로                                   │
│              │             │                                    │
│              └──────┬──────┘                                    │
│                     │                                            │
│                [마법의 문]                                        │
│              (비밀번호 필요)                                      │
│                                                                  │
│  증명 과정:                                                       │
│  1. Alice가 동굴 안으로 들어감 (A 또는 B 통로 선택)                │
│  2. Bob이 밖에서 "A 통로로 나와!" 또는 "B 통로로 나와!" 요청       │
│  3. Alice가 비밀번호를 알면 → 어느 쪽으로든 나올 수 있음           │
│     Alice가 비밀번호를 모르면 → 50% 확률로만 성공                  │
│  4. 이것을 20번 반복하면?                                         │
│     - 비밀번호 아는 사람: 100% 성공                               │
│     - 모르는 사람: (1/2)^20 = 0.0001% 성공                       │
│                                                                  │
│  결과: Bob은 Alice가 비밀번호를 안다고 확신                        │
│       하지만 비밀번호 자체는 전혀 모름!                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**Aztec에서의 ZKP:**

```
┌─────────────────────────────────────────────────────────────────┐
│  ZKP가 증명하는 것 (공개하지 않고!)                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  전송 시 증명 내용:                                               │
│                                                                  │
│  1. "나는 유효한 Note를 가지고 있다"                              │
│     (어떤 Note인지, 얼마인지는 비공개)                            │
│                                                                  │
│  2. "그 Note의 진짜 소유자다"                                     │
│     (내 비밀키로 서명, 비밀키는 비공개)                            │
│                                                                  │
│  3. "전송 금액이 Note 금액 이하다"                                │
│     (잔액 부족 시 증명 생성 자체가 불가능)                         │
│                                                                  │
│  4. "새로 만든 Note들의 합 = 소비한 Note"                         │
│     (토큰이 갑자기 생성/소멸되지 않음)                             │
│                                                                  │
│  증명 결과: 32KB짜리 증명 데이터                                   │
│  → 누구나 이 증명을 검증 가능                                     │
│  → 하지만 원본 데이터는 알 수 없음                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 2. 왜 프라이버시가 어려운가?

### 2.1 일반 블록체인의 문제

```
┌─────────────────────────────────────────────────────────────────┐
│  Ethereum에서 토큰 전송                                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  // ERC-20 전송 함수                                             │
│  function transfer(address to, uint256 amount) {                │
│      balances[msg.sender] -= amount;                            │
│      balances[to] += amount;                                    │
│  }                                                               │
│                                                                  │
│  Etherscan에서 누구나 볼 수 있는 것:                              │
│    - 보내는 사람: 0xAlice...                                     │
│    - 받는 사람: 0xBob...                                         │
│    - 금액: 1,000 USDC                                           │
│    - 전송 후 Alice 잔액: 5,000 USDC                              │
│    - 전송 후 Bob 잔액: 3,000 USDC                                │
│                                                                  │
│  → 모든 금융 기록이 완전히 투명!                                  │
│  → 현금 없는 사회인데 모든 거래가 공개되는 것과 같음               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 2.2 프라이버시를 위한 시도들

```
┌─────────────────────────────────────────────────────────────────┐
│  방법 1: 암호화만 사용                                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  문제: 암호화된 데이터로는 연산 불가능!                            │
│                                                                  │
│  예시:                                                           │
│    encrypted_balance = encrypt(1000)                            │
│    encrypted_balance - 300 = ???                                │
│                                                                  │
│  → 블록체인 노드가 "잔액이 충분한가?"를 확인할 수 없음             │
│  → 누구나 잔액 없이도 전송 가능해짐 (보안 붕괴)                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  방법 2: 믹서 (Mixer/Tumbler)                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  작동 방식:                                                       │
│    1. 여러 사람이 같은 금액을 풀에 넣음                           │
│    2. 일정 시간 후 다른 주소로 인출                               │
│    3. 누가 누구에게 보냈는지 추적 어려움                          │
│                                                                  │
│  한계:                                                           │
│    - 고정된 금액만 가능 (0.1 ETH, 1 ETH 등)                      │
│    - 입출금 시점으로 추적 가능                                    │
│    - 입금/출금 패턴 분석으로 연결 가능                            │
│    - "금액"은 여전히 공개                                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 2.3 ZKP가 필요한 이유

```
┌─────────────────────────────────────────────────────────────────┐
│  필요한 것:                                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. 데이터는 숨기면서                                             │
│  2. 규칙(잔액 충분, 토큰 보존 등)은 검증 가능                      │
│                                                                  │
│  → 이것이 바로 ZKP가 하는 일!                                     │
│                                                                  │
│  "나는 규칙을 지켰다. 근데 뭘 했는지는 안 알려줄게.                 │
│   믿어? 여기 수학적 증명이 있어."                                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. Aztec의 해결책: UTXO + ZKP

### 3.1 핵심 아이디어

```
┌─────────────────────────────────────────────────────────────────┐
│  Aztec의 접근법                                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. UTXO 모델 채택                                               │
│     - 잔액을 직접 저장하지 않음                                   │
│     - 대신 "노트(Note)"라는 개별 단위로 관리                      │
│                                                                  │
│  2. 노트 암호화                                                   │
│     - 각 노트는 소유자의 키로 암호화                              │
│     - 온체인에는 해시(Commitment)만 저장                          │
│                                                                  │
│  3. ZKP로 검증                                                   │
│     - 전송 시 ZK Proof 생성                                      │
│     - 규칙 준수를 증명하지만 내용은 숨김                          │
│                                                                  │
│  4. Nullifier로 이중지불 방지                                    │
│     - 노트 사용 시 고유 Nullifier 공개                           │
│     - 같은 Nullifier 재사용 불가                                 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 3.2 온체인 vs 오프체인

```
┌─────────────────────────────────────────────────────────────────┐
│                         온체인 (공개)                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Note Hash Tree:                                                 │
│    - 모든 노트의 Commitment (해시값)                             │
│    - 예: [0x1a2b..., 0x3c4d..., 0x5e6f..., ...]                 │
│    - 각 해시가 누구 것인지, 얼마인지 알 수 없음                   │
│                                                                  │
│  Nullifier Set:                                                  │
│    - 사용된 노트들의 Nullifier                                   │
│    - 예: {0x9876..., 0x5432..., ...}                            │
│    - 어떤 노트가 사용됐는지 알 수 없음                           │
│                                                                  │
│  ZK Proofs:                                                      │
│    - 각 트랜잭션의 유효성 증명                                   │
│    - 증명만으로는 내용 추론 불가                                 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│                        오프체인 (비공개)                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  각 사용자의 PXE (로컬 컴퓨터):                                   │
│                                                                  │
│  Alice의 PXE:                                                    │
│    - Alice의 비밀키                                              │
│    - Alice가 소유한 Note들 (복호화된 상태)                        │
│      Note 1: { amount: 500, secret: xxx }                       │
│      Note 2: { amount: 300, secret: yyy }                       │
│    - 이 Note들이 Tree 어디에 있는지 정보                         │
│                                                                  │
│  Bob의 PXE:                                                      │
│    - Bob의 비밀키                                                │
│    - Bob이 소유한 Note들                                         │
│    - (Alice의 Note는 볼 수 없음!)                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 4. 전체 아키텍처

### 4.1 체인 구조

```
┌─────────────────────────────────────────────────────────────────┐
│                                                                  │
│                     Ethereum L1 (메인넷)                         │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                                                           │  │
│  │  Aztec Rollup Contract                                    │  │
│  │  ├─ noteHashTreeRoot: 0xabc...  (모든 노트의 루트 해시)    │  │
│  │  ├─ nullifierTreeRoot: 0xdef... (모든 널리파이어 루트)     │  │
│  │  ├─ l2BlockNumber: 1234                                   │  │
│  │  └─ rollupProof: [...]          (L2 블록 유효성 증명)      │  │
│  │                                                           │  │
│  │  역할:                                                     │  │
│  │  - L2 상태의 "요약본" 저장                                 │  │
│  │  - Rollup Proof 검증                                      │  │
│  │  - L1 ↔ L2 브릿지 (자산 입출금)                           │  │
│  │                                                           │  │
│  └───────────────────────────────────────────────────────────┘  │
│                              ▲                                   │
│                              │ Rollup Proof 제출                 │
│                              │ (주기적으로)                       │
│                                                                  │
└──────────────────────────────┼───────────────────────────────────┘
                               │
┌──────────────────────────────┼───────────────────────────────────┐
│                              │                                   │
│                     Aztec L2 네트워크                            │
│  ┌───────────────────────────────────────────────────────────┐  │
│  │                                                           │  │
│  │  Sequencer (블록 생성자)                                   │  │
│  │  ├─ 트랜잭션 수집                                         │  │
│  │  ├─ ZK Proof 검증                                         │  │
│  │  ├─ 블록 생성                                             │  │
│  │  └─ L1에 Rollup Proof 제출                                │  │
│  │                                                           │  │
│  │  Full State:                                              │  │
│  │  ├─ Note Hash Tree (전체)                                 │  │
│  │  ├─ Nullifier Tree (전체)                                 │  │
│  │  └─ Public State (공개 컨트랙트 상태)                      │  │
│  │                                                           │  │
│  └───────────────────────────────────────────────────────────┘  │
│                              ▲                                   │
│                              │ 트랜잭션 제출                      │
│                                                                  │
└──────────────────────────────┼───────────────────────────────────┘
                               │
┌──────────────────────────────┼───────────────────────────────────┐
│                              │                                   │
│              사용자 측 (각 사용자의 컴퓨터)                        │
│  ┌─────────────────────┐   ┌─────────────────────┐              │
│  │   Alice의 PXE       │   │   Bob의 PXE         │              │
│  │  ┌───────────────┐  │   │  ┌───────────────┐  │              │
│  │  │ 비밀키        │  │   │  │ 비밀키        │  │              │
│  │  │ 내 Note들     │  │   │  │ 내 Note들     │  │              │
│  │  │ ZK Prover     │  │   │  │ ZK Prover     │  │              │
│  │  └───────────────┘  │   │  └───────────────┘  │              │
│  └─────────────────────┘   └─────────────────────┘              │
│                                                                  │
└──────────────────────────────────────────────────────────────────┘
```

### 4.2 데이터 저장 구조

```
┌─────────────────────────────────────────────────────────────────┐
│  Note Hash Tree (Merkle Tree)                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│                         [Root]                                   │
│                        0xfinal                                   │
│                       /        \                                 │
│                     ...        ...                               │
│                    /              \                              │
│            [0x1a2b...]      [0x3c4d...]     [0x5e6f...]         │
│                 │                │               │               │
│            Commitment        Commitment      Commitment          │
│             (Note A)         (Note B)        (Note C)           │
│                                                                  │
│  각 Leaf = Hash(Note 내용)                                       │
│  Note 내용 = { amount, owner, secret, ... }                     │
│  → Leaf만 봐서는 내용 알 수 없음                                 │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Nullifier Tree (또는 Set)                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  사용된 Nullifier 목록:                                          │
│  {                                                               │
│    0x9876...,  ← 어떤 Note가 사용됨                              │
│    0x5432...,  ← 또 다른 Note가 사용됨                           │
│    0x1111...,                                                   │
│    ...                                                          │
│  }                                                               │
│                                                                  │
│  새 트랜잭션이 오면:                                              │
│    - 제출된 Nullifier가 이미 있는지 확인                         │
│    - 있으면 → 거부 (이중 지불 시도!)                             │
│    - 없으면 → 추가하고 처리                                      │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 5. 실제 전송 과정 상세 분석

Alice가 Bob에게 300 토큰을 전송하는 전체 과정을 살펴봅니다.

### 5.1 초기 상태

```
┌─────────────────────────────────────────────────────────────────┐
│  온체인 상태 (모두에게 공개)                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Note Hash Tree:                                                 │
│    Leaf 0: 0x1a2b3c...  ← (알 수 없는 누군가의 노트)             │
│    Leaf 1: 0x4d5e6f...  ← (알 수 없는 누군가의 노트)             │
│    Leaf 2: 0x7g8h9i...  ← (알 수 없는 누군가의 노트)             │
│    ...                                                          │
│                                                                  │
│  Nullifier Set: { 0xaaaa..., 0xbbbb... }                        │
│                                                                  │
│  → 외부 관찰자: "노트가 3개 있고, 2개가 사용됐구나"               │
│     (누가 뭘 가지고 있는지는 전혀 모름)                           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Alice의 PXE (Alice만 볼 수 있음)                                │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  내 비밀키: sk_alice = 0xsecret...                              │
│                                                                  │
│  내가 가진 Note:                                                 │
│    Note_A = {                                                   │
│      amount: 1000,                                              │
│      owner: Alice,                                              │
│      secret: 0xrandom123,                                       │
│      tree_index: 0,        ← Note Hash Tree의 Leaf 0에 있음     │
│    }                                                            │
│                                                                  │
│  → Alice는 "Leaf 0이 내 거고, 1000토큰이야"라는 것을 알고 있음    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Bob의 PXE (Bob만 볼 수 있음)                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  내 비밀키: sk_bob = 0xbobsecret...                             │
│                                                                  │
│  내가 가진 Note:                                                 │
│    (없음)                                                       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 5.2 전송 트랜잭션 생성 (Alice의 PXE에서)

```
┌─────────────────────────────────────────────────────────────────┐
│  Step 1: 입력 준비                                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Alice의 PXE가 수행:                                             │
│                                                                  │
│  1. 사용할 Note 선택                                             │
│     - Note_A (1000 토큰)를 선택                                  │
│     - 전송할 금액: 300                                           │
│     - 거스름돈: 700                                              │
│                                                                  │
│  2. 새 Note 2개 생성 (아직 메모리에만)                            │
│     - Note_Bob = { amount: 300, owner: Bob, secret: 0xnew1 }    │
│     - Note_Change = { amount: 700, owner: Alice, secret: 0xnew2}│
│                                                                  │
│  3. Nullifier 계산                                               │
│     - Nullifier_A = Hash(Note_A + Alice의 비밀키)               │
│     - 결과: 0xdead1234...                                       │
│                                                                  │
│  4. Commitment 계산                                              │
│     - Commitment_Bob = Hash(Note_Bob)                           │
│     - Commitment_Change = Hash(Note_Change)                     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Step 2: ZK Proof 생성                                          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ZK Circuit (프로그램)에 입력:                                    │
│                                                                  │
│  [Private Inputs - 증명에 포함되지만 공개 안 됨]                  │
│    - Note_A 전체 내용 (amount, owner, secret)                   │
│    - Alice의 비밀키                                              │
│    - Note Hash Tree에서 Note_A의 위치 증명 (Merkle proof)        │
│    - Note_Bob, Note_Change 내용                                 │
│                                                                  │
│  [Public Inputs - 검증 시 공개됨]                                │
│    - Note Hash Tree Root (현재)                                 │
│    - Nullifier_A                                                │
│    - Commitment_Bob                                             │
│    - Commitment_Change                                          │
│                                                                  │
│  Circuit이 확인하는 것:                                          │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │  1. Note_A가 Tree에 존재하는가?                          │    │
│  │     - Merkle proof 검증                                  │    │
│  │                                                          │    │
│  │  2. Nullifier_A가 Note_A로부터 올바르게 계산됐는가?       │    │
│  │     - Hash(Note_A + sk) == Nullifier_A                   │    │
│  │                                                          │    │
│  │  3. Alice가 Note_A의 소유자인가?                         │    │
│  │     - Note_A.owner == PublicKey(sk_alice)                │    │
│  │                                                          │    │
│  │  4. 금액이 보존되는가?                                    │    │
│  │     - Note_A.amount == Note_Bob.amount + Note_Change.amt │    │
│  │     - 1000 == 300 + 700 ✓                                │    │
│  │                                                          │    │
│  │  5. Commitment들이 올바른가?                              │    │
│  │     - Hash(Note_Bob) == Commitment_Bob                   │    │
│  │     - Hash(Note_Change) == Commitment_Change             │    │
│  └─────────────────────────────────────────────────────────┘    │
│                                                                  │
│  출력: ZK Proof (약 32KB 데이터)                                 │
│  → 이 증명은 위 모든 조건을 만족함을 보장                         │
│  → 하지만 Private Inputs는 전혀 노출되지 않음!                    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 5.3 트랜잭션 제출 및 처리

```
┌─────────────────────────────────────────────────────────────────┐
│  Step 3: 트랜잭션 제출                                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Alice의 PXE → Aztec Network로 전송:                             │
│                                                                  │
│  Transaction = {                                                │
│    // 공개 데이터만 포함                                         │
│    nullifiers: [0xdead1234...],     // Note_A의 Nullifier       │
│    commitments: [                                               │
│      0xbob_comm...,                 // Bob의 새 Note            │
│      0xchange_comm...               // Alice의 거스름돈          │
│    ],                                                           │
│    proof: [... 32KB ZK Proof ...],                              │
│    encrypted_notes: [               // 암호화된 Note 데이터       │
│      encrypt(Note_Bob, Bob의 공개키),                           │
│      encrypt(Note_Change, Alice의 공개키)                        │
│    ]                                                            │
│  }                                                               │
│                                                                  │
│  → 주목: 금액, 송신자, 수신자 정보가 없음!                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Step 4: Sequencer의 검증                                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Sequencer가 확인하는 것:                                        │
│                                                                  │
│  1. ZK Proof 검증                                                │
│     - 수학적으로 증명이 유효한가?                                │
│     - Public Inputs와 일치하는가?                                │
│     → ✓ 유효함                                                  │
│                                                                  │
│  2. Nullifier 중복 확인                                          │
│     - 0xdead1234...가 이미 Nullifier Set에 있는가?              │
│     → ✗ 없음 (처음 사용)                                        │
│                                                                  │
│  3. Note Hash Tree Root 확인                                     │
│     - 트랜잭션의 Root가 현재 상태와 일치하는가?                   │
│     → ✓ 일치                                                    │
│                                                                  │
│  모든 검증 통과 → 트랜잭션 승인!                                  │
│                                                                  │
│  Sequencer는 모르는 것:                                          │
│  - 누가 보냈는지                                                 │
│  - 누가 받는지                                                   │
│  - 얼마를 보냈는지                                               │
│  - 기존 잔액이 얼마였는지                                        │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 5.4 상태 업데이트

```
┌─────────────────────────────────────────────────────────────────┐
│  Step 5: 온체인 상태 변경                                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Note Hash Tree:                                                 │
│    Leaf 0: 0x1a2b3c...  ← Note_A (여전히 존재, 삭제 안 함)       │
│    Leaf 1: 0x4d5e6f...                                          │
│    Leaf 2: 0x7g8h9i...                                          │
│    Leaf 3: 0xbob_comm...  ← 새로 추가 (Bob의 Note)              │
│    Leaf 4: 0xchange_comm... ← 새로 추가 (Alice의 거스름돈)       │
│                                                                  │
│  Nullifier Set:                                                  │
│    { 0xaaaa..., 0xbbbb..., 0xdead1234... }                      │
│                         └── 새로 추가 (Note_A 사용됨 표시)        │
│                                                                  │
│  핵심 포인트:                                                     │
│  - Tree에서 노트를 "삭제"하지 않음                                │
│  - 대신 Nullifier로 "사용됨" 표시                                │
│  - 왜? 삭제하면 Tree 구조가 변경되어 다른 증명이 무효화됨          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Step 6: 수신자(Bob) 동기화                                      │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Bob의 PXE가 네트워크에서 새 블록 수신:                           │
│                                                                  │
│  1. 새로운 encrypted_notes 확인                                  │
│     - [encrypt(Note_Bob, Bob의 공개키), ...]                    │
│                                                                  │
│  2. 자신의 비밀키로 복호화 시도                                   │
│     - 첫 번째 노트: 성공! → Note_Bob 획득                        │
│       { amount: 300, owner: Bob, secret: 0xnew1 }               │
│     - 두 번째 노트: 실패 (Alice 것이라 복호화 안 됨)              │
│                                                                  │
│  3. 로컬 상태 업데이트                                            │
│     - 내가 가진 Note 목록에 Note_Bob 추가                        │
│     - Tree에서의 위치(index) 기록                                │
│                                                                  │
│  Bob의 PXE 상태:                                                 │
│    내가 가진 Note:                                               │
│      Note_Bob = { amount: 300, owner: Bob, tree_index: 3 }      │
│                                                                  │
│  → Bob은 이제 300 토큰을 쓸 수 있음!                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

### 5.5 전송 후 최종 상태

```
┌─────────────────────────────────────────────────────────────────┐
│  외부 관찰자가 보는 것                                           │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  "블록 N에서 일어난 일:"                                          │
│    - 새 Nullifier 1개 추가됨: 0xdead1234...                     │
│    - 새 Commitment 2개 추가됨: 0xbob..., 0xchange...            │
│    - ZK Proof 유효함                                            │
│                                                                  │
│  "그래서... 뭐가 어떻게 된 거지?"                                 │
│    - 모름! 누가 누구에게 얼마를 보냈는지 전혀 알 수 없음           │
│    - "누군가가 뭔가를 했고, 그게 규칙에 맞다"는 것만 알 수 있음    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Alice가 아는 것                                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  "내가 Bob에게 300 토큰을 보냈어"                                 │
│                                                                  │
│  - 내 Note_A (1000)는 이제 사용 불가 (Nullified)                 │
│  - 새 Note_Change (700)가 생겼고, 이걸 쓸 수 있어                │
│  - Bob이 Note_Bob (300)을 받았을 거야                           │
│                                                                  │
│  Alice의 현재 잔액: 700 토큰                                     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Bob이 아는 것                                                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  "누군가 나에게 300 토큰을 보냈어"                                │
│                                                                  │
│  - Note_Bob (300)이 내 PXE에 들어왔어                           │
│  - 누가 보냈는지는... 모름! (암호화되어 있어서)                   │
│    (물론 Alice가 따로 알려줬을 수도 있음)                        │
│                                                                  │
│  Bob의 현재 잔액: 300 토큰                                       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 6. 자주 묻는 질문

### Q1: "장부가 없는데 어떻게 잔액을 아나요?"

```
A: 장부는 있습니다! 다만 형태가 다릅니다.

일반 블록체인:
  장부 = balances[address] = amount  (직접 저장)

Aztec:
  장부 = Note Hash Tree + Nullifier Set
  잔액 = Σ(내 Note들) - Σ(Nullified Note들)

내 잔액을 계산하려면:
1. 내 PXE에서 내가 가진 모든 Note 목록 확인
2. 각 Note가 Nullified 됐는지 온체인에서 확인
3. Nullify 안 된 Note들의 amount 합산

예:
  내 Note들: A(500), B(300), C(200)
  Nullified: A
  → 내 잔액: 300 + 200 = 500

차이점: 온체인 데이터만으로는 계산 불가능 (내 Note가 뭔지 모르니까)
```

### Q2: "다른 사람의 잔액은 어떻게 확인하나요?"

```
A: 확인할 수 없습니다! 그게 프라이버시입니다.

일반 블록체인:
  const balance = await contract.balanceOf(address);  // 누구나 확인 가능

Aztec:
  - Bob의 Note는 Bob의 키로 암호화됨
  - Bob만 자신의 Note를 복호화할 수 있음
  - 다른 사람은 Bob이 얼마를 가졌는지 알 방법 없음

예외:
  - Bob이 자발적으로 View Key를 공유하면 읽기 권한 부여 가능
  - 규제 준수를 위해 감사인에게 열람권 줄 수 있음
```

### Q3: "누가 나에게 돈을 보냈는지 알 수 있나요?"

```
A: 기본적으로는 알 수 없습니다.

받은 Note에 포함된 정보:
  - amount (금액)
  - owner (나)
  - secret (무작위 값)

포함되지 않은 정보:
  - 보낸 사람 주소

알 수 있는 방법:
1. 송신자가 별도로 알려줌 (오프체인 통신)
2. 스마트 컨트랙트에서 메타데이터 포함하도록 설계
3. Note의 암호화된 메모 필드 활용
```

### Q4: "Note를 잃어버리면 어떻게 되나요?"

```
A: 복구 가능합니다!

Note 데이터는 온체인에 암호화되어 저장됩니다:
1. encrypted_notes 필드에 암호화된 Note 정보 포함
2. 내 비밀키로 복호화 가능

복구 과정:
1. 새 PXE 설정 (비밀키만 있으면 됨)
2. 블록체인 전체 스캔
3. 각 encrypted_note를 내 키로 복호화 시도
4. 성공한 것들 = 내 Note
5. Nullifier Set 확인해서 사용 여부 파악

→ 비밀키만 안전하게 보관하면 복구 가능!
→ 비밀키를 잃으면... 자산도 잃음 (일반 지갑과 동일)
```

### Q5: "ZK Proof 생성이 느리지 않나요?"

```
A: 네, 상대적으로 느립니다. 하지만 개선 중입니다.

현재 상황 (2024):
- 단순 전송: 5-15초
- 복잡한 연산: 30초-1분

이유:
- ZK Circuit은 복잡한 수학 연산
- 큰 다항식 연산, 타원곡선 연산 필요

개선 방향:
1. 하드웨어 가속 (GPU, 전용 ASIC)
2. 더 효율적인 증명 시스템 개발
3. 증명 집계 (여러 증명을 하나로)
4. 클라이언트 사이드 최적화

참고: 검증은 매우 빠름 (수 밀리초)
```

### Q6: "L1과 L2는 정확히 어떤 관계인가요?"

```
L1 (Ethereum):
- 보안의 원천 (Ultimate Security)
- Aztec Rollup Contract 호스팅
- 요약된 상태만 저장 (Merkle Roots)
- Rollup Proof 검증

L2 (Aztec):
- 실제 트랜잭션 처리
- 전체 Note Hash Tree 관리
- 프라이버시 로직 실행

데이터 흐름:
  사용자 → Aztec L2 → (주기적으로) → Ethereum L1
              │                           │
         트랜잭션 처리              상태 요약 + 증명 기록

보안:
- L2가 잘못된 상태를 제출하면?
  → L1의 Rollup Contract가 ZK Proof 검증
  → 무효한 증명은 거부됨
  → L2 Sequencer가 악의적이어도 자산 안전
```

---

## 7. 심화 질문과 답변

### 7.1 PXE (금고)를 잃어버리면?

**질문**: "오프체인에서 개인 금고(PXE)를 각자 갖고 있는데, 그걸 잃어버리면?"

```
┌─────────────────────────────────────────────────────────────────┐
│  핵심 답변: 비밀키만 있으면 복구 가능!                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  PXE에 저장된 것:                                                │
│    1. 비밀키 (sk)                                                │
│    2. 내 Note 목록 (캐시)                                        │
│    3. 각 Note의 Tree 위치 (캐시)                                 │
│                                                                  │
│  온체인에 저장된 것 (복구의 핵심!):                               │
│    - encrypted_notes: 모든 Note가 암호화되어 저장됨              │
│    - 각 트랜잭션마다 encrypt(Note, 수신자의 공개키) 포함          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**복구 과정:**

```
┌─────────────────────────────────────────────────────────────────┐
│  PXE 복구 시나리오                                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Alice의 컴퓨터가 고장났다! PXE 데이터 전부 손실!                 │
│                                                                  │
│  복구 Step 1: 새 PXE 설치                                        │
│    - 새 컴퓨터에 Aztec 클라이언트 설치                           │
│    - 비밀키(sk) 또는 시드 문구(mnemonic) 입력                    │
│                                                                  │
│  복구 Step 2: 블록체인 스캔 (Sync)                               │
│    for each block in blockchain:                                │
│      for each transaction in block:                             │
│        for each encrypted_note in transaction:                  │
│          try:                                                   │
│            note = decrypt(encrypted_note, my_secret_key)        │
│            if success:                                          │
│              add_to_my_notes(note, tree_position)               │
│          catch:                                                 │
│            pass  # 내 것이 아님, 스킵                            │
│                                                                  │
│  복구 Step 3: Nullifier 확인                                     │
│    for each my_note in my_notes:                                │
│      nullifier = compute_nullifier(my_note, my_secret_key)      │
│      if nullifier in nullifier_set:                             │
│        mark_as_spent(my_note)                                   │
│      else:                                                      │
│        mark_as_unspent(my_note)  # 사용 가능!                   │
│                                                                  │
│  결과: 모든 자산 복구 완료!                                       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**비밀키 백업 중요성:**

```
┌─────────────────────────────────────────────────────────────────┐
│  비밀키를 잃어버리면?                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  → 자산 영구 손실! (일반 지갑과 동일)                            │
│                                                                  │
│  이유:                                                           │
│  - encrypted_notes는 온체인에 있지만                             │
│  - 복호화할 키가 없으면 내용을 알 수 없음                        │
│  - 누구도 대신 복구해줄 수 없음 (그게 프라이버시!)               │
│                                                                  │
│  권장 백업 방법:                                                  │
│  - 시드 문구(24단어) 종이에 적어 금고 보관                       │
│  - 하드웨어 지갑 사용                                            │
│  - 절대 온라인에 저장하지 않기                                   │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 7.2 왜 L2가 필요한가? L1에 직접 저장하면 안 되나?

**질문**: "Commitment와 Nullifier만 저장하면 되는데, 왜 굳이 Aztec L2가 필요해? L1 Contract에 저장해도 되잖아?"

```
┌─────────────────────────────────────────────────────────────────┐
│  이론적으로는 가능! 하지만 실용적으로 불가능한 이유들:             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  이유 1: 가스비 (비용)                                           │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  ZK Proof 검증 비용 (L1 직접):                                   │
│    - Proof 검증: ~300,000 gas                                   │
│    - Commitment 저장: ~20,000 gas                               │
│    - Nullifier 저장: ~20,000 gas                                │
│    - 기타 연산: ~50,000 gas                                     │
│    ─────────────────────────                                    │
│    총: ~400,000 gas                                             │
│                                                                  │
│    ETH 가격 $3,000, gas price 30 gwei 기준:                     │
│    = 400,000 × 30 × 10^-9 × 3000 = $36/트랜잭션                 │
│                                                                  │
│  L2 사용 시:                                                     │
│    - L2에서 트랜잭션 처리: ~$0.10                                │
│    - L1에는 배치(수백~수천 tx)를 요약해서 제출                   │
│    - 개별 트랜잭션당 L1 비용: ~$0.01-0.05                        │
│                                                                  │
│    → 100배 이상 저렴!                                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  이유 2: 처리 속도 (TPS)                                         │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  Ethereum L1:                                                    │
│    - 블록 시간: ~12초                                           │
│    - 블록당 처리량: ~15-30 TPS                                  │
│    - ZK tx는 더 복잡 → 실제 ~5-10 TPS                           │
│                                                                  │
│  Aztec L2:                                                       │
│    - 블록 시간: ~1초                                            │
│    - 처리량: 수백 TPS                                           │
│    - L1 제출은 비동기적으로 배치 처리                            │
│                                                                  │
│    → 10-100배 빠름!                                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  이유 3: 데이터 가용성 (Data Availability)                       │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  encrypted_notes를 어디에 저장할 것인가?                         │
│                                                                  │
│  L1에 직접 저장 시:                                              │
│    - 모든 encrypted_note가 L1 calldata에 포함                   │
│    - calldata 비용: 16 gas/byte (non-zero)                      │
│    - 평균 Note 크기: ~200 bytes                                 │
│    - Note 저장 비용: 200 × 16 = 3,200 gas                       │
│    - 트랜잭션당 여러 Note → 비용 급증                            │
│                                                                  │
│  L2 + Data Availability Layer:                                  │
│    - L2에 전체 데이터 저장                                       │
│    - L1에는 요약(root hash)만 저장                              │
│    - 또는 별도 DA Layer 사용 (EigenDA, Celestia 등)             │
│                                                                  │
│    → 데이터 저장 비용 대폭 절감!                                  │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  이유 4: 프라이버시 특화 기능                                     │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  L1 EVM의 한계:                                                  │
│    - Public 함수만 존재 (모든 입력이 공개)                       │
│    - Private 상태 변수도 실제로는 읽을 수 있음                   │
│    - ZK 친화적이지 않은 연산 구조                                │
│                                                                  │
│  Aztec L2의 특화 기능:                                           │
│    - Private 함수 네이티브 지원                                  │
│    - 암호화된 Note 처리 최적화                                   │
│    - ZK 회로 생성/검증 최적화                                    │
│    - Private/Public 함수 조합 가능                              │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  이유 5: Rollup을 통한 보안 상속                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  "L2인데 L1만큼 안전한가?"                                        │
│                                                                  │
│  ZK Rollup의 보안 모델:                                          │
│    - L2의 모든 상태 변경은 ZK Proof로 검증됨                     │
│    - L1 Contract가 유효한 Proof만 승인                          │
│    - Sequencer가 악의적이어도:                                   │
│      → 잘못된 상태 전이 불가능 (Proof가 안 만들어짐)              │
│      → 최악의 경우 검열만 가능 (거래 거부)                       │
│      → 검열도 탈출 해치(escape hatch)로 우회 가능                │
│                                                                  │
│  결론: L1의 보안을 그대로 상속받으면서 확장성 확보!               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

**비교 요약:**

| 항목 | L1 직접 | Aztec L2 |
|------|---------|----------|
| 트랜잭션 비용 | ~$36 | ~$0.10 |
| 처리 속도 | ~5 TPS | ~100+ TPS |
| 블록 시간 | 12초 | 1초 |
| Private 함수 | 불가능 | 네이티브 지원 |
| 보안 수준 | L1 | L1과 동등 |

---

## 8. 완전한 시퀀스 플로우: Alice와 Bob의 전체 여정

### 8.1 시나리오 설정

```
┌─────────────────────────────────────────────────────────────────┐
│  시나리오: Private Token의 생애 주기                             │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  1. Alice가 1000 토큰으로 컨트랙트 배포 (자산 생성)              │
│  2. Alice가 Bob에게 300 토큰 전송                               │
│  3. Bob이 Carol에게 100 토큰 전송                               │
│                                                                  │
│  각 단계에서:                                                    │
│  - 누가 어떤 트랜잭션을 보내는지                                 │
│  - 트랜잭션에 무엇이 포함되는지                                  │
│  - 온체인/오프체인에 어떤 변화가 생기는지                        │
│  - 각 참여자가 무엇을 알게 되는지                                │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 8.2 Phase 1: 컨트랙트 배포 & 토큰 생성

```
┌─────────────────────────────────────────────────────────────────┐
│  Step 1-1: Alice가 배포 트랜잭션 준비 (Alice의 PXE에서)          │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Alice의 입력:                                                   │
│    - 컨트랙트 코드 (PrivateToken)                               │
│    - 초기 공급량: 1000                                          │
│    - 소유자: Alice의 주소                                        │
│                                                                  │
│  PXE가 수행하는 작업:                                            │
│                                                                  │
│  1. 초기 Note 생성:                                              │
│     Note_Alice_Initial = {                                      │
│       amount: 1000,                                             │
│       owner: Alice.publicKey,                                   │
│       secret: random(),      // 0x1234abcd...                   │
│       salt: random()         // 고유성 보장                      │
│     }                                                           │
│                                                                  │
│  2. Commitment 계산:                                             │
│     commitment_0 = Hash(                                        │
│       Note_Alice_Initial.amount,                                │
│       Note_Alice_Initial.owner,                                 │
│       Note_Alice_Initial.secret,                                │
│       Note_Alice_Initial.salt                                   │
│     )                                                           │
│     결과: 0xaaa111...                                           │
│                                                                  │
│  3. 암호화된 Note 생성:                                          │
│     encrypted_note_0 = encrypt(                                 │
│       Note_Alice_Initial,                                       │
│       Alice.publicKey                                           │
│     )                                                           │
│     결과: 0xenc_aaa...                                          │
│                                                                  │
│  4. ZK Proof 생성 (Constructor용):                               │
│     proof_deploy = prove({                                      │
│       public_inputs: {                                          │
│         commitment: 0xaaa111...,                                │
│         contract_address: 계산된_주소                            │
│       },                                                        │
│       private_inputs: {                                         │
│         amount: 1000,                                           │
│         owner: Alice.publicKey,                                 │
│         secret: 0x1234abcd...,                                  │
│         salt: ...                                               │
│       }                                                         │
│     })                                                          │
│                                                                  │
│     증명 내용:                                                   │
│     - "commitment가 올바르게 계산됐다"                            │
│     - "amount, owner 등이 유효하다"                              │
│     - (실제 값은 숨김!)                                          │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Step 1-2: 배포 트랜잭션 구조                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  DeployTransaction = {                                          │
│                                                                  │
│    // 메타데이터                                                 │
│    type: "deploy",                                              │
│    contract_class: "PrivateToken",                              │
│                                                                  │
│    // 공개 데이터 (누구나 볼 수 있음)                             │
│    public_data: {                                               │
│      contract_address: 0xcontract...,                          │
│      bytecode_hash: 0xcode...,                                 │
│    },                                                           │
│                                                                  │
│    // Private 함수 실행 결과                                     │
│    private_execution_result: {                                  │
│                                                                  │
│      // 새로 생성되는 Note의 Commitment                          │
│      new_commitments: [                                         │
│        0xaaa111...    // Alice의 1000 토큰 Note                 │
│      ],                                                         │
│                                                                  │
│      // 소비되는 Note (배포 시에는 없음)                          │
│      nullifiers: [],                                            │
│                                                                  │
│      // 암호화된 Note 데이터 (복구용)                            │
│      encrypted_notes: [                                         │
│        {                                                        │
│          data: 0xenc_aaa...,  // 암호화된 Note_Alice_Initial    │
│          recipient: Alice.publicKey                             │
│        }                                                        │
│      ],                                                         │
│                                                                  │
│      // ZK Proof                                                │
│      proof: 0xproof_deploy...   // ~32KB                        │
│                                                                  │
│    },                                                           │
│                                                                  │
│    // 서명                                                       │
│    signature: sign(tx_hash, Alice.privateKey)                   │
│                                                                  │
│  }                                                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Step 1-3: 트랜잭션 제출 및 처리                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  [Alice's PXE] ──tx──> [Aztec Sequencer]                        │
│                                                                  │
│  Sequencer 검증:                                                 │
│    1. ✓ ZK Proof 유효성 검증                                    │
│    2. ✓ 서명 검증                                               │
│    3. ✓ contract_address 계산 일치 확인                         │
│    4. ✓ bytecode_hash 확인                                      │
│                                                                  │
│  Sequencer는 모르는 것:                                          │
│    - 초기 공급량 (1000)                                         │
│    - 실제 토큰 소유자 (Alice)                                    │
│    - Note의 실제 내용                                           │
│                                                                  │
│  Sequencer가 아는 것:                                            │
│    - "유효한 Note가 1개 생성됐다"                                │
│    - "컨트랙트가 배포됐다"                                       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Step 1-4: 상태 변경                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  [L2 상태 변경]                                                  │
│                                                                  │
│  Note Hash Tree:                                                 │
│    Before: (empty)                                              │
│    After:  [0] = 0xaaa111...  ← Alice의 Note commitment         │
│                                                                  │
│  Nullifier Set:                                                  │
│    Before: {}                                                   │
│    After:  {}  (변화 없음)                                       │
│                                                                  │
│  Contract Storage:                                               │
│    contracts[0xcontract...] = deployed                          │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  [Alice's PXE 상태 변경]                                         │
│                                                                  │
│  my_notes:                                                       │
│    Before: []                                                   │
│    After:  [                                                    │
│      {                                                          │
│        note: Note_Alice_Initial,                                │
│        commitment: 0xaaa111...,                                 │
│        tree_index: 0,                                           │
│        status: "unspent"                                        │
│      }                                                          │
│    ]                                                            │
│                                                                  │
│  my_balance: 1000 토큰                                          │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  [Bob's PXE 상태] - 변화 없음                                    │
│    my_notes: []                                                 │
│    my_balance: 0 토큰                                           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 8.3 Phase 2: Alice → Bob 300 토큰 전송

```
┌─────────────────────────────────────────────────────────────────┐
│  Step 2-1: Alice가 전송 준비 (Alice의 PXE에서)                   │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Alice의 입력:                                                   │
│    - 받는 사람: Bob.publicKey                                   │
│    - 금액: 300                                                  │
│                                                                  │
│  PXE가 수행하는 작업:                                            │
│                                                                  │
│  1. 사용할 Note 선택:                                            │
│     선택된 Note: Note_Alice_Initial (1000 토큰)                 │
│     → 300 전송 후 거스름돈 700 필요                              │
│                                                                  │
│  2. Nullifier 계산 (소비 표시용):                                │
│     nullifier_alice_initial = Hash(                             │
│       Note_Alice_Initial.commitment,  // 0xaaa111...            │
│       Alice.secretKey,                                          │
│       unique_nonce                                              │
│     )                                                           │
│     결과: 0xnull_aaa...                                         │
│                                                                  │
│  3. 새 Note 2개 생성:                                            │
│                                                                  │
│     // Bob에게 갈 Note                                           │
│     Note_Bob_300 = {                                            │
│       amount: 300,                                              │
│       owner: Bob.publicKey,                                     │
│       secret: random(),      // 0x5678efgh...                   │
│       salt: random()                                            │
│     }                                                           │
│     commitment_bob = Hash(Note_Bob_300)                         │
│     결과: 0xbbb222...                                           │
│                                                                  │
│     // Alice의 거스름돈 Note                                     │
│     Note_Alice_700 = {                                          │
│       amount: 700,                                              │
│       owner: Alice.publicKey,                                   │
│       secret: random(),      // 0x9abc...                       │
│       salt: random()                                            │
│     }                                                           │
│     commitment_change = Hash(Note_Alice_700)                    │
│     결과: 0xccc333...                                           │
│                                                                  │
│  4. Note 암호화:                                                 │
│     encrypted_note_bob = encrypt(Note_Bob_300, Bob.publicKey)   │
│     encrypted_note_change = encrypt(Note_Alice_700, Alice.pubK) │
│                                                                  │
│  5. Merkle Proof 준비:                                          │
│     // Note_Alice_Initial이 Tree에 있음을 증명                  │
│     merkle_proof = get_merkle_path(tree_index: 0)               │
│     결과: [sibling_hashes...]                                   │
│                                                                  │
│  6. ZK Proof 생성:                                               │
│     proof_transfer = prove({                                    │
│       public_inputs: {                                          │
│         tree_root: current_root,     // Tree의 현재 상태        │
│         nullifier: 0xnull_aaa...,    // 소비되는 Note 표시      │
│         new_commitments: [                                      │
│           0xbbb222...,               // Bob의 새 Note           │
│           0xccc333...                // Alice의 거스름돈         │
│         ]                                                       │
│       },                                                        │
│       private_inputs: {                                         │
│         // 소비되는 Note 정보 (비공개)                           │
│         input_note: Note_Alice_Initial,                         │
│         input_note_index: 0,                                    │
│         merkle_path: [sibling_hashes...],                       │
│         owner_secret_key: Alice.secretKey,                      │
│                                                                  │
│         // 생성되는 Note 정보 (비공개)                           │
│         output_notes: [Note_Bob_300, Note_Alice_700],           │
│         transfer_amount: 300                                    │
│       }                                                         │
│     })                                                          │
│                                                                  │
│     Circuit이 검증하는 것:                                       │
│     ┌─────────────────────────────────────────────────────┐    │
│     │ 1. input_note가 Tree에 존재 (merkle_proof 검증)      │    │
│     │ 2. nullifier가 올바르게 계산됨                       │    │
│     │ 3. Alice가 input_note 소유자 (서명 검증)            │    │
│     │ 4. 금액 보존: 1000 = 300 + 700                      │    │
│     │ 5. new_commitments가 올바르게 계산됨                 │    │
│     │ 6. output_notes의 owner가 올바름                    │    │
│     └─────────────────────────────────────────────────────┘    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Step 2-2: 전송 트랜잭션 구조                                    │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  TransferTransaction = {                                        │
│                                                                  │
│    // 메타데이터                                                 │
│    type: "private_call",                                        │
│    contract_address: 0xcontract...,                             │
│    function_name: "transfer",                                   │
│                                                                  │
│    // 함수 인자 (암호화/해시됨 - 원본 값 숨김)                    │
│    args_hash: Hash(300, Alice.addr, Bob.addr),                  │
│                                                                  │
│    // Private 실행 결과                                          │
│    private_execution_result: {                                  │
│                                                                  │
│      // 소비되는 Note의 Nullifier                                │
│      nullifiers: [                                              │
│        0xnull_aaa...   // Note_Alice_Initial 소비됨             │
│      ],                                                         │
│                                                                  │
│      // 새로 생성되는 Note의 Commitment                          │
│      new_commitments: [                                         │
│        0xbbb222...,    // Bob의 300 토큰                        │
│        0xccc333...     // Alice의 700 토큰 (거스름돈)            │
│      ],                                                         │
│                                                                  │
│      // 암호화된 Note (각 수신자만 복호화 가능)                   │
│      encrypted_notes: [                                         │
│        {                                                        │
│          data: encrypt(Note_Bob_300, Bob.publicKey),            │
│          recipient_tag: tag_for_bob  // Bob이 찾을 수 있는 태그  │
│        },                                                       │
│        {                                                        │
│          data: encrypt(Note_Alice_700, Alice.publicKey),        │
│          recipient_tag: tag_for_alice                           │
│        }                                                        │
│      ],                                                         │
│                                                                  │
│      // ZK Proof (핵심!)                                        │
│      proof: 0xproof_transfer...    // ~32KB                     │
│                                                                  │
│    },                                                           │
│                                                                  │
│    // 서명                                                       │
│    signature: sign(tx_hash, Alice.privateKey)                   │
│                                                                  │
│  }                                                               │
│                                                                  │
│  ────────────────────────────────────────────────────────────── │
│                                                                  │
│  관찰자가 볼 수 있는 것:                                          │
│    - "누군가가 transfer 함수를 호출함"                           │
│    - "Note 1개가 소비됨 (nullifier)"                            │
│    - "Note 2개가 생성됨 (commitments)"                          │
│    - "ZK Proof가 유효함"                                        │
│                                                                  │
│  관찰자가 볼 수 없는 것:                                          │
│    - 누가 보냈는지 (Alice)                                      │
│    - 누가 받는지 (Bob)                                          │
│    - 얼마를 보냈는지 (300)                                      │
│    - 원래 잔액 (1000)                                           │
│    - 남은 잔액 (700)                                            │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Step 2-3: Sequencer 처리                                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  [Alice's PXE] ──tx──> [Mempool] ──> [Sequencer]                │
│                                                                  │
│  Sequencer 검증 과정:                                            │
│                                                                  │
│  Check 1: ZK Proof 검증                                          │
│    verify(                                                      │
│      proof: 0xproof_transfer...,                                │
│      public_inputs: {                                           │
│        tree_root: 0xroot...,                                    │
│        nullifiers: [0xnull_aaa...],                             │
│        new_commitments: [0xbbb222..., 0xccc333...]              │
│      }                                                          │
│    )                                                            │
│    → Result: ✓ VALID                                            │
│                                                                  │
│  Check 2: Tree Root 확인                                         │
│    current_tree_root == tx.tree_root?                           │
│    → Result: ✓ MATCH                                            │
│                                                                  │
│  Check 3: Nullifier 중복 확인                                    │
│    0xnull_aaa... in nullifier_set?                              │
│    → Result: ✗ NOT FOUND (= 처음 사용, OK!)                      │
│                                                                  │
│  Check 4: 서명 검증                                              │
│    verify_signature(tx, Alice.publicKey)?                       │
│    → Result: ✓ VALID                                            │
│                                                                  │
│  모든 검증 통과 → 트랜잭션 블록에 포함!                           │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Step 2-4: 상태 변경                                            │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  [L2 상태 변경]                                                  │
│                                                                  │
│  Note Hash Tree:                                                 │
│    Before:                                                       │
│      [0] = 0xaaa111...  (Alice의 1000)                          │
│                                                                  │
│    After:                                                        │
│      [0] = 0xaaa111...  (여전히 존재! 삭제 안 함)                │
│      [1] = 0xbbb222...  (Bob의 300) ← 새로 추가                  │
│      [2] = 0xccc333...  (Alice의 700) ← 새로 추가               │
│                                                                  │
│  Nullifier Set:                                                  │
│    Before: {}                                                   │
│    After:  { 0xnull_aaa... }  ← Note [0]이 사용됨 표시          │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  [Alice's PXE 상태 변경]                                         │
│                                                                  │
│  my_notes:                                                       │
│    Before: [                                                    │
│      { note: Note_Alice_Initial, index: 0, status: "unspent" }  │
│    ]                                                            │
│    After: [                                                     │
│      { note: Note_Alice_Initial, index: 0, status: "SPENT" },   │
│      { note: Note_Alice_700, index: 2, status: "unspent" }      │
│    ]                                                            │
│                                                                  │
│  my_balance: 1000 → 700 토큰                                    │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  [Bob's PXE 동기화] - 새 블록 수신 시                            │
│                                                                  │
│  1. 새 블록의 encrypted_notes 스캔                               │
│  2. 각 encrypted_note를 자신의 키로 복호화 시도:                 │
│                                                                  │
│     // 첫 번째 encrypted_note                                   │
│     try decrypt(0xenc_bob..., Bob.secretKey)                    │
│       → 성공! Note_Bob_300 획득                                  │
│       → my_notes에 추가                                         │
│                                                                  │
│     // 두 번째 encrypted_note                                   │
│     try decrypt(0xenc_alice..., Bob.secretKey)                  │
│       → 실패 (Alice 것이라 복호화 안 됨)                         │
│       → 무시                                                    │
│                                                                  │
│  Bob's PXE After:                                               │
│    my_notes: [                                                  │
│      { note: Note_Bob_300, index: 1, status: "unspent" }        │
│    ]                                                            │
│    my_balance: 0 → 300 토큰                                     │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Step 2-5: 최종 상태 요약                                        │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────┬────────────────┬────────────────┐              │
│  │             │  Alice         │  Bob           │              │
│  ├─────────────┼────────────────┼────────────────┤              │
│  │ 잔액        │  700 토큰      │  300 토큰      │              │
│  │ Note 개수   │  1개           │  1개           │              │
│  │ 사용된 Note │  1개           │  0개           │              │
│  └─────────────┴────────────────┴────────────────┘              │
│                                                                  │
│  온체인 관찰자 시점:                                              │
│  "3개의 commitment와 1개의 nullifier가 존재한다."                │
│  "누가 얼마를 가졌는지는 전혀 알 수 없다."                       │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 8.4 Phase 3: Bob → Carol 100 토큰 전송

```
┌─────────────────────────────────────────────────────────────────┐
│  Step 3-1: Bob이 전송 준비 (Bob의 PXE에서)                       │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Bob의 입력:                                                     │
│    - 받는 사람: Carol.publicKey                                 │
│    - 금액: 100                                                  │
│                                                                  │
│  1. 사용할 Note 선택:                                            │
│     선택: Note_Bob_300 (Bob의 유일한 Note)                      │
│     거스름돈: 200 필요                                          │
│                                                                  │
│  2. Nullifier 계산:                                              │
│     nullifier_bob = Hash(                                       │
│       0xbbb222...,              // Note commitment              │
│       Bob.secretKey,                                            │
│       unique_nonce                                              │
│     )                                                           │
│     결과: 0xnull_bbb...                                         │
│                                                                  │
│  3. 새 Note 생성:                                                │
│     Note_Carol_100 = { amount: 100, owner: Carol, ... }         │
│     commitment_carol = 0xddd444...                              │
│                                                                  │
│     Note_Bob_200 = { amount: 200, owner: Bob, ... }             │
│     commitment_bob_change = 0xeee555...                         │
│                                                                  │
│  4. ZK Proof 생성:                                               │
│     public_inputs:                                              │
│       - tree_root: 현재 root (3개 leaf 포함)                    │
│       - nullifier: 0xnull_bbb...                                │
│       - new_commitments: [0xddd444..., 0xeee555...]             │
│                                                                  │
│     private_inputs:                                             │
│       - input: Note_Bob_300 at index 1                          │
│       - outputs: [Note_Carol_100, Note_Bob_200]                 │
│       - 300 = 100 + 200 (보존 증명)                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Step 3-2: 트랜잭션 & 상태 변경                                  │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  Transaction:                                                   │
│    nullifiers: [0xnull_bbb...]                                  │
│    new_commitments: [0xddd444..., 0xeee555...]                  │
│    encrypted_notes: [                                           │
│      encrypt(Note_Carol_100, Carol.pubKey),                     │
│      encrypt(Note_Bob_200, Bob.pubKey)                          │
│    ]                                                            │
│    proof: 0xproof_bob_transfer...                               │
│                                                                  │
│  ─────────────────────────────────────────────────────────────  │
│                                                                  │
│  상태 변경 후:                                                   │
│                                                                  │
│  Note Hash Tree:                                                 │
│    [0] = 0xaaa111...  (Alice 1000, NULLIFIED)                   │
│    [1] = 0xbbb222...  (Bob 300, NULLIFIED)  ← 이번에 소비됨     │
│    [2] = 0xccc333...  (Alice 700, active)                       │
│    [3] = 0xddd444...  (Carol 100) ← 새로 추가                   │
│    [4] = 0xeee555...  (Bob 200) ← 새로 추가                     │
│                                                                  │
│  Nullifier Set:                                                  │
│    { 0xnull_aaa..., 0xnull_bbb... }                             │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────────┐
│  Step 3-3: 각 참여자의 최종 상태                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  ┌─────────────┬────────────┬────────────┬────────────┐         │
│  │             │  Alice     │  Bob       │  Carol     │         │
│  ├─────────────┼────────────┼────────────┼────────────┤         │
│  │ 잔액        │  700       │  200       │  100       │         │
│  │ Note 개수   │  1         │  1         │  1         │         │
│  │ Note 상세   │  [2]=700   │  [4]=200   │  [3]=100   │         │
│  └─────────────┴────────────┴────────────┴────────────┘         │
│                                                                  │
│  총 공급량 확인: 700 + 200 + 100 = 1000 ✓ (초기 공급량 유지)    │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

### 8.5 전체 시퀀스 다이어그램

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           전체 흐름 다이어그램                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  시간 →                                                                 │
│                                                                         │
│  ════════════════════════════════════════════════════════════════════  │
│  Phase 1: 컨트랙트 배포                                                 │
│  ════════════════════════════════════════════════════════════════════  │
│                                                                         │
│  Alice's PXE          Aztec L2              Note Tree    Nullifier Set │
│       │                   │                     │              │        │
│       │ 1. Create Note    │                     │              │        │
│       │    (1000 토큰)    │                     │              │        │
│       │                   │                     │              │        │
│       │ 2. Generate Proof │                     │              │        │
│       │    (constructor)  │                     │              │        │
│       │                   │                     │              │        │
│       │────Deploy TX─────>│                     │              │        │
│       │  - commitment     │ 3. Verify Proof    │              │        │
│       │  - proof          │ 4. Add commitment  │              │        │
│       │  - encrypted_note │────────────────────>│ [0]=0xaaa   │        │
│       │                   │                     │              │        │
│       │<────Success───────│                     │              │        │
│       │                   │                     │              │        │
│                                                                         │
│  Alice's Balance: 1000                                                  │
│  Bob's Balance: 0                                                       │
│                                                                         │
│  ════════════════════════════════════════════════════════════════════  │
│  Phase 2: Alice → Bob (300 토큰)                                        │
│  ════════════════════════════════════════════════════════════════════  │
│                                                                         │
│  Alice's PXE          Aztec L2              Note Tree    Nullifier Set │
│       │                   │                     │              │        │
│       │ 1. Select Note[0] │                     │              │        │
│       │    (1000 토큰)    │                     │              │        │
│       │                   │                     │              │        │
│       │ 2. Create:        │                     │              │        │
│       │  - Note_Bob(300)  │                     │              │        │
│       │  - Note_Change(700)                     │              │        │
│       │                   │                     │              │        │
│       │ 3. Compute:       │                     │              │        │
│       │  - nullifier      │                     │              │        │
│       │  - commitments    │                     │              │        │
│       │                   │                     │              │        │
│       │ 4. Generate Proof │                     │              │        │
│       │                   │                     │              │        │
│       │───Transfer TX────>│                     │              │        │
│       │  - nullifier      │ 5. Verify Proof    │              │        │
│       │  - commitments    │ 6. Check nullifier │              │        │
│       │  - proof          │    not exists      │              │        │
│       │  - enc_notes      │ 7. Add nullifier   │──────────────>│{0xnull}│
│       │                   │ 8. Add commitments │              │        │
│       │                   │────────────────────>│ [1]=0xbbb   │        │
│       │                   │                    >│ [2]=0xccc   │        │
│       │<────Success───────│                     │              │        │
│       │                   │                     │              │        │
│                                                                         │
│  ─────────────────────────────────────────────────────────────────────  │
│                                                                         │
│  Bob's PXE            Aztec L2                                          │
│       │                   │                                             │
│       │<──New Block───────│                                             │
│       │   (enc_notes)     │                                             │
│       │                   │                                             │
│       │ 9. Try decrypt    │                                             │
│       │    each enc_note  │                                             │
│       │                   │                                             │
│       │ 10. Success!      │                                             │
│       │   Note_Bob(300)   │                                             │
│       │   at index [1]    │                                             │
│       │                   │                                             │
│                                                                         │
│  Alice's Balance: 700                                                   │
│  Bob's Balance: 300                                                     │
│                                                                         │
│  ════════════════════════════════════════════════════════════════════  │
│  Phase 3: Bob → Carol (100 토큰)                                        │
│  ════════════════════════════════════════════════════════════════════  │
│                                                                         │
│  Bob's PXE            Aztec L2              Note Tree    Nullifier Set │
│       │                   │                     │              │        │
│       │ 1. Select Note[1] │                     │              │        │
│       │    (300 토큰)     │                     │              │        │
│       │                   │                     │              │        │
│       │ 2. Create:        │                     │              │        │
│       │  - Note_Carol(100)│                     │              │        │
│       │  - Note_Change(200)                     │              │        │
│       │                   │                     │              │        │
│       │───Transfer TX────>│                     │              │        │
│       │                   │ 3. Verify & Update │              │        │
│       │                   │───────────────────>│ [3]=0xddd   │        │
│       │                   │                   >│ [4]=0xeee   │        │
│       │                   │──────────────────────────────────>│+0xnull2│
│       │<────Success───────│                     │              │        │
│                                                                         │
│  Carol's PXE          Aztec L2                                          │
│       │                   │                                             │
│       │<──New Block───────│                                             │
│       │   + decrypt       │                                             │
│       │   = Note(100)     │                                             │
│                                                                         │
│  Final Balances:                                                        │
│    Alice: 700 (Note[2])                                                 │
│    Bob: 200 (Note[4])                                                   │
│    Carol: 100 (Note[3])                                                 │
│    Total: 1000 ✓                                                        │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

---

### 8.6 트랜잭션 파라미터 상세

```
┌─────────────────────────────────────────────────────────────────┐
│  Private Transaction의 전체 구조                                 │
├─────────────────────────────────────────────────────────────────┤
│                                                                  │
│  PrivateTransaction {                                           │
│                                                                  │
│    // ═══════════════════════════════════════════════════════  │
│    // Header (메타데이터)                                        │
│    // ═══════════════════════════════════════════════════════  │
│    header: {                                                    │
│      version: 1,                                                │
│      chain_id: 31337,          // 네트워크 ID                   │
│      nonce: 5,                 // 재전송 방지                    │
│      max_fee: 1000000,         // 최대 수수료                   │
│    },                                                           │
│                                                                  │
│    // ═══════════════════════════════════════════════════════  │
│    // Origin (트랜잭션 발신자)                                   │
│    // ═══════════════════════════════════════════════════════  │
│    origin: {                                                    │
│      // 주의: 이것은 "계정 컨트랙트" 주소                        │
│      // (EOA가 아님 - Aztec은 Account Abstraction 사용)          │
│      address: 0x2735b31f...,                                   │
│    },                                                           │
│                                                                  │
│    // ═══════════════════════════════════════════════════════  │
│    // Function Call (호출할 함수)                                │
│    // ═══════════════════════════════════════════════════════  │
│    function_call: {                                             │
│      contract_address: 0xcontract...,                          │
│      function_selector: 0x27e740b2,  // transfer 함수           │
│      is_private: true,                                          │
│                                                                  │
│      // 인자는 해시만 공개 (실제 값은 proof에 포함)               │
│      args_hash: 0xargs...,                                      │
│    },                                                           │
│                                                                  │
│    // ═══════════════════════════════════════════════════════  │
│    // Private Kernel Output (핵심!)                             │
│    // ═══════════════════════════════════════════════════════  │
│    private_kernel_output: {                                     │
│                                                                  │
│      // 1. 소비되는 Note 표시 ─────────────────────────────────  │
│      nullifiers: [                                              │
│        {                                                        │
│          value: 0xnull_aaa...,     // Nullifier 값             │
│          // 어떤 Note인지는 알 수 없음!                         │
│        }                                                        │
│      ],                                                         │
│                                                                  │
│      // 2. 새로 생성되는 Note ─────────────────────────────────  │
│      note_hashes: [                // = commitments             │
│        {                                                        │
│          value: 0xbbb222...,       // Bob의 Note commitment    │
│          // 금액, 소유자 모름!                                  │
│        },                                                       │
│        {                                                        │
│          value: 0xccc333...,       // Alice 거스름돈 commitment │
│        }                                                        │
│      ],                                                         │
│                                                                  │
│      // 3. 암호화된 로그 (Note 데이터 복구용) ─────────────────  │
│      encrypted_logs: [                                          │
│        {                                                        │
│          // Bob에게 보내는 암호화된 Note 정보                   │
│          ciphertext: 0xenc_bob...,                             │
│          // 수신자 태그 (Bob이 자기 것인지 확인용)              │
│          tag: derive_tag(Bob.ivsk, contract),                  │
│        },                                                       │
│        {                                                        │
│          // Alice의 거스름돈 Note                              │
│          ciphertext: 0xenc_alice...,                           │
│          tag: derive_tag(Alice.ivsk, contract),                │
│        }                                                        │
│      ],                                                         │
│                                                                  │
│      // 4. L2→L1 메시지 (브릿지용, 여기선 없음)                  │
│      l2_to_l1_messages: [],                                     │
│                                                                  │
│      // 5. Public 함수 호출 요청 (여기선 없음)                   │
│      public_call_requests: [],                                  │
│                                                                  │
│    },                                                           │
│                                                                  │
│    // ═══════════════════════════════════════════════════════  │
│    // ZK Proof (가장 중요!)                                     │
│    // ═══════════════════════════════════════════════════════  │
│    proof: {                                                     │
│      // Client IVC Proof (~32KB)                                │
│      // 여러 개의 nested proof를 하나로 압축                    │
│      data: 0xproof...,                                         │
│                                                                  │
│      // 이 proof가 증명하는 것:                                  │
│      // ┌─────────────────────────────────────────────────┐    │
│      // │ 1. 소비되는 Note가 Tree에 존재                   │    │
│      // │ 2. Nullifier가 Note에서 올바르게 파생           │    │
│      // │ 3. 트랜잭션 서명자가 Note 소유자                │    │
│      // │ 4. 입력 금액 = 출력 금액 (보존)                 │    │
│      // │ 5. 새 Note commitment가 올바르게 계산           │    │
│      // │ 6. 컨트랙트 로직이 올바르게 실행                │    │
│      // └─────────────────────────────────────────────────┘    │
│    },                                                           │
│                                                                  │
│  }                                                               │
│                                                                  │
└─────────────────────────────────────────────────────────────────┘
```

---

## 부록: 용어 사전

| 용어 | 영어 | 설명 |
|------|------|------|
| 노트 | Note | 암호화된 잔액 단위, UTXO와 유사 |
| 커밋먼트 | Commitment | 노트의 해시값, 내용을 숨기면서 존재 증명 |
| 널리파이어 | Nullifier | 노트가 사용됐음을 표시하는 고유 ID |
| 영지식증명 | Zero Knowledge Proof | 비밀을 밝히지 않고 사실을 증명하는 기술 |
| 머클트리 | Merkle Tree | 데이터를 효율적으로 저장하고 검증하는 구조 |
| PXE | Private Execution Environment | 로컬에서 비밀 연산을 수행하는 환경 |
| UTXO | Unspent Transaction Output | 아직 사용하지 않은 트랜잭션 출력 |
| 시퀀서 | Sequencer | L2 블록을 생성하는 노드 |
| 롤업 | Rollup | L2의 상태를 L1에 요약해서 저장하는 기술 |

---

## 참고 자료

- [Aztec Documentation](https://docs.aztec.network/)
- [Noir Language](https://noir-lang.org/)
- [Zero Knowledge Proofs 입문](https://zkp.science/)
- [UTXO vs Account Model](https://www.horizen.io/academy/utxo-vs-account-model/)
