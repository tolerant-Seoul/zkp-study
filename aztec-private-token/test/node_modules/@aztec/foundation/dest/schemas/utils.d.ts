import { type ParseInput, type ParseReturnType, type ZodObject, ZodOptional, type ZodRawShape, type ZodType, type ZodTypeAny, z } from 'zod';
import type { ZodFor } from './types.js';
export declare const hexSchema: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, string, string>;
/** Schema for a buffer represented as a base64 string. */
export declare const bufferSchema: z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, Buffer<ArrayBuffer>, string>;
export declare class ZodNullableOptional<T extends ZodTypeAny> extends ZodOptional<T> {
    _isNullableOptional: boolean;
    _parse(input: ParseInput): ParseReturnType<this['_output']>;
    static create<T extends ZodTypeAny>(type: T): ZodNullableOptional<T>;
}
/**
 * Declares a parameter as optional. Use this over z.optional in order to accept nulls as undefineds.
 * This is required as JSON does not have an undefined type, and null is used to represent it, so we
 * need to convert nulls to undefineds as we parse.
 */
export declare function optional<T extends ZodTypeAny>(schema: T): ZodNullableOptional<T>;
type ToJsonIs<T, TRet> = T extends {
    toJSON(): TRet;
} ? T : never;
/**
 * Creates a schema that accepts a hex string and uses it to hydrate an instance.
 * @param klazz - Class that implements either fromString or fromBuffer.
 * @returns A schema for the class.
 */
export declare function hexSchemaFor<TClass extends {
    fromString(str: string): any;
} | {
    fromBuffer(buf: Buffer): any;
}>(klazz: TClass, refinement?: (input: string) => boolean): ZodType<TClass extends {
    fromString(str: string): infer TInstance;
} | {
    fromBuffer(buf: Buffer): infer TInstance;
} ? ToJsonIs<TInstance, string> : never, any, string>;
/**
 * Creates a schema that accepts a base64 string and uses it to hydrate an instance.
 * @param klazz - Class that implements fromBuffer.
 * @returns A schema for the class.
 */
export declare function bufferSchemaFor<TClass extends {
    fromBuffer(buf: Buffer): any;
}>(klazz: TClass): ZodType<TClass extends {
    fromBuffer(buf: Buffer): infer TInstance;
} ? ToJsonIs<TInstance, Buffer> : never, any, string>;
/** Creates a schema for a js Map type that matches the serialization used in jsonStringify. */
export declare function mapSchema<TKey, TValue>(key: ZodFor<TKey>, value: ZodFor<TValue>): ZodFor<Map<TKey, TValue>>;
/** Creates a schema for a js Set type that matches the serialization used in jsonStringify. */
export declare function setSchema<T>(value: ZodFor<T>): ZodFor<Set<T>>;
/** Given an already parsed and validated object, extracts the keys defined in the given schema. Does not validate again. */
export declare function pickFromSchema<T extends object, S extends ZodObject<ZodRawShape>>(obj: T, schema: S): Partial<T>;
export {};
//# sourceMappingURL=utils.d.ts.map