import type { ProjPointType } from '@noble/curves/abstract/weierstrass';
import { inspect } from 'util';
import { BufferReader } from '../serialize/index.js';
import { BLS12Fq, BLS12Fr } from './bls12_fields.js';
import { Fr } from './fields.js';
/**
 * Represents a Point on an elliptic curve with x and y coordinates.
 * The Point class provides methods for creating instances from different input types,
 * converting instances to various output formats, and checking the equality of points.
 * TODO(#7386): Clean up this class.
 */
export declare class BLS12Point {
    /**
     * The point's x coordinate
     */
    readonly x: BLS12Fq;
    /**
     * The point's y coordinate
     */
    readonly y: BLS12Fq;
    /**
     * Whether the point is at infinity
     */
    readonly isInfinite: boolean;
    static ZERO: BLS12Point;
    static ONE: BLS12Point;
    static SIZE_IN_BYTES: number;
    static COMPRESSED_SIZE_IN_BYTES: number;
    static COMPRESSED_ZERO: Buffer<ArrayBufferLike>;
    constructor(
    /**
     * The point's x coordinate
     */
    x: BLS12Fq, 
    /**
     * The point's y coordinate
     */
    y: BLS12Fq, 
    /**
     * Whether the point is at infinity
     */
    isInfinite: boolean);
    toJSON(): `0x${string}`;
    [inspect.custom](): string;
    static get schema(): import("zod").ZodType<BLS12Point, any, string>;
    /**
     * Generate a random Point instance.
     *
     * @returns A randomly generated Point instance.
     */
    static random(): BLS12Point;
    /**
     * Create a Point instance from a given buffer or BufferReader.
     * The input 'buffer' should have exactly 96 bytes representing the x and y coordinates.
     *
     * @param buffer - The buffer or BufferReader containing the x and y coordinates of the point.
     * @returns A Point instance.
     */
    static fromBuffer(buffer: Buffer | BufferReader): BLS12Point;
    /**
     * Create a Point instance from a hex-encoded string.
     * The input should be prefixed with '0x' or not, and have exactly 128 hex characters representing the x and y coordinates.
     * Throws an error if the input length is invalid or coordinate values are out of range.
     *
     * @param str - The hex-encoded string representing the Point coordinates.
     * @returns A Point instance.
     */
    static fromString(str: string): BLS12Point;
    /**
     * Create a compressed buffer instance from a point.
     * @dev NOTE: The compression standard for BLS12-381 differs from BN curves. Instead of
     * one is_positive flag, we have three flags to prepend:
     * - is_compressed: indicator that the point is compressed
     * - is_infinity: whether the point the point at infinity
     * - is_greater: only set if is_compressed && !is_infinity && y > (p - 1)/2
     * See https://github.com/arkworks-rs/algebra/blob/master/curves/bls12_381/src/curves/g1.rs -> serialize_with_mode() -> encoding
     * and noble-curves/src/bls12-381.ts -> setMask()
     * @dev Most of the logic below is taken from noble-curves/src/bls12-381.ts -> toBytes()
     * @param point A BLS12Point instance.
     * @returns The buffer containing the x coordinate and the flags of the y coordinate.
     */
    compress(): Buffer;
    /**
     * Create a Point instance from a compressed buffer.
     * @dev See compress() above for compression encoding for BLS12-381.
     * @dev Most of the logic below is taken from noble-curves/src/bls12-381.ts -> fromBytes()
     * @param buffer - The buffer containing the x coordinate and the flags of the y coordinate.
     * @returns A BLS12Point instance.
     */
    static decompress(buffer: Buffer): BLS12Point;
    /**
     * Converts a Point to two BN254 Fr elements by storing its compressed form as:
     * +------------------+------------------+
     * | Field Element 1  | Field Element 2  |
     * | [bytes 0-31]     | [bytes 32-47]   |
     * +------------------+------------------+
     * |     32 bytes     |     16 bytes    |
     * +------------------+------------------+
     * Used in the rollup circuits to store blob commitments in the native field type. See blob.ts.
     * @param point - A BLS12Point instance.
     * @returns The point fields.
     */
    toBN254Fields(): Fr[];
    /**
     * Creates a Point instance from 2 BN254 Fr fields as encoded in toBNFields() above.
     * Used in the rollup circuits to store blob commitments in the native field type. See blob.ts.
     * @param fields - The encoded BN254 fields.
     * @returns The point fields.
     */
    static fromBN254Fields(fields: [Fr, Fr]): BLS12Point;
    /**
     * Creates a point from an array of 2 fields.
     * @returns The point
     */
    static fromBLS12FqFields(fields: BLS12Fq[]): BLS12Point;
    /**
     * Creates a point from @noble/curves projective point definition.
     * @returns The point
     */
    static fromNobleProjectivePoint(point: ProjPointType<bigint>): BLS12Point;
    /**
     * Uses the x coordinate and isPositive flag (+/-) to reconstruct the point.
     * @param x - The x coordinate of the point
     * @param sign - The "sign" of the y coordinate - note that this is not a sign as is known in integer arithmetic.
     * Instead it is a boolean flag that determines whether the y coordinate is <= (Fr.MODULUS - 1) / 2
     * @returns The point as an array of 2 fields
     */
    static fromXAndSign(x: BLS12Fq, sign: boolean): BLS12Point;
    /**
     * @param x - The x coordinate of the point
     * @returns y^2 such that y^2 = x^3 + 4
     */
    static YSquaredFromX(x: BLS12Fq): BLS12Fq;
    /**
     * @param x - The x coordinate of the point
     * @returns The y coordinate of the point, if it exists on BLS12-381
     */
    static YFromX(x: BLS12Fq): BLS12Fq | null;
    /**
     * @param x - The x coordinate of the point
     * @param y - The y coordinate of the point
     * @returns Whether the point exists on BLS12-381
     */
    static isOnCurve(x: BLS12Fq, y: BLS12Fq): boolean;
    /**
     * Returns the contents of the point as an array of 2 fields.
     * @returns The point as an array of 2 fields
     */
    toBLS12FqFields(): BLS12Fq[];
    /**
     * Returns the x coordinate and the sign of the y coordinate.
     * @dev The y sign can be determined by checking if the y coordinate is greater than half of the modulus.
     * @returns The x coordinate and the sign of the y coordinate.
     */
    toXAndSign(): [BLS12Fq, boolean];
    /**
     * Returns the contents of the point as BigInts.
     * @returns The point as BigInts
     */
    toBigInts(): {
        x: bigint;
        y: bigint;
        isInfinite: bigint;
    };
    /**
     * Converts the Point instance to a Buffer representation of the coordinates.
     * @returns A Buffer representation of the Point instance.
     * @dev Note that toBuffer does not include the isInfinite flag and other serialization methods do (e.g. toBigInts).
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Convert the Point instance to a hexadecimal string representation.
     * The output string is prefixed with '0x' and consists of exactly 128 hex characters,
     * representing the concatenated x and y coordinates of the point.
     *
     * @returns A hex-encoded string representing the Point instance.
     */
    toString(): `0x${string}`;
    /**
     * Check if two Point instances are equal by comparing their buffer values.
     * Returns true if the buffer values are the same, and false otherwise.
     *
     * @param rhs - The Point instance to compare with the current instance.
     * @returns A boolean indicating whether the two Point instances are equal.
     */
    equals(rhs: BLS12Point): boolean;
    /**
     * Check whether the point is zero.
     */
    isZero(): boolean;
    /**
     * Check if this is point at infinity.
     * Check this is consistent with how bb is encoding the point at infinity
     */
    get inf(): boolean;
    /** Arithmetic - wrapper around noble curves */
    toNobleProjectivePoint(): ProjPointType<bigint>;
    add(rhs: BLS12Point): BLS12Point;
    negate(): BLS12Point;
    sub(rhs: BLS12Point): BLS12Point;
    /**
     * @dev From noble curves package:
     * Constant time multiplication. Uses wNAF method. Windowed method may be 10% faster,
     * but takes 2x longer to generate and consumes 2x memory.
     * Uses precomputes when available, uses endomorphism for Koblitz curves.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    mul(rhs: BLS12Fr): BLS12Point;
    /**
     * @dev From noble curves package:
     * Non-constant-time multiplication. Uses double-and-add algorithm.
     * It's faster, but should only be used when you don't care about an exposed private key e.g. sig verification, which works over *public* keys.
     * @param scalar by which the point would be multiplied
     * @returns New point
     */
    mulUnsafe(rhs: BLS12Fr): BLS12Point;
    /**
     * @dev From noble curves package:
     * Efficiently calculate `aP + bQ`. Unsafe, can expose private key, if used incorrectly.
     * Not using Strauss-Shamir trick: precomputation tables are faster. The trick could be useful if both P and Q are not G (not in our case).
     * @returns affine point
     */
    mulAndAddUnsafe(a: BLS12Fr, b: BLS12Fr, Q: BLS12Point): BLS12Point;
}
export declare class BLSPointNotOnCurveError extends Error {
    constructor(x: BLS12Fq, y?: BLS12Fq);
}
//# sourceMappingURL=bls12_point.d.ts.map