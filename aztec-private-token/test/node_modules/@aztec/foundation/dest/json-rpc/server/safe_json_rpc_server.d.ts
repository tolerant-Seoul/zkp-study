import http from 'http';
import { type default as Application } from 'koa';
import Router from 'koa-router';
import { type Logger } from '../../log/index.js';
import { type ApiSchemaFor } from '../../schemas/index.js';
export type DiagnosticsData = {
    id: number | string | null;
    method: string;
    params: any[];
    headers: http.IncomingHttpHeaders;
};
export type DiagnosticsMiddleware = (ctx: DiagnosticsData, next: () => Promise<void>) => Promise<void>;
export type SafeJsonRpcServerConfig = {
    /** Maximum batch size for batched rpc requests */
    maxBatchSize: number;
    /** Return an HTTP 200 status code on errors, but include an error object as per the JSON RPC spec */
    http200OnError: boolean;
    /** The maximum body size the server will accept */
    maxBodySizeBytes: string;
};
export declare class SafeJsonRpcServer {
    /** The proxy object to delegate requests to */
    private readonly proxy;
    /** Health check function */
    private readonly healthCheck;
    /** Additional middlewares */
    private extraMiddlewares;
    /** Logger */
    private log;
    /**
     * The HTTP server accepting remote requests.
     * This member field is initialized when the server is started.
     */
    private httpServer?;
    private config;
    constructor(
    /** The proxy object to delegate requests to */
    proxy: Proxy, config?: Partial<SafeJsonRpcServerConfig>, 
    /** Health check function */
    healthCheck?: StatusCheckFn, 
    /** Additional middlewares */
    extraMiddlewares?: Application.Middleware[], 
    /** Logger */
    log?: Logger);
    isHealthy(): boolean | Promise<boolean>;
    /**
     * Get an express app object.
     * @param prefix - Our server prefix.
     * @returns The app object.
     */
    getApp(prefix?: string): Application<Application.DefaultState, Application.DefaultContext>;
    /**
     * Get a router object wrapping our RPC class.
     * @param prefix - The server prefix.
     * @returns The router object.
     */
    private getRouter;
    private processBatch;
    private processRequest;
    /**
     * Start this server with koa.
     * @param port - Port number.
     * @param prefix - Prefix string.
     */
    start(port: number, prefix?: string): void;
    /**
     * Stops the HTTP server
     */
    stop(): Promise<void>;
    /**
     * Explicitly calls an RPC method.
     * @param methodName - The RPC method.
     * @param jsonParams - The RPC parameters.
     * @returns The remote result.
     */
    call(methodName: string, jsonParams?: any[]): Promise<any>;
}
export type StatusCheckFn = () => boolean | Promise<boolean>;
interface Proxy {
    hasMethod(methodName: string): boolean;
    call(methodName: string, jsonParams?: any[]): Promise<any>;
}
/**
 * Forwards calls to a handler. Relies on a schema definition to validate and convert inputs
 * before forwarding calls, and then converts outputs into JSON using default conversions.
 */
export declare class SafeJsonProxy<T extends object = any> implements Proxy {
    private handler;
    private log;
    private schema;
    constructor(handler: T, schema: ApiSchemaFor<T>);
    /**
     * Call an RPC method.
     * @param methodName - The RPC method.
     * @param jsonParams - The RPC parameters.
     * @returns The remote result.
     */
    call(methodName: string, jsonParams?: any[]): Promise<any>;
    hasMethod(methodName: string): boolean;
}
export type NamespacedApiHandlers = Record<string, ApiHandler>;
export type ApiHandler<T extends object = any> = [T, ApiSchemaFor<T>, StatusCheckFn?];
export declare function makeHandler<T extends object>(handler: T, schema: ApiSchemaFor<T>): ApiHandler<T>;
export type SafeJsonRpcServerOptions = Partial<SafeJsonRpcServerConfig & {
    healthCheck: StatusCheckFn;
    log: Logger;
    middlewares: Application.Middleware[];
}>;
/**
 * Creates a single SafeJsonRpcServer from multiple handlers.
 * @param servers - List of handlers to be combined.
 * @returns A single JsonRpcServer with namespaced methods.
 */
export declare function createNamespacedSafeJsonRpcServer(handlers: NamespacedApiHandlers, options?: Omit<SafeJsonRpcServerOptions, 'healthcheck'>): SafeJsonRpcServer;
export declare function createSafeJsonRpcServer<T extends object = any>(handler: T, schema: ApiSchemaFor<T>, options?: SafeJsonRpcServerOptions): SafeJsonRpcServer;
/**
 * Creates a router for handling a plain status request that will return 200 status when running.
 * @param getCurrentStatus - List of health check functions to run.
 * @param apiPrefix - The prefix to use for all api requests
 * @returns - The router for handling status requests.
 */
export declare function createStatusRouter(getCurrentStatus: StatusCheckFn, apiPrefix?: string): Router<any, {}>;
/**
 * Wraps a JsonRpcServer in a nodejs http server and starts it.
 * Installs a status router that calls to the isHealthy method to the server.
 * Returns once starts listening unless noWait is set.
 * @returns A running http server.
 */
export declare function startHttpRpcServer(rpcServer: Pick<SafeJsonRpcServer, 'getApp' | 'isHealthy'>, options?: {
    host?: string;
    port?: number | string;
    apiPrefix?: string;
    timeoutMs?: number;
    noWait?: boolean;
}): Promise<http.Server & {
    port: number;
}>;
export {};
//# sourceMappingURL=safe_json_rpc_server.d.ts.map