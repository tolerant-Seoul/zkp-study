import { Fr } from '../../fields/fields.js';
import { type Bufferable } from '../../serialize/serialize.js';
import type { Hasher } from '../../trees/hasher.js';
export declare function sha256(data: Buffer): Buffer<ArrayBuffer>;
export declare function sha256Trunc(data: Buffer): Buffer<ArrayBufferLike>;
export declare function sha256ToField(data: Bufferable[]): Fr;
/**
 * The "SHA256 Compression" operation (component operation of SHA256 "Hash").
 * WARNING: modifies `state` in place (and also returns it)
 *
 * This algorithm is extracted from the hash.js package
 * and modified to take in an initial state to operate on.
 *
 * @param state - The initial state to operate on (modified in-place). 8 u32s.
 * @param inputs - The inputs to compress into the state. 16 u32s.
 * @returns The modified state. 8 u32s.
 */
export declare function sha256Compression(state: Uint32Array, inputs: Uint32Array): Uint32Array;
/**
 * A helper class encapsulating SHA256 hash functionality.
 * @deprecated Don't call SHA256 directly in production code. Instead, create suitably-named functions for specific
 * purposes.
 */
export declare class SHA256 implements Hasher {
    hash(lhs: Uint8Array, rhs: Uint8Array): Buffer<ArrayBuffer>;
    hashInputs(inputs: Buffer[]): Buffer<ArrayBuffer>;
}
/**
 * A helper class encapsulating truncated SHA256 hash functionality.
 * @deprecated Don't call SHA256 directly in production code. Instead, create suitably-named functions for specific
 * purposes.
 */
export declare class SHA256Trunc implements Hasher {
    hash(lhs: Uint8Array, rhs: Uint8Array): Buffer<ArrayBuffer>;
    hashInputs(inputs: Buffer[]): Buffer<ArrayBuffer>;
}
//# sourceMappingURL=index.d.ts.map