import { Buffer32 } from '../../buffer/buffer32.js';
import { EthAddress } from '../../eth-address/index.js';
import { Signature } from '../../eth-signature/eth_signature.js';
/** Signature recovery options */
type RecoveryOpts = {
    /**
     * Whether to allow s-values in the high half of the curve (s >= CURVE.n/2).
     * These are discouraged by EIP2 to prevent signature malleability, and outright
     * rejected in OpenZeppelin's ECDSA recover, which we use in our Rollup contract.
     */
    allowMalleable?: boolean;
    /**
     * Whether to allow an y-parity 0-1 bit instead of the standard v value 27-28.
     */
    allowYParityAsV?: boolean;
};
export declare class Secp256k1Error extends Error {
    constructor(message: string, opts?: {
        cause: unknown;
    });
}
export declare function makeEthSignDigest(message: Buffer32): Buffer32;
/**
 * Converts a private key to a public key.
 * @param privateKey - The private key to convert.
 * @returns The public key.
 */
export declare function publicKeyFromPrivateKey(privateKey: Buffer): Buffer;
/**
 * Converts a private key to an address.
 * @param privateKey - The private key to convert.
 * @returns The address.
 */
export declare function addressFromPrivateKey(privateKey: Buffer): EthAddress;
/**
 * Recovers an address from a hash and a signature.
 * @param hash - The hash to recover the address from.
 * @param signature - The signature to recover the address from.
 * @param opts - Recovery options.
 * @returns The address.
 * @throws Error if signature recovery fails or if signature is malleable and allowMalleable is false.
 */
export declare function recoverAddress(hash: Buffer32, signature: Signature, opts?: RecoveryOpts): EthAddress;
/**
 * Safely attempts to recover an address from a hash and a signature.
 * @param hash - The hash to recover the address from.
 * @param signature - The signature to recover the address from.
 * @param opts - Recovery options.
 * @returns The address if recovery succeeds, undefined otherwise.
 */
export declare function tryRecoverAddress(hash: Buffer32, signature: Signature, opts?: RecoveryOpts): EthAddress | undefined;
/**
 * @attribution - viem
 * Converts a yParityOrV value to a recovery bit.
 * @param yParityOrV - The yParityOrV value to convert.
 * @returns The recovery bit.
 */
export declare function toRecoveryBit(yParityOrV: number): 0 | 1;
/**
 * Signs a message using ecdsa over the secp256k1 curve.
 * @param message - The message to sign.
 * @param privateKey - The private key to sign the message with.
 * @returns The signature.
 */
export declare function signMessage(message: Buffer32, privateKey: Buffer): Signature;
/**
 * Flips an ECDSA signature.
 * If the signature has a low s-value (s < CURVE.n/2), it flips it to high s-value (CURVE.n - s) and vice versa.
 * Also flips the v value accordingly (27 <-> 28, or 0 <-> 1).
 * This is useful for testing signature malleability handling.
 * @param signature - The signature to flip.
 * @returns A new signature with flipped s-value and v-value.
 */
export declare function flipSignature(signature: Signature): Signature;
/**
 * Normalizes an ECDSA signature.
 * If the signature has a high s-value (s >= CURVE.n/2), it flips it to low s-value (CURVE.n - s), and flips v accordingly.
 * If the signature uses a recovery bit of 0/1, it is converted to a v-value 27/28 for ecrecover.
 * @remarks This does not handle post EIP155 tx signatures which embed the chain id in v. Use it only for feeding into ECRECOVER precompiles.
 * @param signature - The signature to normalize.
 */
export declare function normalizeSignature(signature: Signature): Signature;
/**
 * Recovers a public key from a hash and a signature.
 * @param hash - The hash to recover the public key from.
 * @param signature - The signature to recover the public key from.
 * @returns The public key.
 */
export declare function recoverPublicKey(hash: Buffer32, signature: Signature, opts?: RecoveryOpts): Buffer;
export {};
//# sourceMappingURL=utils.d.ts.map