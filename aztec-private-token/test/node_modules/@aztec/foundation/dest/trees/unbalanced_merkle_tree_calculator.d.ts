import { type Bufferable } from '@aztec/foundation/serialize';
import type { AsyncHasher } from '@aztec/foundation/trees';
import { SiblingPath } from '@aztec/foundation/trees';
/**
 * An ephemeral unbalanced Merkle tree implementation.
 * Follows the rollup implementation which greedily hashes pairs of nodes up the tree.
 * Remaining rightmost nodes are shifted up until they can be paired.
 * If there is only one leaf, the root is the leaf.
 */
export declare class UnbalancedMerkleTreeCalculator {
    private maxDepth;
    private hasher;
    private cache;
    private valueCache;
    protected size: bigint;
    root: Buffer;
    constructor(maxDepth: number, hasher: AsyncHasher['hash']);
    static create(height: number, hasher?: (left: Buffer, right: Buffer) => Promise<Buffer<ArrayBuffer>>): UnbalancedMerkleTreeCalculator;
    /**
     * Returns the root of the tree.
     * @returns The root of the tree.
     */
    getRoot(): Buffer;
    /**
     * Returns a sibling path for the element at the given index.
     * @param value - The value of the element.
     * @returns A sibling path for the element.
     * Note: The sibling path is an array of sibling hashes, with the lowest hash (leaf hash) first, and the highest hash last.
     */
    getSiblingPath<N extends number>(value: Bufferable): Promise<SiblingPath<N>>;
    /**
     * Appends the given leaves to the tree.
     * @param leaves - The leaves to append.
     * @returns Empty promise.
     */
    appendLeaves(leaves: Buffer[]): Promise<void>;
    /**
     * Calculates root while adding leaves and nodes to the cache.
     * @param leaves - The leaves to append.
     * @returns Resulting root of the tree.
     */
    private batchInsert;
    private storeNode;
}
//# sourceMappingURL=unbalanced_merkle_tree_calculator.d.ts.map