import type { Tuple } from '../serialize/types.js';
/**
 * Pads an array to the target length by appending an element to its end. Throws if target length exceeds the input array length. Does not modify the input array.
 * @param arr - Array with elements to pad.
 * @param elem - Element to use for padding.
 * @param length - Target length.
 * @param errorMsg - Error message to throw if target length exceeds the input array length.
 * @returns A new padded array.
 */
export declare function padArrayEnd<T, N extends number>(arr: T[], elem: T, length: N, errorMsg?: string): Tuple<T, N>;
/** Removes the right-padding for an array. Does not modify original array. */
export declare function removeArrayPaddingEnd<T>(arr: T[], isEmpty: (item: T) => boolean): T[];
/**
 * Pads an array to the target length by prepending elements at the beginning. Throws if target length exceeds the input array length. Does not modify the input array.
 * @param arr - Array with elements to pad.
 * @param elem - Element to use for padding.
 * @param length - Target length.
 * @returns A new padded array.
 */
export declare function padArrayStart<T, N extends number>(arr: T[], elem: T, length: N): Tuple<T, N>;
/**
 * Returns if an array is composed of empty items.
 * @param arr - Array to check.
 * @returns True if every item in the array isEmpty.
 */
export declare function isArrayEmpty<T>(arr: T[], isEmpty: (item: T) => boolean): boolean;
/**
 * Returns the number of non-empty items in an array.
 * @param arr - Array to check.
 * @returns Number of non-empty items in an array.
 */
export declare function arrayNonEmptyLength<T>(arr: T[], isEmpty: (item: T) => boolean): number;
/**
 * Executes the given function n times and returns the results in an array.
 * @param n - How many times to repeat.
 * @param fn - Mapper from index to value.
 * @returns The array with the result from all executions.
 */
export declare function times<T>(n: number, fn: (i: number) => T): T[];
/**
 * Executes the given async function n times and returns the results in an array. Awaits each execution before starting the next one.
 * @param n - How many times to repeat.
 * @param fn - Mapper from index to value.
 * @returns The array with the result from all executions.
 */
export declare function timesAsync<T>(n: number, fn: (i: number) => Promise<T>): Promise<T[]>;
/**
 * Filters an array with an async predicate. Fires all predicate promises in parallel.
 * @param arr - The array to filter.
 * @param fn - The async function to determine if an item should be included.
 * @returns A promise that resolves to the filtered array.
 */
export declare function filterAsync<T>(arr: T[], fn: (item: T) => Promise<boolean>): Promise<T[]>;
/**
 * Executes the given async function n times in parallel and returns the results in an array.
 * @param n - How many times to repeat.
 * @param fn - Mapper from index to value.
 * @returns The array with the result from all executions.
 */
export declare function timesParallel<T>(n: number, fn: (i: number) => Promise<T>): Promise<T[]>;
/**
 * Returns the serialized size of all non-empty items in an array.
 * @param arr - Array
 * @returns The serialized size in bytes.
 */
export declare function arraySerializedSizeOfNonEmpty(arr: (({
    isZero: () => boolean;
} | {
    isEmpty: () => boolean;
}) & {
    toBuffer: () => Buffer;
})[]): number;
/**
 * Removes duplicates from the given array.
 * @param arr - The array.
 * @returns A new array.
 */
export declare function unique<T>(arr: T[]): T[];
/**
 * Removes all undefined elements from the array.
 * @param arr - The array.
 * @returns A new array.
 */
export declare function compactArray<T>(arr: (T | undefined)[]): T[];
/**
 * Returns whether two arrays are equal. The arrays are equal if they have the same length and all elements are equal.
 */
export declare function areArraysEqual<T>(a: T[], b: T[], eq?: (a: T, b: T) => boolean): boolean;
/**
 * Returns the element of the array that has the maximum value of the given function.
 * In case of a tie, returns the first element with the maximum value.
 * @param arr - The array.
 * @param fn - The function to get the value to compare.
 */
export declare function maxBy<T>(arr: T[], fn: (x: T) => number | bigint): T | undefined;
/** Computes the sum of a numeric array. */
export declare function sum(arr: number[]): number;
/** Computes the median of a numeric array. Returns undefined if array is empty. */
export declare function median(arr: number[]): number | undefined;
/** Computes the median of a bigint array. Returns undefined if array is empty. */
export declare function median(arr: bigint[]): bigint | undefined;
/** Computes the mean of a numeric array. Returns undefined if the array is empty. */
export declare function mean(values: number[]): number | undefined;
/** Computes the variance of a numeric array. Returns undefined if there are less than 2 points. */
export declare function variance(values: number[]): number | undefined;
/** Computes the standard deviation of a numeric array. Returns undefined if there are less than 2 points. */
export declare function stdDev(values: number[]): number | undefined;
/** Counts how many items from the beginning of the array match the given predicate. */
export declare function countWhile<T>(collection: T[], predicate: (x: T) => boolean): number;
/** Splits the given iterable into chunks of the given size. Last chunk may be of smaller than the requested size. */
export declare function chunk<T>(items: T[], chunkSize: number): T[][];
/** Partitions the given iterable into two arrays based on the predicate. */
export declare function partition<T>(items: T[], predicate: (item: T) => boolean): [T[], T[]];
//# sourceMappingURL=array.d.ts.map