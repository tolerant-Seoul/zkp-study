import { EthAddress } from '@aztec/foundation/eth-address';
import type { ViemSignature } from '@aztec/foundation/eth-signature';
import { RollupAbi } from '@aztec/l1-artifacts/RollupAbi';
import { type Account, type GetContractReturnType, type Hex, type StateOverride, type WatchContractEventReturnType } from 'viem';
import type { DeployL1ContractsReturnType } from '../deploy_l1_contracts.js';
import type { L1ContractAddresses } from '../l1_contract_addresses.js';
import type { L1ReaderConfig } from '../l1_reader.js';
import type { L1TxRequest, L1TxUtils } from '../l1_tx_utils/index.js';
import type { ViemClient } from '../types.js';
import { EmpireSlashingProposerContract } from './empire_slashing_proposer.js';
import { SlasherContract } from './slasher_contract.js';
import { TallySlashingProposerContract } from './tally_slashing_proposer.js';
export type ViemCommitteeAttestation = {
    addr: `0x${string}`;
    signature: ViemSignature;
};
export type ViemCommitteeAttestations = {
    signatureIndices: `0x${string}`;
    signaturesOrAddresses: `0x${string}`;
};
export type L1RollupContractAddresses = Pick<L1ContractAddresses, 'rollupAddress' | 'inboxAddress' | 'outboxAddress' | 'feeJuicePortalAddress' | 'feeJuiceAddress' | 'stakingAssetAddress' | 'rewardDistributorAddress' | 'slashFactoryAddress' | 'gseAddress'>;
export type EpochProofPublicInputArgs = {
    previousArchive: `0x${string}`;
    endArchive: `0x${string}`;
    proverId: `0x${string}`;
};
export type ViemHeader = {
    lastArchiveRoot: `0x${string}`;
    contentCommitment: ViemContentCommitment;
    slotNumber: bigint;
    timestamp: bigint;
    coinbase: `0x${string}`;
    feeRecipient: `0x${string}`;
    gasFees: ViemGasFees;
    totalManaUsed: bigint;
};
export type ViemContentCommitment = {
    blobsHash: `0x${string}`;
    inHash: `0x${string}`;
    outHash: `0x${string}`;
};
export type ViemGasFees = {
    feePerDaGas: bigint;
    feePerL2Gas: bigint;
};
export type ViemStateReference = {
    l1ToL2MessageTree: ViemAppendOnlyTreeSnapshot;
    partialStateReference: ViemPartialStateReference;
};
export type ViemPartialStateReference = {
    noteHashTree: ViemAppendOnlyTreeSnapshot;
    nullifierTree: ViemAppendOnlyTreeSnapshot;
    publicDataTree: ViemAppendOnlyTreeSnapshot;
};
export type ViemAppendOnlyTreeSnapshot = {
    root: `0x${string}`;
    nextAvailableLeafIndex: number;
};
export declare enum SlashingProposerType {
    None = 0,
    Tally = 1,
    Empire = 2
}
export declare class RollupContract {
    readonly client: ViemClient;
    private readonly rollup;
    private static cachedStfStorageSlot;
    static get checkBlobStorageSlot(): bigint;
    static get stfStorageSlot(): Hex;
    static getFromL1ContractsValues(deployL1ContractsValues: DeployL1ContractsReturnType): RollupContract;
    static getFromConfig(config: L1ReaderConfig): RollupContract;
    constructor(client: ViemClient, address: Hex | EthAddress);
    getGSE(): Promise<`0x${string}`>;
    get address(): `0x${string}`;
    getContract(): GetContractReturnType<typeof RollupAbi, ViemClient>;
    getSlashingProposer(): Promise<EmpireSlashingProposerContract | TallySlashingProposerContract | undefined>;
    getL1StartBlock(): Promise<bigint>;
    getL1GenesisTime(): Promise<bigint>;
    getProofSubmissionEpochs(): Promise<bigint>;
    getEpochDuration(): Promise<bigint>;
    getSlotDuration(): Promise<bigint>;
    getTargetCommitteeSize(): Promise<bigint>;
    getEjectionThreshold(): Promise<bigint>;
    getLocalEjectionThreshold(): Promise<bigint>;
    getLagInEpochs(): Promise<bigint>;
    getActivationThreshold(): Promise<bigint>;
    getExitDelay(): Promise<bigint>;
    getManaTarget(): Promise<bigint>;
    getProvingCostPerMana(): Promise<bigint>;
    getProvingCostPerManaInFeeAsset(): Promise<bigint>;
    getManaLimit(): Promise<bigint>;
    getVersion(): Promise<bigint>;
    getGenesisArchiveTreeRoot(): Promise<`0x${string}`>;
    /**
     * Returns rollup constants used for epoch queries.
     * Return type is `L1RollupConstants` which is defined in stdlib,
     * so we cant reference it until we move this contract to that package.
     */
    getRollupConstants(): Promise<{
        l1StartBlock: bigint;
        l1GenesisTime: bigint;
        slotDuration: number;
        epochDuration: number;
        proofSubmissionEpochs: number;
    }>;
    getSlasherAddress(): Promise<`0x${string}`>;
    /**
     * Returns a SlasherContract instance for interacting with the slasher contract.
     */
    getSlasherContract(): Promise<SlasherContract | undefined>;
    getOwner(): Promise<`0x${string}`>;
    getActiveAttesterCount(): Promise<bigint>;
    getSlashingProposerAddress(): Promise<EthAddress>;
    getBlockReward(): Promise<bigint>;
    getBlockNumber(): Promise<bigint>;
    getProvenBlockNumber(): Promise<bigint>;
    getSlotNumber(): Promise<bigint>;
    getL1FeesAt(timestamp: bigint): Promise<{
        baseFee: bigint;
        blobFee: bigint;
    }>;
    getFeeAssetPerEth(): Promise<bigint>;
    getCommitteeAt(timestamp: bigint): Promise<readonly `0x${string}`[] | undefined>;
    getSampleSeedAt(timestamp: bigint): Promise<bigint>;
    getCurrentSampleSeed(): Promise<bigint>;
    getCurrentEpoch(): Promise<bigint>;
    getCurrentEpochCommittee(): Promise<readonly `0x${string}`[] | undefined>;
    getCurrentProposer(): Promise<`0x${string}`>;
    getProposerAt(timestamp: bigint): Promise<`0x${string}`>;
    getBlock(blockNumber: bigint | number): Promise<{
        archive: `0x${string}`;
        headerHash: `0x${string}`;
        blobCommitmentsHash: `0x${string}`;
        attestationsHash: `0x${string}`;
        payloadDigest: `0x${string}`;
        slotNumber: bigint;
        feeHeader: {
            excessMana: bigint;
            manaUsed: bigint;
            feeAssetPriceNumerator: bigint;
            congestionCost: bigint;
            proverCost: bigint;
        };
    }>;
    getTips(): Promise<{
        pendingBlockNumber: bigint;
        provenBlockNumber: bigint;
    }>;
    getTimestampForSlot(slot: bigint): Promise<bigint>;
    getEntryQueueLength(): Promise<bigint>;
    getCurrentEpochNumber(): Promise<bigint>;
    getEpochNumberForBlock(blockNumber: bigint): Promise<bigint>;
    getAvailableValidatorFlushes(): Promise<bigint>;
    getNextFlushableEpoch(): Promise<bigint>;
    getRollupAddresses(): Promise<L1RollupContractAddresses>;
    getFeeJuicePortal(): Promise<EthAddress>;
    getEpochNumberForSlotNumber(slotNumber: bigint): Promise<bigint>;
    getEpochProofPublicInputs(args: readonly [bigint, bigint, EpochProofPublicInputArgs, readonly `0x${string}`[], `0x${string}`]): Promise<readonly `0x${string}`[]>;
    validateHeader(args: readonly [
        ViemHeader,
        ViemCommitteeAttestations,
        `0x${string}`[],
        ViemSignature,
        `0x${string}`,
        `0x${string}`,
        {
            ignoreDA: boolean;
            ignoreSignatures: boolean;
        }
    ], account: `0x${string}` | Account): Promise<void>;
    /**
     * @notice  Calls `canProposeAtTime` with the time of the next Ethereum block and the sender address
     *
     * @dev     Throws if unable to propose
     *
     * @param archive - The archive that we expect to be current state
     * @return [slot, blockNumber] - If you can propose, the L2 slot number and L2 block number of the next Ethereum block,
     * @throws otherwise
     */
    canProposeAtNextEthBlock(archive: Buffer, account: `0x${string}` | Account, slotDuration: bigint | number, opts?: {
        forcePendingBlockNumber?: number;
    }): Promise<{
        slot: bigint;
        blockNumber: bigint;
        timeOfNextL1Slot: bigint;
    }>;
    /**
     * Returns a state override that sets the pending block number to the specified value. Useful for simulations.
     * Requires querying the current state of the contract to get the current proven block number, as they are both
     * stored in the same slot. If the argument is undefined, it returns an empty override.
     */
    makePendingBlockNumberOverride(forcePendingBlockNumber: number | undefined): Promise<StateOverride>;
    /** Creates a request to Rollup#invalidateBadAttestation to be simulated or sent */
    buildInvalidateBadAttestationRequest(blockNumber: number, attestationsAndSigners: ViemCommitteeAttestations, committee: EthAddress[], invalidIndex: number): L1TxRequest;
    /** Creates a request to Rollup#invalidateInsufficientAttestations to be simulated or sent */
    buildInvalidateInsufficientAttestationsRequest(blockNumber: number, attestationsAndSigners: ViemCommitteeAttestations, committee: EthAddress[]): L1TxRequest;
    /** Calls getHasSubmitted directly. Returns whether the given prover has submitted a proof with the given length for the given epoch. */
    getHasSubmittedProof(epochNumber: number, numberOfBlocksInEpoch: number, prover: Hex | EthAddress): Promise<boolean>;
    getManaBaseFeeAt(timestamp: bigint, inFeeAsset: boolean): Promise<bigint>;
    getSlotAt(timestamp: bigint): Promise<bigint>;
    status(blockNumber: bigint, options?: {
        blockNumber?: bigint;
    }): Promise<readonly [bigint, `0x${string}`, bigint, `0x${string}`, `0x${string}`, bigint]>;
    canPruneAtTime(timestamp: bigint, options?: {
        blockNumber?: bigint;
    }): Promise<boolean>;
    archive(): Promise<`0x${string}`>;
    archiveAt(blockNumber: bigint): Promise<`0x${string}`>;
    getSequencerRewards(address: Hex | EthAddress): Promise<bigint>;
    getSpecificProverRewardsForEpoch(epoch: bigint, prover: Hex | EthAddress): Promise<bigint>;
    getAttesters(): Promise<`0x${string}`[]>;
    getAttesterView(address: Hex | EthAddress): Promise<{
        status: number;
        effectiveBalance: bigint;
        exit: {
            withdrawalId: bigint;
            amount: bigint;
            exitableAt: bigint;
            recipientOrWithdrawer: `0x${string}`;
            isRecipient: boolean;
            exists: boolean;
        };
        config: {
            publicKey: {
                x: bigint;
                y: bigint;
            };
            withdrawer: `0x${string}`;
        };
    }>;
    getStatus(address: Hex | EthAddress): Promise<number>;
    getBlobCommitmentsHash(blockNumber: bigint): Promise<`0x${string}`>;
    getCurrentBlobCommitmentsHash(): Promise<`0x${string}`>;
    getStakingAsset(): Promise<`0x${string}`>;
    getRewardConfig(): Promise<{
        rewardDistributor: `0x${string}`;
        sequencerBps: number;
        booster: `0x${string}`;
        blockReward: bigint;
    }>;
    setupEpoch(l1TxUtils: L1TxUtils): Promise<{
        receipt: import("viem").TransactionReceipt;
        state: import("../l1_tx_utils/types.js").L1TxState;
    }>;
    vote(l1TxUtils: L1TxUtils, proposalId: bigint): Promise<{
        receipt: import("viem").TransactionReceipt;
        state: import("../l1_tx_utils/types.js").L1TxState;
    }>;
    listenToSlasherChanged(callback: (args: {
        oldSlasher: `0x${string}`;
        newSlasher: `0x${string}`;
    }) => unknown): WatchContractEventReturnType;
    listenToBlockInvalidated(callback: (args: {
        blockNumber: bigint;
    }) => unknown): WatchContractEventReturnType;
    getSlashEvents(l1BlockHash: Hex): Promise<{
        amount: bigint;
        attester: EthAddress;
    }[]>;
    listenToSlash(callback: (args: {
        amount: bigint;
        attester: EthAddress;
    }) => unknown): WatchContractEventReturnType;
}
//# sourceMappingURL=rollup.d.ts.map