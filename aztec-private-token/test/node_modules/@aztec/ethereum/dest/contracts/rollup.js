function _ts_decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for(var i = decorators.length - 1; i >= 0; i--)if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}
import { memoize } from '@aztec/foundation/decorators';
import { EthAddress } from '@aztec/foundation/eth-address';
import { RollupAbi } from '@aztec/l1-artifacts/RollupAbi';
import { RollupStorage } from '@aztec/l1-artifacts/RollupStorage';
import chunk from 'lodash.chunk';
import { encodeFunctionData, getContract, hexToBigInt, keccak256 } from 'viem';
import { getPublicClient } from '../client.js';
import { formatViemError } from '../utils.js';
import { EmpireSlashingProposerContract } from './empire_slashing_proposer.js';
import { GSEContract } from './gse.js';
import { SlasherContract } from './slasher_contract.js';
import { TallySlashingProposerContract } from './tally_slashing_proposer.js';
import { checkBlockTag } from './utils.js';
export var SlashingProposerType = /*#__PURE__*/ function(SlashingProposerType) {
    SlashingProposerType[SlashingProposerType["None"] = 0] = "None";
    SlashingProposerType[SlashingProposerType["Tally"] = 1] = "Tally";
    SlashingProposerType[SlashingProposerType["Empire"] = 2] = "Empire";
    return SlashingProposerType;
}({});
export class RollupContract {
    client;
    rollup;
    static cachedStfStorageSlot;
    static get checkBlobStorageSlot() {
        const asString = RollupStorage.find((storage)=>storage.label === 'checkBlob')?.slot;
        if (asString === undefined) {
            throw new Error('checkBlobStorageSlot not found');
        }
        return BigInt(asString);
    }
    static get stfStorageSlot() {
        return RollupContract.cachedStfStorageSlot ??= keccak256(Buffer.from('aztec.stf.storage', 'utf-8'));
    }
    static getFromL1ContractsValues(deployL1ContractsValues) {
        const { l1Client, l1ContractAddresses: { rollupAddress } } = deployL1ContractsValues;
        return new RollupContract(l1Client, rollupAddress.toString());
    }
    static getFromConfig(config) {
        const client = getPublicClient(config);
        const address = config.l1Contracts.rollupAddress.toString();
        return new RollupContract(client, address);
    }
    constructor(client, address){
        this.client = client;
        if (address instanceof EthAddress) {
            address = address.toString();
        }
        this.rollup = getContract({
            address,
            abi: RollupAbi,
            client
        });
    }
    getGSE() {
        return this.rollup.read.getGSE();
    }
    get address() {
        return this.rollup.address;
    }
    getContract() {
        return this.rollup;
    }
    async getSlashingProposer() {
        const slasher = await this.getSlasherContract();
        if (!slasher) {
            return undefined;
        }
        const proposerAddress = await slasher.getProposer();
        const proposerAbi = [
            {
                type: 'function',
                name: 'SLASHING_PROPOSER_TYPE',
                inputs: [],
                outputs: [
                    {
                        name: '',
                        type: 'uint8',
                        internalType: 'enum SlasherFlavor'
                    }
                ],
                stateMutability: 'view'
            }
        ];
        const proposer = getContract({
            address: proposerAddress.toString(),
            abi: proposerAbi,
            client: this.client
        });
        const proposerType = await proposer.read.SLASHING_PROPOSER_TYPE();
        if (proposerType === 1..valueOf()) {
            return new TallySlashingProposerContract(this.client, proposerAddress);
        } else if (proposerType === 2..valueOf()) {
            return new EmpireSlashingProposerContract(this.client, proposerAddress);
        } else {
            throw new Error(`Unknown slashing proposer type: ${proposerType}`);
        }
    }
    getL1StartBlock() {
        return this.rollup.read.L1_BLOCK_AT_GENESIS();
    }
    getL1GenesisTime() {
        return this.rollup.read.getGenesisTime();
    }
    getProofSubmissionEpochs() {
        return this.rollup.read.getProofSubmissionEpochs();
    }
    getEpochDuration() {
        return this.rollup.read.getEpochDuration();
    }
    getSlotDuration() {
        return this.rollup.read.getSlotDuration();
    }
    getTargetCommitteeSize() {
        return this.rollup.read.getTargetCommitteeSize();
    }
    getEjectionThreshold() {
        return this.rollup.read.getEjectionThreshold();
    }
    getLocalEjectionThreshold() {
        return this.rollup.read.getLocalEjectionThreshold();
    }
    getLagInEpochs() {
        return this.rollup.read.getLagInEpochs();
    }
    getActivationThreshold() {
        return this.rollup.read.getActivationThreshold();
    }
    getExitDelay() {
        return this.rollup.read.getExitDelay();
    }
    getManaTarget() {
        return this.rollup.read.getManaTarget();
    }
    getProvingCostPerMana() {
        return this.rollup.read.getProvingCostPerManaInEth();
    }
    getProvingCostPerManaInFeeAsset() {
        return this.rollup.read.getProvingCostPerManaInFeeAsset();
    }
    getManaLimit() {
        return this.rollup.read.getManaLimit();
    }
    getVersion() {
        return this.rollup.read.getVersion();
    }
    async getGenesisArchiveTreeRoot() {
        return await this.rollup.read.archiveAt([
            0n
        ]);
    }
    /**
   * Returns rollup constants used for epoch queries.
   * Return type is `L1RollupConstants` which is defined in stdlib,
   * so we cant reference it until we move this contract to that package.
   */ async getRollupConstants() {
        const [l1StartBlock, l1GenesisTime, slotDuration, epochDuration, proofSubmissionEpochs] = await Promise.all([
            this.getL1StartBlock(),
            this.getL1GenesisTime(),
            this.getSlotDuration(),
            this.getEpochDuration(),
            this.getProofSubmissionEpochs()
        ]);
        return {
            l1StartBlock,
            l1GenesisTime,
            slotDuration: Number(slotDuration),
            epochDuration: Number(epochDuration),
            proofSubmissionEpochs: Number(proofSubmissionEpochs)
        };
    }
    getSlasherAddress() {
        return this.rollup.read.getSlasher();
    }
    /**
   * Returns a SlasherContract instance for interacting with the slasher contract.
   */ async getSlasherContract() {
        const slasherAddress = EthAddress.fromString(await this.getSlasherAddress());
        if (slasherAddress.isZero()) {
            return undefined;
        }
        return new SlasherContract(this.client, slasherAddress);
    }
    getOwner() {
        return this.rollup.read.owner();
    }
    getActiveAttesterCount() {
        return this.rollup.read.getActiveAttesterCount();
    }
    async getSlashingProposerAddress() {
        const slasher = await this.getSlasherContract();
        if (!slasher) {
            return EthAddress.ZERO;
        }
        return await slasher.getProposer();
    }
    getBlockReward() {
        return this.rollup.read.getBlockReward();
    }
    getBlockNumber() {
        return this.rollup.read.getPendingBlockNumber();
    }
    getProvenBlockNumber() {
        return this.rollup.read.getProvenBlockNumber();
    }
    getSlotNumber() {
        return this.rollup.read.getCurrentSlot();
    }
    getL1FeesAt(timestamp) {
        return this.rollup.read.getL1FeesAt([
            timestamp
        ]);
    }
    getFeeAssetPerEth() {
        return this.rollup.read.getFeeAssetPerEth();
    }
    async getCommitteeAt(timestamp) {
        const { result } = await this.client.simulateContract({
            address: this.address,
            abi: RollupAbi,
            functionName: 'getCommitteeAt',
            args: [
                timestamp
            ]
        }).catch((e)=>{
            if (e instanceof Error && e.message.includes('ValidatorSelection__InsufficientValidatorSetSize')) {
                return {
                    result: undefined
                };
            }
            throw e;
        });
        return result;
    }
    getSampleSeedAt(timestamp) {
        return this.rollup.read.getSampleSeedAt([
            timestamp
        ]);
    }
    getCurrentSampleSeed() {
        return this.rollup.read.getCurrentSampleSeed();
    }
    getCurrentEpoch() {
        return this.rollup.read.getCurrentEpoch();
    }
    async getCurrentEpochCommittee() {
        const { result } = await this.client.simulateContract({
            address: this.address,
            abi: RollupAbi,
            functionName: 'getCurrentEpochCommittee',
            args: []
        }).catch((e)=>{
            if (e instanceof Error && e.message.includes('ValidatorSelection__InsufficientValidatorSetSize')) {
                return {
                    result: undefined
                };
            }
            throw e;
        });
        return result;
    }
    async getCurrentProposer() {
        const { result } = await this.client.simulateContract({
            address: this.address,
            abi: RollupAbi,
            functionName: 'getCurrentProposer',
            args: []
        });
        return result;
    }
    async getProposerAt(timestamp) {
        const { result } = await this.client.simulateContract({
            address: this.address,
            abi: RollupAbi,
            functionName: 'getProposerAt',
            args: [
                timestamp
            ]
        });
        return result;
    }
    getBlock(blockNumber) {
        return this.rollup.read.getBlock([
            BigInt(blockNumber)
        ]);
    }
    getTips() {
        return this.rollup.read.getTips();
    }
    getTimestampForSlot(slot) {
        return this.rollup.read.getTimestampForSlot([
            slot
        ]);
    }
    getEntryQueueLength() {
        return this.rollup.read.getEntryQueueLength();
    }
    getCurrentEpochNumber() {
        return this.rollup.read.getCurrentEpoch();
    }
    getEpochNumberForBlock(blockNumber) {
        return this.rollup.read.getEpochForBlock([
            BigInt(blockNumber)
        ]);
    }
    getAvailableValidatorFlushes() {
        return this.rollup.read.getAvailableValidatorFlushes();
    }
    getNextFlushableEpoch() {
        return this.rollup.read.getNextFlushableEpoch();
    }
    async getRollupAddresses() {
        const [inboxAddress, outboxAddress, feeJuicePortalAddress, rewardDistributorAddress, feeJuiceAddress, stakingAssetAddress, gseAddress] = (await Promise.all([
            this.rollup.read.getInbox(),
            this.rollup.read.getOutbox(),
            this.rollup.read.getFeeAssetPortal(),
            this.rollup.read.getRewardDistributor(),
            this.rollup.read.getFeeAsset(),
            this.rollup.read.getStakingAsset(),
            this.rollup.read.getGSE()
        ])).map(EthAddress.fromString);
        return {
            rollupAddress: EthAddress.fromString(this.address),
            inboxAddress,
            outboxAddress,
            feeJuicePortalAddress,
            feeJuiceAddress,
            stakingAssetAddress,
            rewardDistributorAddress,
            gseAddress
        };
    }
    async getFeeJuicePortal() {
        return EthAddress.fromString(await this.rollup.read.getFeeAssetPortal());
    }
    async getEpochNumberForSlotNumber(slotNumber) {
        return await this.rollup.read.getEpochAtSlot([
            slotNumber
        ]);
    }
    getEpochProofPublicInputs(args) {
        return this.rollup.read.getEpochProofPublicInputs(args);
    }
    async validateHeader(args, account) {
        try {
            await this.client.simulateContract({
                address: this.address,
                abi: RollupAbi,
                functionName: 'validateHeaderWithAttestations',
                args,
                account
            });
        } catch (error) {
            throw formatViemError(error);
        }
    }
    /**
   * @notice  Calls `canProposeAtTime` with the time of the next Ethereum block and the sender address
   *
   * @dev     Throws if unable to propose
   *
   * @param archive - The archive that we expect to be current state
   * @return [slot, blockNumber] - If you can propose, the L2 slot number and L2 block number of the next Ethereum block,
   * @throws otherwise
   */ async canProposeAtNextEthBlock(archive, account, slotDuration, opts = {}) {
        if (typeof slotDuration === 'number') {
            slotDuration = BigInt(slotDuration);
        }
        const latestBlock = await this.client.getBlock();
        const timeOfNextL1Slot = latestBlock.timestamp + slotDuration;
        const who = typeof account === 'string' ? account : account.address;
        try {
            const { result: [slot, blockNumber] } = await this.client.simulateContract({
                address: this.address,
                abi: RollupAbi,
                functionName: 'canProposeAtTime',
                args: [
                    timeOfNextL1Slot,
                    `0x${archive.toString('hex')}`,
                    who
                ],
                account,
                stateOverride: await this.makePendingBlockNumberOverride(opts.forcePendingBlockNumber)
            });
            return {
                slot,
                blockNumber,
                timeOfNextL1Slot
            };
        } catch (err) {
            throw formatViemError(err);
        }
    }
    /**
   * Returns a state override that sets the pending block number to the specified value. Useful for simulations.
   * Requires querying the current state of the contract to get the current proven block number, as they are both
   * stored in the same slot. If the argument is undefined, it returns an empty override.
   */ async makePendingBlockNumberOverride(forcePendingBlockNumber) {
        if (forcePendingBlockNumber === undefined) {
            return [];
        }
        const slot = RollupContract.stfStorageSlot;
        const currentValue = await this.client.getStorageAt({
            address: this.address,
            slot
        });
        const currentProvenBlockNumber = currentValue ? hexToBigInt(currentValue) & (1n << 128n) - 1n : 0n;
        const newValue = BigInt(forcePendingBlockNumber) << 128n | currentProvenBlockNumber;
        return [
            {
                address: this.address,
                stateDiff: [
                    {
                        slot,
                        value: `0x${newValue.toString(16).padStart(64, '0')}`
                    }
                ]
            }
        ];
    }
    /** Creates a request to Rollup#invalidateBadAttestation to be simulated or sent */ buildInvalidateBadAttestationRequest(blockNumber, attestationsAndSigners, committee, invalidIndex) {
        return {
            to: this.address,
            data: encodeFunctionData({
                abi: RollupAbi,
                functionName: 'invalidateBadAttestation',
                args: [
                    BigInt(blockNumber),
                    attestationsAndSigners,
                    committee.map((addr)=>addr.toString()),
                    BigInt(invalidIndex)
                ]
            })
        };
    }
    /** Creates a request to Rollup#invalidateInsufficientAttestations to be simulated or sent */ buildInvalidateInsufficientAttestationsRequest(blockNumber, attestationsAndSigners, committee) {
        return {
            to: this.address,
            data: encodeFunctionData({
                abi: RollupAbi,
                functionName: 'invalidateInsufficientAttestations',
                args: [
                    BigInt(blockNumber),
                    attestationsAndSigners,
                    committee.map((addr)=>addr.toString())
                ]
            })
        };
    }
    /** Calls getHasSubmitted directly. Returns whether the given prover has submitted a proof with the given length for the given epoch. */ getHasSubmittedProof(epochNumber, numberOfBlocksInEpoch, prover) {
        if (prover instanceof EthAddress) {
            prover = prover.toString();
        }
        return this.rollup.read.getHasSubmitted([
            BigInt(epochNumber),
            BigInt(numberOfBlocksInEpoch),
            prover
        ]);
    }
    getManaBaseFeeAt(timestamp, inFeeAsset) {
        return this.rollup.read.getManaBaseFeeAt([
            timestamp,
            inFeeAsset
        ]);
    }
    getSlotAt(timestamp) {
        return this.rollup.read.getSlotAt([
            timestamp
        ]);
    }
    async status(blockNumber, options) {
        await checkBlockTag(options?.blockNumber, this.client);
        return this.rollup.read.status([
            blockNumber
        ], options);
    }
    async canPruneAtTime(timestamp, options) {
        await checkBlockTag(options?.blockNumber, this.client);
        return this.rollup.read.canPruneAtTime([
            timestamp
        ], options);
    }
    archive() {
        return this.rollup.read.archive();
    }
    archiveAt(blockNumber) {
        return this.rollup.read.archiveAt([
            blockNumber
        ]);
    }
    getSequencerRewards(address) {
        if (address instanceof EthAddress) {
            address = address.toString();
        }
        return this.rollup.read.getSequencerRewards([
            address
        ]);
    }
    getSpecificProverRewardsForEpoch(epoch, prover) {
        if (prover instanceof EthAddress) {
            prover = prover.toString();
        }
        return this.rollup.read.getSpecificProverRewardsForEpoch([
            epoch,
            prover
        ]);
    }
    async getAttesters() {
        const attesterSize = await this.getActiveAttesterCount();
        const gse = new GSEContract(this.client, await this.getGSE());
        const ts = (await this.client.getBlock()).timestamp;
        const indices = Array.from({
            length: Number(attesterSize)
        }, (_, i)=>BigInt(i));
        const chunks = chunk(indices, 1000);
        return (await Promise.all(chunks.map((chunk)=>gse.getAttestersFromIndicesAtTime(this.address, ts, chunk)))).flat();
    }
    getAttesterView(address) {
        if (address instanceof EthAddress) {
            address = address.toString();
        }
        return this.rollup.read.getAttesterView([
            address
        ]);
    }
    getStatus(address) {
        if (address instanceof EthAddress) {
            address = address.toString();
        }
        return this.rollup.read.getStatus([
            address
        ]);
    }
    getBlobCommitmentsHash(blockNumber) {
        return this.rollup.read.getBlobCommitmentsHash([
            blockNumber
        ]);
    }
    getCurrentBlobCommitmentsHash() {
        return this.rollup.read.getCurrentBlobCommitmentsHash();
    }
    getStakingAsset() {
        return this.rollup.read.getStakingAsset();
    }
    getRewardConfig() {
        return this.rollup.read.getRewardConfig();
    }
    setupEpoch(l1TxUtils) {
        return l1TxUtils.sendAndMonitorTransaction({
            to: this.address,
            data: encodeFunctionData({
                abi: RollupAbi,
                functionName: 'setupEpoch',
                args: []
            })
        });
    }
    vote(l1TxUtils, proposalId) {
        return l1TxUtils.sendAndMonitorTransaction({
            to: this.address,
            data: encodeFunctionData({
                abi: RollupAbi,
                functionName: 'vote',
                args: [
                    proposalId
                ]
            })
        });
    }
    listenToSlasherChanged(callback) {
        return this.rollup.watchEvent.SlasherUpdated({}, {
            onLogs: (logs)=>{
                for (const log of logs){
                    const args = log.args;
                    if (args.oldSlasher && args.newSlasher) {
                        callback(args);
                    }
                }
            }
        });
    }
    listenToBlockInvalidated(callback) {
        return this.rollup.watchEvent.BlockInvalidated({}, {
            onLogs: (logs)=>{
                for (const log of logs){
                    const args = log.args;
                    if (args.blockNumber !== undefined) {
                        callback({
                            blockNumber: args.blockNumber
                        });
                    }
                }
            }
        });
    }
    async getSlashEvents(l1BlockHash) {
        const events = await this.rollup.getEvents.Slashed({}, {
            blockHash: l1BlockHash,
            strict: true
        });
        return events.map((event)=>({
                amount: event.args.amount,
                attester: EthAddress.fromString(event.args.attester)
            }));
    }
    listenToSlash(callback) {
        return this.rollup.watchEvent.Slashed({}, {
            strict: true,
            onLogs: (logs)=>{
                for (const log of logs){
                    const args = log.args;
                    callback({
                        amount: args.amount,
                        attester: EthAddress.fromString(args.attester)
                    });
                }
            }
        });
    }
}
_ts_decorate([
    memoize
], RollupContract.prototype, "getL1StartBlock", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getL1GenesisTime", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getProofSubmissionEpochs", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getEpochDuration", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getSlotDuration", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getTargetCommitteeSize", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getEjectionThreshold", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getLagInEpochs", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getActivationThreshold", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getExitDelay", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getManaTarget", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getProvingCostPerMana", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getProvingCostPerManaInFeeAsset", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getManaLimit", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getVersion", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getGenesisArchiveTreeRoot", null);
_ts_decorate([
    memoize
], RollupContract.prototype, "getRollupConstants", null);
