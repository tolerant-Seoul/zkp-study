import { type ConfigMappingsType, type NetworkNames } from '@aztec/foundation/config';
import { EthAddress } from '@aztec/foundation/eth-address';
import { type L1TxUtilsConfig } from './l1_tx_utils/index.js';
export type GenesisStateConfig = {
    /** Whether to populate the genesis state with initial fee juice for the test accounts */
    testAccounts: boolean;
    /** Whether to populate the genesis state with initial fee juice for the sponsored FPC */
    sponsoredFPC: boolean;
};
export type L1ContractsConfig = {
    /** How many seconds an L1 slot lasts. */
    ethereumSlotDuration: number;
    /** How many seconds an L2 slots lasts (must be multiple of ethereum slot duration). */
    aztecSlotDuration: number;
    /** How many L2 slots an epoch lasts. */
    aztecEpochDuration: number;
    /** The target validator committee size. */
    aztecTargetCommitteeSize: number;
    /** The number of epochs to lag behind the current epoch for validator selection. */
    lagInEpochs: number;
    /** The number of epochs after an epoch ends that proofs are still accepted. */
    aztecProofSubmissionEpochs: number;
    /** The deposit amount for a validator */
    activationThreshold: bigint;
    /** The minimum stake for a validator. */
    ejectionThreshold: bigint;
    /** The local ejection threshold for a validator. Stricter than ejectionThreshold but local to a specific rollup */
    localEjectionThreshold: bigint;
    /** The slashing quorum, i.e. how many slots must signal for the same payload in a round for it to be submittable to the Slasher (defaults to slashRoundSize / 2 + 1) */
    slashingQuorum?: number;
    /** The slashing round size, i.e. how many epochs are in a slashing round */
    slashingRoundSizeInEpochs: number;
    /** The slashing lifetime in rounds. I.e., if 1, round N must be submitted before round N + 2 */
    slashingLifetimeInRounds: number;
    /** The slashing execution delay in rounds. I.e., if 1, round N may not be submitted until round N + 2 */
    slashingExecutionDelayInRounds: number;
    /** The slashing vetoer. May blacklist a payload from being submitted. */
    slashingVetoer: EthAddress;
    /** How many slashing rounds back we slash (ie when slashing in round N, we slash for offenses committed during epochs of round N-offset) */
    slashingOffsetInRounds: number;
    /** How long slashing can be disabled for in seconds when vetoer disables it */
    slashingDisableDuration: number;
    /** Type of slasher proposer */
    slasherFlavor: 'empire' | 'tally' | 'none';
    /** Minimum amount that can be slashed in tally slashing */
    slashAmountSmall: bigint;
    /** Medium amount to slash in tally slashing */
    slashAmountMedium: bigint;
    /** Largest amount that can be slashed per round in tally slashing */
    slashAmountLarge: bigint;
    /** Governance proposing quorum (defaults to roundSize/2 + 1) */
    governanceProposerQuorum?: number;
    /** Governance proposing round size */
    governanceProposerRoundSize: number;
    /** The mana target for the rollup */
    manaTarget: bigint;
    /** The proving cost per mana */
    provingCostPerMana: bigint;
    /** The number of seconds to wait for an exit */
    exitDelaySeconds: number;
} & L1TxUtilsConfig;
export declare const DefaultL1ContractsConfig: {
    ethereumSlotDuration: number;
    aztecSlotDuration: number;
    aztecEpochDuration: number;
    aztecTargetCommitteeSize: number;
    lagInEpochs: number;
    aztecProofSubmissionEpochs: number;
    activationThreshold: bigint;
    ejectionThreshold: bigint;
    localEjectionThreshold: bigint;
    slashAmountSmall: bigint;
    slashAmountMedium: bigint;
    slashAmountLarge: bigint;
    slashingRoundSizeInEpochs: number;
    slashingLifetimeInRounds: number;
    slashingExecutionDelayInRounds: number;
    slashingVetoer: EthAddress;
    governanceProposerRoundSize: number;
    manaTarget: bigint;
    provingCostPerMana: bigint;
    exitDelaySeconds: number;
    slasherFlavor: "tally";
    slashingOffsetInRounds: number;
    slashingDisableDuration: number;
};
export declare const getGovernanceConfiguration: (networkName: NetworkNames) => {
    proposeConfig: {
        lockDelay: bigint;
        lockAmount: bigint;
    };
    votingDelay: bigint;
    votingDuration: bigint;
    executionDelay: bigint;
    gracePeriod: bigint;
    quorum: bigint;
    requiredYeaMargin: bigint;
    minimumVotes: bigint;
};
export declare const getRewardConfig: (networkName: NetworkNames) => {
    sequencerBps: number;
    rewardDistributor: `0x${string}`;
    booster: `0x${string}`;
    blockReward: bigint;
};
export declare const getRewardBoostConfig: () => {
    increment: number;
    maxScore: number;
    a: number;
    k: number;
    minimum: number;
};
export declare const getEntryQueueConfig: (networkName: NetworkNames) => {
    bootstrapValidatorSetSize: bigint;
    bootstrapFlushSize: bigint;
    normalFlushSizeMin: bigint;
    normalFlushSizeQuotient: bigint;
    maxQueueFlushSize: bigint;
};
export declare const l1ContractsConfigMappings: ConfigMappingsType<L1ContractsConfig>;
export declare const genesisStateConfigMappings: ConfigMappingsType<GenesisStateConfig>;
export declare function getL1ContractsConfigEnvVars(): L1ContractsConfig;
export declare function getGenesisStateConfigEnvVars(): GenesisStateConfig;
/**
 * Validates the L1 contracts configuration to ensure all requirements enforced by L1 contracts
 * during construction are satisfied before deployment.
 * Accumulates all validation errors and throws an exception listing them all if any are found.
 */
export declare function validateConfig(config: Omit<L1ContractsConfig, keyof L1TxUtilsConfig>): void;
//# sourceMappingURL=config.d.ts.map