import { SecretValue } from '@aztec/foundation/config';
import { EthAddress } from '@aztec/foundation/eth-address';
import type { Fr } from '@aztec/foundation/fields';
import { type Logger } from '@aztec/foundation/log';
import { DateProvider } from '@aztec/foundation/timer';
import type { Abi, Narrow } from 'abitype';
import { type Chain, type ContractConstructorArgs, type HDAccount, type Hex, type PrivateKeyAccount } from 'viem';
import { type L1ContractsConfig } from './config.js';
import { RollupContract } from './contracts/rollup.js';
import type { L1ContractAddresses } from './l1_contract_addresses.js';
import { type GasPrice, type L1TxConfig, type L1TxRequest, L1TxUtils, type L1TxUtilsConfig } from './l1_tx_utils/index.js';
import type { ExtendedViemWalletClient } from './types.js';
export declare const DEPLOYER_ADDRESS: Hex;
export type Operator = {
    attester: EthAddress;
    withdrawer: EthAddress;
    bn254SecretKey: SecretValue<bigint>;
};
/**
 * Return type of the deployL1Contract function.
 */
export type DeployL1ContractsReturnType = {
    /** Extended Wallet Client Type. */
    l1Client: ExtendedViemWalletClient;
    /** The currently deployed l1 contract addresses */
    l1ContractAddresses: L1ContractAddresses;
    /** Version of the current rollup contract. */
    rollupVersion: number;
};
export interface LinkReferences {
    [fileName: string]: {
        [contractName: string]: ReadonlyArray<{
            start: number;
            length: number;
        }>;
    };
}
export interface Libraries {
    linkReferences: LinkReferences;
    libraryCode: Record<string, ContractArtifacts>;
}
/**
 * Contract artifacts
 */
export interface ContractArtifacts<TAbi extends Abi | readonly unknown[] = Abi> {
    /**
     * The contract name.
     */
    name: string;
    /**
     * The contract abi.
     */
    contractAbi: Narrow<TAbi>;
    /**
     * The contract bytecode
     */
    contractBytecode: Hex;
    /**
     * The contract libraries
     */
    libraries?: Libraries;
}
export type VerificationLibraryEntry = {
    file: string;
    contract: string;
    address: string;
};
export type VerificationRecord = {
    name: string;
    address: string;
    constructorArgsHex: Hex;
    libraries: VerificationLibraryEntry[];
};
export interface DeployL1ContractsArgs extends Omit<L1ContractsConfig, keyof L1TxUtilsConfig> {
    /** The vk tree root. */
    vkTreeRoot: Fr;
    /** The protocol contract tree root. */
    protocolContractTreeRoot: Fr;
    /** The genesis root of the archive tree. */
    genesisArchiveRoot: Fr;
    /** The salt for CREATE2 deployment. */
    salt: number | undefined;
    /** The initial validators for the rollup contract. */
    initialValidators?: Operator[];
    /** Configuration for the L1 tx utils module. */
    l1TxConfig?: Partial<L1TxUtilsConfig>;
    /** Enable fast mode for deployments (fire and forget transactions) */
    acceleratedTestDeployments?: boolean;
    /** The initial balance of the fee juice portal. This is the amount of fee juice that is prefunded to accounts */
    feeJuicePortalInitialBalance?: bigint;
    /** Whether to deploy the real verifier or the mock verifier */
    realVerifier: boolean;
    /** The zk passport args */
    zkPassportArgs?: ZKPassportArgs;
    /** If provided, use this token for BOTH fee and staking assets (skip deployments) */
    existingTokenAddress?: EthAddress;
}
export interface ZKPassportArgs {
    /** Whether to use the mock zk passport verifier */
    mockZkPassportVerifier?: boolean;
    /** The domain of the zk passport (url) */
    zkPassportDomain?: string;
    /** The scope of the zk passport (personhood, etc) */
    zkPassportScope?: string;
}
/**
 * Validates that the provided address points to a contract that resembles an ERC20 token.
 * Checks for contract code and attempts common ERC20 view calls.
 * Throws an error if validation fails.
 */
export declare function validateExistingErc20TokenAddress(l1Client: ExtendedViemWalletClient, tokenAddress: EthAddress, logger: Logger): Promise<void>;
export declare const deploySharedContracts: (l1Client: ExtendedViemWalletClient, deployer: L1Deployer, args: DeployL1ContractsArgs, logger: Logger) => Promise<{
    feeAssetAddress: EthAddress;
    feeAssetHandlerAddress: EthAddress | undefined;
    stakingAssetAddress: EthAddress;
    stakingAssetHandlerAddress: EthAddress | undefined;
    zkPassportVerifierAddress: EthAddress | undefined;
    registryAddress: EthAddress;
    gseAddress: EthAddress;
    governanceAddress: EthAddress;
    governanceProposerAddress: EthAddress;
    coinIssuerAddress: EthAddress;
    rewardDistributorAddress: EthAddress;
}>;
/**
 * Deploys a new rollup, using the existing canonical version to derive certain values (addresses of assets etc).
 * @param clients - The L1 clients.
 * @param args - The deployment arguments.
 * @param registryAddress - The address of the registry.
 * @param logger - The logger.
 * @param txUtilsConfig - The L1 tx utils config.
 * @param createVerificationJson - Optional path to write verification data for forge verify.
 */
export declare const deployRollupForUpgrade: (extendedClient: ExtendedViemWalletClient, args: Omit<DeployL1ContractsArgs, "governanceProposerQuorum" | "governanceProposerRoundSize" | "ejectionThreshold" | "activationThreshold">, registryAddress: EthAddress, logger: Logger, txUtilsConfig: L1TxUtilsConfig, createVerificationJson?: string | false) => Promise<{
    rollup: RollupContract;
    slashFactoryAddress: EthAddress;
}>;
export declare const deploySlashFactory: (deployer: L1Deployer, rollupAddress: Hex, logger: Logger) => Promise<EthAddress>;
export declare const deployUpgradePayload: (deployer: L1Deployer, addresses: Pick<L1ContractAddresses, "registryAddress" | "rollupAddress">) => Promise<EthAddress>;
/**
 * Deploys a new rollup contract, funds and initializes the fee juice portal, and initializes the validator set.
 */
export declare const deployRollup: (extendedClient: ExtendedViemWalletClient, deployer: L1Deployer, args: Omit<DeployL1ContractsArgs, "governanceProposerQuorum" | "governanceProposerRoundSize" | "ejectionThreshold" | "activationThreshold">, addresses: Pick<L1ContractAddresses, "feeJuiceAddress" | "registryAddress" | "rewardDistributorAddress" | "stakingAssetAddress" | "gseAddress" | "governanceAddress">, logger: Logger) => Promise<{
    rollup: RollupContract;
    slashFactoryAddress: EthAddress;
}>;
export declare const handoverToGovernance: (extendedClient: ExtendedViemWalletClient, deployer: L1Deployer, registryAddress: EthAddress, gseAddress: EthAddress, coinIssuerAddress: EthAddress, feeAssetAddress: EthAddress, governanceAddress: EthAddress, logger: Logger, acceleratedTestDeployments: boolean | undefined, useExternalToken?: boolean) => Promise<{
    dateGatedRelayerAddress: EthAddress;
}>;
export declare const addMultipleValidators: (extendedClient: ExtendedViemWalletClient, deployer: L1Deployer, gseAddress: Hex, rollupAddress: Hex, stakingAssetAddress: Hex, validators: Operator[], acceleratedTestDeployments: boolean | undefined, logger: Logger) => Promise<void>;
/**
 * Initialize the fee asset handler and make it a minter on the fee asset.
 * @note This function will only be used for testing purposes.
 *
 * @param extendedClient - The L1 clients.
 * @param deployer - The L1 deployer.
 * @param feeAssetAddress - The address of the fee asset.
 * @param logger - The logger.
 */
export declare const cheat_initializeFeeAssetHandler: (extendedClient: ExtendedViemWalletClient, deployer: L1Deployer, feeAssetAddress: EthAddress, logger: Logger) => Promise<{
    feeAssetHandlerAddress: EthAddress;
    txHash: Hex;
}>;
/**
 * Deploys the aztec L1 contracts; Rollup & (optionally) Decoder Helper.
 * @param rpcUrls - List of URLs of the ETH RPC to use for deployment.
 * @param account - Private Key or HD Account that will deploy the contracts.
 * @param chain - The chain instance to deploy to.
 * @param logger - A logger object.
 * @param args - Arguments for initialization of L1 contracts
 * @returns A list of ETH addresses of the deployed contracts.
 */
export declare const deployL1Contracts: (rpcUrls: string[], account: HDAccount | PrivateKeyAccount, chain: Chain, logger: Logger, args: DeployL1ContractsArgs, txUtilsConfig?: L1TxUtilsConfig, createVerificationJson?: string | false) => Promise<DeployL1ContractsReturnType>;
export declare class L1Deployer {
    readonly client: ExtendedViemWalletClient;
    private acceleratedTestDeployments;
    private logger;
    private txUtilsConfig?;
    private createVerificationJson;
    private salt;
    private txHashes;
    readonly l1TxUtils: L1TxUtils;
    readonly verificationRecords: VerificationRecord[];
    constructor(client: ExtendedViemWalletClient, maybeSalt: number | undefined, dateProvider?: DateProvider, acceleratedTestDeployments?: boolean, logger?: Logger, txUtilsConfig?: L1TxUtilsConfig | undefined, createVerificationJson?: boolean);
    deploy<const TAbi extends Abi>(params: ContractArtifacts<TAbi>, args?: ContractConstructorArgs<TAbi>, opts?: {
        gasLimit?: bigint;
        noSimulation?: boolean;
    }): Promise<{
        address: EthAddress;
        existed: boolean;
    }>;
    waitForDeployments(): Promise<void>;
    sendTransaction(tx: L1TxRequest, options?: L1TxConfig): Promise<{
        txHash: Hex;
        gasLimit: bigint;
        gasPrice: GasPrice;
    }>;
}
/**
 * Helper function to deploy ETH contracts.
 * @param walletClient - A viem WalletClient.
 * @param publicClient - A viem PublicClient.
 * @param abi - The ETH contract's ABI (as abitype's Abi).
 * @param bytecode  - The ETH contract's bytecode.
 * @param args - Constructor arguments for the contract.
 * @param salt - Optional salt for CREATE2 deployment (does not wait for deployment tx to be mined if set, does not send tx if contract already exists).
 * @returns The ETH address the contract was deployed to.
 */
export declare function deployL1Contract(extendedClient: ExtendedViemWalletClient, abi: Narrow<Abi | readonly unknown[]>, bytecode: Hex, args?: readonly unknown[], opts?: {
    salt?: Hex;
    libraries?: Libraries;
    logger?: Logger;
    l1TxUtils?: L1TxUtils;
    gasLimit?: bigint;
    acceleratedTestDeployments?: boolean;
    noSimulation?: boolean;
}): Promise<{
    address: EthAddress;
    txHash: Hex | undefined;
    deployedLibraries?: VerificationLibraryEntry[];
    existed: boolean;
}>;
export declare function getExpectedAddress(abi: Narrow<Abi | readonly unknown[]>, bytecode: Hex, args: readonly unknown[], salt: Hex): {
    address: `0x${string}`;
    paddedSalt: `0x${string}`;
    calldata: `0x${string}`;
};
//# sourceMappingURL=deploy_l1_contracts.d.ts.map