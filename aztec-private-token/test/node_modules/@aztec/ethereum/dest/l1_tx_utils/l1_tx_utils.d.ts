import { EthAddress } from '@aztec/foundation/eth-address';
import { type Logger } from '@aztec/foundation/log';
import { DateProvider } from '@aztec/foundation/timer';
import { type Abi, type BlockOverrides, type Hex, type NonceManager, type PrepareTransactionRequestRequest, type StateOverride, type TransactionReceipt } from 'viem';
import type { ViemClient } from '../types.js';
import { type L1TxUtilsConfig } from './config.js';
import type { IL1TxMetrics, IL1TxStore } from './interfaces.js';
import { ReadOnlyL1TxUtils } from './readonly_l1_tx_utils.js';
import { type L1BlobInputs, type L1TxConfig, type L1TxRequest, type L1TxState, type SigningCallback, TxUtilsState } from './types.js';
export declare class L1TxUtils extends ReadOnlyL1TxUtils {
    client: ViemClient;
    address: EthAddress;
    protected signer: SigningCallback;
    protected store?: IL1TxStore | undefined;
    protected metrics?: IL1TxMetrics | undefined;
    protected nonceManager: NonceManager;
    protected txs: L1TxState[];
    constructor(client: ViemClient, address: EthAddress, signer: SigningCallback, logger?: Logger, dateProvider?: DateProvider, config?: Partial<L1TxUtilsConfig>, debugMaxGasLimit?: boolean, store?: IL1TxStore | undefined, metrics?: IL1TxMetrics | undefined);
    get state(): TxUtilsState;
    get lastMinedAtBlockNumber(): bigint | undefined;
    protected updateState(l1TxState: L1TxState, newState: TxUtilsState.MINED, l1Timestamp: number): Promise<void>;
    protected updateState(l1TxState: L1TxState, newState: TxUtilsState, l1Timestamp?: undefined): Promise<void>;
    updateConfig(newConfig: Partial<L1TxUtilsConfig>): void;
    getSenderAddress(): EthAddress;
    getSenderBalance(): Promise<bigint>;
    /**
     * Rehydrates transaction states from the store and resumes monitoring for pending transactions.
     * This should be called on startup to restore state and resume monitoring of any in-flight transactions.
     */
    loadStateAndResumeMonitoring(): Promise<void>;
    private signTransaction;
    protected prepareSignedTransaction(txData: PrepareTransactionRequestRequest): Promise<`0x${string}`>;
    /**
     * Sends a transaction with gas estimation and pricing
     * @param request - The transaction request (to, data, value)
     * @param gasConfig - Optional gas configuration
     * @returns The transaction hash and parameters used
     */
    sendTransaction(request: L1TxRequest, gasConfigOverrides?: L1TxConfig, blobInputs?: L1BlobInputs, stateChange?: TxUtilsState): Promise<{
        txHash: Hex;
        state: L1TxState;
    }>;
    private tryGetTxReceipt;
    /**
     * Returns whether a given tx should be considered as timed out and no longer monitored.
     * Relies on the txTimeout setting for user txs, and on the txCancellationTimeout for cancel txs.
     * @remarks We check against the latestBlockTimestamp as opposed to the current time to avoid a race condition where
     * the tx is mined in a block with the same timestamp as txTimeoutAt, but our execution node has not yet processed it,
     * or the loop here has not yet checked the tx before that timeout.
     */
    private isTxTimedOut;
    /**
     * Monitors a transaction until completion, handling speed-ups if needed
     */
    protected monitorTransaction(state: L1TxState): Promise<TransactionReceipt>;
    /**
     * Creates tx data to be signed by viem signTransaction method, using the state as input.
     * If isCancelTx is true, creates a 0-value tx to self with 21k gas and no data instead,
     * and an empty blob input if the original tx also had blobs.
     */
    private makeTxData;
    /** Returns when all monitor loops have stopped. */
    waitMonitoringStopped(timeoutSeconds?: number): Promise<void>;
    /**
     * Sends a transaction and monitors it until completion
     * @param request - The transaction request (to, data, value)
     * @param gasConfig - Optional gas configuration
     * @returns The receipt of the successful transaction
     */
    sendAndMonitorTransaction(request: L1TxRequest, gasConfig?: L1TxConfig, blobInputs?: L1BlobInputs): Promise<{
        receipt: TransactionReceipt;
        state: L1TxState;
    }>;
    simulate(request: L1TxRequest & {
        gas?: bigint;
        from?: Hex;
    }, _blockOverrides?: BlockOverrides<bigint, number>, stateOverrides?: StateOverride, abi?: Abi, _gasConfig?: L1TxUtilsConfig & {
        fallbackGasEstimate?: bigint;
        ignoreBlockGasLimit?: boolean;
    }): Promise<{
        gasUsed: bigint;
        result: `0x${string}`;
    }>;
    /**
     * Attempts to cancel a transaction by sending a 0-value tx to self with same nonce but higher gas prices
     * Only sends the cancellation if the original tx is still pending, not if it was dropped
     * @returns The hash of the cancellation transaction
     */
    protected attemptTxCancellation(state: L1TxState): Promise<void>;
    /** Returns L1 timestamps in milliseconds */
    private getL1Timestamp;
    /** Makes empty blob inputs for the cancellation tx. To be overridden in L1TxUtilsWithBlobs. */
    protected makeEmptyBlobInputs(_maxFeePerBlobGas: bigint): Required<L1BlobInputs>;
}
//# sourceMappingURL=l1_tx_utils.d.ts.map