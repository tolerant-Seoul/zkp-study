import { MAX_L2_TO_L1_MSGS_PER_TX, MAX_NOTE_HASHES_PER_TX, MAX_NULLIFIERS_PER_TX, MAX_PUBLIC_LOGS_PER_TX, MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX } from '@aztec/constants';
import { type FieldsOf } from '@aztec/foundation/array';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, FieldReader, type Tuple } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { z } from 'zod';
import { PublicLog } from '../logs/public_log.js';
import { ScopedL2ToL1Message } from '../messaging/l2_to_l1_message.js';
import { PublicDataWrite } from './public_data_write.js';
export declare class AvmAccumulatedData {
    /**
     * The note hashes from private combining with those made in the AVM execution.
     */
    noteHashes: Tuple<Fr, typeof MAX_NOTE_HASHES_PER_TX>;
    /**
     * The nullifiers from private combining with those made in the AVM execution.
     */
    nullifiers: Tuple<Fr, typeof MAX_NULLIFIERS_PER_TX>;
    /**
     * The L2 to L1 messages from private combining with those made in the AVM execution.
     */
    l2ToL1Msgs: Tuple<ScopedL2ToL1Message, typeof MAX_L2_TO_L1_MSGS_PER_TX>;
    /**
     * The public logs emitted from the AVM execution.
     */
    publicLogs: Tuple<PublicLog, typeof MAX_PUBLIC_LOGS_PER_TX>;
    /**
     * The public data writes made in the AVM execution.
     */
    publicDataWrites: Tuple<PublicDataWrite, typeof MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX>;
    constructor(
    /**
     * The note hashes from private combining with those made in the AVM execution.
     */
    noteHashes: Tuple<Fr, typeof MAX_NOTE_HASHES_PER_TX>, 
    /**
     * The nullifiers from private combining with those made in the AVM execution.
     */
    nullifiers: Tuple<Fr, typeof MAX_NULLIFIERS_PER_TX>, 
    /**
     * The L2 to L1 messages from private combining with those made in the AVM execution.
     */
    l2ToL1Msgs: Tuple<ScopedL2ToL1Message, typeof MAX_L2_TO_L1_MSGS_PER_TX>, 
    /**
     * The public logs emitted from the AVM execution.
     */
    publicLogs: Tuple<PublicLog, typeof MAX_PUBLIC_LOGS_PER_TX>, 
    /**
     * The public data writes made in the AVM execution.
     */
    publicDataWrites: Tuple<PublicDataWrite, typeof MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX>);
    static get schema(): z.ZodEffects<z.ZodObject<{
        noteHashes: z.ZodArray<z.ZodType<Fr, any, string>, "many">;
        nullifiers: z.ZodArray<z.ZodType<Fr, any, string>, "many">;
        l2ToL1Msgs: z.ZodArray<z.ZodEffects<z.ZodObject<{
            message: z.ZodEffects<z.ZodObject<{
                recipient: z.ZodType<import("@aztec/foundation/schemas").EthAddress, any, string>;
                content: z.ZodType<Fr, any, string>;
            }, "strip", z.ZodTypeAny, {
                recipient: import("@aztec/foundation/schemas").EthAddress;
                content: Fr;
            }, {
                recipient: string;
                content: string;
            }>, import("../messaging/l2_to_l1_message.js").L2ToL1Message, {
                recipient: string;
                content: string;
            }>;
            contractAddress: import("@aztec/foundation/schemas").ZodFor<import("../aztec-address/index.js").AztecAddress>;
        }, "strip", z.ZodTypeAny, {
            message: import("../messaging/l2_to_l1_message.js").L2ToL1Message;
            contractAddress: import("../aztec-address/index.js").AztecAddress;
        }, {
            message: {
                recipient: string;
                content: string;
            };
            contractAddress?: any;
        }>, ScopedL2ToL1Message, {
            message: {
                recipient: string;
                content: string;
            };
            contractAddress?: any;
        }>, "many">;
        publicLogs: z.ZodArray<import("@aztec/foundation/schemas").ZodFor<PublicLog>, "many">;
        publicDataWrites: z.ZodArray<z.ZodEffects<z.ZodObject<{
            leafSlot: z.ZodType<Fr, any, string>;
            value: z.ZodType<Fr, any, string>;
        }, "strip", z.ZodTypeAny, {
            value: Fr;
            leafSlot: Fr;
        }, {
            value: string;
            leafSlot: string;
        }>, PublicDataWrite, {
            value: string;
            leafSlot: string;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        noteHashes: Fr[];
        nullifiers: Fr[];
        l2ToL1Msgs: ScopedL2ToL1Message[];
        publicDataWrites: PublicDataWrite[];
        publicLogs: PublicLog[];
    }, {
        noteHashes: string[];
        nullifiers: string[];
        l2ToL1Msgs: {
            message: {
                recipient: string;
                content: string;
            };
            contractAddress?: any;
        }[];
        publicDataWrites: {
            value: string;
            leafSlot: string;
        }[];
        publicLogs: any[];
    }>, AvmAccumulatedData, {
        noteHashes: string[];
        nullifiers: string[];
        l2ToL1Msgs: {
            message: {
                recipient: string;
                content: string;
            };
            contractAddress?: any;
        }[];
        publicDataWrites: {
            value: string;
            leafSlot: string;
        }[];
        publicLogs: any[];
    }>;
    getSize(): number;
    static fromBuffer(buffer: Buffer | BufferReader): AvmAccumulatedData;
    toBuffer(): Buffer<ArrayBufferLike>;
    static getFields(fields: FieldsOf<AvmAccumulatedData>): readonly [[Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr], [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr], [ScopedL2ToL1Message, ScopedL2ToL1Message, ScopedL2ToL1Message, ScopedL2ToL1Message, ScopedL2ToL1Message, ScopedL2ToL1Message, ScopedL2ToL1Message, ScopedL2ToL1Message], [PublicLog, PublicLog, PublicLog, PublicLog, PublicLog, PublicLog, PublicLog, PublicLog], [PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite, PublicDataWrite]];
    static fromFields(fields: Fr[] | FieldReader): AvmAccumulatedData;
    toFields(): Fr[];
    static fromString(str: string): AvmAccumulatedData;
    toString(): `0x${string}`;
    static empty(): AvmAccumulatedData;
    isEmpty(): boolean;
    [inspect.custom](): string;
}
/**
 * Represents the lengths of arrays in AVM accumulated data
 */
export declare class AvmAccumulatedDataArrayLengths {
    /**
     * Number of note hashes
     */
    noteHashes: number;
    /**
     * Number of nullifiers
     */
    nullifiers: number;
    /**
     * Number of L2 to L1 messages
     */
    l2ToL1Msgs: number;
    /**
     * Number of public logs
     */
    publicLogs: number;
    /**
     * Number of public data writes
     */
    publicDataWrites: number;
    constructor(
    /**
     * Number of note hashes
     */
    noteHashes: number, 
    /**
     * Number of nullifiers
     */
    nullifiers: number, 
    /**
     * Number of L2 to L1 messages
     */
    l2ToL1Msgs: number, 
    /**
     * Number of public logs
     */
    publicLogs: number, 
    /**
     * Number of public data writes
     */
    publicDataWrites: number);
    static get schema(): z.ZodEffects<z.ZodObject<{
        noteHashes: z.ZodNumber;
        nullifiers: z.ZodNumber;
        l2ToL1Msgs: z.ZodNumber;
        publicLogs: z.ZodNumber;
        publicDataWrites: z.ZodNumber;
    }, "strip", z.ZodTypeAny, {
        noteHashes: number;
        nullifiers: number;
        l2ToL1Msgs: number;
        publicDataWrites: number;
        publicLogs: number;
    }, {
        noteHashes: number;
        nullifiers: number;
        l2ToL1Msgs: number;
        publicDataWrites: number;
        publicLogs: number;
    }>, AvmAccumulatedDataArrayLengths, {
        noteHashes: number;
        nullifiers: number;
        l2ToL1Msgs: number;
        publicDataWrites: number;
        publicLogs: number;
    }>;
    static fromBuffer(buffer: Buffer | BufferReader): AvmAccumulatedDataArrayLengths;
    toBuffer(): Buffer<ArrayBufferLike>;
    static fromFields(fields: Fr[] | FieldReader): AvmAccumulatedDataArrayLengths;
    toFields(): Fr[];
    static empty(): AvmAccumulatedDataArrayLengths;
    [inspect.custom](): string;
}
//# sourceMappingURL=avm_accumulated_data.d.ts.map