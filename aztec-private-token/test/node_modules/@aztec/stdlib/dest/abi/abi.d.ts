import type { Fr } from '@aztec/foundation/fields';
import { type ZodFor } from '@aztec/foundation/schemas';
import { z } from 'zod';
import { FunctionSelector } from './function_selector.js';
/** A basic value. */
export interface BasicValue<T extends string, V> {
    /** The kind of the value. */
    kind: T;
    value: V;
}
/** An exported value. */
export type AbiValue = BasicValue<'boolean', boolean> | BasicValue<'string', string> | BasicValue<'array', AbiValue[]> | TupleValue | IntegerValue | StructValue;
export declare const AbiValueSchema: z.ZodType<AbiValue>;
export type TypedStructFieldValue<T> = {
    name: string;
    value: T;
};
export interface StructValue {
    kind: 'struct';
    fields: TypedStructFieldValue<AbiValue>[];
}
export interface TupleValue {
    kind: 'tuple';
    fields: AbiValue[];
}
export interface IntegerValue extends BasicValue<'integer', string> {
    sign: boolean;
}
/** Indicates whether a parameter is public or secret/private. */
export declare const ABIParameterVisibility: readonly ["public", "private", "databus"];
/** Indicates whether a parameter is public or secret/private. */
export type ABIParameterVisibility = (typeof ABIParameterVisibility)[number];
/** A basic type. */
export interface BasicType<T extends string> {
    /** The kind of the type. */
    kind: T;
}
/** Sign for numeric types. */
declare const Sign: readonly ["unsigned", "signed"];
type Sign = (typeof Sign)[number];
/** A variable type. */
export type AbiType = BasicType<'field'> | BasicType<'boolean'> | IntegerType | ArrayType | StringType | StructType | TupleType;
export declare const AbiTypeSchema: z.ZodType<AbiType>;
/** A named type. */
export declare const ABIVariableSchema: z.ZodObject<{
    /** The name of the variable. */
    name: z.ZodString;
    /** The type of the variable. */
    type: z.ZodType<AbiType, z.ZodTypeDef, AbiType>;
}, "strip", z.ZodTypeAny, {
    type: AbiType;
    name: string;
}, {
    type: AbiType;
    name: string;
}>;
/** A named type. */
export type ABIVariable = z.infer<typeof ABIVariableSchema>;
/** A function parameter. */
export declare const ABIParameterSchema: z.ZodIntersection<z.ZodObject<{
    /** The name of the variable. */
    name: z.ZodString;
    /** The type of the variable. */
    type: z.ZodType<AbiType, z.ZodTypeDef, AbiType>;
}, "strip", z.ZodTypeAny, {
    type: AbiType;
    name: string;
}, {
    type: AbiType;
    name: string;
}>, z.ZodObject<{
    /** Visibility of the parameter in the function. */
    visibility: z.ZodEnum<["public", "private", "databus"]>;
}, "strip", z.ZodTypeAny, {
    visibility: "public" | "private" | "databus";
}, {
    visibility: "public" | "private" | "databus";
}>>;
/** A function parameter. */
export type ABIParameter = z.infer<typeof ABIParameterSchema>;
/** An integer type. */
export interface IntegerType extends BasicType<'integer'> {
    /** The sign of the integer. */
    sign: Sign;
    /** The width of the integer in bits. */
    width: number;
}
/** An array type. */
export interface ArrayType extends BasicType<'array'> {
    /** The length of the array. */
    length: number;
    /** The type of the array elements. */
    type: AbiType;
}
/** A tuple type. */
export interface TupleType extends BasicType<'tuple'> {
    /** The types of the tuple elements. */
    fields: AbiType[];
}
/** A string type. */
export interface StringType extends BasicType<'string'> {
    /** The length of the string. */
    length: number;
}
/** A struct type. */
export interface StructType extends BasicType<'struct'> {
    /** The fields of the struct. */
    fields: ABIVariable[];
    /** Fully qualified name of the struct. */
    path: string;
}
/** An error could be a custom error of any regular type or a string error. */
export type AbiErrorType = {
    error_kind: 'string';
    string: string;
} | {
    error_kind: 'fmtstring';
    length: number;
    item_types: AbiType[];
} | ({
    error_kind: 'custom';
} & AbiType);
/** Aztec.nr function types. */
export declare enum FunctionType {
    PRIVATE = "private",
    PUBLIC = "public",
    UTILITY = "utility"
}
/** The abi entry of a function. */
export interface FunctionAbi {
    /** The name of the function. */
    name: string;
    /** Whether the function is secret. */
    functionType: FunctionType;
    /** Whether the function is internal. */
    isInternal: boolean;
    /** Whether the function can alter state or not */
    isStatic: boolean;
    /** Function parameters. */
    parameters: ABIParameter[];
    /** The types of the return values. */
    returnTypes: AbiType[];
    /** The types of the errors that the function can throw. */
    errorTypes: Partial<Record<string, AbiErrorType>>;
    /** Whether the function is flagged as an initializer. */
    isInitializer: boolean;
}
export declare const FunctionAbiSchema: z.ZodObject<{
    name: z.ZodString;
    functionType: z.ZodNativeEnum<typeof FunctionType>;
    isInternal: z.ZodBoolean;
    isStatic: z.ZodBoolean;
    isInitializer: z.ZodBoolean;
    parameters: z.ZodArray<z.ZodObject<{
        name: z.ZodString;
        type: z.ZodType<AbiType, z.ZodTypeDef, AbiType>;
        visibility: z.ZodEnum<["public", "private", "databus"]>;
    }, "strip", z.ZodTypeAny, {
        type: AbiType;
        name: string;
        visibility: "public" | "private" | "databus";
    }, {
        type: AbiType;
        name: string;
        visibility: "public" | "private" | "databus";
    }>, "many">;
    returnTypes: z.ZodArray<z.ZodType<AbiType, z.ZodTypeDef, AbiType>, "many">;
    errorTypes: z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodObject<{
        error_kind: z.ZodLiteral<"string">;
        string: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        string: string;
        error_kind: "string";
    }, {
        string: string;
        error_kind: "string";
    }>, z.ZodObject<{
        error_kind: z.ZodLiteral<"fmtstring">;
        length: z.ZodNumber;
        item_types: z.ZodArray<z.ZodType<AbiType, z.ZodTypeDef, AbiType>, "many">;
    }, "strip", z.ZodTypeAny, {
        length: number;
        error_kind: "fmtstring";
        item_types: AbiType[];
    }, {
        length: number;
        error_kind: "fmtstring";
        item_types: AbiType[];
    }>, z.ZodIntersection<z.ZodObject<{
        error_kind: z.ZodLiteral<"custom">;
    }, "strip", z.ZodTypeAny, {
        error_kind: "custom";
    }, {
        error_kind: "custom";
    }>, z.ZodType<AbiType, z.ZodTypeDef, AbiType>>]>>;
}, "strip", z.ZodTypeAny, {
    name: string;
    parameters: {
        type: AbiType;
        name: string;
        visibility: "public" | "private" | "databus";
    }[];
    functionType: FunctionType;
    isInternal: boolean;
    isStatic: boolean;
    isInitializer: boolean;
    returnTypes: AbiType[];
    errorTypes: Record<string, {
        string: string;
        error_kind: "string";
    } | {
        length: number;
        error_kind: "fmtstring";
        item_types: AbiType[];
    } | ({
        error_kind: "custom";
    } & AbiType)>;
}, {
    name: string;
    parameters: {
        type: AbiType;
        name: string;
        visibility: "public" | "private" | "databus";
    }[];
    functionType: FunctionType;
    isInternal: boolean;
    isStatic: boolean;
    isInitializer: boolean;
    returnTypes: AbiType[];
    errorTypes: Record<string, {
        string: string;
        error_kind: "string";
    } | {
        length: number;
        error_kind: "fmtstring";
        item_types: AbiType[];
    } | ({
        error_kind: "custom";
    } & AbiType)>;
}>;
/** Debug metadata for a function. */
export interface FunctionDebugMetadata {
    /** Maps opcodes to source code pointers */
    debugSymbols: DebugInfo;
    /** Maps the file IDs to the file contents to resolve pointers */
    files: DebugFileMap;
}
export declare const FunctionDebugMetadataSchema: z.ZodObject<{
    debugSymbols: z.ZodObject<{
        location_tree: z.ZodObject<{
            locations: z.ZodArray<z.ZodObject<{
                parent: z.ZodNullable<z.ZodNumber>;
                value: z.ZodObject<{
                    span: z.ZodObject<{
                        start: z.ZodNumber;
                        end: z.ZodNumber;
                    }, "strip", z.ZodTypeAny, {
                        start: number;
                        end: number;
                    }, {
                        start: number;
                        end: number;
                    }>;
                    file: z.ZodNumber;
                }, "strip", z.ZodTypeAny, {
                    span: {
                        start: number;
                        end: number;
                    };
                    file: number;
                }, {
                    span: {
                        start: number;
                        end: number;
                    };
                    file: number;
                }>;
            }, "strip", z.ZodTypeAny, {
                value: {
                    span: {
                        start: number;
                        end: number;
                    };
                    file: number;
                };
                parent: number | null;
            }, {
                value: {
                    span: {
                        start: number;
                        end: number;
                    };
                    file: number;
                };
                parent: number | null;
            }>, "many">;
        }, "strip", z.ZodTypeAny, {
            locations: {
                value: {
                    span: {
                        start: number;
                        end: number;
                    };
                    file: number;
                };
                parent: number | null;
            }[];
        }, {
            locations: {
                value: {
                    span: {
                        start: number;
                        end: number;
                    };
                    file: number;
                };
                parent: number | null;
            }[];
        }>;
        acir_locations: z.ZodRecord<z.ZodString, z.ZodNumber>;
        brillig_locations: z.ZodRecord<z.ZodString, z.ZodRecord<z.ZodString, z.ZodNumber>>;
    }, "strip", z.ZodTypeAny, {
        location_tree: {
            locations: {
                value: {
                    span: {
                        start: number;
                        end: number;
                    };
                    file: number;
                };
                parent: number | null;
            }[];
        };
        acir_locations: Record<string, number>;
        brillig_locations: Record<string, Record<string, number>>;
    }, {
        location_tree: {
            locations: {
                value: {
                    span: {
                        start: number;
                        end: number;
                    };
                    file: number;
                };
                parent: number | null;
            }[];
        };
        acir_locations: Record<string, number>;
        brillig_locations: Record<string, Record<string, number>>;
    }>;
    files: z.ZodRecord<z.ZodString, z.ZodObject<{
        source: z.ZodString;
        path: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        path: string;
        source: string;
    }, {
        path: string;
        source: string;
    }>>;
}, "strip", z.ZodTypeAny, {
    debugSymbols: {
        location_tree: {
            locations: {
                value: {
                    span: {
                        start: number;
                        end: number;
                    };
                    file: number;
                };
                parent: number | null;
            }[];
        };
        acir_locations: Record<string, number>;
        brillig_locations: Record<string, Record<string, number>>;
    };
    files: Record<string, {
        path: string;
        source: string;
    }>;
}, {
    debugSymbols: {
        location_tree: {
            locations: {
                value: {
                    span: {
                        start: number;
                        end: number;
                    };
                    file: number;
                };
                parent: number | null;
            }[];
        };
        acir_locations: Record<string, number>;
        brillig_locations: Record<string, Record<string, number>>;
    };
    files: Record<string, {
        path: string;
        source: string;
    }>;
}>;
/** The artifact entry of a function. */
export interface FunctionArtifact extends FunctionAbi {
    /** The ACIR bytecode of the function. */
    bytecode: Buffer;
    /** The verification key of the function, base64 encoded, if it's a private fn. */
    verificationKey?: string;
    /** Maps opcodes to source code pointers */
    debugSymbols: string;
    /** Debug metadata for the function. */
    debug?: FunctionDebugMetadata;
}
export interface FunctionArtifactWithContractName extends FunctionArtifact {
    /** The name of the contract. */
    contractName: string;
}
export declare const FunctionArtifactSchema: z.ZodIntersection<z.ZodObject<{
    name: z.ZodString;
    functionType: z.ZodNativeEnum<typeof FunctionType>;
    isInternal: z.ZodBoolean;
    isStatic: z.ZodBoolean;
    isInitializer: z.ZodBoolean;
    parameters: z.ZodArray<z.ZodObject<{
        name: z.ZodString;
        type: z.ZodType<AbiType, z.ZodTypeDef, AbiType>;
        visibility: z.ZodEnum<["public", "private", "databus"]>;
    }, "strip", z.ZodTypeAny, {
        type: AbiType;
        name: string;
        visibility: "public" | "private" | "databus";
    }, {
        type: AbiType;
        name: string;
        visibility: "public" | "private" | "databus";
    }>, "many">;
    returnTypes: z.ZodArray<z.ZodType<AbiType, z.ZodTypeDef, AbiType>, "many">;
    errorTypes: z.ZodRecord<z.ZodString, z.ZodUnion<[z.ZodObject<{
        error_kind: z.ZodLiteral<"string">;
        string: z.ZodString;
    }, "strip", z.ZodTypeAny, {
        string: string;
        error_kind: "string";
    }, {
        string: string;
        error_kind: "string";
    }>, z.ZodObject<{
        error_kind: z.ZodLiteral<"fmtstring">;
        length: z.ZodNumber;
        item_types: z.ZodArray<z.ZodType<AbiType, z.ZodTypeDef, AbiType>, "many">;
    }, "strip", z.ZodTypeAny, {
        length: number;
        error_kind: "fmtstring";
        item_types: AbiType[];
    }, {
        length: number;
        error_kind: "fmtstring";
        item_types: AbiType[];
    }>, z.ZodIntersection<z.ZodObject<{
        error_kind: z.ZodLiteral<"custom">;
    }, "strip", z.ZodTypeAny, {
        error_kind: "custom";
    }, {
        error_kind: "custom";
    }>, z.ZodType<AbiType, z.ZodTypeDef, AbiType>>]>>;
}, "strip", z.ZodTypeAny, {
    name: string;
    parameters: {
        type: AbiType;
        name: string;
        visibility: "public" | "private" | "databus";
    }[];
    functionType: FunctionType;
    isInternal: boolean;
    isStatic: boolean;
    isInitializer: boolean;
    returnTypes: AbiType[];
    errorTypes: Record<string, {
        string: string;
        error_kind: "string";
    } | {
        length: number;
        error_kind: "fmtstring";
        item_types: AbiType[];
    } | ({
        error_kind: "custom";
    } & AbiType)>;
}, {
    name: string;
    parameters: {
        type: AbiType;
        name: string;
        visibility: "public" | "private" | "databus";
    }[];
    functionType: FunctionType;
    isInternal: boolean;
    isStatic: boolean;
    isInitializer: boolean;
    returnTypes: AbiType[];
    errorTypes: Record<string, {
        string: string;
        error_kind: "string";
    } | {
        length: number;
        error_kind: "fmtstring";
        item_types: AbiType[];
    } | ({
        error_kind: "custom";
    } & AbiType)>;
}>, z.ZodObject<{
    bytecode: z.ZodUnion<[z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, Buffer<ArrayBuffer>, string>, z.ZodEffects<z.ZodObject<{
        type: z.ZodLiteral<"Buffer">;
        data: z.ZodArray<z.ZodNumber, "many">;
    }, "strip", z.ZodTypeAny, {
        type: "Buffer";
        data: number[];
    }, {
        type: "Buffer";
        data: number[];
    }>, Buffer<ArrayBuffer>, {
        type: "Buffer";
        data: number[];
    }>]>;
    verificationKey: z.ZodOptional<z.ZodString>;
    debugSymbols: z.ZodString;
    debug: z.ZodOptional<z.ZodObject<{
        debugSymbols: z.ZodObject<{
            location_tree: z.ZodObject<{
                locations: z.ZodArray<z.ZodObject<{
                    parent: z.ZodNullable<z.ZodNumber>;
                    value: z.ZodObject<{
                        span: z.ZodObject<{
                            start: z.ZodNumber;
                            end: z.ZodNumber;
                        }, "strip", z.ZodTypeAny, {
                            start: number;
                            end: number;
                        }, {
                            start: number;
                            end: number;
                        }>;
                        file: z.ZodNumber;
                    }, "strip", z.ZodTypeAny, {
                        span: {
                            start: number;
                            end: number;
                        };
                        file: number;
                    }, {
                        span: {
                            start: number;
                            end: number;
                        };
                        file: number;
                    }>;
                }, "strip", z.ZodTypeAny, {
                    value: {
                        span: {
                            start: number;
                            end: number;
                        };
                        file: number;
                    };
                    parent: number | null;
                }, {
                    value: {
                        span: {
                            start: number;
                            end: number;
                        };
                        file: number;
                    };
                    parent: number | null;
                }>, "many">;
            }, "strip", z.ZodTypeAny, {
                locations: {
                    value: {
                        span: {
                            start: number;
                            end: number;
                        };
                        file: number;
                    };
                    parent: number | null;
                }[];
            }, {
                locations: {
                    value: {
                        span: {
                            start: number;
                            end: number;
                        };
                        file: number;
                    };
                    parent: number | null;
                }[];
            }>;
            acir_locations: z.ZodRecord<z.ZodString, z.ZodNumber>;
            brillig_locations: z.ZodRecord<z.ZodString, z.ZodRecord<z.ZodString, z.ZodNumber>>;
        }, "strip", z.ZodTypeAny, {
            location_tree: {
                locations: {
                    value: {
                        span: {
                            start: number;
                            end: number;
                        };
                        file: number;
                    };
                    parent: number | null;
                }[];
            };
            acir_locations: Record<string, number>;
            brillig_locations: Record<string, Record<string, number>>;
        }, {
            location_tree: {
                locations: {
                    value: {
                        span: {
                            start: number;
                            end: number;
                        };
                        file: number;
                    };
                    parent: number | null;
                }[];
            };
            acir_locations: Record<string, number>;
            brillig_locations: Record<string, Record<string, number>>;
        }>;
        files: z.ZodRecord<z.ZodString, z.ZodObject<{
            source: z.ZodString;
            path: z.ZodString;
        }, "strip", z.ZodTypeAny, {
            path: string;
            source: string;
        }, {
            path: string;
            source: string;
        }>>;
    }, "strip", z.ZodTypeAny, {
        debugSymbols: {
            location_tree: {
                locations: {
                    value: {
                        span: {
                            start: number;
                            end: number;
                        };
                        file: number;
                    };
                    parent: number | null;
                }[];
            };
            acir_locations: Record<string, number>;
            brillig_locations: Record<string, Record<string, number>>;
        };
        files: Record<string, {
            path: string;
            source: string;
        }>;
    }, {
        debugSymbols: {
            location_tree: {
                locations: {
                    value: {
                        span: {
                            start: number;
                            end: number;
                        };
                        file: number;
                    };
                    parent: number | null;
                }[];
            };
            acir_locations: Record<string, number>;
            brillig_locations: Record<string, Record<string, number>>;
        };
        files: Record<string, {
            path: string;
            source: string;
        }>;
    }>>;
}, "strip", z.ZodTypeAny, {
    debugSymbols: string;
    bytecode: Buffer<ArrayBuffer>;
    debug?: {
        debugSymbols: {
            location_tree: {
                locations: {
                    value: {
                        span: {
                            start: number;
                            end: number;
                        };
                        file: number;
                    };
                    parent: number | null;
                }[];
            };
            acir_locations: Record<string, number>;
            brillig_locations: Record<string, Record<string, number>>;
        };
        files: Record<string, {
            path: string;
            source: string;
        }>;
    } | undefined;
    verificationKey?: string | undefined;
}, {
    debugSymbols: string;
    bytecode: string | {
        type: "Buffer";
        data: number[];
    };
    debug?: {
        debugSymbols: {
            location_tree: {
                locations: {
                    value: {
                        span: {
                            start: number;
                            end: number;
                        };
                        file: number;
                    };
                    parent: number | null;
                }[];
            };
            acir_locations: Record<string, number>;
            brillig_locations: Record<string, Record<string, number>>;
        };
        files: Record<string, {
            path: string;
            source: string;
        }>;
    } | undefined;
    verificationKey?: string | undefined;
}>>;
/** A file ID. It's assigned during compilation. */
type FileId = number;
/** A pointer to a specific section of the source code. */
interface SourceCodeLocation {
    /** The section of the source code. */
    span: {
        /** The byte where the section starts. */
        start: number;
        /** The byte where the section ends. */
        end: number;
    };
    /** The source code file pointed to. */
    file: FileId;
}
/**
 * The location of an opcode in the bytecode.
 * It's a string of the form `{acirIndex}` or `{acirIndex}:{brilligIndex}`.
 */
export type OpcodeLocation = string;
export type BrilligFunctionId = number;
export type OpcodeToLocationsMap = Record<OpcodeLocation, number>;
export type LocationNodeDebugInfo = {
    parent: number | null;
    value: SourceCodeLocation;
};
export type LocationTree = {
    locations: LocationNodeDebugInfo[];
};
/** The debug information for a given function. */
export interface DebugInfo {
    /** A map of the opcode location to the source code location. */
    location_tree: LocationTree;
    acir_locations: OpcodeToLocationsMap;
    /** For each Brillig function, we have a map of the opcode location to the source code location. */
    brillig_locations: Record<BrilligFunctionId, OpcodeToLocationsMap>;
}
/** The debug information for a given program (a collection of functions) */
export interface ProgramDebugInfo {
    /** A list of debug information that matches with each function in a program */
    debug_infos: Array<DebugInfo>;
}
/** Maps a file ID to its metadata for debugging purposes. */
export type DebugFileMap = Record<FileId, {
    /** The source code of the file. */
    source: string;
    /** The path of the file. */
    path: string;
}>;
/** Type representing a field layout in the storage of a contract. */
export type FieldLayout = {
    /** Slot in which the field is stored. */
    slot: Fr;
};
/** Defines artifact of a contract. */
export interface ContractArtifact {
    /** The name of the contract. */
    name: string;
    /** The functions of the contract. Includes private and utility functions, plus the public dispatch function. */
    functions: FunctionArtifact[];
    /** The public functions of the contract, excluding dispatch. */
    nonDispatchPublicFunctions: FunctionAbi[];
    /** The outputs of the contract. */
    outputs: {
        structs: Record<string, AbiType[]>;
        globals: Record<string, AbiValue[]>;
    };
    /** Storage layout */
    storageLayout: Record<string, FieldLayout>;
    /** The map of file ID to the source code and path of the file. */
    fileMap: DebugFileMap;
}
export declare const ContractArtifactSchema: ZodFor<ContractArtifact>;
export declare function getFunctionArtifactByName(artifact: ContractArtifact, functionName: string): FunctionArtifact;
/** Gets a function artifact including debug metadata given its name or selector. */
export declare function getFunctionArtifact(artifact: ContractArtifact, functionNameOrSelector: string | FunctionSelector): Promise<FunctionArtifactWithContractName>;
/** Gets all function abis */
export declare function getAllFunctionAbis(artifact: ContractArtifact): FunctionAbi[];
export declare function parseDebugSymbols(debugSymbols: string): DebugInfo[];
/**
 * Gets the debug metadata of a given function from the contract artifact
 * @param artifact - The contract build artifact
 * @param functionName - The name of the function
 * @returns The debug metadata of the function
 */
export declare function getFunctionDebugMetadata(contractArtifact: ContractArtifact, functionArtifact: FunctionArtifact): FunctionDebugMetadata | undefined;
/**
 * Returns an initializer from the contract, assuming there is at least one. If there are multiple initializers,
 * it returns the one named "constructor" or "initializer"; if there is none with that name, it returns the first
 * initializer it finds, prioritizing initializers with no arguments and then private ones.
 * @param contractArtifact - The contract artifact.
 * @returns An initializer function, or none if there are no functions flagged as initializers in the contract.
 */
export declare function getDefaultInitializer(contractArtifact: ContractArtifact): FunctionAbi | undefined;
/**
 * Returns an initializer from the contract.
 * @param initializerNameOrArtifact - The name of the constructor, or the artifact of the constructor, or undefined
 * to pick the default initializer.
 */
export declare function getInitializer(contract: ContractArtifact, initializerNameOrArtifact: string | undefined | FunctionArtifact): FunctionAbi | undefined;
export declare function emptyFunctionAbi(): FunctionAbi;
export declare function emptyFunctionArtifact(): FunctionArtifact;
export declare function emptyContractArtifact(): ContractArtifact;
export {};
//# sourceMappingURL=abi.d.ts.map