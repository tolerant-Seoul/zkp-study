import { Buffer32 } from '@aztec/foundation/buffer';
import type { EthAddress } from '@aztec/foundation/eth-address';
import { Signature } from '@aztec/foundation/eth-signature';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import type { L2BlockInfo } from '../block/l2_block_info.js';
import { TxHash } from '../tx/index.js';
import { Tx } from '../tx/tx.js';
import { ConsensusPayload } from './consensus_payload.js';
import { Gossipable } from './gossipable.js';
import { TopicType } from './topic_type.js';
export declare class BlockProposalHash extends Buffer32 {
    constructor(hash: Buffer);
}
export type BlockProposalOptions = {
    publishFullTxs: boolean;
};
/**
 * BlockProposal
 *
 * A block proposal is created by the leader of the chain proposing a sequence of transactions to
 * be included in the head of the chain
 */
export declare class BlockProposal extends Gossipable {
    /** The payload of the message, and what the signature is over */
    readonly payload: ConsensusPayload;
    /** The signer of the BlockProposal over the header of the new block*/
    readonly signature: Signature;
    /** The sequence of transactions in the block */
    readonly txHashes: TxHash[];
    /** The transactions in the block */
    readonly txs?: Tx[] | undefined;
    static p2pTopic: TopicType;
    private sender;
    constructor(
    /** The payload of the message, and what the signature is over */
    payload: ConsensusPayload, 
    /** The signer of the BlockProposal over the header of the new block*/
    signature: Signature, 
    /** The sequence of transactions in the block */
    txHashes: TxHash[], 
    /** The transactions in the block */
    txs?: Tx[] | undefined);
    generateP2PMessageIdentifier(): Promise<Buffer32>;
    get archive(): Fr;
    get slotNumber(): Fr;
    toBlockInfo(): Omit<L2BlockInfo, 'blockNumber'>;
    static createProposalFromSigner(payload: ConsensusPayload, txHashes: TxHash[], txs: Tx[] | undefined, payloadSigner: (payload: Buffer32) => Promise<Signature>): Promise<BlockProposal>;
    /**Get Sender
     * Lazily evaluate the sender of the proposal; result is cached
     * @returns The sender address, or undefined if signature recovery fails
     */
    getSender(): EthAddress | undefined;
    getPayload(): Buffer<ArrayBufferLike>;
    toBuffer(): Buffer;
    static fromBuffer(buf: Buffer | BufferReader): BlockProposal;
    getSize(): number;
}
//# sourceMappingURL=block_proposal.d.ts.map