import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import type { FieldsOf } from '@aztec/foundation/types';
import { z } from 'zod';
import type { L2Block } from '../block/l2_block.js';
import { ProposedBlockHeader, StateReference } from '../tx/index.js';
import type { Signable, SignatureDomainSeparator } from './signature_utils.js';
export declare class ConsensusPayload implements Signable {
    /** The proposed block header the attestation is made over */
    readonly header: ProposedBlockHeader;
    /** The archive root after the block is added */
    readonly archive: Fr;
    /** The state reference after the block is added */
    readonly stateReference: StateReference;
    private size;
    constructor(
    /** The proposed block header the attestation is made over */
    header: ProposedBlockHeader, 
    /** The archive root after the block is added */
    archive: Fr, 
    /** The state reference after the block is added */
    stateReference: StateReference);
    static get schema(): z.ZodEffects<z.ZodObject<{
        header: import("@aztec/foundation/schemas").ZodFor<ProposedBlockHeader>;
        archive: z.ZodType<Fr, any, string>;
        stateReference: z.ZodEffects<z.ZodObject<{
            l1ToL2MessageTree: z.ZodEffects<z.ZodObject<{
                root: z.ZodType<Fr, any, string>;
                nextAvailableLeafIndex: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>;
            }, "strip", z.ZodTypeAny, {
                root: Fr;
                nextAvailableLeafIndex: number;
            }, {
                root: string;
                nextAvailableLeafIndex: string | number | bigint;
            }>, import("../trees/append_only_tree_snapshot.js").AppendOnlyTreeSnapshot, {
                root: string;
                nextAvailableLeafIndex: string | number | bigint;
            }>;
            partial: z.ZodEffects<z.ZodObject<{
                noteHashTree: z.ZodEffects<z.ZodObject<{
                    root: z.ZodType<Fr, any, string>;
                    nextAvailableLeafIndex: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>;
                }, "strip", z.ZodTypeAny, {
                    root: Fr;
                    nextAvailableLeafIndex: number;
                }, {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                }>, import("../trees/append_only_tree_snapshot.js").AppendOnlyTreeSnapshot, {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                }>;
                nullifierTree: z.ZodEffects<z.ZodObject<{
                    root: z.ZodType<Fr, any, string>;
                    nextAvailableLeafIndex: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>;
                }, "strip", z.ZodTypeAny, {
                    root: Fr;
                    nextAvailableLeafIndex: number;
                }, {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                }>, import("../trees/append_only_tree_snapshot.js").AppendOnlyTreeSnapshot, {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                }>;
                publicDataTree: z.ZodEffects<z.ZodObject<{
                    root: z.ZodType<Fr, any, string>;
                    nextAvailableLeafIndex: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>;
                }, "strip", z.ZodTypeAny, {
                    root: Fr;
                    nextAvailableLeafIndex: number;
                }, {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                }>, import("../trees/append_only_tree_snapshot.js").AppendOnlyTreeSnapshot, {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                }>;
            }, "strip", z.ZodTypeAny, {
                noteHashTree: import("../trees/append_only_tree_snapshot.js").AppendOnlyTreeSnapshot;
                nullifierTree: import("../trees/append_only_tree_snapshot.js").AppendOnlyTreeSnapshot;
                publicDataTree: import("../trees/append_only_tree_snapshot.js").AppendOnlyTreeSnapshot;
            }, {
                noteHashTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
                nullifierTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
                publicDataTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
            }>, import("../tx/partial_state_reference.js").PartialStateReference, {
                noteHashTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
                nullifierTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
                publicDataTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
            }>;
        }, "strip", z.ZodTypeAny, {
            partial: import("../tx/partial_state_reference.js").PartialStateReference;
            l1ToL2MessageTree: import("../trees/append_only_tree_snapshot.js").AppendOnlyTreeSnapshot;
        }, {
            partial: {
                noteHashTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
                nullifierTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
                publicDataTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
            };
            l1ToL2MessageTree: {
                root: string;
                nextAvailableLeafIndex: string | number | bigint;
            };
        }>, StateReference, {
            partial: {
                noteHashTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
                nullifierTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
                publicDataTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
            };
            l1ToL2MessageTree: {
                root: string;
                nextAvailableLeafIndex: string | number | bigint;
            };
        }>;
    }, "strip", z.ZodTypeAny, {
        archive: Fr;
        header: ProposedBlockHeader;
        stateReference: StateReference;
    }, {
        archive: string;
        stateReference: {
            partial: {
                noteHashTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
                nullifierTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
                publicDataTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
            };
            l1ToL2MessageTree: {
                root: string;
                nextAvailableLeafIndex: string | number | bigint;
            };
        };
        header?: any;
    }>, ConsensusPayload, {
        archive: string;
        stateReference: {
            partial: {
                noteHashTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
                nullifierTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
                publicDataTree: {
                    root: string;
                    nextAvailableLeafIndex: string | number | bigint;
                };
            };
            l1ToL2MessageTree: {
                root: string;
                nextAvailableLeafIndex: string | number | bigint;
            };
        };
        header?: any;
    }>;
    static getFields(fields: FieldsOf<ConsensusPayload>): readonly [ProposedBlockHeader, Fr, StateReference];
    getPayloadToSign(domainSeparator: SignatureDomainSeparator): Buffer;
    toBuffer(): Buffer;
    equals(other: ConsensusPayload): boolean;
    static fromBuffer(buf: Buffer | BufferReader): ConsensusPayload;
    static fromFields(fields: FieldsOf<ConsensusPayload>): ConsensusPayload;
    static fromBlock(block: L2Block): ConsensusPayload;
    static empty(): ConsensusPayload;
    static random(): ConsensusPayload;
    /**
     * Get the size of the consensus payload in bytes.
     * @returns The size of the consensus payload.
     */
    getSize(): number;
    toInspect(): {
        header: {
            lastArchive: `0x${string}`;
            contentCommitment: {
                blobsHash: `0x${string}`;
                inHash: `0x${string}`;
                outHash: `0x${string}`;
            };
            slotNumber: bigint;
            timestamp: bigint;
            coinbase: `0x${string}`;
            feeRecipient: `0x${string}`;
            gasFees: {
                feePerDaGas: bigint;
                feePerL2Gas: bigint;
            };
            totalManaUsed: bigint;
        };
        archive: `0x${string}`;
        stateReference: {
            l1ToL2MessageTree: `0x${string}`;
            noteHashTree: `0x${string}`;
            nullifierTree: `0x${string}`;
            publicDataTree: `0x${string}`;
        };
    };
    toString(): string;
}
//# sourceMappingURL=consensus_payload.d.ts.map