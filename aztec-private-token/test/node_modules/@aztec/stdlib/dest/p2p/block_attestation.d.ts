import { Buffer32 } from '@aztec/foundation/buffer';
import type { EthAddress } from '@aztec/foundation/eth-address';
import { Signature } from '@aztec/foundation/eth-signature';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import type { ZodFor } from '../schemas/index.js';
import { ConsensusPayload } from './consensus_payload.js';
import { Gossipable } from './gossipable.js';
import { TopicType } from './topic_type.js';
export declare class BlockAttestationHash extends Buffer32 {
    constructor(hash: Buffer);
}
/**
 * BlockAttestation
 *
 * A validator that has attested to seeing the contents of a block
 * will produce a block attestation over the header of the block
 */
export declare class BlockAttestation extends Gossipable {
    /** The payload of the message, and what the signature is over */
    readonly payload: ConsensusPayload;
    /** The signature of the block attester */
    readonly signature: Signature;
    /** The signature from the block proposer */
    readonly proposerSignature: Signature;
    static p2pTopic: TopicType;
    private sender;
    private proposer;
    constructor(
    /** The payload of the message, and what the signature is over */
    payload: ConsensusPayload, 
    /** The signature of the block attester */
    signature: Signature, 
    /** The signature from the block proposer */
    proposerSignature: Signature);
    static get schema(): ZodFor<BlockAttestation>;
    generateP2PMessageIdentifier(): Promise<Buffer32>;
    get archive(): Fr;
    get slotNumber(): Fr;
    /**
     * Lazily evaluate and cache the signer of the attestation
     * @returns The signer of the attestation, or undefined if signature recovery fails
     */
    getSender(): EthAddress | undefined;
    /**
     * Lazily evaluate and cache the proposer of the block
     * @returns The proposer of the block
     */
    getProposer(): EthAddress | undefined;
    getPayload(): Buffer;
    toBuffer(): Buffer;
    static fromBuffer(buf: Buffer | BufferReader): BlockAttestation;
    static empty(): BlockAttestation;
    static random(): BlockAttestation;
    getSize(): number;
    toInspect(): {
        payload: {
            header: {
                lastArchive: `0x${string}`;
                contentCommitment: {
                    blobsHash: `0x${string}`;
                    inHash: `0x${string}`;
                    outHash: `0x${string}`;
                };
                slotNumber: bigint;
                timestamp: bigint;
                coinbase: `0x${string}`;
                feeRecipient: `0x${string}`;
                gasFees: {
                    feePerDaGas: bigint;
                    feePerL2Gas: bigint;
                };
                totalManaUsed: bigint;
            };
            archive: `0x${string}`;
            stateReference: {
                l1ToL2MessageTree: `0x${string}`;
                noteHashTree: `0x${string}`;
                nullifierTree: `0x${string}`;
                publicDataTree: `0x${string}`;
            };
        };
        signature: `0x${string}`;
        proposerSignature: `0x${string}`;
    };
}
//# sourceMappingURL=block_attestation.d.ts.map