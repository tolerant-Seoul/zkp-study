import { Fr } from '@aztec/foundation/fields';
import { schemas } from '@aztec/foundation/schemas';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { hexToBuffer } from '@aztec/foundation/string';
import { encodeAbiParameters, parseAbiParameters } from 'viem';
import { z } from 'zod';
import { ProposedBlockHeader, StateReference } from '../tx/index.js';
export class ConsensusPayload {
    header;
    archive;
    stateReference;
    size;
    constructor(/** The proposed block header the attestation is made over */ header, /** The archive root after the block is added */ archive, /** The state reference after the block is added */ stateReference){
        this.header = header;
        this.archive = archive;
        this.stateReference = stateReference;
    }
    static get schema() {
        return z.object({
            header: ProposedBlockHeader.schema,
            archive: schemas.Fr,
            stateReference: StateReference.schema
        }).transform((obj)=>new ConsensusPayload(obj.header, obj.archive, obj.stateReference));
    }
    static getFields(fields) {
        return [
            fields.header,
            fields.archive,
            fields.stateReference
        ];
    }
    getPayloadToSign(domainSeparator) {
        const abi = parseAbiParameters('uint8, ' + //domainSeperator
        '(' + 'bytes32, ' + // archive
        '((bytes32,uint32),((bytes32,uint32),(bytes32,uint32),(bytes32,uint32))), ' + // stateReference
        '(int256), ' + // oracleInput
        'bytes32' + // headerHash
        ')');
        const archiveRoot = this.archive.toString();
        const stateReference = this.stateReference.toAbi();
        const headerHash = this.header.hash().toString();
        const encodedData = encodeAbiParameters(abi, [
            domainSeparator,
            [
                archiveRoot,
                stateReference,
                [
                    0n
                ],
                headerHash
            ]
        ]);
        return hexToBuffer(encodedData);
    }
    toBuffer() {
        return serializeToBuffer([
            this.header,
            this.archive,
            this.stateReference
        ]);
    }
    equals(other) {
        return this.header.equals(other.header) && this.archive.equals(other.archive) && this.stateReference.equals(other.stateReference);
    }
    static fromBuffer(buf) {
        const reader = BufferReader.asReader(buf);
        const payload = new ConsensusPayload(reader.readObject(ProposedBlockHeader), reader.readObject(Fr), reader.readObject(StateReference));
        return payload;
    }
    static fromFields(fields) {
        return new ConsensusPayload(fields.header, fields.archive, fields.stateReference);
    }
    static fromBlock(block) {
        return new ConsensusPayload(block.header.toPropose(), block.archive.root, block.header.state);
    }
    static empty() {
        return new ConsensusPayload(ProposedBlockHeader.empty(), Fr.ZERO, StateReference.empty());
    }
    static random() {
        return new ConsensusPayload(ProposedBlockHeader.random(), Fr.random(), StateReference.random());
    }
    /**
   * Get the size of the consensus payload in bytes.
   * @returns The size of the consensus payload.
   */ getSize() {
        // We cache size to avoid recalculating it
        if (this.size) {
            return this.size;
        }
        this.size = this.toBuffer().length;
        return this.size;
    }
    toInspect() {
        return {
            header: this.header.toInspect(),
            archive: this.archive.toString(),
            stateReference: this.stateReference.toInspect()
        };
    }
    toString() {
        return `header: ${this.header.toString()}, archive: ${this.archive.toString()}, stateReference: ${this.stateReference.l1ToL2MessageTree.root.toString()}`;
    }
}
