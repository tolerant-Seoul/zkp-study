import { Buffer32 } from '@aztec/foundation/buffer';
import { keccak256, tryRecoverAddress } from '@aztec/foundation/crypto';
import { Signature } from '@aztec/foundation/eth-signature';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { z } from 'zod';
import { ConsensusPayload } from './consensus_payload.js';
import { Gossipable } from './gossipable.js';
import { SignatureDomainSeparator, getHashedSignaturePayloadEthSignedMessage } from './signature_utils.js';
import { TopicType } from './topic_type.js';
export class BlockAttestationHash extends Buffer32 {
    constructor(hash){
        super(hash);
    }
}
/**
 * BlockAttestation
 *
 * A validator that has attested to seeing the contents of a block
 * will produce a block attestation over the header of the block
 */ export class BlockAttestation extends Gossipable {
    payload;
    signature;
    proposerSignature;
    static p2pTopic = TopicType.block_attestation;
    sender;
    proposer;
    constructor(/** The payload of the message, and what the signature is over */ payload, /** The signature of the block attester */ signature, /** The signature from the block proposer */ proposerSignature){
        super(), this.payload = payload, this.signature = signature, this.proposerSignature = proposerSignature;
    }
    static get schema() {
        return z.object({
            payload: ConsensusPayload.schema,
            signature: Signature.schema,
            proposerSignature: Signature.schema
        }).transform((obj)=>new BlockAttestation(obj.payload, obj.signature, obj.proposerSignature));
    }
    generateP2PMessageIdentifier() {
        return Promise.resolve(new BlockAttestationHash(keccak256(this.signature.toBuffer())));
    }
    get archive() {
        return this.payload.archive;
    }
    get slotNumber() {
        return this.payload.header.slotNumber;
    }
    /**
   * Lazily evaluate and cache the signer of the attestation
   * @returns The signer of the attestation, or undefined if signature recovery fails
   */ getSender() {
        if (!this.sender) {
            // Recover the sender from the attestation
            const hashed = getHashedSignaturePayloadEthSignedMessage(this.payload, SignatureDomainSeparator.blockAttestation);
            // Cache the sender for later use
            this.sender = tryRecoverAddress(hashed, this.signature);
        }
        return this.sender;
    }
    /**
   * Lazily evaluate and cache the proposer of the block
   * @returns The proposer of the block
   */ getProposer() {
        if (!this.proposer) {
            // Recover the proposer from the proposal signature
            const hashed = getHashedSignaturePayloadEthSignedMessage(this.payload, SignatureDomainSeparator.blockProposal);
            // Cache the proposer for later use
            this.proposer = tryRecoverAddress(hashed, this.proposerSignature);
        }
        return this.proposer;
    }
    getPayload() {
        return this.payload.getPayloadToSign(SignatureDomainSeparator.blockAttestation);
    }
    toBuffer() {
        return serializeToBuffer([
            this.payload,
            this.signature,
            this.proposerSignature
        ]);
    }
    static fromBuffer(buf) {
        const reader = BufferReader.asReader(buf);
        return new BlockAttestation(reader.readObject(ConsensusPayload), reader.readObject(Signature), reader.readObject(Signature));
    }
    static empty() {
        return new BlockAttestation(ConsensusPayload.empty(), Signature.empty(), Signature.empty());
    }
    static random() {
        return new BlockAttestation(ConsensusPayload.random(), Signature.random(), Signature.random());
    }
    getSize() {
        return this.payload.getSize() + this.signature.getSize() + this.proposerSignature.getSize();
    }
    toInspect() {
        return {
            payload: this.payload.toInspect(),
            signature: this.signature.toString(),
            proposerSignature: this.proposerSignature.toString()
        };
    }
}
