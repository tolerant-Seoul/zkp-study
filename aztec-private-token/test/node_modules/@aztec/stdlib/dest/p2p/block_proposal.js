import { Buffer32 } from '@aztec/foundation/buffer';
import { keccak256, tryRecoverAddress } from '@aztec/foundation/crypto';
import { Signature } from '@aztec/foundation/eth-signature';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { TxHash } from '../tx/index.js';
import { Tx } from '../tx/tx.js';
import { ConsensusPayload } from './consensus_payload.js';
import { Gossipable } from './gossipable.js';
import { SignatureDomainSeparator, getHashedSignaturePayload, getHashedSignaturePayloadEthSignedMessage } from './signature_utils.js';
import { TopicType } from './topic_type.js';
export class BlockProposalHash extends Buffer32 {
    constructor(hash){
        super(hash);
    }
}
/**
 * BlockProposal
 *
 * A block proposal is created by the leader of the chain proposing a sequence of transactions to
 * be included in the head of the chain
 */ export class BlockProposal extends Gossipable {
    payload;
    signature;
    txHashes;
    txs;
    static p2pTopic = TopicType.block_proposal;
    sender;
    constructor(/** The payload of the message, and what the signature is over */ payload, /** The signer of the BlockProposal over the header of the new block*/ signature, /** The sequence of transactions in the block */ txHashes, // Note(md): this is placed after the txs payload in order to be backwards compatible with previous versions
    /** The transactions in the block */ txs){
        super(), this.payload = payload, this.signature = signature, this.txHashes = txHashes, this.txs = txs;
    }
    generateP2PMessageIdentifier() {
        return Promise.resolve(new BlockProposalHash(keccak256(this.signature.toBuffer())));
    }
    get archive() {
        return this.payload.archive;
    }
    get slotNumber() {
        return this.payload.header.slotNumber;
    }
    toBlockInfo() {
        return {
            slotNumber: this.slotNumber.toNumber(),
            lastArchive: this.payload.header.lastArchiveRoot,
            timestamp: this.payload.header.timestamp,
            archive: this.archive,
            txCount: this.txHashes.length
        };
    }
    static async createProposalFromSigner(payload, txHashes, // Note(md): Provided separately to tx hashes such that this function can be optional
    txs, payloadSigner) {
        const hashed = getHashedSignaturePayload(payload, SignatureDomainSeparator.blockProposal);
        const sig = await payloadSigner(hashed);
        return new BlockProposal(payload, sig, txHashes, txs);
    }
    /**Get Sender
   * Lazily evaluate the sender of the proposal; result is cached
   * @returns The sender address, or undefined if signature recovery fails
   */ getSender() {
        if (!this.sender) {
            const hashed = getHashedSignaturePayloadEthSignedMessage(this.payload, SignatureDomainSeparator.blockProposal);
            // Cache the sender for later use
            this.sender = tryRecoverAddress(hashed, this.signature);
        }
        return this.sender;
    }
    getPayload() {
        return this.payload.getPayloadToSign(SignatureDomainSeparator.blockProposal);
    }
    toBuffer() {
        const buffer = [
            this.payload,
            this.signature,
            this.txHashes.length,
            this.txHashes
        ];
        if (this.txs) {
            buffer.push(this.txs.length);
            buffer.push(this.txs);
        }
        return serializeToBuffer(buffer);
    }
    static fromBuffer(buf) {
        const reader = BufferReader.asReader(buf);
        const payload = reader.readObject(ConsensusPayload);
        const sig = reader.readObject(Signature);
        const txHashes = reader.readArray(reader.readNumber(), TxHash);
        if (!reader.isEmpty()) {
            const txs = reader.readArray(reader.readNumber(), Tx);
            return new BlockProposal(payload, sig, txHashes, txs);
        }
        return new BlockProposal(payload, sig, txHashes);
    }
    getSize() {
        return this.payload.getSize() + this.signature.getSize() + 4 /* txHashes.length */  + this.txHashes.length * TxHash.SIZE + (this.txs ? 4 /* txs.length */  + this.txs.reduce((acc, tx)=>acc + tx.getSize(), 0) : 0);
    }
}
