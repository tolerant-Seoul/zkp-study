import type { SecretValue } from '@aztec/foundation/config';
import type { EthAddress } from '@aztec/foundation/eth-address';
import type { Signature } from '@aztec/foundation/eth-signature';
import { Fr } from '@aztec/foundation/fields';
import { type ZodFor } from '@aztec/foundation/schemas';
import type { SequencerConfig, SlasherConfig } from '@aztec/stdlib/interfaces/server';
import type { BlockAttestation, BlockProposal, BlockProposalOptions } from '@aztec/stdlib/p2p';
import type { ProposedBlockHeader, StateReference, Tx } from '@aztec/stdlib/tx';
import type { PeerId } from '@libp2p/interface';
import { z } from 'zod';
import type { CommitteeAttestationsAndSigners } from '../block/index.js';
/**
 * Validator client configuration
 */
export interface ValidatorClientConfig {
    /** The private keys of the validators participating in attestation duties */
    validatorPrivateKeys?: SecretValue<`0x${string}`[]>;
    /** The addresses of the validators to use with remote signers */
    validatorAddresses?: EthAddress[];
    /** Do not run the validator */
    disableValidator: boolean;
    /** Temporarily disable these specific validator addresses */
    disabledValidators: EthAddress[];
    /** Interval between polling for new attestations from peers */
    attestationPollingIntervalMs: number;
    /** Whether to re-execute transactions in a block proposal before attesting */
    validatorReexecute: boolean;
    /** Will re-execute until this many milliseconds are left in the slot */
    validatorReexecuteDeadlineMs: number;
    /** Whether to always reexecute block proposals, even for non-validator nodes or when out of the currnet committee */
    alwaysReexecuteBlockProposals?: boolean;
    /** Whether to run in fisherman mode: validates all proposals and attestations but does not broadcast attestations or participate in consensus */
    fishermanMode?: boolean;
}
export type ValidatorClientFullConfig = ValidatorClientConfig & Pick<SequencerConfig, 'txPublicSetupAllowList'> & Pick<SlasherConfig, 'slashBroadcastedInvalidBlockPenalty'> & {
    /**
     * Whether transactions are disabled for this node
     * @remarks This should match the property in P2PConfig. It's not picked from there to avoid circular dependencies.
     */
    disableTransactions?: boolean;
};
export declare const ValidatorClientConfigSchema: z.ZodObject<{
    validatorAddresses: z.ZodOptional<z.ZodArray<z.ZodType<EthAddress, any, string>, "many">>;
    disableValidator: z.ZodBoolean;
    disabledValidators: z.ZodArray<z.ZodType<EthAddress, any, string>, "many">;
    attestationPollingIntervalMs: z.ZodNumber;
    validatorReexecute: z.ZodBoolean;
    validatorReexecuteDeadlineMs: z.ZodNumber;
    alwaysReexecuteBlockProposals: z.ZodOptional<z.ZodBoolean>;
    fishermanMode: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    disableValidator: boolean;
    disabledValidators: EthAddress[];
    attestationPollingIntervalMs: number;
    validatorReexecute: boolean;
    validatorReexecuteDeadlineMs: number;
    fishermanMode?: boolean | undefined;
    validatorAddresses?: EthAddress[] | undefined;
    alwaysReexecuteBlockProposals?: boolean | undefined;
}, {
    disableValidator: boolean;
    disabledValidators: string[];
    attestationPollingIntervalMs: number;
    validatorReexecute: boolean;
    validatorReexecuteDeadlineMs: number;
    fishermanMode?: boolean | undefined;
    validatorAddresses?: string[] | undefined;
    alwaysReexecuteBlockProposals?: boolean | undefined;
}>;
export declare const ValidatorClientFullConfigSchema: z.ZodObject<{
    validatorAddresses: z.ZodOptional<z.ZodArray<z.ZodType<EthAddress, any, string>, "many">>;
    disableValidator: z.ZodBoolean;
    disabledValidators: z.ZodArray<z.ZodType<EthAddress, any, string>, "many">;
    attestationPollingIntervalMs: z.ZodNumber;
    validatorReexecute: z.ZodBoolean;
    validatorReexecuteDeadlineMs: z.ZodNumber;
    alwaysReexecuteBlockProposals: z.ZodOptional<z.ZodBoolean>;
    fishermanMode: z.ZodOptional<z.ZodBoolean>;
} & {
    txPublicSetupAllowList: z.ZodOptional<z.ZodArray<z.ZodUnion<[z.ZodObject<{
        address: ZodFor<import("../aztec-address/index.js").AztecAddress>;
        selector: ZodFor<import("../abi/function_selector.js").FunctionSelector>;
    }, "strip", z.ZodTypeAny, {
        selector: import("../abi/function_selector.js").FunctionSelector;
        address: import("../aztec-address/index.js").AztecAddress;
    }, {
        selector?: any;
        address?: any;
    }>, z.ZodObject<{
        address: ZodFor<import("../aztec-address/index.js").AztecAddress>;
    }, "strip", z.ZodTypeAny, {
        address: import("../aztec-address/index.js").AztecAddress;
    }, {
        address?: any;
    }>, z.ZodObject<{
        classId: ZodFor<Fr>;
        selector: ZodFor<import("../abi/function_selector.js").FunctionSelector>;
    }, "strip", z.ZodTypeAny, {
        selector: import("../abi/function_selector.js").FunctionSelector;
        classId: Fr;
    }, {
        selector?: any;
        classId?: any;
    }>, z.ZodObject<{
        classId: ZodFor<Fr>;
    }, "strip", z.ZodTypeAny, {
        classId: Fr;
    }, {
        classId?: any;
    }>]>, "many">>;
    slashBroadcastedInvalidBlockPenalty: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>;
    disableTransactions: z.ZodOptional<z.ZodBoolean>;
}, "strip", z.ZodTypeAny, {
    slashBroadcastedInvalidBlockPenalty: bigint;
    disableValidator: boolean;
    disabledValidators: EthAddress[];
    attestationPollingIntervalMs: number;
    validatorReexecute: boolean;
    validatorReexecuteDeadlineMs: number;
    txPublicSetupAllowList?: ({
        selector: import("../abi/function_selector.js").FunctionSelector;
        address: import("../aztec-address/index.js").AztecAddress;
    } | {
        address: import("../aztec-address/index.js").AztecAddress;
    } | {
        selector: import("../abi/function_selector.js").FunctionSelector;
        classId: Fr;
    } | {
        classId: Fr;
    })[] | undefined;
    fishermanMode?: boolean | undefined;
    validatorAddresses?: EthAddress[] | undefined;
    alwaysReexecuteBlockProposals?: boolean | undefined;
    disableTransactions?: boolean | undefined;
}, {
    slashBroadcastedInvalidBlockPenalty: string | number | bigint;
    disableValidator: boolean;
    disabledValidators: string[];
    attestationPollingIntervalMs: number;
    validatorReexecute: boolean;
    validatorReexecuteDeadlineMs: number;
    txPublicSetupAllowList?: ({
        selector?: any;
        address?: any;
    } | {
        address?: any;
    } | {
        selector?: any;
        classId?: any;
    } | {
        classId?: any;
    })[] | undefined;
    fishermanMode?: boolean | undefined;
    validatorAddresses?: string[] | undefined;
    alwaysReexecuteBlockProposals?: boolean | undefined;
    disableTransactions?: boolean | undefined;
}>;
export interface Validator {
    start(): Promise<void>;
    updateConfig(config: Partial<ValidatorClientFullConfig>): void;
    createBlockProposal(blockNumber: number, header: ProposedBlockHeader, archive: Fr, stateReference: StateReference, txs: Tx[], proposerAddress: EthAddress | undefined, options: BlockProposalOptions): Promise<BlockProposal | undefined>;
    attestToProposal(proposal: BlockProposal, sender: PeerId): Promise<BlockAttestation[] | undefined>;
    broadcastBlockProposal(proposal: BlockProposal): Promise<void>;
    collectAttestations(proposal: BlockProposal, required: number, deadline: Date): Promise<BlockAttestation[]>;
    signAttestationsAndSigners(attestationsAndSigners: CommitteeAttestationsAndSigners, proposer: EthAddress): Promise<Signature>;
}
//# sourceMappingURL=validator.d.ts.map