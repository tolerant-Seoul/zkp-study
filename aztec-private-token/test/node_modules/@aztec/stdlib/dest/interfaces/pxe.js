import { L1_TO_L2_MSG_TREE_HEIGHT } from '@aztec/constants';
import { SiblingPath } from '@aztec/foundation/trees';
import { z } from 'zod';
import { AbiTypeSchema, ContractArtifactSchema } from '../abi/abi.js';
import { AuthWitness } from '../auth_witness/auth_witness.js';
import { L2Block } from '../block/l2_block.js';
import { CompleteAddress, ContractClassWithIdSchema, ContractInstanceWithAddressSchema, NodeInfoSchema, ProtocolContractAddressesSchema } from '../contract/index.js';
import { GasFees } from '../gas/gas_fees.js';
import { LogFilterSchema } from '../logs/log_filter.js';
import { UniqueNote } from '../note/extended_note.js';
import { NotesFilterSchema } from '../note/notes_filter.js';
import { AbiDecodedSchema, optional, schemas } from '../schemas/schemas.js';
import { PrivateExecutionResult, SimulationOverrides, Tx, TxExecutionRequest, TxHash, TxReceipt, TxSimulationResult, indexedTxSchema } from '../tx/index.js';
import { TxProfileResult, UtilitySimulationResult } from '../tx/profiling.js';
import { TxProvingResult } from '../tx/proven_tx.js';
import { GetContractClassLogsResponseSchema, GetPublicLogsResponseSchema } from './get_logs_response.js';
const EventMetadataDefinitionSchema = z.object({
    eventSelector: schemas.EventSelector,
    abiType: AbiTypeSchema,
    fieldNames: z.array(z.string())
});
/** This is used in getting events via the filter */ export var EventType = /*#__PURE__*/ function(EventType) {
    EventType["Encrypted"] = "Encrypted";
    EventType["Unencrypted"] = "Unencrypted";
    return EventType;
}({});
const ContractMetadataSchema = z.object({
    contractInstance: z.union([
        ContractInstanceWithAddressSchema,
        z.undefined()
    ]),
    isContractInitialized: z.boolean(),
    isContractPublished: z.boolean()
});
const ContractClassMetadataSchema = z.object({
    contractClass: z.union([
        ContractClassWithIdSchema,
        z.undefined()
    ]),
    isContractClassPubliclyRegistered: z.boolean(),
    artifact: z.union([
        ContractArtifactSchema,
        z.undefined()
    ])
});
const PXEInfoSchema = z.object({
    pxeVersion: z.string(),
    protocolContractAddresses: ProtocolContractAddressesSchema
});
export const PXESchema = {
    isL1ToL2MessageSynced: z.function().args(schemas.Fr).returns(z.boolean()),
    getL1ToL2MessageBlock: z.function().args(schemas.Fr).returns(z.number().optional()),
    registerAccount: z.function().args(schemas.Fr, schemas.Fr).returns(CompleteAddress.schema),
    getRegisteredAccounts: z.function().returns(z.array(CompleteAddress.schema)),
    registerSender: z.function().args(schemas.AztecAddress).returns(schemas.AztecAddress),
    getSenders: z.function().returns(z.array(schemas.AztecAddress)),
    removeSender: z.function().args(schemas.AztecAddress).returns(z.void()),
    registerContractClass: z.function().args(ContractArtifactSchema).returns(z.void()),
    registerContract: z.function().args(z.object({
        instance: ContractInstanceWithAddressSchema,
        artifact: z.optional(ContractArtifactSchema)
    })).returns(z.void()),
    updateContract: z.function().args(schemas.AztecAddress, ContractArtifactSchema).returns(z.void()),
    getContracts: z.function().returns(z.array(schemas.AztecAddress)),
    proveTx: z.function().args(TxExecutionRequest.schema, optional(PrivateExecutionResult.schema)).returns(TxProvingResult.schema),
    profileTx: z.function().args(TxExecutionRequest.schema, z.union([
        z.literal('gates'),
        z.literal('full'),
        z.literal('execution-steps')
    ]), optional(z.boolean()), optional(schemas.AztecAddress)).returns(TxProfileResult.schema),
    simulateTx: z.function().args(TxExecutionRequest.schema, z.boolean(), optional(z.boolean()), optional(z.boolean()), optional(SimulationOverrides.schema), optional(z.array(schemas.AztecAddress))).returns(TxSimulationResult.schema),
    sendTx: z.function().args(Tx.schema).returns(TxHash.schema),
    getTxReceipt: z.function().args(TxHash.schema).returns(TxReceipt.schema),
    getTxEffect: z.function().args(TxHash.schema).returns(indexedTxSchema().optional()),
    getPublicStorageAt: z.function().args(schemas.AztecAddress, schemas.Fr).returns(schemas.Fr),
    getNotes: z.function().args(NotesFilterSchema).returns(z.array(UniqueNote.schema)),
    getL1ToL2MembershipWitness: z.function().args(schemas.AztecAddress, schemas.Fr, schemas.Fr).returns(z.tuple([
        schemas.BigInt,
        SiblingPath.schemaFor(L1_TO_L2_MSG_TREE_HEIGHT)
    ])),
    getL2ToL1MembershipWitness: z.function().args(z.number(), schemas.Fr).returns(z.tuple([
        schemas.BigInt,
        SiblingPath.schema
    ])),
    getBlock: z.function().args(z.number()).returns(z.union([
        L2Block.schema,
        z.undefined()
    ])),
    getCurrentBaseFees: z.function().returns(GasFees.schema),
    simulateUtility: z.function().args(z.string(), z.array(z.any()), schemas.AztecAddress, optional(z.array(AuthWitness.schema)), optional(schemas.AztecAddress), optional(z.array(schemas.AztecAddress))).returns(UtilitySimulationResult.schema),
    getPublicLogs: z.function().args(LogFilterSchema).returns(GetPublicLogsResponseSchema),
    getContractClassLogs: z.function().args(LogFilterSchema).returns(GetContractClassLogsResponseSchema),
    getBlockNumber: z.function().returns(z.number()),
    getProvenBlockNumber: z.function().returns(z.number()),
    getNodeInfo: z.function().returns(NodeInfoSchema),
    getPXEInfo: z.function().returns(PXEInfoSchema),
    getContractMetadata: z.function().args(schemas.AztecAddress).returns(ContractMetadataSchema),
    getContractClassMetadata: z.function().args(schemas.Fr, optional(z.boolean())).returns(ContractClassMetadataSchema),
    getPrivateEvents: z.function().args(schemas.AztecAddress, EventMetadataDefinitionSchema, z.number(), z.number(), z.array(schemas.AztecAddress)).returns(z.array(AbiDecodedSchema)),
    getPublicEvents: z.function().args(EventMetadataDefinitionSchema, z.number(), z.number()).returns(z.array(AbiDecodedSchema))
};
