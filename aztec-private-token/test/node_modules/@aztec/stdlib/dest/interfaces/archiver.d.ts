import type { L1ContractAddresses } from '@aztec/ethereum';
import type { ApiSchemaFor } from '@aztec/foundation/schemas';
import { z } from 'zod';
import { type L2BlockSource } from '../block/l2_block_source.js';
import { type ContractDataSource } from '../contract/index.js';
import type { L1ToL2MessageSource } from '../messaging/l1_to_l2_message_source.js';
import type { L2LogsSource } from './l2_logs_source.js';
/**
 * The archiver configuration.
 */
export type ArchiverSpecificConfig = {
    /** The polling interval in ms for retrieving new L2 blocks and encrypted logs. */
    archiverPollingIntervalMS?: number;
    /** The number of L2 blocks the archiver will attempt to download at a time. */
    archiverBatchSize?: number;
    /** The polling interval viem uses in ms */
    viemPollingIntervalMS?: number;
    /** The deployed L1 contract addresses */
    l1Contracts: L1ContractAddresses;
    /** The max number of logs that can be obtained in 1 "getPublicLogs" call. */
    maxLogs?: number;
    /** The maximum possible size of the archiver DB in KB. Overwrites the general dataStoreMapSizeKb. */
    archiverStoreMapSizeKb?: number;
    /** Whether to skip validating block attestations (use only for testing). */
    skipValidateBlockAttestations?: boolean;
    /** Maximum allowed drift in seconds between the Ethereum client and current time. */
    maxAllowedEthClientDriftSeconds?: number;
};
export declare const ArchiverSpecificConfigSchema: z.ZodObject<{
    archiverPollingIntervalMS: z.ZodOptional<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>>;
    archiverBatchSize: z.ZodOptional<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>>;
    viemPollingIntervalMS: z.ZodOptional<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>>;
    maxLogs: z.ZodOptional<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>>;
    archiverStoreMapSizeKb: z.ZodOptional<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>>;
    skipValidateBlockAttestations: z.ZodOptional<z.ZodBoolean>;
    maxAllowedEthClientDriftSeconds: z.ZodOptional<z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>>;
}, "strip", z.ZodTypeAny, {
    archiverPollingIntervalMS?: number | undefined;
    archiverBatchSize?: number | undefined;
    viemPollingIntervalMS?: number | undefined;
    maxLogs?: number | undefined;
    archiverStoreMapSizeKb?: number | undefined;
    skipValidateBlockAttestations?: boolean | undefined;
    maxAllowedEthClientDriftSeconds?: number | undefined;
}, {
    archiverPollingIntervalMS?: string | number | bigint | undefined;
    archiverBatchSize?: string | number | bigint | undefined;
    viemPollingIntervalMS?: string | number | bigint | undefined;
    maxLogs?: string | number | bigint | undefined;
    archiverStoreMapSizeKb?: string | number | bigint | undefined;
    skipValidateBlockAttestations?: boolean | undefined;
    maxAllowedEthClientDriftSeconds?: string | number | bigint | undefined;
}>;
export type ArchiverApi = Omit<L2BlockSource & L2LogsSource & ContractDataSource & L1ToL2MessageSource, 'start' | 'stop'>;
export declare const ArchiverApiSchema: ApiSchemaFor<ArchiverApi>;
//# sourceMappingURL=archiver.d.ts.map