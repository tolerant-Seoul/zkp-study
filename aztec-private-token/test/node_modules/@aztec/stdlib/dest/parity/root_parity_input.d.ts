import { VK_TREE_HEIGHT } from '@aztec/constants';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, type Tuple } from '@aztec/foundation/serialize';
import type { FieldsOf } from '@aztec/foundation/types';
import { RecursiveProof } from '../proofs/recursive_proof.js';
import { VerificationKeyAsFields } from '../vks/verification_key.js';
import { ParityPublicInputs } from './parity_public_inputs.js';
export declare class RootParityInput<PROOF_LENGTH extends number> {
    /** The proof of the execution of the parity circuit. */
    readonly proof: RecursiveProof<PROOF_LENGTH>;
    /** The circuit's verification key */
    readonly verificationKey: VerificationKeyAsFields;
    /** The vk path in the vk tree*/
    readonly vkPath: Tuple<Fr, typeof VK_TREE_HEIGHT>;
    /** The public inputs of the parity circuit. */
    readonly publicInputs: ParityPublicInputs;
    constructor(
    /** The proof of the execution of the parity circuit. */
    proof: RecursiveProof<PROOF_LENGTH>, 
    /** The circuit's verification key */
    verificationKey: VerificationKeyAsFields, 
    /** The vk path in the vk tree*/
    vkPath: Tuple<Fr, typeof VK_TREE_HEIGHT>, 
    /** The public inputs of the parity circuit. */
    publicInputs: ParityPublicInputs);
    toBuffer(): Buffer<ArrayBufferLike>;
    toString(): `0x${string}`;
    static from<PROOF_LENGTH extends number>(fields: FieldsOf<RootParityInput<PROOF_LENGTH>>): RootParityInput<PROOF_LENGTH>;
    static getFields<PROOF_LENGTH extends number>(fields: FieldsOf<RootParityInput<PROOF_LENGTH>>): readonly [RecursiveProof<PROOF_LENGTH>, VerificationKeyAsFields, [Fr, Fr, Fr, Fr, Fr, Fr], ParityPublicInputs];
    static fromBuffer<PROOF_LENGTH extends number>(buffer: Buffer | BufferReader, expectedSize?: PROOF_LENGTH): RootParityInput<PROOF_LENGTH>;
    static fromString<PROOF_LENGTH extends number>(str: string, expectedSize?: PROOF_LENGTH): RootParityInput<PROOF_LENGTH>;
    /** Returns a hex representation for JSON serialization. */
    toJSON(): Buffer<ArrayBufferLike>;
    /** Creates an instance from a hex string with expected size. */
    static schemaFor<N extends number>(expectedSize?: N): import("zod").ZodEffects<import("zod").ZodUnion<[import("zod").ZodEffects<import("zod").ZodEffects<import("zod").ZodString, string, string>, Buffer<ArrayBuffer>, string>, import("zod").ZodEffects<import("zod").ZodObject<{
        type: import("zod").ZodLiteral<"Buffer">;
        data: import("zod").ZodArray<import("zod").ZodNumber, "many">;
    }, "strip", import("zod").ZodTypeAny, {
        type: "Buffer";
        data: number[];
    }, {
        type: "Buffer";
        data: number[];
    }>, Buffer<ArrayBuffer>, {
        type: "Buffer";
        data: number[];
    }>]>, RootParityInput<N>, string | {
        type: "Buffer";
        data: number[];
    }>;
}
//# sourceMappingURL=root_parity_input.d.ts.map