import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import { z } from 'zod';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { BlockHeader } from '../tx/block_header.js';
import { Body } from './body.js';
import type { L2BlockInfo } from './l2_block_info.js';
/**
 * The data that makes up the rollup proof, with encoder decoder functions.
 */
export declare class L2Block {
    /** Snapshot of archive tree after the block is applied. */
    archive: AppendOnlyTreeSnapshot;
    /** L2 block header. */
    header: BlockHeader;
    /** L2 block body. */
    body: Body;
    private blockHash;
    constructor(
    /** Snapshot of archive tree after the block is applied. */
    archive: AppendOnlyTreeSnapshot, 
    /** L2 block header. */
    header: BlockHeader, 
    /** L2 block body. */
    body: Body, blockHash?: Fr | undefined);
    static get schema(): z.ZodEffects<z.ZodObject<{
        archive: z.ZodEffects<z.ZodObject<{
            root: z.ZodType<Fr, any, string>;
            nextAvailableLeafIndex: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>;
        }, "strip", z.ZodTypeAny, {
            root: Fr;
            nextAvailableLeafIndex: number;
        }, {
            root: string;
            nextAvailableLeafIndex: string | number | bigint;
        }>, AppendOnlyTreeSnapshot, {
            root: string;
            nextAvailableLeafIndex: string | number | bigint;
        }>;
        header: import("@aztec/foundation/schemas").ZodFor<BlockHeader>;
        body: import("@aztec/foundation/schemas").ZodFor<Body>;
    }, "strip", z.ZodTypeAny, {
        archive: AppendOnlyTreeSnapshot;
        header: BlockHeader;
        body: Body;
    }, {
        archive: {
            root: string;
            nextAvailableLeafIndex: string | number | bigint;
        };
        header?: any;
        body?: any;
    }>, L2Block, {
        archive: {
            root: string;
            nextAvailableLeafIndex: string | number | bigint;
        };
        header?: any;
        body?: any;
    }>;
    /**
     * Deserializes a block from a buffer
     * @returns A deserialized L2 block.
     */
    static fromBuffer(buf: Buffer | BufferReader): L2Block;
    /**
     * Serializes a block
     * @returns A serialized L2 block as a Buffer.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Deserializes L2 block from a buffer.
     * @param str - A serialized L2 block.
     * @returns Deserialized L2 block.
     */
    static fromString(str: string): L2Block;
    /**
     * Serializes a block to a string.
     * @returns A serialized L2 block as a string.
     */
    toString(): string;
    /**
     * Creates an L2 block containing random data.
     * @param l2BlockNum - The number of the L2 block.
     * @param txsPerBlock - The number of transactions to include in the block.
     * @param numPublicCallsPerTx - The number of public function calls to include in each transaction.
     * @param numPublicLogsPerCall - The number of public logs per 1 public function invocation.
     * @param inHash - The hash of the L1 to L2 messages subtree which got inserted in this block.
     * @returns The L2 block.
     */
    static random(l2BlockNum: number, txsPerBlock?: number, numPublicCallsPerTx?: number, numPublicLogsPerCall?: number, inHash?: Fr | undefined, slotNumber?: number | undefined, maxEffects?: number | undefined): Promise<L2Block>;
    /**
     * Creates an L2 block containing empty data.
     * @returns The L2 block.
     */
    static empty(): L2Block;
    get number(): number;
    get slot(): bigint;
    get timestamp(): bigint;
    /**
     * Returns the block's hash (hash of block header).
     * @returns The block's hash.
     */
    hash(): Promise<Fr>;
    /**
     * Returns stats used for logging.
     * @returns Stats on tx count, number, and log size and count.
     */
    getStats(): {
        privateLogCount: number;
        publicLogCount: number;
        contractClassLogCount: number;
        contractClassLogSize: number;
        txCount: number;
        blockNumber: number;
        blockTimestamp: number;
    };
    toBlockInfo(): L2BlockInfo;
    equals(other: L2Block): boolean;
}
//# sourceMappingURL=l2_block.d.ts.map