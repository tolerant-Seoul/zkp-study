// Ignoring import issue to fix portable inferred type issue in zod schema
import { Buffer32 } from '@aztec/foundation/buffer';
import { randomBigInt } from '@aztec/foundation/crypto';
import { schemas } from '@aztec/foundation/schemas';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { z } from 'zod';
import { L2Block } from './l2_block.js';
import { CommitteeAttestation } from './proposal/committee_attestation.js';
export class L1PublishedData {
    blockNumber;
    timestamp;
    blockHash;
    constructor(blockNumber, timestamp, blockHash){
        this.blockNumber = blockNumber;
        this.timestamp = timestamp;
        this.blockHash = blockHash;
    }
    static get schema() {
        return z.object({
            blockNumber: schemas.BigInt,
            timestamp: schemas.BigInt,
            blockHash: z.string()
        });
    }
    static random() {
        return new L1PublishedData(randomBigInt(1000n) + 1n, BigInt(Math.floor(Date.now() / 1000)), Buffer32.random().toString());
    }
    static fromFields(fields) {
        return new L1PublishedData(fields.blockNumber, fields.timestamp, fields.blockHash);
    }
}
export class PublishedL2Block {
    block;
    l1;
    attestations;
    constructor(block, l1, attestations){
        this.block = block;
        this.l1 = l1;
        this.attestations = attestations;
    }
    static get schema() {
        return z.object({
            block: L2Block.schema,
            l1: L1PublishedData.schema,
            attestations: z.array(CommitteeAttestation.schema)
        }).transform((obj)=>PublishedL2Block.fromFields(obj));
    }
    static fromBuffer(bufferOrReader) {
        const reader = BufferReader.asReader(bufferOrReader);
        const block = reader.readObject(L2Block);
        const l1BlockNumber = reader.readBigInt();
        const l1BlockHash = reader.readString();
        const l1Timestamp = reader.readBigInt();
        const attestations = reader.readVector(CommitteeAttestation);
        return new PublishedL2Block(block, new L1PublishedData(l1BlockNumber, l1Timestamp, l1BlockHash), attestations);
    }
    static fromFields(fields) {
        return new PublishedL2Block(fields.block, fields.l1, fields.attestations);
    }
    toBuffer() {
        return serializeToBuffer(this.block, this.l1.blockNumber, this.l1.blockHash, this.l1.timestamp, this.attestations.length, this.attestations);
    }
}
