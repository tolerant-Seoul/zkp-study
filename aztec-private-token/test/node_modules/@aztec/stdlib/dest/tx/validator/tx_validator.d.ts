import { z } from 'zod';
import type { ProcessedTx } from '../processed_tx.js';
import type { Tx } from '../tx.js';
import type { TxHash } from '../tx_hash.js';
export type AnyTx = Tx | ProcessedTx;
export declare function getTxHash(tx: AnyTx): TxHash;
export declare function hasPublicCalls(tx: AnyTx): boolean;
export type TxValidationResult = {
    result: 'valid';
} | {
    result: 'invalid';
    reason: string[];
} | {
    result: 'skipped';
    reason: string[];
};
export interface TxValidator<T extends AnyTx = AnyTx> {
    validateTx(tx: T): Promise<TxValidationResult>;
}
export declare const TxValidationResultSchema: z.ZodDiscriminatedUnion<"result", [z.ZodObject<{
    result: z.ZodLiteral<"valid">;
    reason: z.ZodOptional<z.ZodArray<z.ZodString, "many">>;
}, "strip", z.ZodTypeAny, {
    result: "valid";
    reason?: string[] | undefined;
}, {
    result: "valid";
    reason?: string[] | undefined;
}>, z.ZodObject<{
    result: z.ZodLiteral<"invalid">;
    reason: z.ZodArray<z.ZodString, "many">;
}, "strip", z.ZodTypeAny, {
    reason: string[];
    result: "invalid";
}, {
    reason: string[];
    result: "invalid";
}>, z.ZodObject<{
    result: z.ZodLiteral<"skipped">;
    reason: z.ZodArray<z.ZodString, "many">;
}, "strip", z.ZodTypeAny, {
    reason: string[];
    result: "skipped";
}, {
    reason: string[];
    result: "skipped";
}>]>;
//# sourceMappingURL=tx_validator.d.ts.map