import { Fr } from '@aztec/foundation/fields';
import { type ZodFor } from '@aztec/foundation/schemas';
import { BufferReader, FieldReader } from '@aztec/foundation/serialize';
import type { FieldsOf } from '@aztec/foundation/types';
import { inspect } from 'util';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { ContentCommitment } from './content_commitment.js';
import { GlobalVariables } from './global_variables.js';
import { ProposedBlockHeader } from './proposed_block_header.js';
import { StateReference } from './state_reference.js';
/** A header of an L2 block. */
export declare class BlockHeader {
    /** Snapshot of archive before the block is applied. */
    lastArchive: AppendOnlyTreeSnapshot;
    /** Hash of the body of an L2 block. */
    contentCommitment: ContentCommitment;
    /** State reference. */
    state: StateReference;
    /** Global variables of an L2 block. */
    globalVariables: GlobalVariables;
    /** Total fees in the block, computed by the root rollup circuit */
    totalFees: Fr;
    /** Total mana used in the block, computed by the root rollup circuit */
    totalManaUsed: Fr;
    constructor(
    /** Snapshot of archive before the block is applied. */
    lastArchive: AppendOnlyTreeSnapshot, 
    /** Hash of the body of an L2 block. */
    contentCommitment: ContentCommitment, 
    /** State reference. */
    state: StateReference, 
    /** Global variables of an L2 block. */
    globalVariables: GlobalVariables, 
    /** Total fees in the block, computed by the root rollup circuit */
    totalFees: Fr, 
    /** Total mana used in the block, computed by the root rollup circuit */
    totalManaUsed: Fr);
    static get schema(): ZodFor<BlockHeader>;
    static getFields(fields: FieldsOf<BlockHeader>): readonly [AppendOnlyTreeSnapshot, ContentCommitment, StateReference, GlobalVariables, Fr, Fr];
    static from(fields: FieldsOf<BlockHeader>): BlockHeader;
    getSlot(): bigint;
    getBlockNumber(): number;
    getSize(): number;
    toBuffer(): Buffer<ArrayBufferLike>;
    toFields(): Fr[];
    clone(): BlockHeader;
    static fromBuffer(buffer: Buffer | BufferReader): BlockHeader;
    static fromFields(fields: Fr[] | FieldReader): BlockHeader;
    static empty(fields?: Partial<FieldsOf<BlockHeader>>): BlockHeader;
    isEmpty(): boolean;
    /**
     * Serializes this instance into a string.
     * @returns Encoded string.
     */
    toString(): `0x${string}`;
    static fromString(str: string): BlockHeader;
    hash(): Promise<Fr>;
    toPropose(): ProposedBlockHeader;
    toInspect(): {
        lastArchive: `0x${string}`;
        contentCommitment: {
            blobsHash: `0x${string}`;
            inHash: `0x${string}`;
            outHash: `0x${string}`;
        };
        state: {
            l1ToL2MessageTree: `0x${string}`;
            noteHashTree: `0x${string}`;
            nullifierTree: `0x${string}`;
            publicDataTree: `0x${string}`;
        };
        globalVariables: {
            chainId: number;
            version: number;
            blockNumber: number;
            slotNumber: number;
            timestamp: bigint;
            coinbase: `0x${string}`;
            feeRecipient: `0x${string}`;
            feePerDaGas: number;
            feePerL2Gas: number;
        };
        totalFees: bigint;
        totalManaUsed: bigint;
    };
    [inspect.custom](): string;
    equals(other: this): boolean;
}
//# sourceMappingURL=block_header.d.ts.map