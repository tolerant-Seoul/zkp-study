import { sha256ToField } from '@aztec/foundation/crypto';
import { EthAddress } from '@aztec/foundation/eth-address';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, bigintToUInt64BE, serializeToBuffer } from '@aztec/foundation/serialize';
import { bufferToHex, hexToBuffer } from '@aztec/foundation/string';
import { inspect } from 'util';
import { z } from 'zod';
import { AztecAddress } from '../aztec-address/index.js';
import { GasFees } from '../gas/index.js';
import { schemas } from '../schemas/index.js';
import { ContentCommitment } from './content_commitment.js';
/** The proposed values of an L2 block. */ export class ProposedBlockHeader {
    lastArchiveRoot;
    contentCommitment;
    slotNumber;
    timestamp;
    coinbase;
    feeRecipient;
    gasFees;
    totalManaUsed;
    constructor(/** Root of the archive tree before this block is added. */ lastArchiveRoot, /** Content commitment of the L2 block. */ contentCommitment, /** Slot number of the L2 block */ slotNumber, /** Timestamp of the L2 block. */ timestamp, /** Recipient of block reward. */ coinbase, /** Address to receive fees. */ feeRecipient, /** Global gas prices for this block. */ gasFees, /** Total mana used in the block, computed by the root rollup circuit */ totalManaUsed){
        this.lastArchiveRoot = lastArchiveRoot;
        this.contentCommitment = contentCommitment;
        this.slotNumber = slotNumber;
        this.timestamp = timestamp;
        this.coinbase = coinbase;
        this.feeRecipient = feeRecipient;
        this.gasFees = gasFees;
        this.totalManaUsed = totalManaUsed;
    }
    static get schema() {
        return z.object({
            lastArchiveRoot: schemas.Fr,
            contentCommitment: ContentCommitment.schema,
            slotNumber: schemas.Fr,
            timestamp: schemas.BigInt,
            coinbase: schemas.EthAddress,
            feeRecipient: schemas.AztecAddress,
            gasFees: GasFees.schema,
            totalManaUsed: schemas.Fr
        }).transform(ProposedBlockHeader.from);
    }
    static getFields(fields) {
        return [
            fields.lastArchiveRoot,
            fields.contentCommitment,
            fields.slotNumber,
            fields.timestamp,
            fields.coinbase,
            fields.feeRecipient,
            fields.gasFees,
            fields.totalManaUsed
        ];
    }
    static from(fields) {
        return new ProposedBlockHeader(...ProposedBlockHeader.getFields(fields));
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new ProposedBlockHeader(reader.readObject(Fr), reader.readObject(ContentCommitment), Fr.fromBuffer(reader), reader.readUInt64(), reader.readObject(EthAddress), reader.readObject(AztecAddress), reader.readObject(GasFees), reader.readObject(Fr));
    }
    equals(other) {
        return this.lastArchiveRoot.equals(other.lastArchiveRoot) && this.contentCommitment.equals(other.contentCommitment) && this.slotNumber.equals(other.slotNumber) && this.timestamp === other.timestamp && this.coinbase.equals(other.coinbase) && this.feeRecipient.equals(other.feeRecipient) && this.gasFees.equals(other.gasFees) && this.totalManaUsed.equals(other.totalManaUsed);
    }
    toBuffer() {
        // Note: The order here must match the order in the ProposedHeaderLib solidity library.
        return serializeToBuffer([
            this.lastArchiveRoot,
            this.contentCommitment,
            this.slotNumber,
            bigintToUInt64BE(this.timestamp),
            this.coinbase,
            this.feeRecipient,
            this.gasFees,
            this.totalManaUsed
        ]);
    }
    hash() {
        return sha256ToField([
            this.toBuffer()
        ]);
    }
    static empty(fields = {}) {
        return ProposedBlockHeader.from({
            lastArchiveRoot: Fr.ZERO,
            contentCommitment: ContentCommitment.empty(),
            slotNumber: Fr.ZERO,
            timestamp: 0n,
            coinbase: EthAddress.ZERO,
            feeRecipient: AztecAddress.ZERO,
            gasFees: GasFees.empty(),
            totalManaUsed: Fr.ZERO,
            ...fields
        });
    }
    static random() {
        return new ProposedBlockHeader(Fr.random(), ContentCommitment.random(), new Fr(BigInt(Math.floor(Math.random() * 1000) + 1)), BigInt(Math.floor(Date.now() / 1000)), EthAddress.random(), new AztecAddress(Fr.random()), GasFees.random(), new Fr(BigInt(Math.floor(Math.random() * 1000000))));
    }
    isEmpty() {
        return this.lastArchiveRoot.isZero() && this.contentCommitment.isEmpty() && this.slotNumber.isZero() && this.timestamp === 0n && this.coinbase.isZero() && this.feeRecipient.isZero() && this.gasFees.isEmpty() && this.totalManaUsed.isZero();
    }
    /**
   * Serializes this instance into a string.
   * @returns Encoded string.
   */ toString() {
        return bufferToHex(this.toBuffer());
    }
    static fromString(str) {
        return ProposedBlockHeader.fromBuffer(hexToBuffer(str));
    }
    static fromViem(header) {
        return new ProposedBlockHeader(Fr.fromString(header.lastArchiveRoot), ContentCommitment.fromViem(header.contentCommitment), new Fr(header.slotNumber), header.timestamp, new EthAddress(hexToBuffer(header.coinbase)), new AztecAddress(hexToBuffer(header.feeRecipient)), new GasFees(header.gasFees.feePerDaGas, header.gasFees.feePerL2Gas), new Fr(header.totalManaUsed));
    }
    toViem() {
        return {
            lastArchiveRoot: this.lastArchiveRoot.toString(),
            contentCommitment: this.contentCommitment.toViem(),
            slotNumber: this.slotNumber.toBigInt(),
            timestamp: this.timestamp,
            coinbase: this.coinbase.toString(),
            feeRecipient: `0x${this.feeRecipient.toBuffer().toString('hex').padStart(64, '0')}`,
            gasFees: {
                feePerDaGas: this.gasFees.feePerDaGas,
                feePerL2Gas: this.gasFees.feePerL2Gas
            },
            totalManaUsed: this.totalManaUsed.toBigInt()
        };
    }
    toInspect() {
        return {
            lastArchive: this.lastArchiveRoot.toString(),
            contentCommitment: this.contentCommitment.toInspect(),
            slotNumber: this.slotNumber.toBigInt(),
            timestamp: this.timestamp,
            coinbase: this.coinbase.toString(),
            feeRecipient: this.feeRecipient.toString(),
            gasFees: this.gasFees.toInspect(),
            totalManaUsed: this.totalManaUsed.toBigInt()
        };
    }
    [inspect.custom]() {
        const gasfees = `da:${this.gasFees.feePerDaGas}, l2:${this.gasFees.feePerL2Gas}`;
        return `Header {
  lastArchiveRoot: ${this.lastArchiveRoot.toString()},
  contentCommitment: ${inspect(this.contentCommitment)},
  slotNumber: ${this.slotNumber.toBigInt()},
  timestamp: ${this.timestamp},
  coinbase: ${this.coinbase.toString()},
  feeRecipient: ${this.feeRecipient.toString()},
  gasFees: ${gasfees},
  totalManaUsed: ${this.totalManaUsed.toBigInt()},
}`;
    }
}
