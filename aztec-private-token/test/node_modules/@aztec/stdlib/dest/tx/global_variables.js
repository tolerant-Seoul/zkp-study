import { GLOBAL_VARIABLES_LENGTH } from '@aztec/constants';
import { EthAddress } from '@aztec/foundation/eth-address';
import { Fr } from '@aztec/foundation/fields';
import { jsonStringify } from '@aztec/foundation/json-rpc';
import { BufferReader, FieldReader, bigintToUInt64BE, serializeToBuffer, serializeToFields } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { z } from 'zod';
import { AztecAddress } from '../aztec-address/index.js';
import { GasFees } from '../gas/gas_fees.js';
import { schemas } from '../schemas/index.js';
/**
 * Global variables of the L2 block.
 */ export class GlobalVariables {
    chainId;
    version;
    blockNumber;
    slotNumber;
    timestamp;
    coinbase;
    feeRecipient;
    gasFees;
    constructor(/** ChainId for the L2 block. */ chainId, /** Version for the L2 block. */ version, /** Block number of the L2 block. */ blockNumber, /** Slot number of the L2 block */ slotNumber, /** Timestamp of the L2 block. */ timestamp, /** Recipient of block reward. */ coinbase, /** Address to receive fees. */ feeRecipient, /** Global gas prices for this block. */ gasFees){
        this.chainId = chainId;
        this.version = version;
        this.blockNumber = blockNumber;
        this.slotNumber = slotNumber;
        this.timestamp = timestamp;
        this.coinbase = coinbase;
        this.feeRecipient = feeRecipient;
        this.gasFees = gasFees;
    }
    static get schema() {
        return z.object({
            chainId: schemas.Fr,
            version: schemas.Fr,
            blockNumber: schemas.UInt32,
            slotNumber: schemas.Fr,
            timestamp: schemas.BigInt,
            coinbase: schemas.EthAddress,
            feeRecipient: schemas.AztecAddress,
            gasFees: GasFees.schema
        }).transform(GlobalVariables.from);
    }
    getSize() {
        return this.toBuffer().length;
    }
    static from(fields) {
        return new GlobalVariables(...GlobalVariables.getFields(fields));
    }
    static empty(fields = {}) {
        return GlobalVariables.from({
            blockNumber: 0,
            slotNumber: Fr.ZERO,
            timestamp: 0n,
            chainId: Fr.ZERO,
            version: Fr.ZERO,
            coinbase: EthAddress.ZERO,
            feeRecipient: AztecAddress.ZERO,
            gasFees: GasFees.empty(),
            ...fields
        });
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new GlobalVariables(Fr.fromBuffer(reader), Fr.fromBuffer(reader), reader.readNumber(), Fr.fromBuffer(reader), reader.readUInt64(), reader.readObject(EthAddress), reader.readObject(AztecAddress), reader.readObject(GasFees));
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return new GlobalVariables(reader.readField(), reader.readField(), reader.readU32(), reader.readField(), reader.readField().toBigInt(), EthAddress.fromField(reader.readField()), AztecAddress.fromField(reader.readField()), GasFees.fromFields(reader));
    }
    static getFields(fields) {
        // Note: The order here must match the order in the ProposedHeaderLib solidity library.
        return [
            fields.chainId,
            fields.version,
            fields.blockNumber,
            fields.slotNumber,
            fields.timestamp,
            fields.coinbase,
            fields.feeRecipient,
            fields.gasFees
        ];
    }
    toBuffer() {
        return serializeToBuffer([
            this.chainId,
            this.version,
            this.blockNumber,
            this.slotNumber,
            bigintToUInt64BE(this.timestamp),
            this.coinbase,
            this.feeRecipient,
            this.gasFees
        ]);
    }
    toFields() {
        const fields = serializeToFields(...GlobalVariables.getFields(this));
        if (fields.length !== GLOBAL_VARIABLES_LENGTH) {
            throw new Error(`Invalid number of fields for GlobalVariables. Expected ${GLOBAL_VARIABLES_LENGTH}, got ${fields.length}`);
        }
        return fields;
    }
    /**
   * A trimmed version of the JSON representation of the global variables,
   * tailored for human consumption.
   */ toFriendlyJSON() {
        return {
            blockNumber: this.blockNumber,
            slotNumber: this.slotNumber.toNumber(),
            timestamp: this.timestamp.toString(),
            coinbase: this.coinbase.toString(),
            gasFees: jsonStringify(this.gasFees)
        };
    }
    clone() {
        return GlobalVariables.fromBuffer(this.toBuffer());
    }
    isEmpty() {
        return this.chainId.isZero() && this.version.isZero() && this.blockNumber === 0 && this.slotNumber.isZero() && this.timestamp === 0n && this.coinbase.isZero() && this.feeRecipient.isZero() && this.gasFees.isEmpty();
    }
    toInspect() {
        return {
            chainId: this.chainId.toNumber(),
            version: this.version.toNumber(),
            blockNumber: this.blockNumber,
            slotNumber: this.slotNumber.toNumber(),
            timestamp: this.timestamp,
            coinbase: this.coinbase.toString(),
            feeRecipient: this.feeRecipient.toString(),
            feePerDaGas: Number(this.gasFees.feePerDaGas),
            feePerL2Gas: Number(this.gasFees.feePerL2Gas)
        };
    }
    [inspect.custom]() {
        return `GlobalVariables ${inspect(this.toInspect())}`;
    }
    equals(other) {
        return this.chainId.equals(other.chainId) && this.version.equals(other.version) && this.blockNumber === other.blockNumber && this.slotNumber.equals(other.slotNumber) && this.timestamp === other.timestamp && this.coinbase.equals(other.coinbase) && this.feeRecipient.equals(other.feeRecipient) && this.gasFees.equals(other.gasFees);
    }
}
