import { Fr } from '@aztec/foundation/fields';
import { schemas } from '@aztec/foundation/schemas';
import { BufferReader, FieldReader, serializeToBuffer, serializeToFields } from '@aztec/foundation/serialize';
import { bufferToHex } from '@aztec/foundation/string';
import { z } from 'zod';
export class ContentCommitment {
    blobsHash;
    inHash;
    outHash;
    constructor(blobsHash, inHash, outHash){
        this.blobsHash = blobsHash;
        this.inHash = inHash;
        this.outHash = outHash;
    }
    static get schema() {
        return z.object({
            blobsHash: schemas.Fr,
            inHash: schemas.Fr,
            outHash: schemas.Fr
        }).transform(({ blobsHash, inHash, outHash })=>new ContentCommitment(blobsHash, inHash, outHash));
    }
    static getFields(fields) {
        return [
            fields.blobsHash,
            fields.inHash,
            fields.outHash
        ];
    }
    getSize() {
        return this.toBuffer().length;
    }
    toBuffer() {
        return serializeToBuffer(...ContentCommitment.getFields(this));
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new ContentCommitment(reader.readObject(Fr), reader.readObject(Fr), reader.readObject(Fr));
    }
    toInspect() {
        return {
            blobsHash: this.blobsHash.toString(),
            inHash: this.inHash.toString(),
            outHash: this.outHash.toString()
        };
    }
    toViem() {
        return {
            blobsHash: this.blobsHash.toString(),
            inHash: this.inHash.toString(),
            outHash: this.outHash.toString()
        };
    }
    static fromViem(contentCommitment) {
        return new ContentCommitment(Fr.fromString(contentCommitment.blobsHash), Fr.fromString(contentCommitment.inHash), Fr.fromString(contentCommitment.outHash));
    }
    toFields() {
        return serializeToFields(...ContentCommitment.getFields(this));
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return new ContentCommitment(reader.readField(), reader.readField(), reader.readField());
    }
    static random() {
        return new ContentCommitment(Fr.random(), Fr.random(), Fr.random());
    }
    static empty() {
        return new ContentCommitment(Fr.zero(), Fr.zero(), Fr.zero());
    }
    isEmpty() {
        return this.blobsHash.isZero() && this.inHash.isZero() && this.outHash.isZero();
    }
    toString() {
        return bufferToHex(this.toBuffer());
    }
    static fromString(str) {
        const buffer = Buffer.from(str.replace(/^0x/i, ''), 'hex');
        return ContentCommitment.fromBuffer(buffer);
    }
    equals(other) {
        return this.blobsHash.equals(other.blobsHash) && this.inHash.equals(other.inHash) && this.outHash.equals(other.outHash);
    }
}
