import { Fr } from '@aztec/foundation/fields';
import type { FieldsOf } from '@aztec/foundation/types';
import { z } from 'zod';
import { NoteSelector } from '../abi/note_selector.js';
import { PrivateCircuitPublicInputs } from '../kernel/private_circuit_public_inputs.js';
import type { IsEmpty } from '../kernel/utils/interfaces.js';
import { ContractClassLog, ContractClassLogFields } from '../logs/contract_class_log.js';
import { Note } from '../note/note.js';
import { type ZodFor } from '../schemas/index.js';
import type { UInt32 } from '../types/index.js';
import { HashedValues } from './hashed_values.js';
import type { OffchainEffect } from './offchain_effect.js';
/**
 * The contents of a new note.
 */
export declare class NoteAndSlot {
    /** The note. */
    note: Note;
    /** The storage slot of the note. */
    storageSlot: Fr;
    /** The note type identifier. */
    noteTypeId: NoteSelector;
    constructor(
    /** The note. */
    note: Note, 
    /** The storage slot of the note. */
    storageSlot: Fr, 
    /** The note type identifier. */
    noteTypeId: NoteSelector);
    static get schema(): z.ZodEffects<z.ZodObject<{
        note: z.ZodEffects<z.ZodUnion<[z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, Buffer<ArrayBuffer>, string>, z.ZodEffects<z.ZodObject<{
            type: z.ZodLiteral<"Buffer">;
            data: z.ZodArray<z.ZodNumber, "many">;
        }, "strip", z.ZodTypeAny, {
            type: "Buffer";
            data: number[];
        }, {
            type: "Buffer";
            data: number[];
        }>, Buffer<ArrayBuffer>, {
            type: "Buffer";
            data: number[];
        }>]>, Note, string | {
            type: "Buffer";
            data: number[];
        }>;
        storageSlot: ZodFor<Fr>;
        noteTypeId: z.ZodType<NoteSelector, any, string>;
    }, "strip", z.ZodTypeAny, {
        storageSlot: Fr;
        note: Note;
        noteTypeId: NoteSelector;
    }, {
        note: string | {
            type: "Buffer";
            data: number[];
        };
        noteTypeId: string;
        storageSlot?: any;
    }>, NoteAndSlot, {
        note: string | {
            type: "Buffer";
            data: number[];
        };
        noteTypeId: string;
        storageSlot?: any;
    }>;
    static from(fields: FieldsOf<NoteAndSlot>): NoteAndSlot;
    static random(): NoteAndSlot;
}
export declare class CountedContractClassLog implements IsEmpty {
    log: ContractClassLog;
    counter: number;
    constructor(log: ContractClassLog, counter: number);
    static get schema(): ZodFor<CountedContractClassLog>;
    static from(fields: {
        log: ContractClassLog;
        counter: number;
    }): CountedContractClassLog;
    isEmpty(): boolean;
}
export declare class PrivateExecutionResult {
    entrypoint: PrivateCallExecutionResult;
    /** The first non revertible nullifier, or zero if there was none. */
    firstNullifier: Fr;
    /** An array of calldata for the enqueued public function calls and the teardown function call. */
    publicFunctionCalldata: HashedValues[];
    constructor(entrypoint: PrivateCallExecutionResult, 
    /** The first non revertible nullifier, or zero if there was none. */
    firstNullifier: Fr, 
    /** An array of calldata for the enqueued public function calls and the teardown function call. */
    publicFunctionCalldata: HashedValues[]);
    static get schema(): ZodFor<PrivateExecutionResult>;
    static from(fields: FieldsOf<PrivateExecutionResult>): PrivateExecutionResult;
    static random(nested?: number): Promise<PrivateExecutionResult>;
    /**
     * The block number that this execution was simulated with.
     */
    getSimulationBlockNumber(): UInt32;
}
/**
 * The result of executing a call to a private function.
 */
export declare class PrivateCallExecutionResult {
    /** The ACIR bytecode. */
    acir: Buffer;
    /** The verification key. */
    vk: Buffer;
    /** The partial witness. */
    partialWitness: Map<number, string>;
    /** The call stack item. */
    publicInputs: PrivateCircuitPublicInputs;
    /** Mapping of note hash to its index in the note hash tree. Used for building hints for note hash read requests. */
    noteHashLeafIndexMap: Map<bigint, bigint>;
    /** The notes created in the executed function. */
    newNotes: NoteAndSlot[];
    /** Mapping of note hash counter to the counter of its nullifier. */
    noteHashNullifierCounterMap: Map<number, number>;
    /** The raw return values of the executed function. */
    returnValues: Fr[];
    /** The offchain effects emitted during execution of this function call via the `emit_offchain_effect` oracle. */
    offchainEffects: {
        data: Fr[];
    }[];
    /** The nested executions. */
    nestedExecutionResults: PrivateCallExecutionResult[];
    /**
     * Contract class logs emitted during execution of this function call.
     * Note: We only need to collect the ContractClassLogFields as preimages for the tx.
     * But keep them as ContractClassLog so that we can verify the log hashes before submitting the tx (TODO).
     */
    contractClassLogs: CountedContractClassLog[];
    profileResult?: PrivateExecutionProfileResult | undefined;
    constructor(
    /** The ACIR bytecode. */
    acir: Buffer, 
    /** The verification key. */
    vk: Buffer, 
    /** The partial witness. */
    partialWitness: Map<number, string>, 
    /** The call stack item. */
    publicInputs: PrivateCircuitPublicInputs, 
    /** Mapping of note hash to its index in the note hash tree. Used for building hints for note hash read requests. */
    noteHashLeafIndexMap: Map<bigint, bigint>, 
    /** The notes created in the executed function. */
    newNotes: NoteAndSlot[], 
    /** Mapping of note hash counter to the counter of its nullifier. */
    noteHashNullifierCounterMap: Map<number, number>, 
    /** The raw return values of the executed function. */
    returnValues: Fr[], 
    /** The offchain effects emitted during execution of this function call via the `emit_offchain_effect` oracle. */
    offchainEffects: {
        data: Fr[];
    }[], 
    /** The nested executions. */
    nestedExecutionResults: PrivateCallExecutionResult[], 
    /**
     * Contract class logs emitted during execution of this function call.
     * Note: We only need to collect the ContractClassLogFields as preimages for the tx.
     * But keep them as ContractClassLog so that we can verify the log hashes before submitting the tx (TODO).
     */
    contractClassLogs: CountedContractClassLog[], profileResult?: PrivateExecutionProfileResult | undefined);
    static get schema(): ZodFor<PrivateCallExecutionResult>;
    static from(fields: FieldsOf<PrivateCallExecutionResult>): PrivateCallExecutionResult;
    static random(nested?: number): Promise<PrivateCallExecutionResult>;
}
export declare function collectNoteHashLeafIndexMap(execResult: PrivateExecutionResult): Map<bigint, bigint>;
export declare function collectNoteHashNullifierCounterMap(execResult: PrivateExecutionResult): Map<number, number>;
/**
 * Collect all contract class logs across all nested executions and sorts by counter.
 * @param execResult - The topmost execution result.
 * @returns All contract class logs.
 */
export declare function collectSortedContractClassLogs(execResult: PrivateExecutionResult): ContractClassLogFields[];
/**
 * Collect all offchain effects emitted across all nested executions.
 * @param execResult - The execution result to collect offchain effects from.
 * @returns Array of offchain effects.
 */
export declare function collectOffchainEffects(execResult: PrivateExecutionResult): OffchainEffect[];
export declare function getFinalMinRevertibleSideEffectCounter(execResult: PrivateExecutionResult): number;
export declare function collectNested<T>(executionStack: PrivateCallExecutionResult[], extractExecutionItems: (execution: PrivateCallExecutionResult) => T[]): T[];
export declare class PrivateExecutionProfileResult {
    timings: {
        witgen: number;
        oracles?: Record<string, {
            times: number[];
        }>;
    };
    constructor(timings: {
        witgen: number;
        oracles?: Record<string, {
            times: number[];
        }>;
    });
}
//# sourceMappingURL=private_execution_result.d.ts.map