import { RevertCode } from '../avm/revert_code.js';
import { Gas } from '../gas/gas.js';
import { computeL2ToL1MessageHash } from '../hash/hash.js';
import { TxEffect } from './tx_effect.js';
export var TxExecutionPhase = /*#__PURE__*/ function(TxExecutionPhase) {
    TxExecutionPhase[TxExecutionPhase["SETUP"] = 0] = "SETUP";
    TxExecutionPhase[TxExecutionPhase["APP_LOGIC"] = 1] = "APP_LOGIC";
    TxExecutionPhase[TxExecutionPhase["TEARDOWN"] = 2] = "TEARDOWN";
    return TxExecutionPhase;
}({});
export function makeProcessedTxFromPrivateOnlyTx(tx, transactionFee, feePaymentPublicDataWrite, globalVariables) {
    const data = tx.data.forRollup;
    const txEffect = new TxEffect(RevertCode.OK, tx.getTxHash(), transactionFee, data.end.noteHashes.filter((h)=>!h.isZero()), data.end.nullifiers.filter((h)=>!h.isZero()), data.end.l2ToL1Msgs.filter((msg)=>!msg.contractAddress.isZero()).map((msg)=>computeL2ToL1MessageHash({
            l2Sender: msg.contractAddress,
            l1Recipient: msg.message.recipient,
            content: msg.message.content,
            rollupVersion: globalVariables.version,
            chainId: globalVariables.chainId
        })), [
        feePaymentPublicDataWrite
    ], data.end.privateLogs.filter((l)=>!l.isEmpty()), [], tx.getContractClassLogs());
    const gasUsed = {
        // Billed gas is the same as total gas since there is no teardown execution
        totalGas: tx.data.gasUsed,
        billedGas: tx.data.gasUsed,
        teardownGas: Gas.empty(),
        publicGas: Gas.empty()
    };
    return {
        hash: txEffect.txHash,
        data: tx.data,
        clientIvcProof: tx.clientIvcProof,
        avmProvingRequest: undefined,
        globalVariables,
        txEffect,
        gasUsed,
        revertCode: RevertCode.OK,
        revertReason: undefined
    };
}
export function toNumBlobFields(txs) {
    return txs.reduce((acc, tx)=>{
        return acc + tx.txEffect.toBlobFields().length;
    }, 0);
}
export function makeProcessedTxFromTxWithPublicCalls(tx, avmProvingRequest, gasUsed, revertCode, revertReason) {
    const avmPublicInputs = avmProvingRequest.inputs.publicInputs;
    const globalVariables = avmPublicInputs.globalVariables;
    const publicDataWrites = avmPublicInputs.accumulatedData.publicDataWrites.filter((w)=>!w.isEmpty());
    const privateLogs = [
        ...tx.data.forPublic.nonRevertibleAccumulatedData.privateLogs,
        ...revertCode.isOK() ? tx.data.forPublic.revertibleAccumulatedData.privateLogs : []
    ].filter((l)=>!l.isEmpty());
    const contractClassLogs = revertCode.isOK() ? tx.getContractClassLogs() : tx.getSplitContractClassLogs(false);
    const txEffect = new TxEffect(revertCode, tx.getTxHash(), avmPublicInputs.transactionFee, avmPublicInputs.accumulatedData.noteHashes.filter((h)=>!h.isZero()), avmPublicInputs.accumulatedData.nullifiers.filter((h)=>!h.isZero()), avmPublicInputs.accumulatedData.l2ToL1Msgs.filter((msg)=>!msg.contractAddress.isZero()).map((msg)=>computeL2ToL1MessageHash({
            l2Sender: msg.contractAddress,
            l1Recipient: msg.message.recipient,
            content: msg.message.content,
            rollupVersion: globalVariables.version,
            chainId: globalVariables.chainId
        })), publicDataWrites, privateLogs, avmPublicInputs.accumulatedData.publicLogs.filter((l)=>!l.isEmpty()), contractClassLogs);
    return {
        hash: txEffect.txHash,
        data: tx.data,
        clientIvcProof: tx.clientIvcProof,
        avmProvingRequest,
        globalVariables,
        txEffect,
        gasUsed,
        revertCode,
        revertReason
    };
}
