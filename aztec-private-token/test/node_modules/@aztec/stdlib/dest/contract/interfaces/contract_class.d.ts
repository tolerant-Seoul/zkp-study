import type { Fr } from '@aztec/foundation/fields';
import { type ZodFor } from '@aztec/foundation/schemas';
import { z } from 'zod';
import { FunctionSelector } from '../../abi/index.js';
declare const VERSION: 1;
/**
 * A Contract Class in the protocol. Aztec differentiates contracts classes and instances, where a
 * contract class represents the code of the contract, but holds no state. Classes are identified by
 * an id that is a commitment to all its data.
 */
export interface ContractClass {
    /** Version of the contract class. */
    version: typeof VERSION;
    /**
     * Hash of the contract artifact. The specification of this hash is not enforced by the protocol. Should include
     * commitments to code of utility functions and compilation metadata. Intended to be used by clients to verify that
     * an off-chain fetched artifact matches a registered class.
     */
    artifactHash: Fr;
    /** List of individual private functions, constructors included. */
    privateFunctions: PrivateFunction[];
    /** Bytecode for the public_dispatch function, or empty. */
    packedBytecode: Buffer;
}
/** Private function definition within a contract class. */
export interface PrivateFunction {
    /** Selector of the function. Calculated as the hash of the method name and parameters. The specification of this is not enforced by the protocol. */
    selector: FunctionSelector;
    /** Hash of the verification key associated to this private function. */
    vkHash: Fr;
}
/** Private function definition with executable bytecode. */
export interface ExecutablePrivateFunction extends PrivateFunction {
    /** ACIR and Brillig bytecode */
    bytecode: Buffer;
}
/** Utility function definition. */
export interface UtilityFunction {
    /** Selector of the function. Calculated as the hash of the method name and parameters. The specification of this is not enforced by the protocol. */
    selector: FunctionSelector;
    /** Brillig. */
    bytecode: Buffer;
}
/** Sibling paths and sibling commitments for proving membership of a private function within a contract class. */
export type PrivateFunctionMembershipProof = {
    artifactMetadataHash: Fr;
    functionMetadataHash: Fr;
    utilityFunctionsTreeRoot: Fr;
    privateFunctionTreeSiblingPath: Fr[];
    privateFunctionTreeLeafIndex: number;
    artifactTreeSiblingPath: Fr[];
    artifactTreeLeafIndex: number;
};
/** A private function with a membership proof. */
export type ExecutablePrivateFunctionWithMembershipProof = ExecutablePrivateFunction & PrivateFunctionMembershipProof;
/** Sibling paths and commitments for proving membership of a utility  function within a contract class. */
export type UtilityFunctionMembershipProof = {
    artifactMetadataHash: Fr;
    functionMetadataHash: Fr;
    privateFunctionsArtifactTreeRoot: Fr;
    artifactTreeSiblingPath: Fr[];
    artifactTreeLeafIndex: number;
};
/** A utility function with a membership proof. */
export type UtilityFunctionWithMembershipProof = UtilityFunction & UtilityFunctionMembershipProof;
export declare const ContractClassSchema: z.ZodObject<{
    version: z.ZodLiteral<1>;
    artifactHash: z.ZodType<Fr, any, string>;
    privateFunctions: z.ZodArray<z.ZodObject<{
        selector: ZodFor<FunctionSelector>;
        vkHash: z.ZodType<Fr, any, string>;
    }, "strip", z.ZodTypeAny, {
        selector: FunctionSelector;
        vkHash: Fr;
    }, {
        vkHash: string;
        selector?: any;
    }>, "many">;
    packedBytecode: z.ZodUnion<[z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, Buffer<ArrayBuffer>, string>, z.ZodEffects<z.ZodObject<{
        type: z.ZodLiteral<"Buffer">;
        data: z.ZodArray<z.ZodNumber, "many">;
    }, "strip", z.ZodTypeAny, {
        type: "Buffer";
        data: number[];
    }, {
        type: "Buffer";
        data: number[];
    }>, Buffer<ArrayBuffer>, {
        type: "Buffer";
        data: number[];
    }>]>;
}, "strip", z.ZodTypeAny, {
    version: 1;
    artifactHash: Fr;
    packedBytecode: Buffer<ArrayBuffer>;
    privateFunctions: {
        selector: FunctionSelector;
        vkHash: Fr;
    }[];
}, {
    version: 1;
    artifactHash: string;
    packedBytecode: string | {
        type: "Buffer";
        data: number[];
    };
    privateFunctions: {
        vkHash: string;
        selector?: any;
    }[];
}>;
/** Commitments to fields of a contract class. */
interface ContractClassCommitments {
    /** Identifier of the contract class. */
    id: Fr;
    /** Commitment to the public bytecode. */
    publicBytecodeCommitment: Fr;
    /** Root of the private functions tree  */
    privateFunctionsRoot: Fr;
}
/** A contract class with its precomputed id. */
export type ContractClassWithId = ContractClass & Pick<ContractClassCommitments, 'id'>;
export declare const ContractClassWithIdSchema: z.ZodObject<{
    version: z.ZodLiteral<1>;
    artifactHash: z.ZodType<Fr, any, string>;
    privateFunctions: z.ZodArray<z.ZodObject<{
        selector: ZodFor<FunctionSelector>;
        vkHash: z.ZodType<Fr, any, string>;
    }, "strip", z.ZodTypeAny, {
        selector: FunctionSelector;
        vkHash: Fr;
    }, {
        vkHash: string;
        selector?: any;
    }>, "many">;
    packedBytecode: z.ZodUnion<[z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, Buffer<ArrayBuffer>, string>, z.ZodEffects<z.ZodObject<{
        type: z.ZodLiteral<"Buffer">;
        data: z.ZodArray<z.ZodNumber, "many">;
    }, "strip", z.ZodTypeAny, {
        type: "Buffer";
        data: number[];
    }, {
        type: "Buffer";
        data: number[];
    }>, Buffer<ArrayBuffer>, {
        type: "Buffer";
        data: number[];
    }>]>;
} & {
    id: z.ZodType<Fr, any, string>;
}, "strip", z.ZodTypeAny, {
    version: 1;
    id: Fr;
    artifactHash: Fr;
    packedBytecode: Buffer<ArrayBuffer>;
    privateFunctions: {
        selector: FunctionSelector;
        vkHash: Fr;
    }[];
}, {
    version: 1;
    id: string;
    artifactHash: string;
    packedBytecode: string | {
        type: "Buffer";
        data: number[];
    };
    privateFunctions: {
        vkHash: string;
        selector?: any;
    }[];
}>;
/** A contract class with public bytecode information, and optional private and utility functions. */
export type ContractClassPublic = {
    privateFunctions: ExecutablePrivateFunctionWithMembershipProof[];
    utilityFunctions: UtilityFunctionWithMembershipProof[];
} & Pick<ContractClassCommitments, 'id' | 'privateFunctionsRoot'> & Omit<ContractClass, 'privateFunctions'>;
export type ContractClassPublicWithCommitment = ContractClassPublic & Pick<ContractClassCommitments, 'publicBytecodeCommitment'>;
export declare const ContractClassPublicSchema: z.ZodIntersection<z.ZodObject<{
    id: z.ZodType<Fr, any, string>;
    privateFunctionsRoot: z.ZodType<Fr, any, string>;
    privateFunctions: z.ZodArray<z.ZodIntersection<z.ZodIntersection<z.ZodObject<{
        selector: ZodFor<FunctionSelector>;
        vkHash: z.ZodType<Fr, any, string>;
    }, "strip", z.ZodTypeAny, {
        selector: FunctionSelector;
        vkHash: Fr;
    }, {
        vkHash: string;
        selector?: any;
    }>, z.ZodObject<{
        bytecode: z.ZodUnion<[z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, Buffer<ArrayBuffer>, string>, z.ZodEffects<z.ZodObject<{
            type: z.ZodLiteral<"Buffer">;
            data: z.ZodArray<z.ZodNumber, "many">;
        }, "strip", z.ZodTypeAny, {
            type: "Buffer";
            data: number[];
        }, {
            type: "Buffer";
            data: number[];
        }>, Buffer<ArrayBuffer>, {
            type: "Buffer";
            data: number[];
        }>]>;
    }, "strip", z.ZodTypeAny, {
        bytecode: Buffer<ArrayBuffer>;
    }, {
        bytecode: string | {
            type: "Buffer";
            data: number[];
        };
    }>>, z.ZodObject<{
        artifactMetadataHash: z.ZodType<Fr, any, string>;
        functionMetadataHash: z.ZodType<Fr, any, string>;
        utilityFunctionsTreeRoot: z.ZodType<Fr, any, string>;
        privateFunctionTreeSiblingPath: z.ZodArray<z.ZodType<Fr, any, string>, "many">;
        privateFunctionTreeLeafIndex: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>;
        artifactTreeSiblingPath: z.ZodArray<z.ZodType<Fr, any, string>, "many">;
        artifactTreeLeafIndex: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        functionMetadataHash: Fr;
        artifactMetadataHash: Fr;
        utilityFunctionsTreeRoot: Fr;
        privateFunctionTreeSiblingPath: Fr[];
        privateFunctionTreeLeafIndex: number;
        artifactTreeSiblingPath: Fr[];
        artifactTreeLeafIndex: number;
    }, {
        functionMetadataHash: string;
        artifactMetadataHash: string;
        utilityFunctionsTreeRoot: string;
        privateFunctionTreeSiblingPath: string[];
        privateFunctionTreeLeafIndex: string | number | bigint;
        artifactTreeSiblingPath: string[];
        artifactTreeLeafIndex: string | number | bigint;
    }>>, "many">;
    utilityFunctions: z.ZodArray<z.ZodIntersection<z.ZodObject<{
        /** lala */
        selector: ZodFor<FunctionSelector>;
        bytecode: z.ZodUnion<[z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, Buffer<ArrayBuffer>, string>, z.ZodEffects<z.ZodObject<{
            type: z.ZodLiteral<"Buffer">;
            data: z.ZodArray<z.ZodNumber, "many">;
        }, "strip", z.ZodTypeAny, {
            type: "Buffer";
            data: number[];
        }, {
            type: "Buffer";
            data: number[];
        }>, Buffer<ArrayBuffer>, {
            type: "Buffer";
            data: number[];
        }>]>;
    }, "strip", z.ZodTypeAny, {
        bytecode: Buffer<ArrayBuffer>;
        selector: FunctionSelector;
    }, {
        bytecode: string | {
            type: "Buffer";
            data: number[];
        };
        selector?: any;
    }>, z.ZodObject<{
        artifactMetadataHash: z.ZodType<Fr, any, string>;
        functionMetadataHash: z.ZodType<Fr, any, string>;
        privateFunctionsArtifactTreeRoot: z.ZodType<Fr, any, string>;
        artifactTreeSiblingPath: z.ZodArray<z.ZodType<Fr, any, string>, "many">;
        artifactTreeLeafIndex: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodNumber>;
    }, "strip", z.ZodTypeAny, {
        functionMetadataHash: Fr;
        artifactMetadataHash: Fr;
        artifactTreeSiblingPath: Fr[];
        artifactTreeLeafIndex: number;
        privateFunctionsArtifactTreeRoot: Fr;
    }, {
        functionMetadataHash: string;
        artifactMetadataHash: string;
        artifactTreeSiblingPath: string[];
        artifactTreeLeafIndex: string | number | bigint;
        privateFunctionsArtifactTreeRoot: string;
    }>>, "many">;
}, "strip", z.ZodTypeAny, {
    id: Fr;
    privateFunctionsRoot: Fr;
    privateFunctions: ({
        selector: FunctionSelector;
        vkHash: Fr;
    } & {
        bytecode: Buffer<ArrayBuffer>;
    } & {
        functionMetadataHash: Fr;
        artifactMetadataHash: Fr;
        utilityFunctionsTreeRoot: Fr;
        privateFunctionTreeSiblingPath: Fr[];
        privateFunctionTreeLeafIndex: number;
        artifactTreeSiblingPath: Fr[];
        artifactTreeLeafIndex: number;
    })[];
    utilityFunctions: ({
        bytecode: Buffer<ArrayBuffer>;
        selector: FunctionSelector;
    } & {
        functionMetadataHash: Fr;
        artifactMetadataHash: Fr;
        artifactTreeSiblingPath: Fr[];
        artifactTreeLeafIndex: number;
        privateFunctionsArtifactTreeRoot: Fr;
    })[];
}, {
    id: string;
    privateFunctionsRoot: string;
    privateFunctions: ({
        vkHash: string;
        selector?: any;
    } & {
        bytecode: string | {
            type: "Buffer";
            data: number[];
        };
    } & {
        functionMetadataHash: string;
        artifactMetadataHash: string;
        utilityFunctionsTreeRoot: string;
        privateFunctionTreeSiblingPath: string[];
        privateFunctionTreeLeafIndex: string | number | bigint;
        artifactTreeSiblingPath: string[];
        artifactTreeLeafIndex: string | number | bigint;
    })[];
    utilityFunctions: ({
        bytecode: string | {
            type: "Buffer";
            data: number[];
        };
        selector?: any;
    } & {
        functionMetadataHash: string;
        artifactMetadataHash: string;
        artifactTreeSiblingPath: string[];
        artifactTreeLeafIndex: string | number | bigint;
        privateFunctionsArtifactTreeRoot: string;
    })[];
}>, z.ZodObject<Omit<{
    version: z.ZodLiteral<1>;
    artifactHash: z.ZodType<Fr, any, string>;
    privateFunctions: z.ZodArray<z.ZodObject<{
        selector: ZodFor<FunctionSelector>;
        vkHash: z.ZodType<Fr, any, string>;
    }, "strip", z.ZodTypeAny, {
        selector: FunctionSelector;
        vkHash: Fr;
    }, {
        vkHash: string;
        selector?: any;
    }>, "many">;
    packedBytecode: z.ZodUnion<[z.ZodEffects<z.ZodEffects<z.ZodString, string, string>, Buffer<ArrayBuffer>, string>, z.ZodEffects<z.ZodObject<{
        type: z.ZodLiteral<"Buffer">;
        data: z.ZodArray<z.ZodNumber, "many">;
    }, "strip", z.ZodTypeAny, {
        type: "Buffer";
        data: number[];
    }, {
        type: "Buffer";
        data: number[];
    }>, Buffer<ArrayBuffer>, {
        type: "Buffer";
        data: number[];
    }>]>;
}, "privateFunctions">, "strip", z.ZodTypeAny, {
    version: 1;
    artifactHash: Fr;
    packedBytecode: Buffer<ArrayBuffer>;
}, {
    version: 1;
    artifactHash: string;
    packedBytecode: string | {
        type: "Buffer";
        data: number[];
    };
}>>;
/** The contract class with the block it was initially deployed at */
export type ContractClassPublicWithBlockNumber = {
    l2BlockNumber: number;
} & ContractClassPublic;
export {};
//# sourceMappingURL=contract_class.d.ts.map