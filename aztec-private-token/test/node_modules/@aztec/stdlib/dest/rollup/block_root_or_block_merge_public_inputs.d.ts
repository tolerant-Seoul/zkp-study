import { BlockBlobPublicInputs } from '@aztec/blob-lib';
import { AZTEC_MAX_EPOCH_DURATION } from '@aztec/constants';
import { EthAddress } from '@aztec/foundation/eth-address';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader, type Tuple } from '@aztec/foundation/serialize';
import type { FieldsOf } from '@aztec/foundation/types';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { GlobalVariables } from '../tx/global_variables.js';
import { EpochConstantData } from './epoch_constant_data.js';
/**
 * Output of the block root and block merge rollup circuits.
 */
export declare class BlockRootOrBlockMergePublicInputs {
    /**
     * Constants for the entire epoch.
     */
    constants: EpochConstantData;
    /**
     * Archive tree immediately before this block range.
     */
    previousArchive: AppendOnlyTreeSnapshot;
    /**
     * Archive tree after adding this block range.
     */
    newArchive: AppendOnlyTreeSnapshot;
    /**
     * Global variables for the first block in the range.
     */
    startGlobalVariables: GlobalVariables;
    /**
     * Global variables for the last block in the range.
     */
    endGlobalVariables: GlobalVariables;
    /**
     * SHA256 hash of L2 to L1 messages. Used to make public inputs constant-sized (to then be opened on-chain).
     * Note: Truncated to 31 bytes to fit in Fr.
     */
    outHash: Fr;
    /**
     * The hashes of the proposed block headers of the constituent blocks.
     */
    proposedBlockHeaderHashes: Tuple<Fr, typeof AZTEC_MAX_EPOCH_DURATION>;
    /**
     * The summed `transaction_fee`s and recipients of the constituent blocks.
     */
    fees: Tuple<FeeRecipient, typeof AZTEC_MAX_EPOCH_DURATION>;
    /**
     * Public inputs required to verify a batch of blobs.
     */
    blobPublicInputs: BlockBlobPublicInputs;
    constructor(
    /**
     * Constants for the entire epoch.
     */
    constants: EpochConstantData, 
    /**
     * Archive tree immediately before this block range.
     */
    previousArchive: AppendOnlyTreeSnapshot, 
    /**
     * Archive tree after adding this block range.
     */
    newArchive: AppendOnlyTreeSnapshot, 
    /**
     * Global variables for the first block in the range.
     */
    startGlobalVariables: GlobalVariables, 
    /**
     * Global variables for the last block in the range.
     */
    endGlobalVariables: GlobalVariables, 
    /**
     * SHA256 hash of L2 to L1 messages. Used to make public inputs constant-sized (to then be opened on-chain).
     * Note: Truncated to 31 bytes to fit in Fr.
     */
    outHash: Fr, 
    /**
     * The hashes of the proposed block headers of the constituent blocks.
     */
    proposedBlockHeaderHashes: Tuple<Fr, typeof AZTEC_MAX_EPOCH_DURATION>, 
    /**
     * The summed `transaction_fee`s and recipients of the constituent blocks.
     */
    fees: Tuple<FeeRecipient, typeof AZTEC_MAX_EPOCH_DURATION>, 
    /**
     * Public inputs required to verify a batch of blobs.
     */
    blobPublicInputs: BlockBlobPublicInputs);
    /**
     * Deserializes from a buffer or reader.
     * @param buffer - Buffer or reader to read from.
     * @returns The deserialized public inputs.
     */
    static fromBuffer(buffer: Buffer | BufferReader): BlockRootOrBlockMergePublicInputs;
    /**
     * Serialize this as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Serialize this as a hex string.
     * @returns - The hex string.
     */
    toString(): `0x${string}`;
    /**
     * Deserializes from a hex string.
     * @param str - A hex string to deserialize from.
     * @returns A new BaseOrMergeRollupPublicInputs instance.
     */
    static fromString(str: string): BlockRootOrBlockMergePublicInputs;
    /** Returns a buffer representation for JSON serialization. */
    toJSON(): Buffer<ArrayBufferLike>;
    /** Creates an instance from a hex string. */
    static get schema(): import("zod").ZodType<BlockRootOrBlockMergePublicInputs, any, string>;
}
export declare class FeeRecipient {
    recipient: EthAddress;
    value: Fr;
    constructor(recipient: EthAddress, value: Fr);
    static fromBuffer(buffer: Buffer | BufferReader): FeeRecipient;
    toBuffer(): Buffer<ArrayBufferLike>;
    static getFields(fields: FieldsOf<FeeRecipient>): readonly [EthAddress, Fr];
    toFields(): Fr[];
    isEmpty(): boolean;
    toFriendlyJSON(): {
        recipient?: undefined;
        value?: undefined;
    } | {
        recipient: `0x${string}`;
        value: `0x${string}`;
    };
    static random(): FeeRecipient;
}
//# sourceMappingURL=block_root_or_block_merge_public_inputs.d.ts.map