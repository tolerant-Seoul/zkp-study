import { SpongeBlob } from '@aztec/blob-lib';
import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import { PartialStateReference } from '../tx/partial_state_reference.js';
import { BlockConstantData } from './block_constant_data.js';
/**
 * Output of the base and merge rollup circuits.
 */
export declare class BaseOrMergeRollupPublicInputs {
    /**
     * Number of txs in this rollup.
     */
    numTxs: number;
    /**
     * Data which is forwarded through the rollup circuits unchanged.
     */
    constants: BlockConstantData;
    /**
     * Partial state reference at the start of the rollup circuit.
     */
    start: PartialStateReference;
    /**
     * Partial state reference at the end of the rollup circuit.
     */
    end: PartialStateReference;
    /**
     * Sponge state to absorb blob inputs at the start of the rollup circuit.
     */
    startSpongeBlob: SpongeBlob;
    /**
     * Sponge state to absorb blob inputs at the end of the rollup circuit.
     */
    endSpongeBlob: SpongeBlob;
    /**
     * SHA256 hash of L2 to L1 messages. Used to make public inputs constant-sized (to then be opened on-chain).
     * Note: Truncated to 31 bytes to fit in Fr.
     */
    outHash: Fr;
    /**
     * The summed `transaction_fee` of the constituent transactions.
     */
    accumulatedFees: Fr;
    /**
     * The summed `mana_used` of the constituent transactions.
     */
    accumulatedManaUsed: Fr;
    constructor(
    /**
     * Number of txs in this rollup.
     */
    numTxs: number, 
    /**
     * Data which is forwarded through the rollup circuits unchanged.
     */
    constants: BlockConstantData, 
    /**
     * Partial state reference at the start of the rollup circuit.
     */
    start: PartialStateReference, 
    /**
     * Partial state reference at the end of the rollup circuit.
     */
    end: PartialStateReference, 
    /**
     * Sponge state to absorb blob inputs at the start of the rollup circuit.
     */
    startSpongeBlob: SpongeBlob, 
    /**
     * Sponge state to absorb blob inputs at the end of the rollup circuit.
     */
    endSpongeBlob: SpongeBlob, 
    /**
     * SHA256 hash of L2 to L1 messages. Used to make public inputs constant-sized (to then be opened on-chain).
     * Note: Truncated to 31 bytes to fit in Fr.
     */
    outHash: Fr, 
    /**
     * The summed `transaction_fee` of the constituent transactions.
     */
    accumulatedFees: Fr, 
    /**
     * The summed `mana_used` of the constituent transactions.
     */
    accumulatedManaUsed: Fr);
    /** Returns an empty instance. */
    static empty(): BaseOrMergeRollupPublicInputs;
    /**
     * Deserializes from a buffer or reader.
     * Note: Corresponds to a write in cpp.
     * @param buffer - Buffer or reader to read from.
     * @returns The deserialized public inputs.
     */
    static fromBuffer(buffer: Buffer | BufferReader): BaseOrMergeRollupPublicInputs;
    /**
     * Serialize this as a buffer.
     * @returns The buffer.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Serialize this as a hex string.
     * @returns - The hex string.
     */
    toString(): `0x${string}`;
    /**
     * Deserializes from a hex string.
     * @param str - A hex string to deserialize from.
     * @returns A new BaseOrMergeRollupPublicInputs instance.
     */
    static fromString(str: string): BaseOrMergeRollupPublicInputs;
    /** Returns a buffer representation for JSON serialization. */
    toJSON(): Buffer<ArrayBufferLike>;
    /** Creates an instance from a hex string. */
    static get schema(): import("zod").ZodType<BaseOrMergeRollupPublicInputs, any, string>;
}
//# sourceMappingURL=base_or_merge_rollup_public_inputs.d.ts.map