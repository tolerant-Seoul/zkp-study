import { BlobAccumulatorPublicInputs, FinalBlobBatchingChallenges } from '@aztec/blob-lib';
import { ARCHIVE_HEIGHT, BLOBS_PER_BLOCK, L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH, NESTED_RECURSIVE_PROOF_LENGTH } from '@aztec/constants';
import { BLS12Point, Fr } from '@aztec/foundation/fields';
import { BufferReader, type Tuple } from '@aztec/foundation/serialize';
import type { FieldsOf } from '@aztec/foundation/types';
import { RootParityInput } from '../parity/root_parity_input.js';
import { BlockHeader } from '../tx/block_header.js';
import { PreviousRollupData } from './previous_rollup_data.js';
export declare class BlockRootRollupData {
    /**
     * The original and converted roots of the L1 to L2 messages subtrees.
     */
    l1ToL2Roots: RootParityInput<typeof NESTED_RECURSIVE_PROOF_LENGTH>;
    /**
     * Hint for inserting the new l1 to l2 message subtree.
     */
    l1ToL2MessageSubtreeSiblingPath: Tuple<Fr, typeof L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH>;
    /**
     * Hint for checking the hash of previous_block_header is the last leaf of the previous archive.
     */
    previousArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>;
    /**
     * Hint for inserting the new block hash to the last archive.
     */
    newArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>;
    /**
     * The header of the previous block.
     */
    previousBlockHeader: BlockHeader;
    /**
     * The current blob accumulation state across the epoch.
     */
    startBlobAccumulator: BlobAccumulatorPublicInputs;
    /**
     * Finalized challenges z and gamma for performing blob batching. Shared value across the epoch.
     */
    finalBlobChallenges: FinalBlobBatchingChallenges;
    /**
     * Identifier of the prover.
     */
    proverId: Fr;
    constructor(
    /**
     * The original and converted roots of the L1 to L2 messages subtrees.
     */
    l1ToL2Roots: RootParityInput<typeof NESTED_RECURSIVE_PROOF_LENGTH>, 
    /**
     * Hint for inserting the new l1 to l2 message subtree.
     */
    l1ToL2MessageSubtreeSiblingPath: Tuple<Fr, typeof L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH>, 
    /**
     * Hint for checking the hash of previous_block_header is the last leaf of the previous archive.
     */
    previousArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>, 
    /**
     * Hint for inserting the new block hash to the last archive.
     */
    newArchiveSiblingPath: Tuple<Fr, typeof ARCHIVE_HEIGHT>, 
    /**
     * The header of the previous block.
     */
    previousBlockHeader: BlockHeader, 
    /**
     * The current blob accumulation state across the epoch.
     */
    startBlobAccumulator: BlobAccumulatorPublicInputs, 
    /**
     * Finalized challenges z and gamma for performing blob batching. Shared value across the epoch.
     */
    finalBlobChallenges: FinalBlobBatchingChallenges, 
    /**
     * Identifier of the prover.
     */
    proverId: Fr);
    /**
     * Serializes the inputs to a buffer.
     * @returns - The inputs serialized to a buffer.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Serializes the inputs to a hex string.
     * @returns The instance serialized to a hex string.
     */
    toString(): `0x${string}`;
    /**
     * Creates a new instance from fields.
     * @param fields - Fields to create the instance from.
     * @returns A new RootRollupInputs instance.
     */
    static from(fields: FieldsOf<BlockRootRollupData>): BlockRootRollupData;
    /**
     * Extracts fields from an instance.
     * @param fields - Fields to create the instance from.
     * @returns An array of fields.
     */
    static getFields(fields: FieldsOf<BlockRootRollupData>): readonly [RootParityInput<457>, [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr], [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr], [Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr, Fr], BlockHeader, BlobAccumulatorPublicInputs, FinalBlobBatchingChallenges, Fr];
    /**
     * Deserializes the inputs from a buffer.
     * @param buffer - A buffer to deserialize from.
     * @returns A new RootRollupInputs instance.
     */
    static fromBuffer(buffer: Buffer | BufferReader): BlockRootRollupData;
    /**
     * Deserializes the inputs from a hex string.
     * @param str - A hex string to deserialize from.
     * @returns A new RootRollupInputs instance.
     */
    static fromString(str: string): BlockRootRollupData;
    /** Returns a buffer representation for JSON serialization. */
    toJSON(): Buffer<ArrayBufferLike>;
    /** Creates an instance from a hex string. */
    static get schema(): import("zod").ZodType<BlockRootRollupData, any, string>;
}
export declare class BlockRootRollupBlobData {
    /**
     * Flat list of all tx effects which will be added to the blob.
     * Below line gives error 'Type instantiation is excessively deep and possibly infinite. ts(2589)'
     * Tuple<Fr, FIELDS_PER_BLOB * BLOBS_PER_BLOCK>
     */
    blobFields: Fr[];
    /**
     * KZG commitments representing the blob (precomputed in ts, injected to use inside circuit).
     */
    blobCommitments: Tuple<BLS12Point, typeof BLOBS_PER_BLOCK>;
    /**
     * The hash of eth blob hashes for this block
     * See yarn-project/foundation/src/blob/index.ts or body.ts for calculation
     */
    blobsHash: Fr;
    constructor(
    /**
     * Flat list of all tx effects which will be added to the blob.
     * Below line gives error 'Type instantiation is excessively deep and possibly infinite. ts(2589)'
     * Tuple<Fr, FIELDS_PER_BLOB * BLOBS_PER_BLOCK>
     */
    blobFields: Fr[], 
    /**
     * KZG commitments representing the blob (precomputed in ts, injected to use inside circuit).
     */
    blobCommitments: Tuple<BLS12Point, typeof BLOBS_PER_BLOCK>, 
    /**
     * The hash of eth blob hashes for this block
     * See yarn-project/foundation/src/blob/index.ts or body.ts for calculation
     */
    blobsHash: Fr);
    /**
     * Serializes the inputs to a buffer.
     * @returns - The inputs serialized to a buffer.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Serializes the inputs to a hex string.
     * @returns The instance serialized to a hex string.
     */
    toString(): `0x${string}`;
    /**
     * Creates a new instance from fields.
     * @param fields - Fields to create the instance from.
     * @returns A new RootRollupInputs instance.
     */
    static from(fields: FieldsOf<BlockRootRollupBlobData>): BlockRootRollupBlobData;
    /**
     * Extracts fields from an instance.
     * @param fields - Fields to create the instance from.
     * @returns An array of fields.
     */
    static getFields(fields: FieldsOf<BlockRootRollupBlobData>): readonly [Fr[], [BLS12Point, BLS12Point, BLS12Point], Fr];
    /**
     * Deserializes the inputs from a buffer.
     * @param buffer - A buffer to deserialize from.
     * @returns A new RootRollupInputs instance.
     */
    static fromBuffer(buffer: Buffer | BufferReader): BlockRootRollupBlobData;
    /**
     * Deserializes the inputs from a hex string.
     * @param str - A hex string to deserialize from.
     * @returns A new RootRollupInputs instance.
     */
    static fromString(str: string): BlockRootRollupBlobData;
    /** Returns a buffer representation for JSON serialization. */
    toJSON(): Buffer<ArrayBufferLike>;
    /** Creates an instance from a hex string. */
    static get schema(): import("zod").ZodType<BlockRootRollupBlobData, any, string>;
}
/**
 * Represents inputs of the block root rollup circuit.
 */
export declare class BlockRootRollupInputs {
    /**
     * The previous rollup data from 2 merge or base rollup circuits.
     */
    previousRollupData: [PreviousRollupData, PreviousRollupData];
    data: BlockRootRollupData;
    blobData: BlockRootRollupBlobData;
    constructor(
    /**
     * The previous rollup data from 2 merge or base rollup circuits.
     */
    previousRollupData: [PreviousRollupData, PreviousRollupData], data: BlockRootRollupData, blobData: BlockRootRollupBlobData);
    /**
     * Serializes the inputs to a buffer.
     * @returns - The inputs serialized to a buffer.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Serializes the inputs to a hex string.
     * @returns The instance serialized to a hex string.
     */
    toString(): `0x${string}`;
    /**
     * Creates a new instance from fields.
     * @param fields - Fields to create the instance from.
     * @returns A new RootRollupInputs instance.
     */
    static from(fields: FieldsOf<BlockRootRollupInputs>): BlockRootRollupInputs;
    /**
     * Extracts fields from an instance.
     * @param fields - Fields to create the instance from.
     * @returns An array of fields.
     */
    static getFields(fields: FieldsOf<BlockRootRollupInputs>): readonly [[PreviousRollupData, PreviousRollupData], BlockRootRollupData, BlockRootRollupBlobData];
    /**
     * Deserializes the inputs from a buffer.
     * @param buffer - A buffer to deserialize from.
     * @returns A new RootRollupInputs instance.
     */
    static fromBuffer(buffer: Buffer | BufferReader): BlockRootRollupInputs;
    /**
     * Deserializes the inputs from a hex string.
     * @param str - A hex string to deserialize from.
     * @returns A new RootRollupInputs instance.
     */
    static fromString(str: string): BlockRootRollupInputs;
    /** Returns a buffer representation for JSON serialization. */
    toJSON(): Buffer<ArrayBufferLike>;
    /** Creates an instance from a hex string. */
    static get schema(): import("zod").ZodType<BlockRootRollupInputs, any, string>;
}
export declare class SingleTxBlockRootRollupInputs {
    previousRollupData: [PreviousRollupData];
    data: BlockRootRollupData;
    blobData: BlockRootRollupBlobData;
    constructor(previousRollupData: [PreviousRollupData], data: BlockRootRollupData, blobData: BlockRootRollupBlobData);
    /**
     * Serializes the inputs to a buffer.
     * @returns - The inputs serialized to a buffer.
     */
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Serializes the inputs to a hex string.
     * @returns The instance serialized to a hex string.
     */
    toString(): `0x${string}`;
    /**
     * Creates a new instance from fields.
     * @param fields - Fields to create the instance from.
     * @returns A new RootRollupInputs instance.
     */
    static from(fields: FieldsOf<SingleTxBlockRootRollupInputs>): SingleTxBlockRootRollupInputs;
    /**
     * Extracts fields from an instance.
     * @param fields - Fields to create the instance from.
     * @returns An array of fields.
     */
    static getFields(fields: FieldsOf<SingleTxBlockRootRollupInputs>): readonly [[PreviousRollupData], BlockRootRollupData, BlockRootRollupBlobData];
    /**
     * Deserializes the inputs from a buffer.
     * @param buffer - A buffer to deserialize from.
     * @returns A new RootRollupInputs instance.
     */
    static fromBuffer(buffer: Buffer | BufferReader): SingleTxBlockRootRollupInputs;
    /**
     * Deserializes the inputs from a hex string.
     * @param str - A hex string to deserialize from.
     * @returns A new RootRollupInputs instance.
     */
    static fromString(str: string): SingleTxBlockRootRollupInputs;
    /** Returns a buffer representation for JSON serialization. */
    toJSON(): Buffer<ArrayBufferLike>;
    /** Creates an instance from a hex string. */
    static get schema(): import("zod").ZodType<SingleTxBlockRootRollupInputs, any, string>;
}
//# sourceMappingURL=block_root_rollup.d.ts.map