import { SpongeBlob } from '@aztec/blob-lib';
import { ARCHIVE_HEIGHT, MAX_CONTRACT_CLASS_LOGS_PER_TX } from '@aztec/constants';
import { makeTuple } from '@aztec/foundation/array';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { bufferToHex, hexToBuffer } from '@aztec/foundation/string';
import { MembershipWitness } from '@aztec/foundation/trees';
import { PublicDataHint } from '../avm/public_data_hint.js';
import { ContractClassLogFields } from '../logs/index.js';
import { AppendOnlyTreeSnapshot } from '../trees/index.js';
import { PartialStateReference } from '../tx/partial_state_reference.js';
import { BlockConstantData } from './block_constant_data.js';
import { PrivateBaseStateDiffHints } from './state_diff_hints.js';
export class PrivateBaseRollupHints {
    start;
    startSpongeBlob;
    stateDiffHints;
    feePayerFeeJuiceBalanceReadHint;
    archiveRootMembershipWitness;
    contractClassLogsFields;
    constants;
    constructor(/**
     * Partial state reference at the start of the rollup.
     */ start, /**
     * Sponge state to absorb blob inputs at the start of the rollup.
     */ startSpongeBlob, /**
     * Hints used while proving state diff validity.
     */ stateDiffHints, /**
     * Public data read hint for accessing the balance of the fee payer.
     */ feePayerFeeJuiceBalanceReadHint, /**
     * Membership witnesses of blocks referred by each of the 2 kernels.
     */ archiveRootMembershipWitness, /**
     * Preimages to the kernel's contractClassLogsHashes.
     */ contractClassLogsFields, /**
     * Data which is not modified by the base rollup circuit.
     */ constants){
        this.start = start;
        this.startSpongeBlob = startSpongeBlob;
        this.stateDiffHints = stateDiffHints;
        this.feePayerFeeJuiceBalanceReadHint = feePayerFeeJuiceBalanceReadHint;
        this.archiveRootMembershipWitness = archiveRootMembershipWitness;
        this.contractClassLogsFields = contractClassLogsFields;
        this.constants = constants;
    }
    static from(fields) {
        return new PrivateBaseRollupHints(...PrivateBaseRollupHints.getFields(fields));
    }
    static getFields(fields) {
        return [
            fields.start,
            fields.startSpongeBlob,
            fields.stateDiffHints,
            fields.feePayerFeeJuiceBalanceReadHint,
            fields.archiveRootMembershipWitness,
            fields.contractClassLogsFields,
            fields.constants
        ];
    }
    /**
   * Serializes the inputs to a buffer.
   * @returns The inputs serialized to a buffer.
   */ toBuffer() {
        return serializeToBuffer(...PrivateBaseRollupHints.getFields(this));
    }
    /**
   * Serializes the inputs to a hex string.
   * @returns The instance serialized to a hex string.
   */ toString() {
        return bufferToHex(this.toBuffer());
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PrivateBaseRollupHints(reader.readObject(PartialStateReference), reader.readObject(SpongeBlob), reader.readObject(PrivateBaseStateDiffHints), reader.readObject(PublicDataHint), MembershipWitness.fromBuffer(reader, ARCHIVE_HEIGHT), makeTuple(MAX_CONTRACT_CLASS_LOGS_PER_TX, ()=>reader.readObject(ContractClassLogFields)), reader.readObject(BlockConstantData));
    }
    static fromString(str) {
        return PrivateBaseRollupHints.fromBuffer(hexToBuffer(str));
    }
    static empty() {
        return new PrivateBaseRollupHints(PartialStateReference.empty(), SpongeBlob.empty(), PrivateBaseStateDiffHints.empty(), PublicDataHint.empty(), MembershipWitness.empty(ARCHIVE_HEIGHT), makeTuple(MAX_CONTRACT_CLASS_LOGS_PER_TX, ContractClassLogFields.empty), BlockConstantData.empty());
    }
}
export class PublicBaseRollupHints {
    startSpongeBlob;
    lastArchive;
    archiveRootMembershipWitness;
    contractClassLogsFields;
    constructor(/**
     * Sponge state to absorb blob inputs at the start of the rollup.
     */ startSpongeBlob, /**
     * Archive tree snapshot at the very beginning of the block containing this base rollup.
     */ lastArchive, /**
     * Membership witnesses of blocks referred by each of the 2 kernels.
     */ archiveRootMembershipWitness, /**
     * Preimages to the kernel's contractClassLogsHashes.
     */ contractClassLogsFields){
        this.startSpongeBlob = startSpongeBlob;
        this.lastArchive = lastArchive;
        this.archiveRootMembershipWitness = archiveRootMembershipWitness;
        this.contractClassLogsFields = contractClassLogsFields;
    }
    static from(fields) {
        return new PublicBaseRollupHints(...PublicBaseRollupHints.getFields(fields));
    }
    static getFields(fields) {
        return [
            fields.startSpongeBlob,
            fields.lastArchive,
            fields.archiveRootMembershipWitness,
            fields.contractClassLogsFields
        ];
    }
    /**
   * Serializes the inputs to a buffer.
   * @returns The inputs serialized to a buffer.
   */ toBuffer() {
        return serializeToBuffer(...PublicBaseRollupHints.getFields(this));
    }
    /**
   * Serializes the inputs to a hex string.
   * @returns The instance serialized to a hex string.
   */ toString() {
        return bufferToHex(this.toBuffer());
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PublicBaseRollupHints(reader.readObject(SpongeBlob), reader.readObject(AppendOnlyTreeSnapshot), MembershipWitness.fromBuffer(reader, ARCHIVE_HEIGHT), makeTuple(MAX_CONTRACT_CLASS_LOGS_PER_TX, ()=>reader.readObject(ContractClassLogFields)));
    }
    static fromString(str) {
        return PublicBaseRollupHints.fromBuffer(hexToBuffer(str));
    }
    static empty() {
        return new PublicBaseRollupHints(SpongeBlob.empty(), AppendOnlyTreeSnapshot.empty(), MembershipWitness.empty(ARCHIVE_HEIGHT), makeTuple(MAX_CONTRACT_CLASS_LOGS_PER_TX, ContractClassLogFields.empty));
    }
}
