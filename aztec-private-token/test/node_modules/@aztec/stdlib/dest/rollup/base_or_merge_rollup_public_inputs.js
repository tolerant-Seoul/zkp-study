import { SpongeBlob } from '@aztec/blob-lib';
import { Fr } from '@aztec/foundation/fields';
import { bufferSchemaFor } from '@aztec/foundation/schemas';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { bufferToHex, hexToBuffer } from '@aztec/foundation/string';
import { PartialStateReference } from '../tx/partial_state_reference.js';
import { BlockConstantData } from './block_constant_data.js';
/**
 * Output of the base and merge rollup circuits.
 */ export class BaseOrMergeRollupPublicInputs {
    numTxs;
    constants;
    start;
    end;
    startSpongeBlob;
    endSpongeBlob;
    outHash;
    accumulatedFees;
    accumulatedManaUsed;
    constructor(/**
     * Number of txs in this rollup.
     */ numTxs, /**
     * Data which is forwarded through the rollup circuits unchanged.
     */ constants, /**
     * Partial state reference at the start of the rollup circuit.
     */ start, /**
     * Partial state reference at the end of the rollup circuit.
     */ end, /**
     * Sponge state to absorb blob inputs at the start of the rollup circuit.
     */ startSpongeBlob, /**
     * Sponge state to absorb blob inputs at the end of the rollup circuit.
     */ endSpongeBlob, /**
     * SHA256 hash of L2 to L1 messages. Used to make public inputs constant-sized (to then be opened on-chain).
     * Note: Truncated to 31 bytes to fit in Fr.
     */ outHash, /**
     * The summed `transaction_fee` of the constituent transactions.
     */ accumulatedFees, /**
     * The summed `mana_used` of the constituent transactions.
     */ accumulatedManaUsed){
        this.numTxs = numTxs;
        this.constants = constants;
        this.start = start;
        this.end = end;
        this.startSpongeBlob = startSpongeBlob;
        this.endSpongeBlob = endSpongeBlob;
        this.outHash = outHash;
        this.accumulatedFees = accumulatedFees;
        this.accumulatedManaUsed = accumulatedManaUsed;
    }
    /** Returns an empty instance. */ static empty() {
        return new BaseOrMergeRollupPublicInputs(0, BlockConstantData.empty(), PartialStateReference.empty(), PartialStateReference.empty(), SpongeBlob.empty(), SpongeBlob.empty(), Fr.zero(), Fr.zero(), Fr.zero());
    }
    /**
   * Deserializes from a buffer or reader.
   * Note: Corresponds to a write in cpp.
   * @param buffer - Buffer or reader to read from.
   * @returns The deserialized public inputs.
   */ static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new BaseOrMergeRollupPublicInputs(reader.readNumber(), reader.readObject(BlockConstantData), reader.readObject(PartialStateReference), reader.readObject(PartialStateReference), reader.readObject(SpongeBlob), reader.readObject(SpongeBlob), Fr.fromBuffer(reader), Fr.fromBuffer(reader), Fr.fromBuffer(reader));
    }
    /**
   * Serialize this as a buffer.
   * @returns The buffer.
   */ toBuffer() {
        return serializeToBuffer(this.numTxs, this.constants, this.start, this.end, this.startSpongeBlob, this.endSpongeBlob, this.outHash, this.accumulatedFees, this.accumulatedManaUsed);
    }
    /**
   * Serialize this as a hex string.
   * @returns - The hex string.
   */ toString() {
        return bufferToHex(this.toBuffer());
    }
    /**
   * Deserializes from a hex string.
   * @param str - A hex string to deserialize from.
   * @returns A new BaseOrMergeRollupPublicInputs instance.
   */ static fromString(str) {
        return BaseOrMergeRollupPublicInputs.fromBuffer(hexToBuffer(str));
    }
    /** Returns a buffer representation for JSON serialization. */ toJSON() {
        return this.toBuffer();
    }
    /** Creates an instance from a hex string. */ static get schema() {
        return bufferSchemaFor(BaseOrMergeRollupPublicInputs);
    }
}
