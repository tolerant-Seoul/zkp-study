import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import type { AztecAddress } from '../aztec-address/index.js';
/**
 * An authentication witness. Used to authorize an action by a user.
 */
export declare class AuthWitness {
    /** Hash of the request to authorize */
    readonly requestHash: Fr;
    /** Authentication witness for the hash  */
    readonly witness: Fr[];
    constructor(
    /** Hash of the request to authorize */
    requestHash: Fr, 
    /** Authentication witness for the hash  */
    witness: (Fr | number)[]);
    static get schema(): import("zod").ZodType<AuthWitness, any, string>;
    toJSON(): `0x${string}`;
    toBuffer(): Buffer<ArrayBufferLike>;
    static fromBuffer(buffer: Buffer | BufferReader): AuthWitness;
    toString(): `0x${string}`;
    static fromString(str: string): AuthWitness;
    static random(): AuthWitness;
}
/**
 * Compute the inner hash for an authentication witness.
 * This is the "intent" of the message, before siloed with the consumer.
 * @param args - The arguments to hash
 * @returns The inner hash for the witness
 */
export declare const computeInnerAuthWitHash: (args: Fr[]) => Promise<Fr>;
/**
 * Compute the outer hash for an authentication witness.
 * This is the value siloed with its "consumer" and what the `on_behalf_of`
 * should be signing.
 * The consumer is who will be consuming the message, for token approvals it
 * is the token contract itself (because the token makes the call to check the approval).
 * @param consumer - The address that can "consume" the authwit
 * @param chainId - The chain id that can "consume" the authwit
 * @param version - The version that can "consume" the authwit
 * @param innerHash - The inner hash for the witness
 * @returns The outer hash for the witness
 */
export declare const computeOuterAuthWitHash: (consumer: AztecAddress, chainId: Fr, version: Fr, innerHash: Fr) => Promise<Fr>;
//# sourceMappingURL=auth_witness.d.ts.map