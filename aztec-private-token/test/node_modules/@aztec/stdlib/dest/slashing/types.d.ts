import { EthAddress } from '@aztec/foundation/eth-address';
import { z } from 'zod';
import { type ZodFor } from '../schemas/index.js';
export declare enum OffenseType {
    UNKNOWN = 0,
    /** The data for proving an epoch was not publicly available, we slash its committee */
    DATA_WITHHOLDING = 1,
    /** An epoch was not successfully proven in time, we slash its committee */
    VALID_EPOCH_PRUNED = 2,
    /** A proposer failed to attest or propose during an epoch according to the Sentinel */
    INACTIVITY = 3,
    /** A proposer sent an invalid block proposal over the p2p network to the committee */
    BROADCASTED_INVALID_BLOCK_PROPOSAL = 4,
    /** A proposer pushed to L1 a block with insufficient committee attestations */
    PROPOSED_INSUFFICIENT_ATTESTATIONS = 5,
    /** A proposer pushed to L1 a block with incorrect committee attestations (ie signature from a non-committee member) */
    PROPOSED_INCORRECT_ATTESTATIONS = 6,
    /** A committee member attested to a block that was built as a descendent of an invalid block (as in a block with invalid attestations) */
    ATTESTED_DESCENDANT_OF_INVALID = 7
}
export declare function getOffenseTypeName(offense: OffenseType): "unknown" | "data_withholding" | "valid_epoch_pruned" | "inactivity" | "broadcasted_invalid_block_proposal" | "proposed_insufficient_attestations" | "proposed_incorrect_attestations" | "attested_descendant_of_invalid";
export declare const OffenseTypeSchema: z.ZodNativeEnum<typeof OffenseType>;
export declare const OffenseToBigInt: Record<OffenseType, bigint>;
export declare function bigIntToOffense(offense: bigint): OffenseType;
export type Offense = {
    validator: EthAddress;
    amount: bigint;
    offenseType: OffenseType;
    epochOrSlot: bigint;
};
export type OffenseIdentifier = Pick<Offense, 'validator' | 'offenseType' | 'epochOrSlot'>;
export declare const OffenseSchema: z.ZodObject<{
    validator: ZodFor<EthAddress>;
    amount: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>;
    offenseType: z.ZodNativeEnum<typeof OffenseType>;
    epochOrSlot: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>;
}, "strip", z.ZodTypeAny, {
    amount: bigint;
    validator: EthAddress;
    offenseType: OffenseType;
    epochOrSlot: bigint;
}, {
    amount: string | number | bigint;
    offenseType: OffenseType;
    epochOrSlot: string | number | bigint;
    validator?: any;
}>;
/** Offense by a validator in the context of a slash payload */
export type ValidatorSlashOffense = {
    epochOrSlot: bigint;
    offenseType: OffenseType;
};
/** Slashed amount and total offenses by a validator in the context of a slash payload */
export type ValidatorSlash = {
    validator: EthAddress;
    amount: bigint;
    offenses: ValidatorSlashOffense[];
};
/** Slash payload as published by the empire slash proposer */
export type SlashPayload = {
    address: EthAddress;
    slashes: ValidatorSlash[];
    timestamp: bigint;
};
/** Slash payload with round information from empire slash proposer */
export type SlashPayloadRound = SlashPayload & {
    votes: bigint;
    round: bigint;
};
export declare const SlashPayloadRoundSchema: z.ZodObject<{
    address: ZodFor<EthAddress>;
    timestamp: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>;
    votes: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>;
    round: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>;
    slashes: z.ZodArray<z.ZodObject<{
        validator: ZodFor<EthAddress>;
        amount: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>;
        offenses: z.ZodArray<z.ZodObject<{
            offenseType: z.ZodNativeEnum<typeof OffenseType>;
            epochOrSlot: z.ZodPipeline<z.ZodUnion<[z.ZodBigInt, z.ZodNumber, z.ZodString]>, z.ZodBigInt>;
        }, "strip", z.ZodTypeAny, {
            offenseType: OffenseType;
            epochOrSlot: bigint;
        }, {
            offenseType: OffenseType;
            epochOrSlot: string | number | bigint;
        }>, "many">;
    }, "strip", z.ZodTypeAny, {
        amount: bigint;
        validator: EthAddress;
        offenses: {
            offenseType: OffenseType;
            epochOrSlot: bigint;
        }[];
    }, {
        amount: string | number | bigint;
        offenses: {
            offenseType: OffenseType;
            epochOrSlot: string | number | bigint;
        }[];
        validator?: any;
    }>, "many">;
}, "strip", z.ZodTypeAny, {
    timestamp: bigint;
    address: EthAddress;
    votes: bigint;
    round: bigint;
    slashes: {
        amount: bigint;
        validator: EthAddress;
        offenses: {
            offenseType: OffenseType;
            epochOrSlot: bigint;
        }[];
    }[];
}, {
    timestamp: string | number | bigint;
    votes: string | number | bigint;
    round: string | number | bigint;
    slashes: {
        amount: string | number | bigint;
        offenses: {
            offenseType: OffenseType;
            epochOrSlot: string | number | bigint;
        }[];
        validator?: any;
    }[];
    address?: any;
}>;
/** Votes for a validator slash in the consensus slash proposer */
export type ValidatorSlashVote = number;
export type ProposerSlashAction = 
/** Create a new slash payload on an empire-based slash proposer */
{
    type: 'create-empire-payload';
    data: ValidatorSlash[];
}
/** Vote for a slashing payload on an empire-based slash proposer */
 | {
    type: 'vote-empire-payload';
    payload: EthAddress;
}
/** Execute a slashing payload on an empire-based slash proposer */
 | {
    type: 'execute-empire-payload';
    round: bigint;
}
/** Vote for offenses on a consensus slashing proposer */
 | {
    type: 'vote-offenses';
    votes: ValidatorSlashVote[];
    committees: EthAddress[][];
    round: bigint;
}
/** Execute a slashing round on a consensus slashing proposer */
 | {
    type: 'execute-slash';
    committees: EthAddress[][];
    round: bigint;
};
export type ProposerSlashActionType = ProposerSlashAction['type'];
//# sourceMappingURL=types.d.ts.map