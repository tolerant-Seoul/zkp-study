import { PRIVATE_LOG_LENGTH, PRIVATE_LOG_SIZE_IN_FIELDS } from '@aztec/constants';
import { makeTuple } from '@aztec/foundation/array';
import { padArrayEnd } from '@aztec/foundation/collection';
import { Fr } from '@aztec/foundation/fields';
import { schemas } from '@aztec/foundation/schemas';
import { BufferReader, FieldReader, serializeToBuffer, serializeToFields } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { z } from 'zod';
export class PrivateLog {
    fields;
    emittedLength;
    static SIZE_IN_BYTES = Fr.SIZE_IN_BYTES * PRIVATE_LOG_LENGTH;
    constructor(fields, // Named `emittedLength` instead of `length` to avoid being confused with fields.length.
    emittedLength){
        this.fields = fields;
        this.emittedLength = emittedLength;
    }
    static from(fields) {
        return new PrivateLog(...PrivateLog.getFields(fields));
    }
    static getFields(fields) {
        return [
            fields.fields,
            fields.emittedLength
        ];
    }
    toFields() {
        return serializeToFields(...PrivateLog.getFields(this));
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return new PrivateLog(reader.readFieldArray(PRIVATE_LOG_SIZE_IN_FIELDS), reader.readU32());
    }
    getEmittedFields() {
        return this.fields.slice(0, this.emittedLength);
    }
    getEmittedFieldsWithoutTag() {
        return this.fields.slice(1, this.emittedLength);
    }
    toBlobFields() {
        return [
            new Fr(this.emittedLength)
        ].concat(this.getEmittedFields());
    }
    static fromBlobFields(fields) {
        const reader = FieldReader.asReader(fields);
        const emittedLength = reader.readU32();
        const emittedFields = reader.readFieldArray(emittedLength);
        return new PrivateLog(padArrayEnd(emittedFields, Fr.ZERO, PRIVATE_LOG_SIZE_IN_FIELDS), emittedLength);
    }
    isEmpty() {
        return this.fields.every((f)=>f.isZero());
    }
    static empty() {
        return new PrivateLog(makeTuple(PRIVATE_LOG_SIZE_IN_FIELDS, Fr.zero), 0);
    }
    toBuffer() {
        return serializeToBuffer(this.fields, this.emittedLength);
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PrivateLog(reader.readArray(PRIVATE_LOG_SIZE_IN_FIELDS, Fr), reader.readNumber());
    }
    static random(tag = Fr.random()) {
        const fields = makeTuple(PRIVATE_LOG_SIZE_IN_FIELDS, Fr.random);
        fields[0] = tag;
        return new PrivateLog(fields, PRIVATE_LOG_SIZE_IN_FIELDS);
    }
    static get schema() {
        return z.object({
            fields: z.array(schemas.Fr),
            emittedLength: z.number()
        }).strict().transform(({ fields, emittedLength })=>PrivateLog.fromFields(fields.concat(new Fr(emittedLength))));
    }
    equals(other) {
        return this.fields.every((field, i)=>field.equals(other.fields[i])) && this.emittedLength === other.emittedLength;
    }
    [inspect.custom]() {
        return `PrivateLog {
      fields: [${this.fields.map((x)=>inspect(x)).join(', ')}],
      emittedLength: ${this.emittedLength},
    }`;
    }
}
