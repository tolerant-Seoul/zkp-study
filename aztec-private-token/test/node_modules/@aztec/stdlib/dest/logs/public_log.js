import { PUBLIC_LOG_LENGTH, PUBLIC_LOG_SIZE_IN_FIELDS } from '@aztec/constants';
import { makeTuple } from '@aztec/foundation/array';
import { padArrayEnd } from '@aztec/foundation/collection';
import { Fr } from '@aztec/foundation/fields';
import { schemas } from '@aztec/foundation/schemas';
import { BufferReader, FieldReader, serializeToBuffer, serializeToFields } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { z } from 'zod';
import { AztecAddress } from '../aztec-address/index.js';
export class PublicLog {
    contractAddress;
    fields;
    emittedLength;
    static SIZE_IN_BYTES = Fr.SIZE_IN_BYTES * PUBLIC_LOG_LENGTH;
    constructor(contractAddress, fields, emittedLength){
        this.contractAddress = contractAddress;
        this.fields = fields;
        this.emittedLength = emittedLength;
    }
    static from(fields) {
        return new PublicLog(...PublicLog.getFields(fields));
    }
    static getFields(fields) {
        return [
            fields.contractAddress,
            fields.fields,
            fields.emittedLength
        ];
    }
    toFields() {
        return serializeToFields(...PublicLog.getFields(this));
    }
    static fromFields(fields) {
        const reader = FieldReader.asReader(fields);
        return new PublicLog(reader.readObject(AztecAddress), reader.readFieldArray(PUBLIC_LOG_SIZE_IN_FIELDS), reader.readU32());
    }
    getEmittedFields() {
        return this.fields.slice(0, this.emittedLength);
    }
    getEmittedFieldsWithoutTag() {
        return this.fields.slice(1, this.emittedLength);
    }
    toBlobFields() {
        return [
            new Fr(this.emittedLength),
            this.contractAddress.toField()
        ].concat(this.getEmittedFields());
    }
    static fromBlobFields(fields) {
        const reader = FieldReader.asReader(fields);
        const emittedLength = reader.readU32();
        const contractAddress = reader.readObject(AztecAddress);
        const emittedFields = reader.readFieldArray(emittedLength);
        return new PublicLog(contractAddress, padArrayEnd(emittedFields, Fr.ZERO, PUBLIC_LOG_SIZE_IN_FIELDS), emittedLength);
    }
    isEmpty() {
        return this.contractAddress.isZero() && this.fields.every((f)=>f.isZero()) && this.emittedLength === 0;
    }
    static empty() {
        return new PublicLog(AztecAddress.ZERO, makeTuple(PUBLIC_LOG_SIZE_IN_FIELDS, Fr.zero), 0);
    }
    toBuffer() {
        return serializeToBuffer(...PublicLog.getFields(this));
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        return new PublicLog(reader.readObject(AztecAddress), reader.readArray(PUBLIC_LOG_SIZE_IN_FIELDS, Fr), reader.readNumber());
    }
    static async random() {
        return new PublicLog(await AztecAddress.random(), makeTuple(PUBLIC_LOG_SIZE_IN_FIELDS, Fr.random), PUBLIC_LOG_SIZE_IN_FIELDS);
    }
    equals(other) {
        return this.contractAddress.equals(other.contractAddress) && this.fields.every((field, i)=>field.equals(other.fields[i])) && this.emittedLength === other.emittedLength;
    }
    toHumanReadable() {
        return `PublicLog: (contractAddress: ${this.contractAddress} fields: ${this.fields}) emittedLength: ${this.emittedLength}`;
    }
    static get schema() {
        return z.object({
            contractAddress: AztecAddress.schema,
            fields: z.array(schemas.Fr).refine((arr)=>arr.length === PUBLIC_LOG_SIZE_IN_FIELDS),
            emittedLength: z.number()
        }).transform(({ contractAddress, fields, emittedLength })=>PublicLog.fromFields([
                contractAddress.toField(),
                ...fields,
                new Fr(emittedLength)
            ]));
    }
    [inspect.custom]() {
        return `PublicLog {
      contractAddress: ${inspect(this.contractAddress)},
      fields: [${this.fields.map((x)=>inspect(x)).join(', ')}],
      emittedLength: ${this.emittedLength},
    }`;
    }
}
