import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import { AztecAddress } from '../aztec-address/index.js';
import { Gas } from '../gas/gas.js';
import type { PrivateLog } from '../logs/index.js';
import { TxConstantData } from '../tx/tx_constant_data.js';
import type { UInt64 } from '../types/shared.js';
import type { ScopedLogHash } from './log_hash.js';
import { PrivateToPublicAccumulatedData } from './private_to_public_accumulated_data.js';
import { PrivateToPublicKernelCircuitPublicInputs } from './private_to_public_kernel_circuit_public_inputs.js';
import { PrivateToRollupAccumulatedData } from './private_to_rollup_accumulated_data.js';
import { PrivateToRollupKernelCircuitPublicInputs } from './private_to_rollup_kernel_circuit_public_inputs.js';
import { PublicCallRequest } from './public_call_request.js';
export declare class PartialPrivateTailPublicInputsForPublic {
    /**
     * Accumulated side effects and enqueued calls that are not revertible.
     */
    nonRevertibleAccumulatedData: PrivateToPublicAccumulatedData;
    /**
     * Data accumulated from both public and private circuits.
     */
    revertibleAccumulatedData: PrivateToPublicAccumulatedData;
    /**
     * Call request for the public teardown function.
     */
    publicTeardownCallRequest: PublicCallRequest;
    constructor(
    /**
     * Accumulated side effects and enqueued calls that are not revertible.
     */
    nonRevertibleAccumulatedData: PrivateToPublicAccumulatedData, 
    /**
     * Data accumulated from both public and private circuits.
     */
    revertibleAccumulatedData: PrivateToPublicAccumulatedData, 
    /**
     * Call request for the public teardown function.
     */
    publicTeardownCallRequest: PublicCallRequest);
    getSize(): number;
    get needsSetup(): boolean;
    get needsAppLogic(): boolean;
    get needsTeardown(): boolean;
    static fromBuffer(buffer: Buffer | BufferReader): PartialPrivateTailPublicInputsForPublic;
    toBuffer(): Buffer<ArrayBufferLike>;
    static empty(): PartialPrivateTailPublicInputsForPublic;
}
export declare class PartialPrivateTailPublicInputsForRollup {
    end: PrivateToRollupAccumulatedData;
    constructor(end: PrivateToRollupAccumulatedData);
    static fromBuffer(buffer: Buffer | BufferReader): PartialPrivateTailPublicInputsForRollup;
    getSize(): number;
    toBuffer(): Buffer<ArrayBufferLike>;
    static empty(): PartialPrivateTailPublicInputsForRollup;
}
export declare class PrivateKernelTailCircuitPublicInputs {
    /**
     * Data which is not modified by the circuits.
     */
    constants: TxConstantData;
    /**
     * The accumulated gas used after private execution.
     * If the tx has a teardown call request, the teardown gas limits will also be included.
     */
    gasUsed: Gas;
    /**
     * The address of the fee payer for the transaction.
     */
    feePayer: AztecAddress;
    /**
     * The timestamp by which the transaction must be included in a block.
     */
    includeByTimestamp: UInt64;
    forPublic?: PartialPrivateTailPublicInputsForPublic | undefined;
    forRollup?: PartialPrivateTailPublicInputsForRollup | undefined;
    constructor(
    /**
     * Data which is not modified by the circuits.
     */
    constants: TxConstantData, 
    /**
     * The accumulated gas used after private execution.
     * If the tx has a teardown call request, the teardown gas limits will also be included.
     */
    gasUsed: Gas, 
    /**
     * The address of the fee payer for the transaction.
     */
    feePayer: AztecAddress, 
    /**
     * The timestamp by which the transaction must be included in a block.
     */
    includeByTimestamp: UInt64, forPublic?: PartialPrivateTailPublicInputsForPublic | undefined, forRollup?: PartialPrivateTailPublicInputsForRollup | undefined);
    static get schema(): import("zod").ZodType<PrivateKernelTailCircuitPublicInputs, any, string>;
    toJSON(): Buffer<ArrayBufferLike>;
    getSize(): number;
    toPrivateToPublicKernelCircuitPublicInputs(): PrivateToPublicKernelCircuitPublicInputs;
    toPrivateToRollupKernelCircuitPublicInputs(): PrivateToRollupKernelCircuitPublicInputs;
    numberOfPublicCallRequests(): number;
    numberOfNonRevertiblePublicCallRequests(): number;
    numberOfRevertiblePublicCallRequests(): number;
    hasTeardownPublicCallRequest(): boolean;
    getNonRevertiblePublicCallRequests(): PublicCallRequest[];
    getRevertiblePublicCallRequests(): PublicCallRequest[];
    getTeardownPublicCallRequest(): PublicCallRequest | undefined;
    getNonEmptyNoteHashes(): Fr[];
    getNonEmptyNullifiers(): Fr[];
    getNonEmptyPrivateLogs(): PrivateLog[];
    getNonEmptyContractClassLogsHashes(): ScopedLogHash[];
    getEmittedContractClassLogsLength(): number;
    getEmittedPrivateLogsLength(): number;
    static fromBuffer(buffer: Buffer | BufferReader): PrivateKernelTailCircuitPublicInputs;
    toBuffer(): Buffer<ArrayBufferLike>;
    static empty(): PrivateKernelTailCircuitPublicInputs;
    /**
     * Creates an empty instance except for a nullifier in the combined accumulated data.
     * Useful for populating a tx, which relies on that nullifier for extracting its tx hash.
     * TODO(#9269): Remove this method as we move away from 1st nullifier as hash.
     */
    static emptyWithNullifier(): PrivateKernelTailCircuitPublicInputs;
}
//# sourceMappingURL=private_kernel_tail_circuit_public_inputs.d.ts.map