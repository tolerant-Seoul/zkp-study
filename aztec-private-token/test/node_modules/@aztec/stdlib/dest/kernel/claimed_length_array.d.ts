import type { Fr } from '@aztec/foundation/fields';
import { BufferReader, FieldReader, type Serializable, type Tuple } from '@aztec/foundation/serialize';
import { inspect } from 'util';
export declare class ClaimedLengthArray<T extends Serializable, N extends number> {
    array: Tuple<T, N>;
    claimedLength: number;
    constructor(array: Tuple<T, N>, claimedLength: number);
    static fromBuffer<T extends Serializable, N extends number>(buffer: Buffer | BufferReader, deserializer: {
        fromBuffer: (reader: BufferReader) => T;
    }, arrayLength: N): ClaimedLengthArray<T, N>;
    toBuffer(): Buffer<ArrayBufferLike>;
    static fromFields<T extends Serializable, N extends number>(fields: Fr[] | FieldReader, deserializer: {
        fromFields: (reader: FieldReader) => T;
    }, arrayLength: N): ClaimedLengthArray<T, N>;
    toFields(): Fr[];
    static empty<T extends Serializable, N extends number>(elem: {
        empty: () => T;
    }, arraySize: number): ClaimedLengthArray<T, N>;
    isEmpty(): boolean;
    getActiveItems(): T[];
    getSize(): number;
    [inspect.custom](): string;
}
export declare function ClaimedLengthArrayFromBuffer<T extends Serializable, N extends number>(deserializer: {
    fromBuffer: (reader: BufferReader) => T;
}, arrayLength: N): {
    fromBuffer: (reader: BufferReader) => ClaimedLengthArray<T, N>;
};
export declare function ClaimedLengthArrayFromFields<T extends Serializable, N extends number>(deserializer: {
    fromFields: (reader: FieldReader) => T;
}, arrayLength: N): {
    fromFields: (reader: FieldReader) => ClaimedLengthArray<T, N>;
};
//# sourceMappingURL=claimed_length_array.d.ts.map