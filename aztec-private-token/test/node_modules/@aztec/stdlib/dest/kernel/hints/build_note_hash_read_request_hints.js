import { MAX_NOTE_HASH_READ_REQUESTS_PER_TX } from '@aztec/constants';
import { NoteHashReadRequestHintsBuilder } from './note_hash_read_request_hints.js';
import { PendingReadHint, ReadRequestActionEnum, ReadRequestResetActions } from './read_request_hints.js';
import { ScopedValueCache } from './scoped_value_cache.js';
export function isValidNoteHashReadRequest(readRequest, noteHash) {
    return noteHash.value.equals(readRequest.value) && noteHash.contractAddress.equals(readRequest.contractAddress) && readRequest.counter > noteHash.counter;
}
export function getNoteHashReadRequestResetActions(noteHashReadRequests, noteHashes, futureNoteHashes) {
    const resetActions = ReadRequestResetActions.empty(MAX_NOTE_HASH_READ_REQUESTS_PER_TX);
    const noteHashMap = new Map();
    noteHashes.getActiveItems().forEach((noteHash, index)=>{
        const value = noteHash.value.toBigInt();
        const arr = noteHashMap.get(value) ?? [];
        arr.push({
            noteHash,
            index
        });
        noteHashMap.set(value, arr);
    });
    const futureNoteHashMap = new ScopedValueCache(futureNoteHashes);
    for(let i = 0; i < noteHashReadRequests.claimedLength; ++i){
        const readRequest = noteHashReadRequests.array[i];
        const pendingNoteHash = noteHashMap.get(readRequest.value.toBigInt())?.find((n)=>isValidNoteHashReadRequest(readRequest, n.noteHash));
        if (pendingNoteHash !== undefined) {
            resetActions.actions[i] = ReadRequestActionEnum.READ_AS_PENDING;
            resetActions.pendingReadHints.push(new PendingReadHint(i, pendingNoteHash.index));
        } else if (!futureNoteHashMap.get(readRequest).find((futureNoteHash)=>isValidNoteHashReadRequest(readRequest, futureNoteHash))) {
            resetActions.actions[i] = ReadRequestActionEnum.READ_AS_SETTLED;
        }
    }
    return resetActions;
}
export async function buildNoteHashReadRequestHintsFromResetActions(oracle, noteHashReadRequests, noteHashes, resetActions, noteHashLeafIndexMap, maxPending = MAX_NOTE_HASH_READ_REQUESTS_PER_TX, maxSettled = MAX_NOTE_HASH_READ_REQUESTS_PER_TX) {
    const builder = new NoteHashReadRequestHintsBuilder(maxPending, maxSettled);
    resetActions.pendingReadHints.forEach((hint)=>{
        builder.addPendingReadRequest(hint.readRequestIndex, hint.pendingValueIndex);
    });
    for(let i = 0; i < resetActions.actions.length; i++){
        if (resetActions.actions[i] === ReadRequestActionEnum.READ_AS_SETTLED) {
            const readRequest = noteHashReadRequests.array[i];
            const leafIndex = noteHashLeafIndexMap.get(readRequest.value.toBigInt());
            if (leafIndex === undefined) {
                throw new Error('Read request is reading an unknown note hash.');
            }
            const membershipWitness = await oracle.getNoteHashMembershipWitness(leafIndex);
            builder.addSettledReadRequest(i, membershipWitness, readRequest.value);
        }
    }
    const noteHashMap = new Map();
    noteHashes.getActiveItems().forEach((noteHash, index)=>{
        const value = noteHash.value.toBigInt();
        const arr = noteHashMap.get(value) ?? [];
        arr.push({
            noteHash,
            index
        });
        noteHashMap.set(value, arr);
    });
    return builder.toHints();
}
export async function buildNoteHashReadRequestHints(oracle, noteHashReadRequests, noteHashes, noteHashLeafIndexMap, futureNoteHashes, maxPending = MAX_NOTE_HASH_READ_REQUESTS_PER_TX, maxSettled = MAX_NOTE_HASH_READ_REQUESTS_PER_TX) {
    const resetActions = getNoteHashReadRequestResetActions(noteHashReadRequests, noteHashes, futureNoteHashes);
    return await buildNoteHashReadRequestHintsFromResetActions(oracle, noteHashReadRequests, noteHashes, resetActions, noteHashLeafIndexMap, maxPending, maxSettled);
}
