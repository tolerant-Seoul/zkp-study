import { MAX_NULLIFIER_READ_REQUESTS_PER_TX } from '@aztec/constants';
import { siloNullifier } from '../../hash/hash.js';
import { NullifierReadRequestHintsBuilder } from './nullifier_read_request_hints.js';
import { PendingReadHint, ReadRequestActionEnum, ReadRequestResetActions } from './read_request_hints.js';
import { ScopedValueCache } from './scoped_value_cache.js';
export function isValidNullifierReadRequest(readRequest, nullifier) {
    return readRequest.value.equals(nullifier.value) && nullifier.contractAddress.equals(readRequest.contractAddress) && readRequest.counter > nullifier.counter;
}
export function getNullifierReadRequestResetActions(nullifierReadRequests, nullifiers, futureNullifiers) {
    const resetActions = ReadRequestResetActions.empty(MAX_NULLIFIER_READ_REQUESTS_PER_TX);
    const nullifierMap = new Map();
    nullifiers.getActiveItems().forEach((nullifier, index)=>{
        const value = nullifier.value.toBigInt();
        const arr = nullifierMap.get(value) ?? [];
        arr.push({
            nullifier,
            index
        });
        nullifierMap.set(value, arr);
    });
    const futureNullifiersMap = new ScopedValueCache(futureNullifiers);
    for(let i = 0; i < nullifierReadRequests.claimedLength; ++i){
        const readRequest = nullifierReadRequests.array[i];
        const pendingNullifier = nullifierMap.get(readRequest.value.toBigInt())?.find(({ nullifier })=>isValidNullifierReadRequest(readRequest, nullifier));
        if (pendingNullifier !== undefined) {
            resetActions.actions[i] = ReadRequestActionEnum.READ_AS_PENDING;
            resetActions.pendingReadHints.push(new PendingReadHint(i, pendingNullifier.index));
        } else if (!futureNullifiersMap.get(readRequest).some((futureNullifier)=>isValidNullifierReadRequest(readRequest, futureNullifier))) {
            resetActions.actions[i] = ReadRequestActionEnum.READ_AS_SETTLED;
        }
    }
    return resetActions;
}
export async function buildNullifierReadRequestHintsFromResetActions(oracle, nullifierReadRequests, resetActions, maxPending = MAX_NULLIFIER_READ_REQUESTS_PER_TX, maxSettled = MAX_NULLIFIER_READ_REQUESTS_PER_TX, siloed = false) {
    const builder = new NullifierReadRequestHintsBuilder(maxPending, maxSettled);
    resetActions.pendingReadHints.forEach((hint)=>{
        builder.addPendingReadRequest(hint.readRequestIndex, hint.pendingValueIndex);
    });
    for(let i = 0; i < resetActions.actions.length; i++){
        if (resetActions.actions[i] === ReadRequestActionEnum.READ_AS_SETTLED) {
            const readRequest = nullifierReadRequests.array[i];
            const siloedValue = siloed ? readRequest.value : await siloNullifier(readRequest.contractAddress, readRequest.value);
            const membershipWitnessWithPreimage = await oracle.getNullifierMembershipWitness(siloedValue);
            builder.addSettledReadRequest(i, membershipWitnessWithPreimage.membershipWitness, membershipWitnessWithPreimage.leafPreimage);
        }
    }
    return builder.toHints();
}
export async function buildNullifierReadRequestHints(oracle, nullifierReadRequests, nullifiers, futureNullifiers, maxPending = MAX_NULLIFIER_READ_REQUESTS_PER_TX, maxSettled = MAX_NULLIFIER_READ_REQUESTS_PER_TX, siloed = false) {
    const resetActions = getNullifierReadRequestResetActions(nullifierReadRequests, nullifiers, futureNullifiers);
    return await buildNullifierReadRequestHintsFromResetActions(oracle, nullifierReadRequests, resetActions, maxPending, maxSettled, siloed);
}
