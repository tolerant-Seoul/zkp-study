import { BlobAccumulatorPublicInputs, FinalBlobAccumulatorPublicInputs } from '@aztec/blob-lib';
import { makeBatchedBlobAccumulator, makeBlockBlobPublicInputs, makeSpongeBlob } from '@aztec/blob-lib/testing';
import { ARCHIVE_HEIGHT, AVM_V2_PROOF_LENGTH_IN_FIELDS_PADDED, AZTEC_MAX_EPOCH_DURATION, BLOBS_PER_BLOCK, CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FIELDS_PER_BLOB, FIXED_DA_GAS, FIXED_L2_GAS, GeneratorIndex, L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH, MAX_CONTRACT_CLASS_LOGS_PER_TX, MAX_ENQUEUED_CALLS_PER_CALL, MAX_ENQUEUED_CALLS_PER_TX, MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_TX, MAX_NOTE_HASHES_PER_CALL, MAX_NOTE_HASHES_PER_TX, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL, MAX_NULLIFIERS_PER_TX, MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL, MAX_PRIVATE_LOGS_PER_TX, MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX, MAX_PUBLIC_LOGS_PER_TX, MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX, NESTED_RECURSIVE_PROOF_LENGTH, NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH, NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH, NULLIFIER_TREE_HEIGHT, NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP, NUM_BASE_PARITY_PER_ROOT_PARITY, NUM_MSGS_PER_BASE_PARITY, PRIVATE_LOG_SIZE_IN_FIELDS, PUBLIC_DATA_TREE_HEIGHT, PUBLIC_LOG_SIZE_IN_FIELDS, RECURSIVE_PROOF_LENGTH, TUBE_PROOF_LENGTH, VK_TREE_HEIGHT } from '@aztec/constants';
import { makeHalfFullTuple, makeTuple } from '@aztec/foundation/array';
import { compact, padArrayEnd } from '@aztec/foundation/collection';
import { Grumpkin, SchnorrSignature, poseidon2HashWithSeparator, sha256 } from '@aztec/foundation/crypto';
import { EthAddress } from '@aztec/foundation/eth-address';
import { BLS12Point, Fq, Fr, GrumpkinScalar, Point } from '@aztec/foundation/fields';
import { MembershipWitness } from '@aztec/foundation/trees';
import { FunctionSelector } from '../abi/function_selector.js';
import { ContractStorageRead } from '../avm/contract_storage_read.js';
import { ContractStorageUpdateRequest } from '../avm/contract_storage_update_request.js';
import { AvmAccumulatedData, AvmAccumulatedDataArrayLengths, AvmAppendLeavesHint, AvmBytecodeCommitmentHint, AvmCircuitInputs, AvmCircuitPublicInputs, AvmCommitCheckpointHint, AvmContractClassHint, AvmContractInstanceHint, AvmCreateCheckpointHint, AvmExecutionHints, AvmGetLeafPreimageHintNullifierTree, AvmGetLeafPreimageHintPublicDataTree, AvmGetLeafValueHint, AvmGetPreviousValueIndexHint, AvmGetSiblingPathHint, AvmRevertCheckpointHint, AvmSequentialInsertHintNullifierTree, AvmSequentialInsertHintPublicDataTree, AvmTxHint, RevertCode } from '../avm/index.js';
import { PublicDataHint } from '../avm/public_data_hint.js';
import { PublicDataRead } from '../avm/public_data_read.js';
import { PublicDataWrite } from '../avm/public_data_write.js';
import { AztecAddress } from '../aztec-address/index.js';
import { SerializableContractInstance, computeContractClassId, computePublicBytecodeCommitment } from '../contract/index.js';
import { Gas, GasFees, GasSettings } from '../gas/index.js';
import { computeCalldataHash } from '../hash/hash.js';
import { KeyValidationRequest } from '../kernel/hints/key_validation_request.js';
import { KeyValidationRequestAndGenerator } from '../kernel/hints/key_validation_request_and_generator.js';
import { ReadRequest } from '../kernel/hints/read_request.js';
import { ClaimedLengthArray, PartialPrivateTailPublicInputsForPublic, PartialPrivateTailPublicInputsForRollup, PrivateKernelTailCircuitPublicInputs, PrivateToAvmAccumulatedData, PrivateToAvmAccumulatedDataArrayLengths, PrivateToPublicAccumulatedData, PrivateToPublicKernelCircuitPublicInputs, PrivateToRollupAccumulatedData } from '../kernel/index.js';
import { CountedLogHash, LogHash, ScopedLogHash } from '../kernel/log_hash.js';
import { NoteHash } from '../kernel/note_hash.js';
import { Nullifier } from '../kernel/nullifier.js';
import { PrivateCallRequest } from '../kernel/private_call_request.js';
import { PrivateCircuitPublicInputs } from '../kernel/private_circuit_public_inputs.js';
import { PrivateLogData } from '../kernel/private_log_data.js';
import { PrivateToRollupKernelCircuitPublicInputs } from '../kernel/private_to_rollup_kernel_circuit_public_inputs.js';
import { CountedPublicCallRequest, PublicCallRequest, PublicCallRequestArrayLengths } from '../kernel/public_call_request.js';
import { PublicKeys, computeAddress } from '../keys/index.js';
import { ContractClassLogFields } from '../logs/index.js';
import { PrivateLog } from '../logs/private_log.js';
import { PublicLog } from '../logs/public_log.js';
import { CountedL2ToL1Message, L2ToL1Message, ScopedL2ToL1Message } from '../messaging/l2_to_l1_message.js';
import { BaseParityInputs } from '../parity/base_parity_inputs.js';
import { ParityPublicInputs } from '../parity/parity_public_inputs.js';
import { RootParityInput } from '../parity/root_parity_input.js';
import { RootParityInputs } from '../parity/root_parity_inputs.js';
import { Proof } from '../proofs/proof.js';
import { ProvingRequestType } from '../proofs/proving_request_type.js';
import { makeRecursiveProof } from '../proofs/recursive_proof.js';
import { AvmProofData } from '../rollup/avm_proof_data.js';
import { BaseOrMergeRollupPublicInputs } from '../rollup/base_or_merge_rollup_public_inputs.js';
import { PrivateBaseRollupHints, PublicBaseRollupHints } from '../rollup/base_rollup_hints.js';
import { BlockMergeRollupInputs } from '../rollup/block_merge_rollup.js';
import { BlockRootOrBlockMergePublicInputs, FeeRecipient } from '../rollup/block_root_or_block_merge_public_inputs.js';
import { BlockRootRollupBlobData, BlockRootRollupData, BlockRootRollupInputs, SingleTxBlockRootRollupInputs } from '../rollup/block_root_rollup.js';
import { EmptyBlockRootRollupInputs } from '../rollup/empty_block_root_rollup_inputs.js';
import { EpochConstantData } from '../rollup/epoch_constant_data.js';
import { BlockConstantData } from '../rollup/index.js';
import { MergeRollupInputs } from '../rollup/merge_rollup.js';
import { PreviousRollupBlockData } from '../rollup/previous_rollup_block_data.js';
import { PreviousRollupData } from '../rollup/previous_rollup_data.js';
import { PrivateBaseRollupInputs } from '../rollup/private_base_rollup_inputs.js';
import { PrivateTubeData } from '../rollup/private_tube_data.js';
import { PublicBaseRollupInputs } from '../rollup/public_base_rollup_inputs.js';
import { PublicTubeData } from '../rollup/public_tube_data.js';
import { RootRollupInputs, RootRollupPublicInputs } from '../rollup/root_rollup.js';
import { PrivateBaseStateDiffHints } from '../rollup/state_diff_hints.js';
import { AppendOnlyTreeSnapshot } from '../trees/append_only_tree_snapshot.js';
import { MerkleTreeId } from '../trees/merkle_tree_id.js';
import { NullifierLeaf, NullifierLeafPreimage } from '../trees/nullifier_leaf.js';
import { PublicDataTreeLeaf, PublicDataTreeLeafPreimage } from '../trees/public_data_leaf.js';
import { BlockHeader } from '../tx/block_header.js';
import { CallContext } from '../tx/call_context.js';
import { ContentCommitment } from '../tx/content_commitment.js';
import { FunctionData } from '../tx/function_data.js';
import { GlobalVariables } from '../tx/global_variables.js';
import { PartialStateReference } from '../tx/partial_state_reference.js';
import { makeProcessedTxFromPrivateOnlyTx, makeProcessedTxFromTxWithPublicCalls } from '../tx/processed_tx.js';
import { PublicCallRequestWithCalldata } from '../tx/public_call_request_with_calldata.js';
import { StateReference } from '../tx/state_reference.js';
import { TreeSnapshots } from '../tx/tree_snapshots.js';
import { TxConstantData } from '../tx/tx_constant_data.js';
import { TxContext } from '../tx/tx_context.js';
import { TxRequest } from '../tx/tx_request.js';
import { Vector } from '../types/index.js';
import { VkData } from '../vks/index.js';
import { VerificationKey, VerificationKeyAsFields, VerificationKeyData } from '../vks/verification_key.js';
import { mockTx } from './mocks.js';
/**
 * Creates an arbitrary side effect object with the given seed.
 * @param seed - The seed to use for generating the object.
 * @returns A side effect object.
 */ function makeLogHash(seed) {
    return new LogHash(fr(seed), seed + 1);
}
function makeCountedLogHash(seed) {
    return new CountedLogHash(makeLogHash(seed), seed + 0x10);
}
function makeScopedLogHash(seed) {
    return new ScopedLogHash(makeLogHash(seed), makeAztecAddress(seed + 3));
}
function makeNoteHash(seed) {
    return new NoteHash(fr(seed), seed + 1);
}
function makeNullifier(seed) {
    return new Nullifier(fr(seed), seed + 1, fr(seed + 2));
}
function makePrivateLog(seed) {
    return new PrivateLog(makeTuple(PRIVATE_LOG_SIZE_IN_FIELDS, fr, seed), PRIVATE_LOG_SIZE_IN_FIELDS);
}
function makePrivateLogData(seed) {
    return new PrivateLogData(makePrivateLog(seed + 0x100), seed, seed + 1);
}
function makePublicLog(seed) {
    return new PublicLog(makeAztecAddress(seed), makeTuple(PUBLIC_LOG_SIZE_IN_FIELDS, fr, seed + 1), PUBLIC_LOG_SIZE_IN_FIELDS);
}
/**
 * Creates an arbitrary tx context with the given seed.
 * @param seed - The seed to use for generating the tx context.
 * @returns A tx context.
 */ export function makeTxContext(seed = 1) {
    // @todo @LHerskind should probably take value for chainId as it will be verified later.
    return new TxContext(new Fr(seed), Fr.ZERO, makeGasSettings());
}
/**
 * Creates a default instance of gas settings. No seed value is used to ensure we allocate a sensible amount of gas for testing.
 */ export function makeGasSettings() {
    return GasSettings.default({
        maxFeesPerGas: new GasFees(10, 10)
    });
}
/**
 * Creates arbitrary selector from the given seed.
 * @param seed - The seed to use for generating the selector.
 * @returns A selector.
 */ export function makeSelector(seed) {
    return new FunctionSelector(seed);
}
function makeReadRequest(n) {
    return new ReadRequest(new Fr(BigInt(n)), n + 1);
}
/**
 * Creates arbitrary KeyValidationRequest from the given seed.
 * @param seed - The seed to use for generating the KeyValidationRequest.
 * @returns A KeyValidationRequest.
 */ function makeKeyValidationRequests(seed) {
    return new KeyValidationRequest(makePoint(seed), fr(seed + 2));
}
/**
 * Creates arbitrary KeyValidationRequestAndGenerator from the given seed.
 * @param seed - The seed to use for generating the KeyValidationRequestAndGenerator.
 * @returns A KeyValidationRequestAndGenerator.
 */ function makeKeyValidationRequestAndGenerators(seed) {
    return new KeyValidationRequestAndGenerator(makeKeyValidationRequests(seed), fr(seed + 4));
}
function makePublicDataWrite(seed = 1) {
    return new PublicDataWrite(fr(seed), fr(seed + 1));
}
/**
 * Creates arbitrary public data read.
 * @param seed - The seed to use for generating the public data read.
 * @returns A public data read.
 */ export function makePublicDataRead(seed = 1) {
    return new PublicDataRead(fr(seed), fr(seed + 1), 0);
}
/**
 * Creates empty public data read.
 * @returns An empty public data read.
 */ export function makeEmptyPublicDataRead() {
    return new PublicDataRead(fr(0), fr(0), 0);
}
/**
 * Creates arbitrary contract storage update request.
 * @param seed - The seed to use for generating the contract storage update request.
 * @returns A contract storage update request.
 */ export function makeContractStorageUpdateRequest(seed = 1) {
    return new ContractStorageUpdateRequest(fr(seed), fr(seed + 1), seed + 2);
}
/**
 * Creates arbitrary contract storage read.
 * @param seed - The seed to use for generating the contract storage read.
 * @returns A contract storage read.
 */ export function makeContractStorageRead(seed = 1) {
    return new ContractStorageRead(fr(seed), fr(seed + 1), seed + 2);
}
function makeTxConstantData(seed = 1) {
    return new TxConstantData(makeHeader(seed), makeTxContext(seed + 0x100), new Fr(seed + 0x200), new Fr(seed + 0x201));
}
/**
 * Creates arbitrary accumulated data.
 * @param seed - The seed to use for generating the accumulated data.
 * @returns An accumulated data.
 */ export function makePrivateToRollupAccumulatedData(seed = 1, full = false) {
    const tupleGenerator = full ? makeTuple : makeHalfFullTuple;
    return new PrivateToRollupAccumulatedData(tupleGenerator(MAX_NOTE_HASHES_PER_TX, fr, seed + 0x120, Fr.zero), tupleGenerator(MAX_NULLIFIERS_PER_TX, fr, seed + 0x200, Fr.zero), tupleGenerator(MAX_L2_TO_L1_MSGS_PER_TX, makeScopedL2ToL1Message, seed + 0x600, ScopedL2ToL1Message.empty), tupleGenerator(MAX_PRIVATE_LOGS_PER_TX, makePrivateLog, seed + 0x700, PrivateLog.empty), tupleGenerator(MAX_CONTRACT_CLASS_LOGS_PER_TX, makeScopedLogHash, seed + 0xa00, ScopedLogHash.empty));
}
export function makePrivateToPublicAccumulatedData(seed = 1) {
    return new PrivateToPublicAccumulatedData(makeTuple(MAX_NOTE_HASHES_PER_TX, fr, seed), makeTuple(MAX_NULLIFIERS_PER_TX, fr, seed + 0x100), makeTuple(MAX_L2_TO_L1_MSGS_PER_TX, makeScopedL2ToL1Message, seed + 0x200), makeTuple(MAX_PRIVATE_LOGS_PER_TX, makePrivateLog, seed + 0x700), makeTuple(MAX_CONTRACT_CLASS_LOGS_PER_TX, makeScopedLogHash, seed + 0x900), makeTuple(MAX_ENQUEUED_CALLS_PER_TX, makePublicCallRequest, seed + 0x500));
}
function makePrivateToAvmAccumulatedData(seed = 1) {
    return new PrivateToAvmAccumulatedData(makeTuple(MAX_NOTE_HASHES_PER_TX, fr, seed), makeTuple(MAX_NULLIFIERS_PER_TX, fr, seed + 0x100), makeTuple(MAX_L2_TO_L1_MSGS_PER_TX, makeScopedL2ToL1Message, seed + 0x200));
}
function makePrivateToAvmAccumulatedDataArrayLengths(seed = 1) {
    return new PrivateToAvmAccumulatedDataArrayLengths(seed, seed + 1, seed + 2);
}
function makeAvmAccumulatedData(seed = 1) {
    return new AvmAccumulatedData(makeTuple(MAX_NOTE_HASHES_PER_TX, fr, seed), makeTuple(MAX_NULLIFIERS_PER_TX, fr, seed + 0x100), makeTuple(MAX_L2_TO_L1_MSGS_PER_TX, makeScopedL2ToL1Message, seed + 0x200), makeTuple(MAX_PUBLIC_LOGS_PER_TX, makePublicLog, seed + 0x300), makeTuple(MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX, makePublicDataWrite, seed + 0x400));
}
function makeAvmAccumulatedDataArrayLengths(seed = 1) {
    return new AvmAccumulatedDataArrayLengths(seed, seed + 1, seed + 2, seed + 3, seed + 4);
}
export function makeGas(seed = 1) {
    return new Gas(seed, seed + 1);
}
/**
 * Creates arbitrary call context.
 * @param seed - The seed to use for generating the call context.
 * @returns A call context.
 */ export function makeCallContext(seed = 0, overrides = {}) {
    return CallContext.from({
        msgSender: makeAztecAddress(seed),
        contractAddress: makeAztecAddress(seed + 1),
        functionSelector: makeSelector(seed + 3),
        isStaticCall: false,
        ...overrides
    });
}
/**
 * Creates arbitrary private kernel tail circuit public inputs.
 * @param seed - The seed to use for generating the kernel circuit public inputs.
 * @returns Private kernel tail circuit public inputs.
 */ export function makePrivateKernelTailCircuitPublicInputs(seed = 1, isForPublic = true) {
    const forPublic = isForPublic ? new PartialPrivateTailPublicInputsForPublic(makePrivateToPublicAccumulatedData(seed + 0x100), makePrivateToPublicAccumulatedData(seed + 0x200), makePublicCallRequest(seed + 0x400)) : undefined;
    const forRollup = !isForPublic ? new PartialPrivateTailPublicInputsForRollup(makePrivateToRollupAccumulatedData(seed + 0x100)) : undefined;
    return new PrivateKernelTailCircuitPublicInputs(makeTxConstantData(seed + 0x300), makeGas(seed + 0x600), makeAztecAddress(seed + 0x700), BigInt(seed + 0x800), forPublic, forRollup);
}
function makePrivateToPublicKernelCircuitPublicInputs(seed = 1) {
    return new PrivateToPublicKernelCircuitPublicInputs(makeTxConstantData(seed), makePrivateToPublicAccumulatedData(seed + 0x200), makePrivateToPublicAccumulatedData(seed + 0x300), makePublicCallRequest(seed + 0x400), makeGas(seed + 0x500), makeAztecAddress(seed + 0x600), BigInt(seed + 0x700));
}
/**
 * Creates arbitrary public kernel circuit public inputs.
 * @param seed - The seed to use for generating the kernel circuit public inputs.
 * @returns Public kernel circuit public inputs.
 */ export function makePrivateToRollupKernelCircuitPublicInputs(seed = 1, fullAccumulatedData = true) {
    return new PrivateToRollupKernelCircuitPublicInputs(makeTxConstantData(seed + 0x100), makePrivateToRollupAccumulatedData(seed, fullAccumulatedData), makeGas(seed + 0x600), makeAztecAddress(seed + 0x700), BigInt(seed + 0x800));
}
function makeAvmCircuitPublicInputs(seed = 1) {
    return new AvmCircuitPublicInputs(makeGlobalVariables(seed), makeTreeSnapshots(seed + 0x10), makeGas(seed + 0x20), makeGasSettings(), makeGasFees(seed + 0x30), makeAztecAddress(seed + 0x40), makePublicCallRequestArrayLengths(seed + 0x40), makeTuple(MAX_ENQUEUED_CALLS_PER_TX, makePublicCallRequest, seed + 0x100), makeTuple(MAX_ENQUEUED_CALLS_PER_TX, makePublicCallRequest, seed + 0x200), makePublicCallRequest(seed + 0x300), makePrivateToAvmAccumulatedDataArrayLengths(seed + 0x400), makePrivateToAvmAccumulatedDataArrayLengths(seed + 0x410), makePrivateToAvmAccumulatedData(seed + 0x500), makePrivateToAvmAccumulatedData(seed + 0x600), makeTreeSnapshots(seed + 0x700), makeGas(seed + 0x750), makeAvmAccumulatedDataArrayLengths(seed + 0x800), makeAvmAccumulatedData(seed + 0x800), fr(seed + 0x900), false);
}
function makeSiblingPath(seed, size) {
    return makeTuple(size, fr, seed);
}
/**
 * Creates arbitrary/mocked membership witness where the sibling paths is an array of fields in an ascending order starting from `start`.
 * @param size - The size of the membership witness.
 * @param start - The start of the membership witness.
 * @returns A membership witness.
 */ export function makeMembershipWitness(size, start) {
    return new MembershipWitness(size, BigInt(start), makeSiblingPath(start, size));
}
/**
 * Creates arbitrary/mocked verification key in fields format.
 * @returns A verification key as fields object
 */ export function makeVerificationKeyAsFields(size) {
    return VerificationKeyAsFields.makeFake(size);
}
/**
 * Creates arbitrary/mocked verification key.
 * @returns A verification key object
 */ export function makeVerificationKey() {
    return VerificationKey.makeFake();
}
/**
 * Creates an arbitrary point in a curve.
 * @param seed - Seed to generate the point values.
 * @returns A point.
 */ export function makePoint(seed = 1) {
    return new Point(fr(seed), fr(seed + 1), false);
}
/**
 * Creates an arbitrary grumpkin scalar.
 * @param seed - Seed to generate the values.
 * @returns A GrumpkinScalar.
 */ export function makeGrumpkinScalar(seed = 1) {
    return GrumpkinScalar.fromHighLow(fr(seed), fr(seed + 1));
}
/**
 * Makes arbitrary proof.
 * @param seed - The seed to use for generating/mocking the proof.
 * @returns A proof.
 */ export function makeProof(seed = 1) {
    return new Proof(Buffer.alloc(16, seed), 0);
}
function makePrivateCallRequest(seed = 1) {
    return new PrivateCallRequest(makeCallContext(seed + 0x1), fr(seed + 0x3), fr(seed + 0x4), seed + 0x10, seed + 0x11);
}
export function makePublicCallRequest(seed = 1) {
    return new PublicCallRequest(makeAztecAddress(seed), makeAztecAddress(seed + 1), false, fr(seed + 0x3));
}
export function makePublicCallRequestArrayLengths(seed = 1) {
    return new PublicCallRequestArrayLengths(seed, seed + 1, seed % 2 === 0);
}
function makeCountedPublicCallRequest(seed = 1) {
    return new CountedPublicCallRequest(makePublicCallRequest(seed), seed + 0x100);
}
/**
 * Makes arbitrary tx request.
 * @param seed - The seed to use for generating the tx request.
 * @returns A tx request.
 */ export function makeTxRequest(seed = 1) {
    return TxRequest.from({
        origin: makeAztecAddress(seed),
        functionData: new FunctionData(makeSelector(seed + 0x100), /*isPrivate=*/ true),
        argsHash: fr(seed + 0x200),
        txContext: makeTxContext(seed + 0x400),
        salt: fr(seed + 0x500)
    });
}
function makeClaimedLengthArray(arraySize, makeItem, seed, length = arraySize) {
    return new ClaimedLengthArray(makeTuple(arraySize, makeItem, seed), length);
}
/**
 * Makes arbitrary private circuit public inputs.
 * @param seed - The seed to use for generating the private circuit public inputs.
 * @returns A private circuit public inputs.
 */ export function makePrivateCircuitPublicInputs(seed = 0) {
    return PrivateCircuitPublicInputs.from({
        includeByTimestamp: BigInt(seed + 0x31415),
        callContext: makeCallContext(seed, {
            isStaticCall: true
        }),
        argsHash: fr(seed + 0x100),
        returnsHash: fr(seed + 0x200),
        minRevertibleSideEffectCounter: fr(0),
        noteHashReadRequests: makeClaimedLengthArray(MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, makeReadRequest, seed + 0x300),
        nullifierReadRequests: makeClaimedLengthArray(MAX_NULLIFIER_READ_REQUESTS_PER_CALL, makeReadRequest, seed + 0x310),
        keyValidationRequestsAndGenerators: makeClaimedLengthArray(MAX_KEY_VALIDATION_REQUESTS_PER_CALL, makeKeyValidationRequestAndGenerators, seed + 0x320),
        noteHashes: makeClaimedLengthArray(MAX_NOTE_HASHES_PER_CALL, makeNoteHash, seed + 0x400),
        nullifiers: makeClaimedLengthArray(MAX_NULLIFIERS_PER_CALL, makeNullifier, seed + 0x500),
        privateCallRequests: makeClaimedLengthArray(MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, makePrivateCallRequest, seed + 0x600),
        publicCallRequests: makeClaimedLengthArray(MAX_ENQUEUED_CALLS_PER_CALL, makeCountedPublicCallRequest, seed + 0x700),
        publicTeardownCallRequest: makePublicCallRequest(seed + 0x800),
        l2ToL1Msgs: makeClaimedLengthArray(MAX_L2_TO_L1_MSGS_PER_CALL, makeCountedL2ToL1Message, seed + 0x800),
        privateLogs: makeClaimedLengthArray(MAX_PRIVATE_LOGS_PER_CALL, makePrivateLogData, seed + 0x875),
        contractClassLogsHashes: makeClaimedLengthArray(MAX_CONTRACT_CLASS_LOGS_PER_TX, makeCountedLogHash, seed + 0xa00),
        startSideEffectCounter: fr(seed + 0x849),
        endSideEffectCounter: fr(seed + 0x850),
        historicalHeader: makeHeader(seed + 0xd00, undefined),
        txContext: makeTxContext(seed + 0x1400),
        isFeePayer: false
    });
}
export function makeGlobalVariables(seed = 1, overrides = {}) {
    return GlobalVariables.from({
        chainId: new Fr(seed),
        version: new Fr(seed + 1),
        blockNumber: seed + 2,
        slotNumber: new Fr(seed + 3),
        timestamp: BigInt(seed + 4),
        coinbase: EthAddress.fromField(new Fr(seed + 5)),
        feeRecipient: AztecAddress.fromField(new Fr(seed + 6)),
        gasFees: new GasFees(seed + 7, seed + 8),
        ...compact(overrides)
    });
}
export function makeGasFees(seed = 1) {
    return new GasFees(seed, seed + 1);
}
export function makeFeeRecipient(seed = 1) {
    return new FeeRecipient(EthAddress.fromField(fr(seed)), fr(seed + 1));
}
/**
 * Makes arbitrary append only tree snapshot.
 * @param seed - The seed to use for generating the append only tree snapshot.
 * @returns An append only tree snapshot.
 */ export function makeAppendOnlyTreeSnapshot(seed = 1) {
    return new AppendOnlyTreeSnapshot(fr(seed), seed);
}
/**
 * Makes arbitrary eth address.
 * @param seed - The seed to use for generating the eth address.
 * @returns An eth address.
 */ export function makeEthAddress(seed = 1) {
    return EthAddress.fromField(fr(seed));
}
/**
 * Creates a buffer of a given size filled with a given value.
 * @param size - The size of the buffer to create.
 * @param fill - The value to fill the buffer with.
 * @returns A buffer of a given size filled with a given value.
 */ export function makeBytes(size = 32, fill = 1) {
    return Buffer.alloc(size, fill);
}
/**
 * Makes arbitrary aztec address.
 * @param seed - The seed to use for generating the aztec address.
 * @returns An aztec address.
 */ export function makeAztecAddress(seed = 1) {
    return AztecAddress.fromField(fr(seed));
}
/**
 * Makes arbitrary Schnorr signature.
 * @param seed - The seed to use for generating the Schnorr signature.
 * @returns A Schnorr signature.
 */ export function makeSchnorrSignature(seed = 1) {
    return new SchnorrSignature(Buffer.alloc(SchnorrSignature.SIZE, seed));
}
function makeBlockConstantData(seed = 1, globalVariables) {
    return new BlockConstantData(makeAppendOnlyTreeSnapshot(seed + 0x100), makeAppendOnlyTreeSnapshot(seed + 0x200), fr(seed + 0x300), fr(seed + 0x400), globalVariables ?? makeGlobalVariables(seed + 0x500));
}
/**
 * Makes arbitrary base or merge rollup circuit public inputs.
 * @param seed - The seed to use for generating the base rollup circuit public inputs.
 * @param blockNumber - The block number to use for generating the base rollup circuit public inputs.
 * @returns A base or merge rollup circuit public inputs.
 */ export function makeBaseOrMergeRollupPublicInputs(seed = 0, globalVariables = undefined) {
    return new BaseOrMergeRollupPublicInputs(1, makeBlockConstantData(seed + 0x200, globalVariables), makePartialStateReference(seed + 0x300), makePartialStateReference(seed + 0x400), makeSpongeBlob(seed + 0x500), makeSpongeBlob(seed + 0x600), fr(seed + 0x901), fr(seed + 0x902), fr(seed + 0x903));
}
function makeEpochConstantData(seed = 1) {
    return new EpochConstantData(fr(seed), fr(seed + 1), fr(seed + 2));
}
/**
 * Makes arbitrary block merge or block root rollup circuit public inputs.
 * @param seed - The seed to use for generating the block merge or block root rollup circuit public inputs.
 * @param blockNumber - The block number to use for generating the block merge or block root rollup circuit public inputs.
 * @returns A block merge or block root rollup circuit public inputs.
 */ export function makeBlockRootOrBlockMergeRollupPublicInputs(seed = 0, globalVariables = undefined) {
    return new BlockRootOrBlockMergePublicInputs(makeEpochConstantData(seed + 0x100), makeAppendOnlyTreeSnapshot(seed + 0x200), makeAppendOnlyTreeSnapshot(seed + 0x300), globalVariables ?? makeGlobalVariables(seed + 0x400), globalVariables ?? makeGlobalVariables(seed + 0x500), fr(seed + 0x600), makeTuple(AZTEC_MAX_EPOCH_DURATION, ()=>fr(seed), 0x650), makeTuple(AZTEC_MAX_EPOCH_DURATION, ()=>makeFeeRecipient(seed), 0x700), makeBlockBlobPublicInputs(seed));
}
/**
 * Makes arbitrary previous rollup data.
 * @param seed - The seed to use for generating the previous rollup data.
 * @param globalVariables - The global variables to use when generating the previous rollup data.
 * @returns A previous rollup data.
 */ export function makePreviousRollupData(seed = 0, globalVariables = undefined) {
    return new PreviousRollupData(makeBaseOrMergeRollupPublicInputs(seed, globalVariables), makeRecursiveProof(NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, seed + 0x50), makeVkData(seed + 0x100));
}
/**
 * Makes arbitrary previous rollup block data.
 * @param seed - The seed to use for generating the previous rollup block data.
 * @param globalVariables - The global variables to use when generating the previous rollup block data.
 * @returns A previous rollup block data.
 */ export function makePreviousRollupBlockData(seed = 0, globalVariables = undefined) {
    return new PreviousRollupBlockData(makeBlockRootOrBlockMergeRollupPublicInputs(seed, globalVariables), makeRecursiveProof(NESTED_RECURSIVE_ROLLUP_HONK_PROOF_LENGTH, seed + 0x50), makeVkData(seed + 0x100));
}
/**
 * Makes root rollup inputs.
 * @param seed - The seed to use for generating the root rollup inputs.
 * @param globalVariables - The global variables to use.
 * @returns A root rollup inputs.
 */ export function makeRootRollupInputs(seed = 0, globalVariables) {
    return new RootRollupInputs([
        makePreviousRollupBlockData(seed, globalVariables),
        makePreviousRollupBlockData(seed + 0x1000, globalVariables)
    ]);
}
function makeBlockRootRollupData(seed = 0) {
    return new BlockRootRollupData(makeRootParityInput(NESTED_RECURSIVE_PROOF_LENGTH, seed + 0x2000), makeTuple(L1_TO_L2_MSG_SUBTREE_SIBLING_PATH_LENGTH, fr, 0x2100), makeTuple(ARCHIVE_HEIGHT, fr, 0x2200), makeTuple(ARCHIVE_HEIGHT, fr, 0x2300), makeHeader(seed + 0x2400), BlobAccumulatorPublicInputs.fromBatchedBlobAccumulator(makeBatchedBlobAccumulator(seed + 0x2500)), makeBatchedBlobAccumulator(seed + 0x2600).finalBlobChallenges, fr(seed + 0x2700));
}
function makeBlockRootRollupBlobData(seed = 0) {
    return new BlockRootRollupBlobData(makeTuple(FIELDS_PER_BLOB * BLOBS_PER_BLOCK, fr, 0x2500), makeTuple(BLOBS_PER_BLOCK, ()=>BLS12Point.random()), fr(seed + 0x2700));
}
/**
 * Makes block root rollup inputs.
 * @param seed - The seed to use for generating the root rollup inputs.
 * @param globalVariables - The global variables to use.
 * @returns A block root rollup inputs.
 */ export function makeBlockRootRollupInputs(seed = 0, globalVariables) {
    return new BlockRootRollupInputs([
        makePreviousRollupData(seed, globalVariables),
        makePreviousRollupData(seed + 0x1000, globalVariables)
    ], makeBlockRootRollupData(seed + 0x2000), makeBlockRootRollupBlobData(seed + 0x4000));
}
export function makeSingleTxBlockRootRollupInputs(seed = 0, globalVariables) {
    return new SingleTxBlockRootRollupInputs([
        makePreviousRollupData(seed, globalVariables)
    ], makeBlockRootRollupData(seed + 0x2000), makeBlockRootRollupBlobData(seed + 0x4000));
}
/**
 * Makes empty block root rollup inputs.
 * @param seed - The seed to use for generating the root rollup inputs.
 * @param globalVariables - The global variables to use.
 * @returns A block root rollup inputs.
 */ export function makeEmptyBlockRootRollupInputs(seed = 0, globalVariables) {
    return new EmptyBlockRootRollupInputs(makeBlockRootRollupData(seed + 0x1000), makeBlockConstantData(0x2500, globalVariables));
}
export function makeRootParityInput(proofSize, seed = 0) {
    return new RootParityInput(makeRecursiveProof(proofSize, seed), VerificationKeyAsFields.makeFake(seed + 0x100), makeTuple(VK_TREE_HEIGHT, fr, 0x200), makeParityPublicInputs(seed + 0x300));
}
export function makeParityPublicInputs(seed = 0) {
    return new ParityPublicInputs(new Fr(BigInt(seed + 0x200)), new Fr(BigInt(seed + 0x300)), new Fr(BigInt(seed + 0x400)));
}
export function makeBaseParityInputs(seed = 0) {
    return new BaseParityInputs(makeTuple(NUM_MSGS_PER_BASE_PARITY, fr, seed + 0x3000), new Fr(seed + 0x4000));
}
export function makeRootParityInputs(seed = 0) {
    return new RootParityInputs(makeTuple(NUM_BASE_PARITY_PER_ROOT_PARITY, ()=>makeRootParityInput(RECURSIVE_PROOF_LENGTH), seed + 0x4100));
}
/**
 * Makes root rollup public inputs.
 * @param seed - The seed to use for generating the root rollup public inputs.
 * @param blockNumber - The block number to use in the global variables of a header.
 * @returns A root rollup public inputs.
 */ export function makeRootRollupPublicInputs(seed = 0) {
    return new RootRollupPublicInputs(fr(seed + 0x100), fr(seed + 0x200), makeTuple(AZTEC_MAX_EPOCH_DURATION, ()=>fr(seed), 0x300), makeTuple(AZTEC_MAX_EPOCH_DURATION, ()=>makeFeeRecipient(seed), 0x500), fr(seed + 0x700), fr(seed + 0x701), fr(seed + 0x702), fr(seed + 0x703), fr(seed + 0x704), FinalBlobAccumulatorPublicInputs.fromBatchedBlobAccumulator(makeBatchedBlobAccumulator(seed)));
}
/**
 * Makes content commitment
 */ export function makeContentCommitment(seed = 0) {
    return new ContentCommitment(fr(seed + 0x100), fr(seed + 0x200), fr(seed + 0x300));
}
/**
 * Makes header.
 */ export function makeHeader(seed = 0, blockNumber = undefined, slotNumber = undefined, overrides = {}) {
    return BlockHeader.from({
        lastArchive: makeAppendOnlyTreeSnapshot(seed + 0x100),
        contentCommitment: makeContentCommitment(seed + 0x200),
        state: makeStateReference(seed + 0x600),
        globalVariables: makeGlobalVariables(seed += 0x700, {
            ...blockNumber ? {
                blockNumber
            } : {},
            ...slotNumber ? {
                slotNumber: new Fr(slotNumber)
            } : {}
        }),
        totalFees: fr(seed + 0x800),
        totalManaUsed: fr(seed + 0x900),
        ...overrides
    });
}
/**
 * Makes arbitrary state reference.
 * @param seed - The seed to use for generating the state reference.
 * @returns A state reference.
 */ export function makeStateReference(seed = 0) {
    return new StateReference(makeAppendOnlyTreeSnapshot(NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP * seed), makePartialStateReference(seed + 1));
}
function makeTreeSnapshots(seed = 0) {
    return new TreeSnapshots(makeAppendOnlyTreeSnapshot(seed * NUMBER_OF_L1_L2_MESSAGES_PER_ROLLUP), makeAppendOnlyTreeSnapshot((seed + 0x10) * MAX_NOTE_HASHES_PER_TX), makeAppendOnlyTreeSnapshot((seed + 0x20) * MAX_NULLIFIERS_PER_TX), makeAppendOnlyTreeSnapshot((seed + 0x30) * MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX));
}
/**
 * Makes arbitrary L2 to L1 message.
 * @param seed - The seed to use for generating the state reference.
 * @returns L2 to L1 message.
 */ export function makeL2ToL1Message(seed = 0) {
    const recipient = EthAddress.fromField(new Fr(seed));
    const content = new Fr(seed + 1);
    return new L2ToL1Message(recipient, content);
}
function makeCountedL2ToL1Message(seed = 0) {
    return new CountedL2ToL1Message(makeL2ToL1Message(seed), seed + 2);
}
function makeScopedL2ToL1Message(seed = 1) {
    return new ScopedL2ToL1Message(makeL2ToL1Message(seed), makeAztecAddress(seed + 3));
}
/**
 * Makes arbitrary partial state reference.
 * @param seed - The seed to use for generating the partial state reference.
 * @returns A partial state reference.
 */ export function makePartialStateReference(seed = 0) {
    return new PartialStateReference(makeAppendOnlyTreeSnapshot(MAX_NOTE_HASHES_PER_TX * seed), makeAppendOnlyTreeSnapshot(MAX_NULLIFIERS_PER_TX * (seed + 1)), makeAppendOnlyTreeSnapshot(MAX_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX * (seed + 2)));
}
/**
 * Makes arbitrary merge rollup inputs.
 * @param seed - The seed to use for generating the merge rollup inputs.
 * @returns A merge rollup inputs.
 */ export function makeMergeRollupInputs(seed = 0) {
    return new MergeRollupInputs([
        makePreviousRollupData(seed),
        makePreviousRollupData(seed + 0x1000)
    ]);
}
/**
 * Makes arbitrary block merge rollup inputs.
 * @param seed - The seed to use for generating the merge rollup inputs.
 * @returns A block merge rollup inputs.
 */ export function makeBlockMergeRollupInputs(seed = 0) {
    return new BlockMergeRollupInputs([
        makePreviousRollupBlockData(seed),
        makePreviousRollupBlockData(seed + 0x1000)
    ]);
}
/**
 * Makes arbitrary public data tree leaves.
 * @param seed - The seed to use for generating the public data tree leaf.
 * @returns A public data tree leaf.
 */ export function makePublicDataTreeLeaf(seed = 0) {
    return new PublicDataTreeLeaf(new Fr(seed), new Fr(seed + 1));
}
/**
 * Makes arbitrary nullifier leaf.
 * @param seed - The seed to use for generating the nullifier leaf.
 * @returns A nullifier leaf.
 */ export function makeNullifierLeaf(seed = 0) {
    return new NullifierLeaf(new Fr(seed));
}
/**
 * Makes arbitrary nullifier leaf preimages.
 * @param seed - The seed to use for generating the nullifier leaf preimage.
 * @returns A nullifier leaf preimage.
 */ export function makeNullifierLeafPreimage(seed = 0) {
    return new NullifierLeafPreimage(makeNullifierLeaf(seed), new Fr(seed + 1), BigInt(seed + 2));
}
/**
 * Makes arbitrary public data tree leaf preimages.
 * @param seed - The seed to use for generating the public data tree leaf preimage.
 * @returns A public data tree leaf preimage.
 */ export function makePublicDataTreeLeafPreimage(seed = 0) {
    return new PublicDataTreeLeafPreimage(makePublicDataTreeLeaf(seed), new Fr(seed + 2), BigInt(seed + 3));
}
/**
 * Creates an instance of PrivateBaseStateDiffHints with arbitrary values based on the provided seed.
 * @param seed - The seed to use for generating the hints.
 * @returns A PrivateBaseStateDiffHints object.
 */ export function makePrivateBaseStateDiffHints(seed = 1) {
    const nullifierPredecessorPreimages = makeTuple(MAX_NULLIFIERS_PER_TX, (x)=>makeNullifierLeafPreimage(x), seed + 0x1000);
    const nullifierPredecessorMembershipWitnesses = makeTuple(MAX_NULLIFIERS_PER_TX, (x)=>makeMembershipWitness(NULLIFIER_TREE_HEIGHT, x), seed + 0x2000);
    const sortedNullifiers = makeTuple(MAX_NULLIFIERS_PER_TX, fr, seed + 0x3000);
    const sortedNullifierIndexes = makeTuple(MAX_NULLIFIERS_PER_TX, (i)=>i, seed + 0x4000);
    const noteHashSubtreeSiblingPath = makeTuple(NOTE_HASH_SUBTREE_SIBLING_PATH_LENGTH, fr, seed + 0x5000);
    const nullifierSubtreeSiblingPath = makeTuple(NULLIFIER_SUBTREE_SIBLING_PATH_LENGTH, fr, seed + 0x6000);
    const feeWriteLowLeafPreimage = makePublicDataTreeLeafPreimage(seed + 0x7000);
    const feeWriteLowLeafMembershipWitness = makeMembershipWitness(PUBLIC_DATA_TREE_HEIGHT, seed + 0x8000);
    const feeWriteSiblingPath = makeTuple(PUBLIC_DATA_TREE_HEIGHT, fr, seed + 0x9000);
    return new PrivateBaseStateDiffHints(nullifierPredecessorPreimages, nullifierPredecessorMembershipWitnesses, sortedNullifiers, sortedNullifierIndexes, noteHashSubtreeSiblingPath, nullifierSubtreeSiblingPath, feeWriteLowLeafPreimage, feeWriteLowLeafMembershipWitness, feeWriteSiblingPath);
}
function makeVkData(seed = 1) {
    return new VkData(VerificationKeyData.makeFakeHonk(), seed, makeTuple(VK_TREE_HEIGHT, fr, seed + 0x100));
}
function makePrivateTubeData(seed = 1, kernelPublicInputs) {
    return new PrivateTubeData(kernelPublicInputs ?? makePrivateToRollupKernelCircuitPublicInputs(seed, true), makeRecursiveProof(TUBE_PROOF_LENGTH, seed + 0x100), makeVkData(seed + 0x200));
}
function makeContractClassLogFields(seed = 1) {
    return new ContractClassLogFields(makeArray(CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, fr, seed));
}
function makePrivateBaseRollupHints(seed = 1) {
    const start = makePartialStateReference(seed + 0x100);
    const startSpongeBlob = makeSpongeBlob(seed + 0x200);
    const stateDiffHints = makePrivateBaseStateDiffHints(seed + 0x600);
    const archiveRootMembershipWitness = makeMembershipWitness(ARCHIVE_HEIGHT, seed + 0x9000);
    const contractClassLogsFields = makeTuple(MAX_CONTRACT_CLASS_LOGS_PER_TX, makeContractClassLogFields, seed + 0x800);
    const constants = makeBlockConstantData(0x100);
    const feePayerFeeJuiceBalanceReadHint = PublicDataHint.empty();
    return PrivateBaseRollupHints.from({
        start,
        startSpongeBlob,
        stateDiffHints,
        feePayerFeeJuiceBalanceReadHint,
        archiveRootMembershipWitness,
        contractClassLogsFields,
        constants
    });
}
function makePublicBaseRollupHints(seed = 1) {
    return PublicBaseRollupHints.from({
        startSpongeBlob: makeSpongeBlob(seed),
        lastArchive: makeAppendOnlyTreeSnapshot(seed + 0x1000),
        archiveRootMembershipWitness: makeMembershipWitness(ARCHIVE_HEIGHT, seed + 0x2000),
        contractClassLogsFields: makeTuple(MAX_CONTRACT_CLASS_LOGS_PER_TX, makeContractClassLogFields, seed + 0x3000)
    });
}
export function makePrivateBaseRollupInputs(seed = 0) {
    const tubeData = makePrivateTubeData(seed);
    const hints = makePrivateBaseRollupHints(seed + 0x100);
    return PrivateBaseRollupInputs.from({
        tubeData,
        hints
    });
}
function makePublicTubeData(seed = 1) {
    return new PublicTubeData(makePrivateToPublicKernelCircuitPublicInputs(seed), makeRecursiveProof(TUBE_PROOF_LENGTH, seed + 0x100), makeVkData(seed + 0x200));
}
function makeAvmProofData(seed = 1) {
    return new AvmProofData(makeAvmCircuitPublicInputs(seed), makeRecursiveProof(AVM_V2_PROOF_LENGTH_IN_FIELDS_PADDED, seed + 0x100), makeVkData(seed + 0x200));
}
export function makePublicBaseRollupInputs(seed = 0) {
    const tubeData = makePublicTubeData(seed);
    const avmProofData = makeAvmProofData(seed + 0x100);
    const hints = makePublicBaseRollupHints(seed + 0x200);
    return PublicBaseRollupInputs.from({
        tubeData,
        avmProofData,
        hints
    });
}
export function makeExecutablePrivateFunctionWithMembershipProof(seed = 0) {
    return {
        selector: makeSelector(seed),
        bytecode: makeBytes(100, seed + 1),
        artifactTreeSiblingPath: makeTuple(3, fr, seed + 2),
        artifactTreeLeafIndex: seed + 2,
        privateFunctionTreeSiblingPath: makeTuple(3, fr, seed + 3),
        privateFunctionTreeLeafIndex: seed + 3,
        artifactMetadataHash: fr(seed + 4),
        functionMetadataHash: fr(seed + 5),
        utilityFunctionsTreeRoot: fr(seed + 6),
        vkHash: fr(seed + 7)
    };
}
export function makeUtilityFunctionWithMembershipProof(seed = 0) {
    return {
        selector: makeSelector(seed),
        bytecode: makeBytes(100, seed + 1),
        artifactTreeSiblingPath: makeTuple(3, fr, seed + 2),
        artifactTreeLeafIndex: seed + 2,
        artifactMetadataHash: fr(seed + 4),
        functionMetadataHash: fr(seed + 5),
        privateFunctionsArtifactTreeRoot: fr(seed + 6)
    };
}
export async function makeContractClassPublic(seed = 0, publicBytecode) {
    const artifactHash = fr(seed + 1);
    const privateFunctionsRoot = fr(seed + 3);
    const packedBytecode = publicBytecode ?? makeBytes(100, seed + 4);
    const publicBytecodeCommitment = await computePublicBytecodeCommitment(packedBytecode);
    const id = await computeContractClassId({
        artifactHash,
        privateFunctionsRoot,
        publicBytecodeCommitment
    });
    return {
        id,
        artifactHash,
        packedBytecode,
        privateFunctionsRoot,
        privateFunctions: [],
        utilityFunctions: [],
        version: 1
    };
}
// eslint-disable-next-line @typescript-eslint/no-unused-vars
function makeContractClassPrivateFunction(seed = 0) {
    return {
        selector: FunctionSelector.fromField(fr(seed + 1)),
        vkHash: fr(seed + 2)
    };
}
export function makeArray(length, fn, offset = 0) {
    return Array.from({
        length
    }, (_, i)=>fn(i + offset));
}
export function makeArrayAsync(length, fn, offset = 0) {
    return Promise.all(Array(length).fill(0).map((_, i)=>fn(i + offset)));
}
export function makeVector(length, fn, offset = 0) {
    return new Vector(makeArray(length, fn, offset));
}
export async function makeVectorAsync(length, fn, offset = 0) {
    return new Vector(await makeArrayAsync(length, fn, offset));
}
export function makeMap(size, fn, offset = 0) {
    return new Map(makeArray(size, (i)=>fn(i + offset)));
}
export async function makeMapAsync(size, fn, offset = 0) {
    return new Map(await makeArrayAsync(size, (i)=>fn(i + offset)));
}
export async function makePublicKeys(seed = 0) {
    const f = (offset)=>new Grumpkin().mul(Grumpkin.generator, new Fq(seed + offset));
    return new PublicKeys(await f(0), await f(1), await f(2), await f(3));
}
export async function makeContractInstanceFromClassId(classId, seed = 0, overrides) {
    const salt = new Fr(seed);
    const initializationHash = overrides?.initializationHash ?? new Fr(seed + 1);
    const deployer = overrides?.deployer ?? new AztecAddress(new Fr(seed + 2));
    const publicKeys = overrides?.publicKeys ?? await makePublicKeys(seed + 3);
    const saltedInitializationHash = await poseidon2HashWithSeparator([
        salt,
        initializationHash,
        deployer
    ], GeneratorIndex.PARTIAL_ADDRESS);
    const partialAddress = await poseidon2HashWithSeparator([
        classId,
        saltedInitializationHash
    ], GeneratorIndex.PARTIAL_ADDRESS);
    const address = await computeAddress(publicKeys, partialAddress);
    return new SerializableContractInstance({
        version: 1,
        salt,
        deployer,
        currentContractClassId: overrides?.currentClassId ?? classId,
        originalContractClassId: classId,
        initializationHash,
        publicKeys
    }).withAddress(address);
}
export function makeAvmGetSiblingPathHint(seed = 0) {
    // We want a possibly large index, but non-random.
    const index = BigInt(`0x${sha256(Buffer.from(seed.toString())).toString('hex')}`) % (1n << 64n);
    return new AvmGetSiblingPathHint(makeAppendOnlyTreeSnapshot(seed), /*treeId=*/ (seed + 1) % 5, /*index=*/ index, makeArray(seed % 64, (i)=>new Fr(i), seed + 10));
}
export function makeAvmGetPreviousValueIndexHint(seed = 0) {
    // We want a possibly large index, but non-random.
    const index = BigInt(`0x${sha256(Buffer.from(seed.toString())).toString('hex')}`) % (1n << 64n);
    const value = new Fr(BigInt(`0x${sha256(Buffer.from((seed + 2).toString())).toString('hex')}`) % (1n << 128n));
    return new AvmGetPreviousValueIndexHint(makeAppendOnlyTreeSnapshot(seed), /*treeId=*/ (seed + 1) % 5, value, index, /*alreadyPresent=*/ index % 2n === 0n);
}
export function makeAvmGetLeafPreimageHintPublicDataTree(seed = 0) {
    // We want a possibly large index, but non-random.
    const index = BigInt(`0x${sha256(Buffer.from(seed.toString())).toString('hex')}`) % (1n << 64n);
    return new AvmGetLeafPreimageHintPublicDataTree(makeAppendOnlyTreeSnapshot(seed), /*index=*/ index, /*leafPreimage=*/ makePublicDataTreeLeafPreimage(seed + 3));
}
export function makeAvmGetLeafPreimageHintNullifierTree(seed = 0) {
    // We want a possibly large index, but non-random.
    const index = BigInt(`0x${sha256(Buffer.from(seed.toString())).toString('hex')}`) % (1n << 64n);
    return new AvmGetLeafPreimageHintNullifierTree(makeAppendOnlyTreeSnapshot(seed), /*index=*/ index, /*leafPreimage=*/ makeNullifierLeafPreimage(seed + 3));
}
export function makeAvmGetLeafValueHint(seed = 0) {
    // We want a possibly large index, but non-random.
    const index = BigInt(`0x${sha256(Buffer.from(seed.toString())).toString('hex')}`) % (1n << 64n);
    return new AvmGetLeafValueHint(makeAppendOnlyTreeSnapshot(seed), /*treeId=*/ (seed + 1) % 5, /*index=*/ index, /*value=*/ new Fr(seed + 3));
}
export function makeAvmSequentialInsertHintPublicDataTree(seed = 0) {
    const lowLeavesWitnessData = {
        leaf: makePublicDataTreeLeafPreimage(seed + 3),
        index: BigInt(seed + 4),
        path: makeArray(seed % 64, (i)=>new Fr(i), seed + 5)
    };
    const insertionWitnessData = {
        leaf: makePublicDataTreeLeafPreimage(seed + 6),
        index: BigInt(seed + 7),
        path: makeArray(seed % 64, (i)=>new Fr(i), seed + 8)
    };
    return new AvmSequentialInsertHintPublicDataTree(makeAppendOnlyTreeSnapshot(seed), makeAppendOnlyTreeSnapshot(seed + 1), MerkleTreeId.PUBLIC_DATA_TREE, makePublicDataTreeLeaf(seed + 2), lowLeavesWitnessData, insertionWitnessData);
}
export function makeAvmSequentialInsertHintNullifierTree(seed = 0) {
    const lowLeavesWitnessData = {
        leaf: makeNullifierLeafPreimage(seed + 3),
        index: BigInt(seed + 4),
        path: makeArray(seed % 64, (i)=>new Fr(i), seed + 5)
    };
    const insertionWitnessData = {
        leaf: makeNullifierLeafPreimage(seed + 6),
        index: BigInt(seed + 7),
        path: makeArray(seed % 64, (i)=>new Fr(i), seed + 8)
    };
    return new AvmSequentialInsertHintNullifierTree(makeAppendOnlyTreeSnapshot(seed), makeAppendOnlyTreeSnapshot(seed + 1), MerkleTreeId.NULLIFIER_TREE, makeNullifierLeaf(seed + 2), lowLeavesWitnessData, insertionWitnessData);
}
export function makeAvmAppendLeavesHint(seed = 0) {
    return new AvmAppendLeavesHint(makeAppendOnlyTreeSnapshot(seed), makeAppendOnlyTreeSnapshot(seed + 1), // Use NOTE_HASH_TREE or L1_TO_L2_MESSAGE_TREE as mentioned in the comment on AvmAppendLeavesHint
    seed % 2 === 0 ? MerkleTreeId.NOTE_HASH_TREE : MerkleTreeId.L1_TO_L2_MESSAGE_TREE, makeArray(seed % 5 + 1, (i)=>new Fr(seed + i + 2), 0));
}
export function makeAvmCheckpointActionCreateCheckpointHint(seed = 0) {
    return new AvmCreateCheckpointHint(/*actionCounter=*/ seed, /*oldCheckpointId=*/ seed + 1, /*newCheckpointId=*/ seed + 2);
}
export function makeAvmCheckpointActionCommitCheckpointHint(seed = 0) {
    return new AvmCommitCheckpointHint(/*actionCounter=*/ seed, /*oldCheckpointId=*/ seed + 1, /*newCheckpointId=*/ seed + 2);
}
export function makeAvmCheckpointActionRevertCheckpointHint(seed = 0) {
    return new AvmRevertCheckpointHint(/*actionCounter=*/ seed, /*oldCheckpointId=*/ seed + 1, /*newCheckpointId=*/ seed + 2, /*beforeState=*/ makeTreeSnapshots(seed + 3), /*afterState=*/ makeTreeSnapshots(seed + 7));
}
/**
 * Makes arbitrary AvmContractInstanceHint.
 * @param seed - The seed to use for generating the state reference.
 * @returns AvmContractInstanceHint.
 */ export function makeAvmContractInstanceHint(seed = 0) {
    return new AvmContractInstanceHint(new AztecAddress(new Fr(seed)), new Fr(seed + 0x2), new AztecAddress(new Fr(seed + 0x3)), new Fr(seed + 0x4), new Fr(seed + 0x5), new Fr(seed + 0x6), new PublicKeys(new Point(new Fr(seed + 0x7), new Fr(seed + 0x8), false), new Point(new Fr(seed + 0x9), new Fr(seed + 0x10), false), new Point(new Fr(seed + 0x11), new Fr(seed + 0x12), false), new Point(new Fr(seed + 0x13), new Fr(seed + 0x14), false)));
}
/* Makes arbitrary AvmContractClassHint.
 * @param seed - The seed to use for generating the state reference.
 * @returns AvmContractClassHint.
 */ export function makeAvmContractClassHint(seed = 0) {
    const bytecode = makeBytes(32, seed + 0x5);
    return new AvmContractClassHint(new Fr(seed), new Fr(seed + 0x2), new Fr(seed + 0x3), bytecode);
}
export async function makeAvmBytecodeCommitmentHint(seed = 0) {
    const classId = new Fr(seed + 2);
    const bytecode = makeBytes(32, seed + 0x5);
    return new AvmBytecodeCommitmentHint(classId, await computePublicBytecodeCommitment(bytecode));
}
export async function makePublicCallRequestWithCalldata(seed = 0) {
    const calldata = makeArray(seed % 20 + 4, (i)=>new Fr(i), seed + 0x1000);
    const calldataHash = await computeCalldataHash(calldata);
    const publicCallRequest = new PublicCallRequest(new AztecAddress(new Fr(seed)), new AztecAddress(new Fr(seed + 1)), false, calldataHash);
    return new PublicCallRequestWithCalldata(publicCallRequest, calldata);
}
export async function makeAvmTxHint(seed = 0) {
    return new AvmTxHint(`txhash-${seed}`, makeGasSettings(), makeGasFees(seed + 0x1000), {
        noteHashes: makeArray(seed % 20 + 4, (i)=>new Fr(i), seed + 0x1000),
        nullifiers: makeArray(seed % 20 + 4, (i)=>new Fr(i), seed + 0x2000),
        l2ToL1Messages: makeArray(seed % 20 + 4, (i)=>makeScopedL2ToL1Message(i), seed + 0x3000)
    }, {
        noteHashes: makeArray(seed % 20 + 4, (i)=>new Fr(i), seed + 0x3000),
        nullifiers: makeArray(seed % 20 + 4, (i)=>new Fr(i), seed + 0x4000),
        l2ToL1Messages: makeArray(seed % 20 + 4, (i)=>makeScopedL2ToL1Message(i), seed + 0x5000)
    }, await makeArrayAsync(seed % 20 + 4, (i)=>makePublicCallRequestWithCalldata(i), seed + 0x5000), await makeArrayAsync(seed % 20 + 4, (i)=>makePublicCallRequestWithCalldata(i), seed + 0x6000), await makePublicCallRequestWithCalldata(seed + 0x7000), makeGas(seed + 0x8000), makeAztecAddress(seed + 0x9000));
}
/**
 * Creates arbitrary AvmExecutionHints.
 * @param seed - The seed to use for generating the hints.
 * @returns the execution hints.
 */ export async function makeAvmExecutionHints(seed = 0, overrides = {}) {
    const lengthOffset = 10;
    const lengthSeedMod = 10;
    const baseLength = lengthOffset + seed % lengthSeedMod;
    const fields = {
        globalVariables: makeGlobalVariables(seed + 0x4000),
        tx: await makeAvmTxHint(seed + 0x4100),
        contractInstances: makeArray(baseLength + 2, makeAvmContractInstanceHint, seed + 0x4700),
        contractClasses: makeArray(baseLength + 5, makeAvmContractClassHint, seed + 0x4900),
        bytecodeCommitments: await makeArrayAsync(baseLength + 5, makeAvmBytecodeCommitmentHint, seed + 0x4900),
        startingTreeRoots: makeTreeSnapshots(seed + 0x4900),
        getSiblingPathHints: makeArray(baseLength + 5, makeAvmGetSiblingPathHint, seed + 0x4b00),
        getPreviousValueIndexHints: makeArray(baseLength + 5, makeAvmGetPreviousValueIndexHint, seed + 0x4d00),
        getLeafPreimageHintPublicDataTree: makeArray(baseLength + 5, makeAvmGetLeafPreimageHintPublicDataTree, seed + 0x4f00),
        getLeafPreimageHintNullifierTree: makeArray(baseLength + 5, makeAvmGetLeafPreimageHintNullifierTree, seed + 0x5100),
        getLeafValueHints: makeArray(baseLength + 5, makeAvmGetLeafValueHint, seed + 0x5300),
        sequentialInsertHintsPublicDataTree: makeArray(baseLength + 5, makeAvmSequentialInsertHintPublicDataTree, seed + 0x5500),
        sequentialInsertHintsNullifierTree: makeArray(baseLength + 5, makeAvmSequentialInsertHintNullifierTree, seed + 0x5700),
        appendLeavesHints: makeArray(baseLength + 5, makeAvmAppendLeavesHint, seed + 0x5800),
        createCheckpointHints: makeArray(baseLength + 5, makeAvmCheckpointActionCreateCheckpointHint, seed + 0x5900),
        commitCheckpointHints: makeArray(baseLength + 5, makeAvmCheckpointActionCommitCheckpointHint, seed + 0x5b00),
        revertCheckpointHints: makeArray(baseLength + 5, makeAvmCheckpointActionRevertCheckpointHint, seed + 0x5d00),
        ...overrides
    };
    return new AvmExecutionHints(fields.globalVariables, fields.tx, fields.contractInstances, fields.contractClasses, fields.bytecodeCommitments, fields.startingTreeRoots, fields.getSiblingPathHints, fields.getPreviousValueIndexHints, fields.getLeafPreimageHintPublicDataTree, fields.getLeafPreimageHintNullifierTree, fields.getLeafValueHints, fields.sequentialInsertHintsPublicDataTree, fields.sequentialInsertHintsNullifierTree, fields.appendLeavesHints, fields.createCheckpointHints, fields.commitCheckpointHints, fields.revertCheckpointHints);
}
/**
 * Creates arbitrary AvmCircuitInputs.
 * @param seed - The seed to use for generating the hints.
 * @returns the execution hints.
 */ export async function makeAvmCircuitInputs(seed = 0, overrides = {}) {
    const fields = {
        hints: await makeAvmExecutionHints(seed + 0x3000),
        publicInputs: makeAvmCircuitPublicInputs(seed + 0x4000),
        ...overrides
    };
    return new AvmCircuitInputs(fields.hints, fields.publicInputs);
}
/**
 * TODO: Since the max value check is currently disabled this function is pointless. Should it be removed?
 * Test only. Easy to identify big endian field serialize.
 * @param n - The number.
 * @returns The field.
 */ export function fr(n) {
    return new Fr(BigInt(n));
}
/** Makes a bloated processed tx for testing purposes. */ export async function makeBloatedProcessedTx({ seed = 1, header, db, chainId = Fr.ZERO, version = Fr.ZERO, gasSettings = GasSettings.default({
    maxFeesPerGas: new GasFees(10, 10)
}), vkTreeRoot = Fr.ZERO, protocolContractTreeRoot = Fr.ZERO, globalVariables = GlobalVariables.empty(), newL1ToL2Snapshot = AppendOnlyTreeSnapshot.empty(), feePayer, feePaymentPublicDataWrite, privateOnly = false } = {}) {
    seed *= 0x1000; // Avoid clashing with the previous mock values if seed only increases by 1.
    header ??= db?.getInitialHeader() ?? makeHeader(seed);
    feePayer ??= await AztecAddress.random();
    const txConstantData = TxConstantData.empty();
    txConstantData.historicalHeader = header;
    txConstantData.txContext.chainId = chainId;
    txConstantData.txContext.version = version;
    txConstantData.txContext.gasSettings = gasSettings;
    txConstantData.vkTreeRoot = vkTreeRoot;
    txConstantData.protocolContractTreeRoot = protocolContractTreeRoot;
    const tx = !privateOnly ? await mockTx(seed, {
        feePayer
    }) : await mockTx(seed, {
        numberOfNonRevertiblePublicCallRequests: 0,
        numberOfRevertiblePublicCallRequests: 0,
        feePayer
    });
    tx.data.constants = txConstantData;
    // No side effects were created in mockTx. The default gasUsed is the tx overhead.
    tx.data.gasUsed = Gas.from({
        daGas: FIXED_DA_GAS,
        l2Gas: FIXED_L2_GAS
    });
    if (privateOnly) {
        const data = makePrivateToRollupAccumulatedData(seed + 0x1000);
        clearContractClassLogs(data);
        const transactionFee = tx.data.gasUsed.computeFee(globalVariables.gasFees);
        feePaymentPublicDataWrite ??= new PublicDataWrite(Fr.random(), Fr.random());
        tx.data.forRollup.end = data;
        await tx.recomputeHash();
        return makeProcessedTxFromPrivateOnlyTx(tx, transactionFee, feePaymentPublicDataWrite, globalVariables);
    } else {
        const dataFromPrivate = tx.data.forPublic;
        const nonRevertibleData = dataFromPrivate.nonRevertibleAccumulatedData;
        // Create revertible data.
        const revertibleData = makePrivateToPublicAccumulatedData(seed + 0x1000);
        clearContractClassLogs(revertibleData);
        revertibleData.nullifiers[MAX_NULLIFIERS_PER_TX - 1] = Fr.ZERO; // Leave one space for the tx hash nullifier in nonRevertibleAccumulatedData.
        dataFromPrivate.revertibleAccumulatedData = revertibleData;
        // Create avm output.
        const avmOutput = AvmCircuitPublicInputs.empty();
        // Assign data from hints.
        avmOutput.startTreeSnapshots.l1ToL2MessageTree = newL1ToL2Snapshot;
        avmOutput.endTreeSnapshots.l1ToL2MessageTree = newL1ToL2Snapshot;
        // Assign data from private.
        avmOutput.globalVariables = globalVariables;
        avmOutput.startGasUsed = tx.data.gasUsed;
        avmOutput.gasSettings = gasSettings;
        avmOutput.feePayer = feePayer;
        avmOutput.publicCallRequestArrayLengths = new PublicCallRequestArrayLengths(tx.data.numberOfNonRevertiblePublicCallRequests(), tx.data.numberOfRevertiblePublicCallRequests(), tx.data.hasTeardownPublicCallRequest());
        avmOutput.publicSetupCallRequests = dataFromPrivate.nonRevertibleAccumulatedData.publicCallRequests;
        avmOutput.publicAppLogicCallRequests = dataFromPrivate.revertibleAccumulatedData.publicCallRequests;
        avmOutput.publicTeardownCallRequest = dataFromPrivate.publicTeardownCallRequest;
        avmOutput.previousNonRevertibleAccumulatedData = new PrivateToAvmAccumulatedData(dataFromPrivate.nonRevertibleAccumulatedData.noteHashes, dataFromPrivate.nonRevertibleAccumulatedData.nullifiers, dataFromPrivate.nonRevertibleAccumulatedData.l2ToL1Msgs);
        avmOutput.previousNonRevertibleAccumulatedDataArrayLengths = avmOutput.previousNonRevertibleAccumulatedData.getArrayLengths();
        avmOutput.previousRevertibleAccumulatedData = new PrivateToAvmAccumulatedData(dataFromPrivate.revertibleAccumulatedData.noteHashes, dataFromPrivate.revertibleAccumulatedData.nullifiers, dataFromPrivate.revertibleAccumulatedData.l2ToL1Msgs);
        avmOutput.previousRevertibleAccumulatedDataArrayLengths = avmOutput.previousRevertibleAccumulatedData.getArrayLengths();
        // Assign final data emitted from avm.
        avmOutput.accumulatedData.noteHashes = revertibleData.noteHashes;
        avmOutput.accumulatedData.nullifiers = padArrayEnd(nonRevertibleData.nullifiers.concat(revertibleData.nullifiers).filter((n)=>!n.isEmpty()), Fr.ZERO, MAX_NULLIFIERS_PER_TX);
        avmOutput.accumulatedData.l2ToL1Msgs = revertibleData.l2ToL1Msgs;
        avmOutput.accumulatedData.publicDataWrites = makeTuple(MAX_TOTAL_PUBLIC_DATA_UPDATE_REQUESTS_PER_TX, (i)=>new PublicDataWrite(new Fr(i), new Fr(i + 10)), seed + 0x2000);
        avmOutput.gasSettings = gasSettings;
        const avmCircuitInputs = await makeAvmCircuitInputs(seed + 0x3000, {
            publicInputs: avmOutput
        });
        avmCircuitInputs.hints.startingTreeRoots.l1ToL2MessageTree = newL1ToL2Snapshot;
        const gasUsed = {
            totalGas: Gas.empty(),
            teardownGas: Gas.empty(),
            publicGas: Gas.empty(),
            billedGas: Gas.empty()
        };
        await tx.recomputeHash();
        return makeProcessedTxFromTxWithPublicCalls(tx, {
            type: ProvingRequestType.PUBLIC_VM,
            inputs: avmCircuitInputs
        }, gasUsed, RevertCode.OK, undefined /* revertReason */ );
    }
}
// Remove all contract class log hashes from the data as they are not required for the current tests.
// If they are needed one day, change this to create the random fields first and update the data with real hashes of those fields.
function clearContractClassLogs(data) {
    data.contractClassLogsHashes.forEach((_, i)=>data.contractClassLogsHashes[i] = ScopedLogHash.empty());
}
