import { Fr } from '@aztec/foundation/fields';
import { BufferReader, serializeToBuffer } from '@aztec/foundation/serialize';
import { bufferToHex, hexToBuffer } from '@aztec/foundation/string';
import { z } from 'zod';
import { AztecAddress } from '../aztec-address/index.js';
import { schemas } from '../schemas/index.js';
import { TxHash } from '../tx/tx_hash.js';
import { Note } from './note.js';
/**
 * A note with contextual data.
 */ export class ExtendedNote {
    note;
    recipient;
    contractAddress;
    storageSlot;
    txHash;
    constructor(/** The note as emitted from the Noir contract. */ note, /** The address whose public key was used to encrypt the note. */ recipient, /** The contract address this note is created in. */ contractAddress, /** The specific storage location of the note on the contract. */ storageSlot, /** The hash of the tx the note was created in. */ txHash){
        this.note = note;
        this.recipient = recipient;
        this.contractAddress = contractAddress;
        this.storageSlot = storageSlot;
        this.txHash = txHash;
    }
    toBuffer() {
        return serializeToBuffer([
            this.note,
            this.recipient,
            this.contractAddress,
            this.storageSlot,
            this.txHash
        ]);
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const note = reader.readObject(Note);
        const recipient = reader.readObject(AztecAddress);
        const contractAddress = reader.readObject(AztecAddress);
        const storageSlot = reader.readObject(Fr);
        const txHash = reader.readObject(TxHash);
        return new this(note, recipient, contractAddress, storageSlot, txHash);
    }
    static get schema() {
        return z.object({
            note: Note.schema,
            recipient: schemas.AztecAddress,
            contractAddress: schemas.AztecAddress,
            storageSlot: schemas.Fr,
            txHash: TxHash.schema
        }).transform(({ note, recipient, contractAddress, storageSlot, txHash })=>{
            return new ExtendedNote(note, recipient, contractAddress, storageSlot, txHash);
        });
    }
    toString() {
        return bufferToHex(this.toBuffer());
    }
    static fromString(str) {
        return ExtendedNote.fromBuffer(hexToBuffer(str));
    }
    static async random() {
        return new ExtendedNote(Note.random(), await AztecAddress.random(), await AztecAddress.random(), Fr.random(), TxHash.random());
    }
}
export class UniqueNote extends ExtendedNote {
    noteNonce;
    constructor(/** The note as emitted from the Noir contract. */ note, /** The recipient whose public key was used to encrypt the note. */ recipient, /** The contract address this note is created in. */ contractAddress, /** The specific storage location of the note on the contract. */ storageSlot, /** The hash of the tx the note was created in. */ txHash, /** The nonce that was injected into the note hash preimage in order to guarantee uniqueness. */ noteNonce){
        super(note, recipient, contractAddress, storageSlot, txHash), this.noteNonce = noteNonce;
    }
    static get schema() {
        return z.object({
            note: Note.schema,
            recipient: schemas.AztecAddress,
            contractAddress: schemas.AztecAddress,
            storageSlot: schemas.Fr,
            txHash: TxHash.schema,
            noteNonce: schemas.Fr
        }).transform(({ note, recipient, contractAddress, storageSlot, txHash, noteNonce })=>{
            return new UniqueNote(note, recipient, contractAddress, storageSlot, txHash, noteNonce);
        });
    }
    toBuffer() {
        return serializeToBuffer([
            this.note,
            this.recipient,
            this.contractAddress,
            this.storageSlot,
            this.txHash,
            this.noteNonce
        ]);
    }
    static async random() {
        return new UniqueNote(Note.random(), await AztecAddress.random(), await AztecAddress.random(), Fr.random(), TxHash.random(), Fr.random());
    }
    static fromBuffer(buffer) {
        const reader = BufferReader.asReader(buffer);
        const note = reader.readObject(Note);
        const recipient = reader.readObject(AztecAddress);
        const contractAddress = reader.readObject(AztecAddress);
        const storageSlot = reader.readObject(Fr);
        const txHash = reader.readObject(TxHash);
        const noteNonce = reader.readObject(Fr);
        return new this(note, recipient, contractAddress, storageSlot, txHash, noteNonce);
    }
    static fromString(str) {
        return UniqueNote.fromBuffer(hexToBuffer(str));
    }
}
