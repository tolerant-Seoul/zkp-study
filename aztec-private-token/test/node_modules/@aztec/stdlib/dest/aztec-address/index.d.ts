import { Fr, Point } from '@aztec/foundation/fields';
import { type ZodFor } from '@aztec/foundation/schemas';
import { type BufferReader, FieldReader } from '@aztec/foundation/serialize';
import { inspect } from 'util';
/** Branding to ensure fields are not interchangeable types. */
export interface AztecAddress {
    /** Brand. */
    _branding: 'AztecAddress';
}
/**
 * AztecAddress represents a 32-byte address in the Aztec Protocol. It provides methods to create, manipulate, and
 * compare addresses, as well as conversion to and from strings, buffers, and other formats.
 * Addresses are the x coordinate of a point in the Grumpkin curve, and therefore their maximum is determined by the
 * field modulus. An address with a value that is not the x coordinate of a point in the curve is a called an 'invalid
 * address'. These addresses have a greatly reduced feature set, as they cannot own secrets nor have messages encrypted
 * to them, making them quite useless. We need to be able to represent them however as they can be encountered in the
 * wild.
 */
export declare class AztecAddress {
    private xCoord;
    constructor(buffer: Buffer | Fr);
    [inspect.custom](): string;
    static isAddress(str: string): boolean;
    static SIZE_IN_BYTES: number;
    static ZERO: AztecAddress;
    static zero(): AztecAddress;
    static fromField(fr: Fr): AztecAddress;
    static fromBuffer(buffer: Buffer | BufferReader): AztecAddress;
    static fromFields(fields: Fr[] | FieldReader): AztecAddress;
    static fromBigInt(value: bigint): AztecAddress;
    static fromNumber(value: number): AztecAddress;
    static fromString(buf: string): AztecAddress;
    /**
     * @returns a random valid address (i.e. one that can be encrypted to).
     */
    static random(): Promise<AztecAddress>;
    get size(): number;
    equals(other: AztecAddress): boolean;
    isZero(): boolean;
    /**
     * @returns true if the address is valid. Invalid addresses cannot receive encrypted messages.
     */
    isValid(): Promise<boolean>;
    /**
     * @returns the Point from which the address is derived. Throws if the address is invalid.
     */
    toAddressPoint(): Promise<Point>;
    toBuffer(): Buffer<ArrayBufferLike>;
    toBigInt(): bigint;
    toField(): Fr;
    toString(): `0x${string}`;
    toJSON(): `0x${string}`;
    static get schema(): ZodFor<AztecAddress>;
}
//# sourceMappingURL=index.d.ts.map