import { GAS_ESTIMATION_DA_GAS_LIMIT, GAS_ESTIMATION_L2_GAS_LIMIT, GAS_ESTIMATION_TEARDOWN_DA_GAS_LIMIT, GAS_ESTIMATION_TEARDOWN_L2_GAS_LIMIT } from '@aztec/constants';
import { createLogger } from '@aztec/foundation/log';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { Gas, GasSettings } from '@aztec/stdlib/gas';
import { FeeJuicePaymentMethod } from '../fee/fee_juice_payment_method.js';
import { getGasLimits } from './get_gas_limits.js';
import { ProvenTx } from './proven_tx.js';
import { SentTx } from './sent_tx.js';
/**
 * Base class for an interaction with a contract, be it a deployment, a function call, or a batch.
 * Implements the sequence create/simulate/send.
 */ export class BaseContractInteraction {
    wallet;
    authWitnesses;
    capsules;
    log;
    constructor(wallet, authWitnesses = [], capsules = []){
        this.wallet = wallet;
        this.authWitnesses = authWitnesses;
        this.capsules = capsules;
        this.log = createLogger('aztecjs:contract_interaction');
    }
    /**
   * Creates a transaction execution request, simulates and proves it. Differs from .prove in
   * that its result does not include the wallet nor the composed tx object, but only the proving result.
   * This object can then be used to either create a ProvenTx ready to be sent, or directly send the transaction.
   * @param options - optional arguments to be used in the creation of the transaction
   * @returns The proving result.
   */ async proveInternal(options) {
        if (options.from !== AztecAddress.ZERO && !options.from.equals(this.wallet.getAddress())) {
            throw new Error(`The address provided as from does not match the wallet address. Expected ${this.wallet.getAddress().toString()}, got ${options.from.toString()}.`);
        }
        const txRequest = await this.create(options);
        return await this.wallet.proveTx(txRequest);
    }
    // docs:start:prove
    /**
   * Proves a transaction execution request and returns a tx object ready to be sent.
   * @param options - optional arguments to be used in the creation of the transaction
   * @returns The resulting transaction
   */ async prove(options) {
        // docs:end:prove
        const txProvingResult = await this.proveInternal(options);
        return new ProvenTx(this.wallet, await txProvingResult.toTx(), txProvingResult.getOffchainEffects(), txProvingResult.stats);
    }
    // docs:start:send
    /**
   * Sends a transaction to the contract function with the specified options.
   * This function throws an error if called on a utility function.
   * It creates and signs the transaction if necessary, and returns a SentTx instance,
   * which can be used to track the transaction status, receipt, and events.
   * @param options - An optional object containing 'from' property representing
   * the AztecAddress of the sender. If not provided, the default address is used.
   * @returns A SentTx instance for tracking the transaction status and information.
   */ send(options) {
        // docs:end:send
        const sendTx = async ()=>{
            const txProvingResult = await this.proveInternal(options);
            return this.wallet.sendTx(await txProvingResult.toTx());
        };
        return new SentTx(this.wallet, sendTx);
    }
    // docs:start:estimateGas
    /**
   * Estimates gas for a given tx request and returns gas limits for it.
   * @param options - Options.
   * @returns Gas limits.
   */ async estimateGas(options) {
        // docs:end:estimateGas
        const txRequest = await this.create({
            ...options,
            fee: {
                ...options?.fee,
                estimateGas: true
            }
        });
        return {
            gasLimits: txRequest.txContext.gasSettings.gasLimits,
            teardownGasLimits: txRequest.txContext.gasSettings.teardownGasLimits
        };
    }
    /**
   * Returns default fee options based on the user opts without running a simulation for gas estimation.
   * @param fee - User-provided fee options.
   */ async getDefaultFeeOptions(fee) {
        const maxFeesPerGas = fee?.gasSettings?.maxFeesPerGas ?? (await this.wallet.getCurrentBaseFees()).mul(1 + (fee?.baseFeePadding ?? 0.5));
        const paymentMethod = fee?.paymentMethod ?? new FeeJuicePaymentMethod(this.wallet.getAddress());
        const gasSettings = GasSettings.default({
            ...fee?.gasSettings,
            maxFeesPerGas
        });
        this.log.debug(`Using L2 gas settings`, gasSettings);
        return {
            gasSettings,
            paymentMethod
        };
    }
    // docs:start:getFeeOptions
    /**
   * Return fee options based on the user opts, estimating tx gas if needed.
   * @param executionPayload - Execution payload to get the fee for
   * @param fee - User-provided fee options.
   * @param options - Additional options for the transaction. They must faithfully represent the tx to get accurate fee estimates
   * @returns Fee options for the actual transaction.
   */ async getFeeOptions(executionPayload, fee = {}, options) {
        // docs:end:getFeeOptions
        const defaultFeeOptions = await this.getDefaultFeeOptions(fee);
        const paymentMethod = defaultFeeOptions.paymentMethod;
        const maxFeesPerGas = defaultFeeOptions.gasSettings.maxFeesPerGas;
        const maxPriorityFeesPerGas = defaultFeeOptions.gasSettings.maxPriorityFeesPerGas;
        let gasSettings = defaultFeeOptions.gasSettings;
        if (fee?.estimateGas) {
            // Use unrealistically high gas limits for estimation to avoid running out of gas.
            // They will be tuned down after the simulation.
            const gasSettingsForEstimation = new GasSettings(new Gas(GAS_ESTIMATION_DA_GAS_LIMIT, GAS_ESTIMATION_L2_GAS_LIMIT), new Gas(GAS_ESTIMATION_TEARDOWN_DA_GAS_LIMIT, GAS_ESTIMATION_TEARDOWN_L2_GAS_LIMIT), maxFeesPerGas, maxPriorityFeesPerGas);
            const feeForEstimation = {
                paymentMethod,
                gasSettings: gasSettingsForEstimation
            };
            const txRequest = await this.wallet.createTxExecutionRequest(executionPayload, feeForEstimation, options);
            const simulationResult = await this.wallet.simulateTx(txRequest, true, undefined /* skipTxValidation */ , true);
            const { gasLimits, teardownGasLimits } = getGasLimits(simulationResult, fee?.estimatedGasPadding);
            gasSettings = GasSettings.from({
                maxFeesPerGas,
                maxPriorityFeesPerGas,
                gasLimits,
                teardownGasLimits
            });
            this.log.verbose(`Estimated gas limits for tx: DA=${gasLimits.daGas} L2=${gasLimits.l2Gas} teardownDA=${teardownGasLimits.daGas} teardownL2=${teardownGasLimits.l2Gas}`);
        }
        return {
            gasSettings,
            paymentMethod
        };
    }
}
