import { mergeExecutionPayloads } from '@aztec/entrypoints/payload';
import { getInitializer } from '@aztec/stdlib/abi';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { computePartialAddress, getContractClassFromArtifact, getContractInstanceFromInstantiationParams } from '@aztec/stdlib/contract';
import { publishContractClass } from '../deployment/publish_class.js';
import { publishInstance } from '../deployment/publish_instance.js';
import { BaseContractInteraction } from './base_contract_interaction.js';
import { ContractFunctionInteraction } from './contract_function_interaction.js';
import { DeployProvenTx } from './deploy_proven_tx.js';
import { DeploySentTx } from './deploy_sent_tx.js';
// docs:end:deploy_options
// TODO(@spalladino): Add unit tests for this class!
/**
 * Contract interaction for deployment.
 * Handles class publication, instance publication, and initialization of the contract.
 *
 * Note that for some contracts, a tx is not required as part of its "creation":
 * If there are no public functions, and if there are no initialization functions,
 * then technically the contract has already been "created", and all of the contract's
 * functions (private and utility) can be interacted-with immediately, without any
 * "deployment tx".
 *
 * Extends the BaseContractInteraction class.
 */ export class DeployMethod extends BaseContractInteraction {
    publicKeys;
    artifact;
    postDeployCtor;
    args;
    /** The contract instance to be deployed. */ instance;
    /** Constructor function to call. */ constructorArtifact;
    constructor(publicKeys, wallet, artifact, postDeployCtor, args = [], constructorNameOrArtifact, authWitnesses = [], capsules = []){
        super(wallet, authWitnesses, capsules), this.publicKeys = publicKeys, this.artifact = artifact, this.postDeployCtor = postDeployCtor, this.args = args, this.instance = undefined;
        this.constructorArtifact = getInitializer(artifact, constructorNameOrArtifact);
    }
    /**
   * Prepare a transaction execution request which can optionally (depending on the `options`):
   * - Publish the contract's class_id
   * - Publish the contract instance data, to enable execution of its public functions.
   * - Initialize the contract
   *
   * A tx is not necessary if the function has no public functions nor any
   * initializer function.
   *
   * This function internally calls `request()` and `sign()` methods to prepare
   * the transaction for deployment. The resulting signed transaction can be
   * later sent using the `send()` method.
   *
   * @param options - An object containing optional deployment settings, contractAddressSalt, and from.
   * @returns A Promise resolving to an object containing the signed transaction data and other relevant information.
   */ async create(options) {
        const requestWithoutFee = await this.request(options);
        const { fee: userFee, txNonce, cancellable } = options;
        const fee = await this.getFeeOptions(requestWithoutFee, userFee, {
            txNonce,
            cancellable
        });
        return this.wallet.createTxExecutionRequest(requestWithoutFee, fee, {
            txNonce,
            cancellable
        });
    }
    // REFACTOR: Having a `request` method with different semantics than the ones in the other
    // derived ContractInteractions is confusing. We should unify the flow of all ContractInteractions.
    /**
   * Returns an array of function calls that represent this operation. Useful as a building
   * block for constructing batch requests.
   * @param options - Deployment options.
   * @returns An array of function calls.
   * @remarks This method does not have the same return type as the `request` in the ContractInteraction object,
   * it returns a promise for an array instead of a function call directly.
   */ async request(options) {
        const publication = await this.getPublicationExecutionPayload(options);
        // TODO: Should we add the contracts to the DB here, or once the tx has been sent or mined?
        // Note that we need to run this registerContract here so it's available when computeFeeOptionsFromEstimatedGas
        // runs, since it needs the contract to have been registered in order to estimate gas for its initialization,
        // in case the initializer is public. This hints at the need of having "transient" contracts scoped to a
        // simulation, so we can run the simulation with a set of contracts, but only "commit" them to the wallet
        // once this tx has gone through.
        await this.wallet.registerContract({
            artifact: this.artifact,
            instance: await this.getInstance(options)
        });
        const initialization = await this.getInitializationExecutionPayload(options);
        const exec = [
            publication,
            initialization
        ];
        const fnCalls = exec.map((exec)=>exec.calls).flat();
        if (!fnCalls.length) {
            throw new Error(`No transactions are needed to publish or initialize contract ${this.artifact.name}`);
        }
        return mergeExecutionPayloads(exec);
    }
    /**
   * Simulate a deployment and profile the gate count for each function in the transaction.
   * @param options - Same options as `send`, plus extra profiling options.
   *
   * @returns An object containing the function return value and profile result.
   */ async profile(options) {
        const txRequest = await this.create(options);
        return await this.wallet.profileTx(txRequest, options.profileMode, options.skipProofGeneration, options?.from);
    }
    /**
   * Adds this contract to the PXE and returns the Contract object.
   * @param options - Deployment options.
   */ async register(options = {}) {
        const instance = await this.getInstance(options);
        await this.wallet.registerContract({
            artifact: this.artifact,
            instance
        });
        return this.postDeployCtor(instance.address, this.wallet);
    }
    /**
   * Returns an execution payload for:
   * - publication of the contract class and
   * - publication of the contract instance to enable public execution
   * depending on the provided options.
   * @param options - Contract creation options.
   * @returns An execution payload with potentially calls (and bytecode capsule) to the class registry and instance registry.
   */ async getPublicationExecutionPayload(options = {}) {
        const calls = [];
        // Set contract instance object so it's available for populating the DeploySendTx object
        const instance = await this.getInstance(options);
        // Obtain contract class from artifact and check it matches the reported one by the instance.
        // TODO(@spalladino): We're unnecessarily calculating the contract class multiple times here.
        const contractClass = await getContractClassFromArtifact(this.artifact);
        if (!instance.currentContractClassId.equals(contractClass.id)) {
            throw new Error(`Contract class mismatch when deploying contract: got ${instance.currentContractClassId.toString()} from instance and ${contractClass.id.toString()} from artifact`);
        }
        // Publish the contract class if it hasn't been published already.
        if (!options.skipClassPublication) {
            if ((await this.wallet.getContractClassMetadata(contractClass.id)).isContractClassPubliclyRegistered) {
                this.log.debug(`Skipping publication of already-registered contract class ${contractClass.id.toString()} for ${instance.address.toString()}`);
            } else {
                this.log.info(`Creating request for publishing contract class ${contractClass.id.toString()} as part of deployment for ${instance.address.toString()}`);
                const registerContractClassInteraction = await publishContractClass(this.wallet, this.artifact);
                calls.push(await registerContractClassInteraction.request());
            }
        }
        // Publish the contract instance:
        if (!options.skipInstancePublication) {
            // TODO(https://github.com/AztecProtocol/aztec-packages/issues/15596):
            // Read the artifact, and if there are no public functions, warn the caller that publication of the
            // contract instance is not necessary (until such time as they wish to update the instance (i.e. change its class_id)).
            const deploymentInteraction = await publishInstance(this.wallet, instance);
            calls.push(await deploymentInteraction.request());
        }
        return mergeExecutionPayloads(calls);
    }
    /**
   * Returns the calls necessary to initialize the contract.
   * @param options - Deployment options.
   * @returns - An array of function calls.
   */ async getInitializationExecutionPayload(options = {}) {
        const executionsPayloads = [];
        if (this.constructorArtifact && !options.skipInitialization) {
            const { address } = await this.getInstance(options);
            const constructorCall = new ContractFunctionInteraction(this.wallet, address, this.constructorArtifact, this.args);
            executionsPayloads.push(await constructorCall.request());
        }
        return mergeExecutionPayloads(executionsPayloads);
    }
    /**
   * Send a contract deployment transaction (initialize and/or publish) using the provided options.
   * This function extends the 'send' method from the ContractFunctionInteraction class,
   * allowing us to send a transaction specifically for contract deployment.
   *
   * @param options - An object containing various deployment options such as contractAddressSalt and from.
   * @returns A SentTx object that returns the receipt and the deployed contract instance.
   */ send(options) {
        const sendTx = ()=>super.send(options).getTxHash();
        this.log.debug(`Sent deployment tx of ${this.artifact.name} contract`);
        return new DeploySentTx(this.wallet, sendTx, this.postDeployCtor, ()=>this.getInstance(options));
    }
    /**
   * Builds the contract instance and returns it.
   *
   * @param options - An object containing various initialization and publication options.
   * @returns An instance object.
   */ async getInstance(options = {}) {
        if (!this.instance) {
            this.instance = await getContractInstanceFromInstantiationParams(this.artifact, {
                constructorArgs: this.args,
                salt: options.contractAddressSalt,
                publicKeys: this.publicKeys,
                constructorArtifact: this.constructorArtifact,
                deployer: options.universalDeploy ? AztecAddress.ZERO : this.wallet.getAddress()
            });
        }
        return this.instance;
    }
    /**
   * Prove the request.
   * @param options - initialization and publication options.
   * @returns The proven tx.
   */ async prove(options) {
        const txProvingResult = await this.proveInternal(options);
        return await DeployProvenTx.fromProvingResult(this.wallet, txProvingResult, this.postDeployCtor, ()=>this.getInstance(options), txProvingResult.stats);
    }
    /**
   * Estimates gas cost for this deployment operation.
   * @param options - Options.
   */ estimateGas(options) {
        return super.estimateGas(options);
    }
    /** Return this deployment address. */ get address() {
        return this.instance?.address;
    }
    /** Returns the partial address for this deployment. */ get partialAddress() {
        return this.instance && computePartialAddress(this.instance);
    }
    /**
   * Augments this DeployMethod with additional metadata, such as authWitnesses and capsules.
   * @param options - An object containing the metadata to add to the interaction
   * @returns A new DeployMethod with the added metadata, but calling the same original function in the same manner
   */ with({ authWitnesses = [], capsules = [] }) {
        return new DeployMethod(this.publicKeys, this.wallet, this.artifact, this.postDeployCtor, this.args, this.constructorArtifact?.name, this.authWitnesses.concat(authWitnesses), this.capsules.concat(capsules));
    }
}
