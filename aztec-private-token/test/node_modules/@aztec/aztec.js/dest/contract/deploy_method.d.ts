import type { ExecutionPayload } from '@aztec/entrypoints/payload';
import type { Fr } from '@aztec/foundation/fields';
import { type ContractArtifact, type FunctionArtifact } from '@aztec/stdlib/abi';
import type { AuthWitness } from '@aztec/stdlib/auth-witness';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { type ContractInstanceWithAddress } from '@aztec/stdlib/contract';
import type { GasSettings } from '@aztec/stdlib/gas';
import type { PublicKeys } from '@aztec/stdlib/keys';
import type { Capsule, TxExecutionRequest, TxProfileResult } from '@aztec/stdlib/tx';
import type { Wallet } from '../wallet/wallet.js';
import { BaseContractInteraction } from './base_contract_interaction.js';
import type { Contract } from './contract.js';
import type { ContractBase } from './contract_base.js';
import { DeployProvenTx } from './deploy_proven_tx.js';
import { DeploySentTx } from './deploy_sent_tx.js';
import type { ProfileMethodOptions, SendMethodOptions } from './interaction_options.js';
/**
 * Options for deploying a contract on the Aztec network.
 * Allows specifying a contract address salt, and additional send method options.
 */
export type DeployOptions = {
    /** An optional salt value used to deterministically calculate the contract address. */
    contractAddressSalt?: Fr;
    /** Set to true to *not* include the sender in the address computation. */
    universalDeploy?: boolean;
    /** Skip contract class publication. */
    skipClassPublication?: boolean;
    /** Skip publication, instead just privately initialize the contract. */
    skipInstancePublication?: boolean;
    /** Skip contract initialization. */
    skipInitialization?: boolean;
} & SendMethodOptions;
/**
 * Contract interaction for deployment.
 * Handles class publication, instance publication, and initialization of the contract.
 *
 * Note that for some contracts, a tx is not required as part of its "creation":
 * If there are no public functions, and if there are no initialization functions,
 * then technically the contract has already been "created", and all of the contract's
 * functions (private and utility) can be interacted-with immediately, without any
 * "deployment tx".
 *
 * Extends the BaseContractInteraction class.
 */
export declare class DeployMethod<TContract extends ContractBase = Contract> extends BaseContractInteraction {
    private publicKeys;
    private artifact;
    private postDeployCtor;
    private args;
    /** The contract instance to be deployed. */
    private instance?;
    /** Constructor function to call. */
    private constructorArtifact;
    constructor(publicKeys: PublicKeys, wallet: Wallet, artifact: ContractArtifact, postDeployCtor: (address: AztecAddress, wallet: Wallet) => Promise<TContract>, args?: any[], constructorNameOrArtifact?: string | FunctionArtifact, authWitnesses?: AuthWitness[], capsules?: Capsule[]);
    /**
     * Prepare a transaction execution request which can optionally (depending on the `options`):
     * - Publish the contract's class_id
     * - Publish the contract instance data, to enable execution of its public functions.
     * - Initialize the contract
     *
     * A tx is not necessary if the function has no public functions nor any
     * initializer function.
     *
     * This function internally calls `request()` and `sign()` methods to prepare
     * the transaction for deployment. The resulting signed transaction can be
     * later sent using the `send()` method.
     *
     * @param options - An object containing optional deployment settings, contractAddressSalt, and from.
     * @returns A Promise resolving to an object containing the signed transaction data and other relevant information.
     */
    create(options: DeployOptions): Promise<TxExecutionRequest>;
    /**
     * Returns an array of function calls that represent this operation. Useful as a building
     * block for constructing batch requests.
     * @param options - Deployment options.
     * @returns An array of function calls.
     * @remarks This method does not have the same return type as the `request` in the ContractInteraction object,
     * it returns a promise for an array instead of a function call directly.
     */
    request(options: DeployOptions): Promise<ExecutionPayload>;
    /**
     * Simulate a deployment and profile the gate count for each function in the transaction.
     * @param options - Same options as `send`, plus extra profiling options.
     *
     * @returns An object containing the function return value and profile result.
     */
    profile(options: DeployOptions & ProfileMethodOptions): Promise<TxProfileResult>;
    /**
     * Adds this contract to the PXE and returns the Contract object.
     * @param options - Deployment options.
     */
    register(options?: Omit<DeployOptions, 'from'>): Promise<TContract>;
    /**
     * Returns an execution payload for:
     * - publication of the contract class and
     * - publication of the contract instance to enable public execution
     * depending on the provided options.
     * @param options - Contract creation options.
     * @returns An execution payload with potentially calls (and bytecode capsule) to the class registry and instance registry.
     */
    protected getPublicationExecutionPayload(options?: Omit<DeployOptions, 'from'>): Promise<ExecutionPayload>;
    /**
     * Returns the calls necessary to initialize the contract.
     * @param options - Deployment options.
     * @returns - An array of function calls.
     */
    protected getInitializationExecutionPayload(options?: Omit<DeployOptions, 'from'>): Promise<ExecutionPayload>;
    /**
     * Send a contract deployment transaction (initialize and/or publish) using the provided options.
     * This function extends the 'send' method from the ContractFunctionInteraction class,
     * allowing us to send a transaction specifically for contract deployment.
     *
     * @param options - An object containing various deployment options such as contractAddressSalt and from.
     * @returns A SentTx object that returns the receipt and the deployed contract instance.
     */
    send(options: DeployOptions): DeploySentTx<TContract>;
    /**
     * Builds the contract instance and returns it.
     *
     * @param options - An object containing various initialization and publication options.
     * @returns An instance object.
     */
    getInstance(options?: Omit<DeployOptions, 'from'>): Promise<ContractInstanceWithAddress>;
    /**
     * Prove the request.
     * @param options - initialization and publication options.
     * @returns The proven tx.
     */
    prove(options: DeployOptions): Promise<DeployProvenTx<TContract>>;
    /**
     * Estimates gas cost for this deployment operation.
     * @param options - Options.
     */
    estimateGas(options: Omit<DeployOptions, 'estimateGas'>): Promise<Pick<GasSettings, 'gasLimits' | 'teardownGasLimits'>>;
    /** Return this deployment address. */
    get address(): AztecAddress | undefined;
    /** Returns the partial address for this deployment. */
    get partialAddress(): Promise<Fr> | undefined;
    /**
     * Augments this DeployMethod with additional metadata, such as authWitnesses and capsules.
     * @param options - An object containing the metadata to add to the interaction
     * @returns A new DeployMethod with the added metadata, but calling the same original function in the same manner
     */
    with({ authWitnesses, capsules, }: {
        /** The authWitnesses to add to the deployment */
        authWitnesses?: AuthWitness[];
        /** The capsules to add to the deployment */
        capsules?: Capsule[];
    }): DeployMethod;
}
//# sourceMappingURL=deploy_method.d.ts.map