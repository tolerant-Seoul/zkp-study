import { ExecutionPayload } from '@aztec/entrypoints/payload';
import { type FunctionAbi } from '@aztec/stdlib/abi';
import type { AuthWitness } from '@aztec/stdlib/auth-witness';
import { AztecAddress } from '@aztec/stdlib/aztec-address';
import { type Capsule, type HashedValues, type OffchainEffect, type SimulationStats, type TxExecutionRequest, type TxProfileResult } from '@aztec/stdlib/tx';
import type { Wallet } from '../wallet/wallet.js';
import { BaseContractInteraction } from './base_contract_interaction.js';
import type { ProfileMethodOptions, RequestMethodOptions, SendMethodOptions, SimulateMethodOptions } from './interaction_options.js';
/**
 * Represents the result type of a simulation.
 * By default, it will just be the return value of the simulated function
 * so contract interfaces behave as plain functions. If `includeMetadata` is set to true in `SimulateMethodOptions` on the input of `simulate(...)`,
 * it will provide extra information.
 */
type SimulationReturn<T extends boolean | undefined> = T extends true ? {
    /**
     * Additional stats about the simulation
     */
    stats: SimulationStats;
    /**
     * Offchain effects generated during the simulation
     */
    offchainEffects: OffchainEffect[];
    /**
     * Return value of the function
     */
    result: any;
} : any;
/**
 * This is the class that is returned when calling e.g. `contract.methods.myMethod(arg0, arg1)`.
 * It contains available interactions one can call on a method, including view.
 */
export declare class ContractFunctionInteraction extends BaseContractInteraction {
    protected contractAddress: AztecAddress;
    protected functionDao: FunctionAbi;
    protected args: any[];
    private extraHashedArgs;
    constructor(wallet: Wallet, contractAddress: AztecAddress, functionDao: FunctionAbi, args: any[], authWitnesses?: AuthWitness[], capsules?: Capsule[], extraHashedArgs?: HashedValues[]);
    /**
     * Create a transaction execution request that represents this call, encoded and authenticated by the
     * user's wallet, ready to be simulated.
     * @param options - An optional object containing additional configuration for the transaction.
     * @returns A Promise that resolves to a transaction instance.
     */
    create(options?: Omit<SendMethodOptions, 'from'>): Promise<TxExecutionRequest>;
    /**
     * Returns an execution request that represents this operation.
     * Can be used as a building block for constructing batch requests.
     * @param options - An optional object containing additional configuration for the request generation.
     * @returns An execution payload wrapped in promise.
     */
    request(options?: RequestMethodOptions): Promise<ExecutionPayload>;
    /**
     * Simulate a transaction and get its return values
     * Differs from prove in a few important ways:
     * 1. It returns the values of the function execution
     * 2. It supports `utility`, `private` and `public` functions
     *
     * @param options - An optional object containing additional configuration for the transaction.
     * @returns The result of the transaction as returned by the contract function.
     */
    simulate<T extends SimulateMethodOptions>(options: T): Promise<SimulationReturn<T['includeMetadata']>>;
    /**
     * Simulate a transaction and profile the gate count for each function in the transaction.
     * @param options - Same options as `simulate`, plus profiling method
     *
     * @returns An object containing the function return value and profile result.
     */
    profile(options: ProfileMethodOptions): Promise<TxProfileResult>;
    /**
     * Augments this ContractFunctionInteraction with additional metadata, such as authWitnesses, capsules, and extraHashedArgs.
     * This is useful when creating a "batteries included" interaction, such as registering a contract class with its associated
     * capsule instead of having the user provide them externally.
     * @param options - An object containing the metadata to add to the interaction
     * @returns A new ContractFunctionInteraction with the added metadata, but calling the same original function in the same manner
     */
    with({ authWitnesses, capsules, extraHashedArgs, }: {
        /** The authWitnesses to add to the interaction */
        authWitnesses?: AuthWitness[];
        /** The capsules to add to the interaction */
        capsules?: Capsule[];
        /** The extra hashed args to add to the interaction */
        extraHashedArgs?: HashedValues[];
    }): ContractFunctionInteraction;
}
export {};
//# sourceMappingURL=contract_function_interaction.d.ts.map