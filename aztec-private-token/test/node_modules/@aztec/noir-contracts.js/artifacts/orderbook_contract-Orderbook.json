{
  "transpiled": true,
  "noir_version": "1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec",
  "name": "Orderbook",
  "functions": [
    {
      "name": "_create_order",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "order",
            "type": {
              "kind": "struct",
              "path": "order::Order",
              "fields": [
                {
                  "name": "bid_amount",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "ask_amount",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 128
                  }
                },
                {
                  "name": "bid_token_is_zero",
                  "type": {
                    "kind": "boolean"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14154006707395008989": {
            "error_kind": "string",
            "string": "Function _create_order can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "_fulfill_order",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "taker_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "bid_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "bid_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "9049586825106884780": {
            "error_kind": "string",
            "string": "Function _fulfill_order can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBJJwAABAMnAgUEBCcCBgQAHwoABQAGgEUdAIBIgEgGLgiARQABLgiARgACLgiARwADLgiASAAEJQAAAF4lAAAAbygCAAEEgEknAgIEADsOAAIAASkAgEME/////ygAgEQEAAMmJQAAAlIeAgAFAB4CAAYAMyoABQAGAAcnAgUBASQCAAcAAACYJQAAAnseAgAFAR4CAAYACioFBgckAgAHAAAAtCUAAAKNHAoEBQApAgAEAJr09+QnAgcEAycCCQQDACoHCQgtCAEGAAgBCAEnAwYEAQAiBgIILQ4HCAAiCAIILQ4HCCcCCAQDACoGCActCgcILQ4ECAAiCAIILQ4FCAAiCAIILQ4CCAAiBgIFLQsFBCcCBwQCACoFBwI5A6CAQ4BDAAMABAACIAIAAiECAAMnAgQEAC0IAQYAIgYCCS0LCQgnAgoEAgAqCQoHIjoAAwAEAActCgMIJwIKBAMAKggKCQAIAQkBJwMGBAEAIgYCCi0OCAoAIgoCCi0OCAotCggFBiIFAgUkAgACAAAByiMAAAGhLQsGAgAiAgICLQ4CBgAiBgIHLQsHAycCCAQCACoHCAI8DgMCIwAAAcoKKgUEAiQCAAIAAAHgJwIDBAA8BgMBKQIAAgAOLYqGJwIEBAInAgYEAwAqBAYFLQgBAwAIAQUBJwMDBAEAIgMCBS0OBAUAIgUCBS0OBAUnAgUEAwAqAwUELQoEBS0OAQUAIgUCBS0OAgUnAgEEAgAiAwIFLQsFBCcCBgQCACoFBgI3CwACAAQmKACABAR4AA0AAACABIADJACAAwAAAnoqAQABBfeh86+lrdTKPAQCASYqAQABBb4eP/8+pPb6PAQCASYqAQABBX2Wl0VKjQisPAQCASY=",
      "debug_symbols": "tZfbbuIwEIbfJddceGZ85FWqqqI0rZAiQCmstKp4950Bj5OsZG+XZW/Ilwn+PSc78Vf31r+eP152+/fDZ7d++upex90w7D5ehsN2c9od9mz96oz8APhubVcdIHTrIFe+B8NAlgEEUgYbMjhkkEFOLDLKiyUKhAzBZYg8D4pgZAsSQ7IK6QZorIJagBRiBlQLqoVQIWSwoOAzOLU4p6BTeJ3Uq2DQKYIIOoaICj5DAoVsoavPnAS6+pwEeDhxoghRwWcgUHAZrFFQi9PhXod7tQS1BLVEtUSdIukUSQUlzwL26hjXwkq1b+AzkLhBAk4hZbBWQS2OM0Ycu/WUIYCCzyB1pyiQMkjdb5AtzliFmEFyeAO1oFowZJC638BnkLrfQC3OKOgUTicVn60RiBmCWiSrV5Cs3uBquVxWna6dl9PY97J0ZouJl9hxM/b7U7fen4dh1f3YDOfrnz6Pm/31etqM/JQl+/0bX1nwfTf0QpfVNNrUhwJx4Hk4kPehSAAsRaAhYrBoGIuThAkLCWxIhBS9aoSUXBEJdqFBdQ1CMjFrMKOtaTRDSUndAEjVUNwDQvH/OxQXS1VivSqxLhFCVIkQbdWJ1AiEdyLQQMjafw0EsB5Iq815fy8anFtfb/NWk6bZYknOmmow7S4Nbiptqoo0wyHAKRzCejiPaFR4RKd+vzpkq+E0RIKxQXvVpKnADpaxpNZmGEzZC+PMC+6XO7wAopoX2N5NS4OAITOJ+KUb2GpVDIZKSgPEWln+IOLKboiJqrVF22gQa8qiYZ5V5m88IYOlVcnUVx62WtW6VPYi6wHv9GTqVeKtqSoSW554bydPYrzTE59mnlQTS6blSQhUPIlwZ3UgTh8RWM8JNUTIodMSM0eoetJcO96VJWy897W1Q7a1L/qydPgNWCTs93cBiNpoAWfvvN92AWo0a0Kj2UiI04dIWL7zKNQl+KNbq2L5Q75alKYE+UkiVSWaXwAulfcdHz6Wfjzz3Wa7GxeHyIuojbvN69Dn2/fzfjt7evp51Cd6CD2Oh23/dh57UZqdRPn3CfhYyR9zz3w4BLnlgyO/cp4vMv0v"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token0",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token1",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8272873033206518798": {
            "error_kind": "string",
            "string": "Tokens must be different"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "create_order",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "bid_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "ask_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "bid_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "ask_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2908323689890055545": {
            "error_kind": "string",
            "string": "ASK_TOKEN_IS_INVALID"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4456244908619624852": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7808657612405516684": {
            "error_kind": "string",
            "string": "ZERO_ASK_AMOUNT"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "9547248988244986602": {
            "error_kind": "string",
            "string": "BID_TOKEN_IS_INVALID"
          },
          "9865238346456240063": {
            "error_kind": "string",
            "string": "ZERO_BID_AMOUNT"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11163793660944886350": {
            "error_kind": "string",
            "string": "SAME_TOKEN_TRADE"
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "verification_key": "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"
    },
    {
      "name": "fulfill_order",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4456244908619624852": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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zROf1z3x+Z0nPm944vOmJz5veeLze098/uCJzx898fmTJz5/9sTnbU983vHE511PfP7iic9fPfF5zxOfv3ni874nPh944vOhJz4feeLzd098PvbE5xNPfD71xOcfnvj80xOfzzzx+dwTn3954vNvT3y+8MTnP574/NcTny898VGHl8XEJQXN+ASe+JR54pPyxCftiU+5Jz4Vnvg08sSn0hOfjCc+jT3xaeKJT5UnPk098an2xCfriU8zT3yae+LTwhOflp74tPLEp7UnPm088WnriU87T3zae+Kzkyc+HTzx6eiJTydPfDp74tPFE58aT3y6euLTzROf7p749PDEp6cnPjt74rOLJz69PPHZ1ROf3p749PHEp68nPv088envic8AT3wGeuIzyBOf3Tzx2d0Tnz088Rnsic8QT3z29MRnL0989vbEZx9PfPb1xGc/T3z298TnAE98DvTEZ6gnPrWe+AzzxGe4Jz4jPPEZ6YnPQZ74jPLE52BPfA7xxGe0Jz6HeuIzxhOfsZ74jPPEZ7wnPhM88Znoic8kT3wme+IzxROfqZ74TPPEZ7onPjM88TnME5+Znvgc7onPEZ74HOmJz1Ge+Bztic8xnvjM8sTnWE98jvPEZ7YnPnM88TneE5+5nvic4InPPE98TvTEZ74nPgs88TnJE5+TPfFZ6InPIk98TvHEZ7EnPks88Vnqic8yT3xO9cRnuSc+KzzxWemJzypPfFZ74nOaJz5rPPE53ROftZ745DzxWeeJz3pPfDZ44rPRE59Nnvhs9sTnDE98zvTE5yxPfM72xGeLJz5bPfE5xxOfcz3xOc8Tn/M98bnAE58LPfG5yBOfiz3xucQTn0s98fmWJz6XeeJzuSc+V3jic6UnPt/2xOc7nvh81xOfqzzxudoTn2s88fmeJz7XeuJznSc+13vic4MnPjd64nOTJz7f98TnB5743OyJzy2e+Nzqic8PPfG5zROf2z3xucMTnzs98bnLE5+7PfH5kSc+93jic68nPvd54nO/Jz4PeOLzY098fuKJz0898XnQE5+HPPF52BOfRzzx+ZknPo964vOYJz6Pe+Lzf574/NwTnyc88XnSE5+nPPF52hOfX3ji84wnPr/0xOdXnvg864nPc574/NoTn+c98XnBE58XPfF5yROflz3x+Y0nPq944vOqJz6/9cTnNU98XvfE53ee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",
      "debug_symbols": "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",
      "verification_key": "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"
    },
    {
      "name": "get_order",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "order_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "tuple",
            "fields": [
              {
                "kind": "struct",
                "path": "order::Order",
                "fields": [
                  {
                    "name": "bid_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ask_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "bid_token_is_zero",
                    "type": {
                      "kind": "boolean"
                    }
                  }
                ]
              },
              {
                "kind": "boolean"
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tf3Rjuw6cmANv0tf+yIZJIOkX2UwMDyenkEDjfagbf/AD8Pv/qWCjFjctV0sVWadm+51ztk7lkQqQkqKIv/zT//7z//rP/7vP/3lb//nX//tT//4P/7zT//r73/561//8n//6a//+i///O9/+de/Pf/tf/7pcf3PaH/6x/wPfxr9T/+oz/8bf/rH/g9/So/nf0uPC9IT5AJ5QrkgP0EvKA7VQR2aQ3cYC9LDITmIg0dOHjl55OSRk0dOHjl5ZPHI4pHFI4tHFo8sHlk8snhk8cjikbNHzh45e+TskbNHzh45e+TskbNHzh65eOTikYtHLh65eOTikYtHLh65eOTikatHrh65euTqkatHrh65euTqkatHrh5ZPbJ6ZPXI6pHVI+szslwXkqpDc+gOY0F7OCQHccgOxcEjN4/crsjpgu4wFvSHQ3IQhyvydWH3K/J18ffqoA7NoTuMBeOKPC5IDuKQHYpDdVCH5tAdxgR5PBySgzg8I+fHBcWhOlyR9YLm0B2ekfMFVw5OSA7ikB2KQ3VQh+bQHTyyeGTxyOKRrxzM/YLiUB3UoTl0h7HgysEJyUEcPHL2yNkjZ4+cPXL2yNkjF49cPHLxyMUjF49cPHLxyMUjF49cPHL1yFcOlqt3rhyckB2KQ3VQh+bQHcaCKwcneGT1yOqR1SOrR1aPrB5ZPbJ65OaRm0duHrl55OaRm0duHrl55OaRm0fuHrl75O6Ru0fuHrl75O6Ru0fuHrl75OGRh0ceHnl45OGRh0ceHnl45OGRx4qcHw+H5CAO2aE4VAd1aA7dwSMnj3zlYMkXiEN2KA7VQR2aQ3cYC64cnOCRxSOLRxaPfOVg0QvUoTk8I9d0wVhw5eCE5CAO2aE4VAd1aA4eOXvk4pGLRy6rbuSSHYpDdVCH5tAdVkXK9eGQHDxy9cjVI1ePfOVgLRc0h+4wFlw5OCE5iEN2KA7VwSOrR1aPrB65eeQrB2u9QByyQ3GoDurQHLrDWHDl4ASP3D1y98jdI185WPsF6tAcrsdFuWAsuHJwQnIQh+xQHKqDOjQHjzxW5PJ4OCQHccgOxaE6qENz6A4eOXnk5JGTR04eOXnk5JGTR04eOXnk5JHFI4tHFo8sHlk8snhk8cjikcUji0fOHjl75OyRs0fOHjl75OyRs0fOHjl75OKRi0cuHrl45OKRi0cuHrl45OKRi0euHrl65OqRq0euHrl65OqRq0euHrl6ZPXI6pHVI6tHVo+sHlk9snpk9cjqkZtHbh65eeTmkZtHbh65eeTmkZtHbh65e+TukbtH7h65e+TukbtH7h7Zc7B4DhbPwWI5WC4Qh+xQHKqDOjSH7jAmVMtBg+QgDtmhOFQHdWgO3cEjJ4+cPHLyyMkjJ4+cPHLyyMkjJ4+cPLJ4ZPHI4pHFI4tHFo8sHlk8snhk8cjZI2ePnD1y9sjZI2ePnD1y9sjZI2ePXDxy8cjFIxePXDxy8cjFIxePXDxy8cjVI1ePXD1y9cjVI1ePXD1y9cjVI1ePrB5ZPbJ6ZPXI6pHVI6tHVo+sHlk9cvPIzSM3j9w8cvPIzSM3j9w8cvPIzSN3j9w9cvfI3SN3j9w9cvfI3SN3j9w98vDInoPVc7B6DlbPweo5WD0Hq+dg9RysnoPqOaieg+o5qJ6D6jmonoPqOaieg+o5qJ6D6jmonoPqOaieg+o5qJ6D6jmonoNqOdguGAssBw2Sgzhkh+JQHdShOXhk8cjZI2ePnD1y9sjZI2ePnD1y9sjZI2ePXDxy8cjFIxePbDnYL6gO6vCM3B4XdIex4MrBCclBHLJDcagO6uCRq0euHlk9snpk9cjqkdUjq0dWj6weWT2yeuTmkZtHbh65eeTmkZtHbh75ysGWL+gOY8GVg61ekBzEITsUh+qgDs2hO4wFwyMPjzw88vDIVw62q7+uHJygDs2hO4wJ7crBCclBHLJDcagO6tAcrsjjgrHgysEJyUEcskNxqA7q0Bw8cvLI4pHFI4tHFo8sHlk8snhk8cjikcUjZ4+cPXL2yNkjZ4+cPXL2yNkjZ4+cPXLxyMUjF49cPHLxyMUjF49cPHLxyMUjV49cPXL1yNUjV49cPXL1yNUjV49cPbJ6ZPXI6pHVI6tHVo+sHlk9snpk9cjNIzeP3Dxy88jNIzeP3Dxy88jNIzeP3D1y98jdI3eP3D1y98jdI3eP3D1y98jDIw+PPDzy8MjDIw+PPDzy8MjDI48VuT8eDsnhGbmnC7JDcagO6tAcusNYcOXghOTgkZNHTh45eeTkkZNHTh45eWTxyOKRxSOLRxaPLB5ZPLJ4ZPHI4pGzR84eOXvk7JGzR84eOXvk7JGzR84euXjk4pGLRy4euXjk4pGLRy4euXjk4pGrR64euXrk6pGrR64euXrk6pGrR64eWT2yemT1yOqR1SOrR1aPrB5ZPbJ65OaRm0duHrl55OaRm0duHrl55OaRm0fuHrl75O6Ru0fuHrl75O6Ru0fuHrl75OGRh0ceHnl45OGRh0ceHnl45OGRx4o8Hg+H5CAO2aE4VAd1aA7dwSN7Dg7PweE5ODwHh+fg8BwcnoPDc3B4Dg7PweE5ODwHh+fg8BwcnoPDc3B4Dg7PweE5ODwHh+fg8BwcnoPDc3B4Dg7PweE5ODwHh+fg8BwcnoPDc3B4Dg7PweE5ODwHh+fg8BwcnoPDc3B4Dg7PweE5ODwHh+fg8BwcnoPDc3B4Dg7PweE5ODwHh+fg8BwcnoPDc3B4Dg7PwWE5WC4YCywHDZKDOGSH4lAd1KE5eOTmkbtH7h7ZcrBekB2KQ3VQh+bQHcYCy0GD5OCRh0ceHnl45OGRh0ceHnmsyM939I+gFCRBOagE1SANakE9KBwpHCkcKRwpHCkcKRwpHCkcKRwpHBIOCYeEQ8Ih4ZBwSDgkHBIOCUcORw5HDkcORw5HDkcORw5HDkcORwmHZeswkqAc9HQMm1NxZewiDWpBPWg4XWm7KAVJUA4KRw1HDUcNRw1HDYeGQ8Oh4dBwaDg0HBoODYeGQ8PRwtHC0cLRwtHC0cLRwtHC0cLRwtHD0cPRw9HD0cPRw9HD0cPRw9HDMcIxwjHCMcIxwjHCMcIxwjHCMdxhk3EWpSAJykElqAZpUAvqQeFI4UjhSOFI4UjhSOFI4UjhSOFI4ZBwSDgkHBIOCYeEQ8Ih4ZBwSDhyOHI4cjhyOHI4cjhyOHI4cjhyOEo4SjhKOEo4Is9T5HmKPE+R5ynyPEWep8jzFHmeIs9T5HmKPE+R5ynyPEWep8jzFHmeIs9T5HmKPE+R5ynyPEWep8jzFHmeIs9T5HmKPE+R5ynyPEWep8jzFHmeIs9T5HmKPE+R5ynyPEWep8jzFHmeIs9T5HmKPE+R5ynyPEWep8jzFHmeIs9T5HmKPE+R5ynyPEWep8jzFHkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5LpHnEnkukecSeS6R5xJ5niPPc+R5jjzPkec58jxHnufI8xx5bpOLRjEaTpbnk1KQBOWgElSDNKgFhSOFQ8Ih4ZBwSDgkHBIOCYeEQ8Ih4cjhyOHI4cjhyOHI4cjhyOHI4cjhKOEo4SjhKOEo4SjhKOEo4SjhKOGo4ajhqOGo4ajhqOGo4ajhqOGo4dBwaDg0HBoODYeGQ8Oh4dBwaDhaOFo4WjhaOFo4WjhaOFo4WjhaOHo4ejh6OHo4ejh6OHo4ejh6OHo4RjhGOEY4RjhGOEY4RjhGOEY4LM+vX4E2cWlRCpKgHFSCapAGtaAeFI4UjhSOFI4UjhSOFI4UjhSOFI4UDgmHhEPCIeGQcEg4JBwSDgmHhCOHI4cjhyOHI4cjhyOHI4cjhyOHo4SjhKOEo4SjhKOEo4SjhKOEo4SjhqOGo4ajhqOGo4ajhqOGo4ajhkPDoeHQcGg4NBwaDg2HhkPDoeFo4WjhaOFo4bA8H0Y1SIPa9RmJGHZwBF6p7phAATNYwAoqiK1j69gGtoFtYBvYBraBbWAb2Aa2Ebb6eIAJFDCDBayggg3sILaELWFL2BK2hC1hS9gStoQtYRNsgk2wCTbBJtgEm2ATbIItY8vYMraMLWPL2DK2jC1jy9gKtoKtYCvYCraCrWAr2Aq2gq1iq9gqtoqtYqvYKraKrWKr2BSbYlNsik2xKTbFptgUm2Jr2Bq2hq1ha9gatoaNWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVpSqSWVWlKpJZVaUqkllVqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKkljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJW3WkmqYQAEzWMAKKtjADo7Ajq1j69g6tllL1LCCCjawgyNw1pKJCRQwg9gGtoFtYBvYRtj64wEmUMAMFrCCCjawg9gStoQtYUvYEraELWFL2BK2hE2wCTbBJtgEm2ATbIJNsAm2jC1jy9gytowtY8vYMraMLWMr2Aq2gq1gK9islti6EDbPz7GBl83Wi7DZfgutlixMoIAZLGAFFWwgtopNsSk2xabYFJtiU2yKTbEptoatYWvYGraGrWFr2Bq2hq1h69g6to6tY+vYOraOrWPr2Dq2gW1gG9gGtoFtYBvYBraBbYTN5hQ6JlDADBawggo2sIPYEraELWFL2BK2hC1hS9gStoRNsAk2wSbYBJtgE2yCTbAJtowtY8vYMraMLWPL2DK2jC1jK9gKtoKtYCvYCraCrWCjlgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWDGrJoJYMasmglgxqyaCWjKgl8ohaIo+oJfKIWiKPqCXyiFoij6gl8ohaIo+oJfKIWiKPB7aELWFL2BK2hC1hS9gStoQtYRNsgk2wCTbBJtgEm2ATbIItY8vYMraMLWPL2DK2jC1jy9gKtoKtYCvYCraCrWAr2Aq2gq1iq9gqtoqtYqvYKraKrWKr2BSbYlNsik2xKTbFptgUm2Jr2Bq2hq1ha9gatoatYWvYGraOrWPr2Dq2jq1j69g6to6tYxvYBraBbWAb2Aa2gW1gG9ioJYlakqgliVqSqCWJWpKoJYlakqgliVqSqCWJWpKoJYlakqgliVqSqCWJWjJXS0vVsIMjcNaSiQkUMIMFrKCC2GYtSYYjcNaSiQkUMIMFrKCCDcSWsRVsBVvBVrAVbAVbwVawFWwFW8VWsVVsFVvFVrFVbBVbxVaxKTbFptgUm2JTbIpNsSk2xdawNWwNW8PWsDVsDVvD1rA1bFZLJBsmUMDLdi2+Jjal07GCCjawgyPQasnCBAqIbWAb2AY2qyW5GHZwONpER5nLol1/K1dD++/tQsuQhQkUMIMFrKCCDewgtoKtYCvYCraCrWAr2Aq2gq1gq9gqtoqtYqvYKraKrWKr2Co2xabYFJtiU2yKTbEpNsWm2Bq2hq1ha9gatoatYWvYGraGrWPr2CxDbPkymwvpWMAKKtjAy1aS4Qi0DFmYQAEzWMAKKthAbCNsNjnS0WxiKKDZqmEBK6hgAzs4Au1uuzCBAmJL2BK2hM3uttfSaWLTJR1HoN1tFyZQQLPNxQ0LWMHLVq117G67sIMj0GrJwgRetmotabVkYQErqGADOzgCrZYsTCC2gq1gs1pSs6GCLdCqRhmGFrcYWgRrM6sPdf4BBRvYwRFo9WHhFVcfhgJmsIAVVLCBHRyBVh8WYmvYGjarD2qdZfVhodns5K0+LOzgCLT6sDCBZrMr1erDwgJWUMEGdnAEWn1YmEBsA9vAZvVBrQutPiw0WzPs4HC0SZWOl60lQwEzWMAKKnjZmhh2cARafViYQAEzWMAKKogtYUvYrD5ca6OIzbR0FNBachgWsAbOlYonWoRiaEdmbWbZ3ee/VbCB15FdXzGKzZxcaNm9MIECZrCAFVSwgdgKtoqtYrMnhW7tYE8KCwtYQQUb2MERaJVgYQKxKTarBF0NK6hgAzs4Aq0SLEyggBnE1rA1bA1bw9awdWwdW8fWsVkl6HaVWCVYqGADOzgCrRIsTKCAGbxs42FYQQUbeNnG/GvDcc6vXJhAATNYrjWixbCCCjawgyPwqgRyvaQVm1/pKGAGC1hBs6lhAztoNlsv2H4nPIahgg3s4Ai80v/5G9gwgQJmsIAVvGzXOu9iEyUdOzgCywNMoIAZLGAFsRVsBVsxmzVffYAJNJs1X81gAc1mjVrNZg11FQW5lv8WmyjpOAKvouCYQAEvm/2Us4mSjhVUsIEdHIG28PnCBAqIrWFr2Bq2hq1ha9hsMfQ8F5ZOoIAZLGAFr7jZ8sIWQp9oS6EvTKCA2dHmKz6fHw0LaIqr520GodjvY5tB6NjBESgPMIECZrCAFcQm2ASbYMvYMraMzdLJ1jy3WYFiP89sVqDYauA2K9AxgRZhGGawgBVUsIEdHIGWOAsTiK1iq9gqtoqtYqvYLEXWEuNXBPv9pjMZ5h9QsIEdHIEzGSZaXLtgLBkWXsdb7IKxZFhYwStuscvILnD7eWaz9xwtnazV7QK3X182e89RwQZaXOtNu+wn2mW/0GwW1y77hRnENrANbAOb7QiwMHrTZu85JlDADBawggo2sIPYEraELWFL2BK2hM0ydq0jn/zSsBl5s49tRp5jASuoYAO7Xw82I2+h5aZdBDYjz1HA6peGzbKb14PNsltouWmXhs2ymx1gs+wcM1jA6heBzbJzbGD3i8Bm2S203FyIrWKr2Cq2GteOTVV7PqgYFrCC1+HYj22bqubYwRFod4aFCRQwgwWsILaOrWPr2AY2Sxz7PW9T1RwzWMAKKmg2a2pLnIXD0aaqOSZQwAwWsIIKNrCD2CxxrqXSxaaqOQpotmFYwApeNp37JTSwgyPQboA2TmCT0uRaBFpsUppjBRW0uMXQ4lZDi3s1qk1Kc0yggGazM7bnyYUVVNBsdm6Wb/YT3Gaiif38tZloYr9YbSaa2C9Wm4nmWMAKKtjADprNWt3ybeFl6ya2fFuYwQJWUMHLZr8LbSaa4wi0h8iFCRQwgwWsoILYFJtis/um/Yi3mWiOAprN+thKxcIKms3azEpFt86yUrFwBFqpWJhAAS/bmBt2FLCCCjawgyNw7rIzMYECYhvYBraBbWAb2Oa+O1fHjrnzzsQE2jU5DDNYwAoq2ECzVcMRaKViYQIFzGABK6hgA7ElbIJNsFmpGGpYQQUb2MERaKViYQIFzCC2jC1jy9gytoytYCvYCraCrWAr2Aq2gq1gK9gqtoqtYqvYKraKrWKr2Cq2ik2xKTbFptgUm2JTbIpNsSm2hq1ha9gatoatYWvYGraGrWHr2Dq2jq1j69g6to6tY+vYOraBbWAb2Aa2gW1gG9gGtoFtuC0/Hg8wgQJmsIAVVLCBHcSWsCVsCVvClrAlbAlbwpawJWyCTbAJNsEm2ASbYBNsgk2wZWwZW8aWsWVss5Y0QwUb2MEROGvJRFNkwwwWsIIKNrCDI3AWkIkJxFaxVWwVW8VWsVVsFZtiU2yKTbEpNsWm2BSbYlNsDVvD1rA1bA1bw9awNWwNW8PWsXVsHVvH1rF1bB1bx9axdWwD28A2sA1sA9vANrANbAPbCFt6PMAECpjBAlZQwQZ2EFvClrAlbAlbwpawJWwJW8KWsAk2wSbYBJtgE2yCTbAJNsGWsWVsGVvGlrFlbBlbxpaxZWwFW8FGLUnUkkQtsYlmz5JuqGAD+4XJcATahmYLEyhgBsuFZrOtzRYqaDYx7OAI1AeYQAHNpoYFrKDZqmEDOzgC2wNMoNm6YQYLaLZhqGADe+BVNXKy9r3qQ07WUFd9cFTwipCsoa764DgCr/qQrzcV2SaPOQqYQbPZCY0KKtgcbSXAfL2/yHOrz9QMC1hBO+Ni2MAOjkDb+HNhAgXMYAHN1g0VbGAHR6BtBrowgQJmsIDYBJtgE2yCLWPL2GyT0OudT56bgl4bxea5LejCBnZwBNr2oAsTKGAGC4itYCvYCraCrWKr2Cq2iq1iq9gqtoqtYqvYFJtiU2yKTbEpNsWm2BSbYmvYGraGrWFr2Bq2hq1ha9gato6tY+vYOraOrWPr2Dq2jq1jG9gGtoFtYBvYBraBbWAb2EbYbJKcYwIFzGABK6hgAzuILWFL2BK2hC1hS9gStoQtYUvYBJtgE2yCTbAJNsEm2ASbYMvYMraMLWPL2KglmVqSqSWZWpKpJXnWkmRotmIoYAYLWEEFG9jBEThryURsFVvFVrFVbBXbrCXVsIMjcNaSiQkU0GxiWMAKKtjADo7AWUsmJlBAbA2b1ZLrXXO2CXWODbxs2c7Yqka2Q5/1QQ0raBGGYQM7OAKtPixM4HW8tguwTZJzLGAFFWxgB4ejTZJzTKCAGSyg2ZKhgg00mxiOQKsPC82WDQXMYAHNVgzNpoYW93qyselwjgkU0OJ2Q4s7DK+4aw/hK261I7NKsLCDI9AqQbUjs0qwUMAMXjbbI9dm0eVqh2Ppb9vj2iy6rNaolv5qf83Sf2ECBcxgASt42dTabO55PHH4lWpT5xwTKGAGC1hBBRvYQWyKzXJerQst5xdm0E7IGspyfqGCDezgCLScX5hAATOIrWGznG/WLZbzCzs4Au35YWECL1uzi8ueHxYWsIIKNrCDI9Dqw8IEYhvYBjarD82uX6sPCxtoNrtKrD5ce99lmzrnaDY1FNBszbCAFVSwgR0cgVYfFiZQQGwJW8KWsCVsCVvCJtgEm2ATbIJNsAk2wSbYBFvGlrFlbBlbxpaxZWwZW8aWsRVsBVvBVrAVbAVbwVawFWxWS643pNlm3DkmUECrJdmwgBVUsIEdHIGzlkxMoJ3FMLQIxfCK0B+GI9Dqw8IECpjBAl5xrx2Hcu20b+eMO2c8c35iAa8zvt4JZ1tC0LGBHaQ3B7ZBbw56c9Cbg94c9ObMeTuGmfMTOxi9aUsIzmOwJQQdBQybkvNKzis5r+S8kvNKzmuKa0dTAgXMYIljSBVUEBs5r+S8kvNKzis5r+S8SvSbzpyfqGADo99sAuDCTEuS80rOKzmv5LyS80rOKzmv5Lxm+q3QkoWWLLRkoSUt56/ZANkmCzpaSxbDBnZwBFrOdzsGy/mFAmawgBVUsIFms4O0nJ84fzPYH7AnBctCm0KYr0kE2aYQOirYQHpI6aFGDzWu9ca1PivBRK6+Rg81eqjRQ40ealx9VA3tXA+d66FzPVh9uCYcZJtY6NjBK+6wdrD6MOzIrD4sFDCDBayggg3sjjaFcA6P2RRCxwwWsIIKNrCDI9AqwUJsCVvClrAlbAlbwpawJWyCTbAJNsEm2ASbYBNsgk2wZWwZG2OOtgCgI7aMLWPL2DK2jK1gK9gKtoKtYCvYCraCrWAr2Cq2iq1iq9gqtoqtYqvYKraKTbEpNsWm2BSbYlNsik2xKbaGrWFr2Bq2hq1ha9gatoatYevYOraOrWPr2Dq2jq1j69g6toFtYBvYBraBbWAb2Aa2gW2ErT8eYAIFzGABK6hgAzuIjVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklg1oyqCWDWmLTLrO9PLdpl44VVLCBHRyBVksWJlBAbAlbwpawJWwJW8Im2ASbYJu1RA0LaLZiqGADOzgCrZYsTKDZLK7VkoUFNFszVLCBZquGI9BqyULrN/uzs5ZMzGABK6hgAzs4AmctmWhxH4YFtLPohgo2sIMj0KrGwgQ+z6LYdAybdulYwHphMlSwgWaz69eqxkSrGgutzezPzqoxMYMFrKCCDezgCJxVY6KdhRgWsIJ2FnZN9gZ2cFxoV9RVHxzThXYRDAEzaDa7zkYFFWxgB8fCYhMsHc3WDAXMYAErqKB9mlMvtJlQ1xuQMqdSFvsDNhNqYQYLWEEFG+if/JQ5lXKiPMAEmi0ZZrCAFVSwgR0cgfODqIne88UmTTpW0Hu+2KRJxw56zxebNOnoPV9s/qRjBkv0W6mggg3sID1f6flKz1d6vtLzlZ6v9Hyl5ys9r/S80vNKzys9r/S80vNKzys9r/S80vONnm/0fKPnGz3f6PlGzzd6vtHzjZ5v9Hyn52fOm23m/MQKKmh9MQw7OAJnzk+8ziLbGc+vfCdmsIAVVLCBHRyONvuxXJOtis1+dCxgBRVs4HUW1xSsYrMfF14575hAATNYwAoq2EBsCZtgE7NVQwEzaDY1rKCCZuuGZhuGl+2aWlBs9qNjAgXMYAEv2/WavNjsR8cGdnAEWiVYmEABM1hAbAVbwVawFWwVm1UCsUa1SrAwg2azhrJKsFDBBnZwBKrZrH01gQJmsIAVVLCBHRyBDVvD1rBd9aFcX+AXm/3oWMHLlq11rvpQsl1RV31wHIFXfXBMoIAZLGAFzWbXpFWNhWaz5LWqMdGqxsIEXjarvzZT0rGAFVSwgR0cjjZ/sljts62UHc0mhhksYAUVNEU2HIFWQBYmUEBTqGEBK6hgAztotquhbCqlYwIFzGABK6hgAzuILWPL2KyA2D3LViF0LKDZhqGCDbxs1frCCki19rUCUq3NrIAsFDCDBaygvQQwGk7zRYZRCpKg7GQZfC0qVmyGo2MFbYaCUQvqQcNpzk4wSkEWsRpezVDnv72aYdJwsmycZG1gJEE5qATVIA0yifWWpeFCa2s7W0vDhQm0oNZFllpqSWSptdCujSfZzMNyfWlcbOaho4AZLGBdTTInHk5qQT3Im3NOOpyUvRFtHuFsRJtHWK7PmIvNI3S0Br0uCptH6GhHasd/pcyMdWXMohJUgzSoOVla6EQ7SzuQKwGsGW1S4CINuv52M+pBw+m69BelIAkyycQCXv2uFtxunAtboN0ir++si03wK9fElWIT/Byv47Rjt3vhbBi7Fy7s4Ai0e2Gz3rR74UIBczS4ZdLCCmJTbIpNsTVsDVvD1rA1bA1bw9awNWwN28y+ickv9c5F3bmoOxe1ZeBCDbT7VLNDsGRa2EF7ln5SmT9ojVKQBOWgElSDNKgF9aBwpHCkcKRwpHCkcKRwpHCkcKRwpHBYql3TiYpN1HMU0K7DZljAS9RnBAUb2MERaGm4MIECZrCA2DK2jC1js7vT9TK62Jw9xwQKmMECmk0MFWygPSYZDSfL3EkpSIJykEWcaEd6Xa82Ga90a29L0IUCZtCO1HrBEnShgg3soP2kucjyc1IKMlU3zGABL9WwFrbsXNjASzWsfSw7J1p2Djtdy86FAl6l3A7hys5FNUiDWlB3stvgsAa02+Cw9rHnzmtQtNi8OscGdtCO9DpBm1fnmEABM3gdajGqQRp0HWo26kHD6UrqRSlIgkwyDAtYwR545Wu9RjKLTZFzvBpUjEpQDbqO8jGxgR28DtQGh2x+nKOpqqGAl8qGdmx+XLUxGpsfV21AwubH1Wvsstj8OMcOjkC7ny5MoIAZtEvFjrfYtWJtV8xmx1vMZgdZLa4dZE2ggBksYAU1UC2YnaYmUMAMFrCCGtgsmDVUs79mvdoKWEEFn+dm9ztbIm7RcLoSblEKkqAcVIJqkAaFo4ejh2OEY4RjhGOEY4RjhGOEY4RjhGO4w6a8LbqiiFEN0qAW1IOG05Vsi1KQBOWgcKRwpHCkcKRwpHBIOCQcEg4Jh4RDwiHhkHBYrtmwjs1Lc8yg5bUaWmLPv3ZdIdd8rGIz0KqNgtissmoDDDarzB5DbVLZohbUg4bTlTqLUpAE5SCT2LFZ2ixUsIEdHIGWVwsTKOB1+jY6YlPMHCtoca86YNPGarZr57qt2YOzzRpbVIJqkAa1oB40nK7sWmSSaihgBu30rZe6nag11bATta4ZCRQwgwWsoIIN7OBwtAXnHBMooNmGYQErqGADOzgC551tYgIFxJawJWwJW8KWsF1ZV+2JxWaLOSZQwAwW8Iprg0M2A6zaU5nNAGuTJCgHXVfM/Cs1SINaUA8aTnYDs1/4Npmr2kCBTeZybOB1ojZgY5O5FtoNbGECBcxgASuoYAOxVWyWiTbkY5O5HAW0397WlpaJC+3Xt52x3eHsacYmc1X7AW6TuRxHoN0C7RezTeZytB/6doHajdGGN2wyV5t/qwZpUAvqQcPJUtTGQ2xqVrWfezY1q9ovTpua5djB60jtLmRTsxwTKGAGLa6JLRltsMGmW1UrmDbdylHADBawggo2sINmuxrOpls5JtBswzCDBazgZbNiZ9OtHDt4Na+FvXJxUQq6EsmO6krERSWoBmlQCzJJMhyBlq8LE1hAO0wx7KBFuPqzzzGbiQl8Hqn98rOJU4tKUA3SoBbUg4bTlbCLUlA4ajhqOGo4ajhqOGo4ajg0HBoODYeGQ8NhGXp9TVRsipRjA63J7FK1DJ1oGbrQmsw61zJ04XUdTYU9ui6soIINvGz2c9qmSC287q/Vfh3bFKlqv45tilS1H782RcqxgGazg7ScXtjAqwlnrOF0ZfSiFCRBOcgi2nVp2Wy/h23CU73msReb8OQoYAavI73mhReb8OSoYAM7eB3qdX4236na72Wb71TH/LcCXrJrnk+xmU3rXz7/vm3+W9ZupRZ17go2sYDXw6H9gLTJSo4N7OAIvFLSMYECZrCA2DK2jC1jy2azgywPMIECZrCAGu0wt06f2MGroZLZ5lZgExNoCjHMYAErqGAD7YSK4QhUOyHrV02ggNZZFiG2FSxsUVrYorSwRWlhi9LCFqWFLUoLW5QWtigtbFFa2KK0sEVpYYvSwhalhS1KC1uUFrYoLWxRWtiitLBFabHZTGpjCjabyVFBa0nrLPtBunAE2k/ShdaSlgv2o9SGItYWpRZsbis4sYJms3y1X6YLOzgWVpvN5JhAATNYwAoq2MAOWkuWC+e2ghMTKGAGC1hBBRvYQWyCzX7PXhlQbY6TYwYLWEEFG9jBEWgFZKHZkqGAGVTQIuQLrSjM47WisFDADNrxVsMKKtjADo5A+0m8MIECZhBbxVaxVWwVW8Vm9eEaeao2x8nRbN0wgwU0m11GqmADOzgC2wNMoIA2lmGd1QpYQQVtPEMMOzgCbaBqYQJt4MRO3saqFhawggo20GzWUFYfJlp9WJhAATNYwAoq2EBsI2y2Gpyj2ZqhgBk02zC8bNdgTbX5UI6X7RoFqTYfyvGyXUMf1eZDOSZQwAwWsIIKNrCD2ASbYBNsgk2wCTbBJtgEm2DL2DK2jC1jy9gytowtY8vYMraCrWAr2Aq2gq1gK9gKtoKtYKvYrJZco1fV5kM5ZrCAV12/hrfq3HZ0YQM7OALnpooTEyhgBu0sJtrxXpllc5wc7XjtArf6sDCDBayggi3QKkG2ZOi0b+eMLecXKthAa99uOAIt5xcmkN4c2Aa9OejNQW8OenPQm5bzdgw2b8kxgQJmPwabt+RYwbDJo4EdjGtHyHkh54WclxTXjqQCVlDBFseQOhgtKeS8kPNCzgs5L+S8kPNCzgs5LzPn7RiElsy0ZKYlMy05c34YFtDeMTwMFWxgB+09gwWznF+YQAEzWMAKKmi2YtgDa1zgNqFJr+HAajOaHDNYQC4Ne2hYSGdVOqvSWfoAE0hnKZ2ldJbSWUpnKZ2lXIjKhdi4NCz9r5HMapOnHCtoDWXtMF9i2ZHNt1gTR+B8jzUxgQJmsIAVtIecZDgCrSgsvOJWux6sKCy84lY7ISsKCyt4nUW17raisLCDl+16FVxtypVjAgXMYAErqGADO4jtSv/rp3+1eVeLStAz6PXiuNpUrEUtyCLOPzgCLfEXJlDADNrxq2EFFbQf32LYwRFoOyAuTKCAGSxgBRXElrFlbAVbwVawFWwFW8FWsBVsBZvd7K8x7WozuxwTKGtgp9p8L0cbL7IINoq/UMG2hnuqTfhyNJv1ptWAhZftGvquNuHLMYN2btaFNrCwUMEGdnAE2iPANaRebRKXqh2kZbvaCVm2L+zgCLRsVwtm2b5QwAwW0GzdUMEGdnAEWg1YaDZrKKsBCzNYwAoq2MAODkebKeaYQAEzeNmu0fVq08UcFbQXtmJob2yz4Qi0B4NrQLfapDFHe2tbDTNYwAoq2MAOjkCrDwsTiE2wCTbBJtgEm2ATbBlbxpaxZWwZW8aWsWVsGVvGVrAVbAVbwVawFWwFW8FWsBVs8127GiZQwAxeGXu9369z39SFCjawgyPQfgwsTKCAdhbN0I53/tsRaPf9Zhet/RhYKGAGC1hBBa+43S7wTvt2zthyfmEFFbza93qzUG1+mOMItJxfSG8ObIPeHPTmoDcHvTnozUFvWs7b4dhkMscECpjBy3a9/qg2m8zxsl1vQqrNJ3Ps4Ai0nO8WzHJ+oYAZLGAFFWyg2ZrhCLREt86yaWd6vQ+pNu3MsYAVVO8Am3nm2MHoLJt55phAAaOzKoleSfRKolcSvZLolUSvJHol0W2OmV7vb6rNMXNU8Io7rB0spYcdmaX0REvphQkUMIMFrKCCFtcuDbu5L0yggBbXLg17wF9YQQXt9jX/WgdHoCX6wgQKmMECVrDP91jVpqlNum74i66Xb9agV+ovykF2/MWwggo2sIMj0F7z2eVsr/kmSZA1lR2IZf3CCl7PynYaV9Iv6kFjkc1XW5SCJCgHlaAapEEtqAeFI4UjhSOFI4UjhSOFI4XDEvya/lrndLaFI9Bu6tdE1zpntC20qVQPwwwW0GZTJUMFG9jBEZgfYAIFNJsduk3EWVhBBc1WDDs4AssDTKDZqmEGC3i14/yjGtSCetBwupJ/UQqSoBxUgsJRw1HDUcNRw6Hh0HBoODQcGg61VrNeVmu1YdjADo7A9gATKGAGC1hBbA1bw9aw2SQ7eydks+wcBcxgAStotmbYwA5eNhsFsLl3LdnVMz//MGpB11+y9y42sW6iTaxzTKCAGbRDbIYVVLCBHRyB6QEmUMAMYkvYErZktm7YwRFok3nshY9NrHMU8LLZWx6bWOdYQQVtclwytNlx101nTre7PvStc77dwgwW0OJWQ4trjTon3dnxzll3dmRz2p2hJfrCBNrsPjsyS/SFBazgZbORLZuY12w83CbmNRsEt4l5zYb1bGJes6FFm5jnmMECVlDBBl62Ym125fpCNYU1nwqYQVPYQVqaL1SwgR0cgZbmCxMoYAaxNWyW5pY4c0Lewg6OQEvzhQk0m3WspfnCAlZQwQZ2cASOB5hAbAPbwDbMZtfOULCBNtvQesjqg40R2lw/x8tmA4M218/xstmonc31c6yggg3s4Ai0+rAwgQJiS9gStoQtYUvYEjbBJtgEm2ATbIJNsAk2wSbYMraMLWPL2DK2jC1jy9gytoytYCvYCraCrWAr2Aq2gq1gswJiI6Y2UTBZRbSZgo4CZrCAFbS4V0W0eYDzlmYTAZsNMNpMQMcCVlDBBvZAqwTXZNzaG2c8p+DaWcw5uBMb2EE74ytbbH6fYwIFpH07tk77dtq3076d9u30puX8PAbL+YUCZrDEMVjOL1QQ28A2wjYeDzCBAmawuHg8KqhgA7sfw3hES470ALGR84OcH+T8IOcHOT/I+ZGi30aKK3XIA0xg9NuYOT+xgNjI+UHOD3J+kPODnB/k/CDnR45+G5mWzLRkpiUzLWk5b4PeNqtwoeW8jV7brEJHATN42dSOwXJ+oYIN7OAItIeGhQk0mx2kPTQstMlczbB5FtpUwnZNKa82lXChPsAE0kNKDyk9pBVUsIFcfUoPNXqo0UONHmpcfVSN0bgeGtdD43qw+qB2xlYfFgporWPtYPXBhs1t0qCjgg3s4Ai0+rAwgQLaLHW7SqwSLGxgB6+41zx0temBjgkUMK95xGrTAx0rqGADOzgCbXLwQptpL4YFrKCCDeyBlt3XmwR9zMn6xdAiVEMFG2gR1HAEWh5fg8hqk/scBbTjtUO3PF5YQQUb2MERaHl8jSerTQR0FDCDBaygro8G1Kb8rXawjF1I61jGXqOgalP+HAtYQQWvs+h2EVgeLxyBlscL7VsKs1keL8yg2awDLI8XKmg26wvL44Uj0PK42xlbHnfrFsvjeUVZHndrHcvjhRW84g47N7vPT7Q8XpjAK+6wc7OMnReXZezCBvZAS9OFeX1ZozZLz7GCur63UZul59hB/yBH0/wgZ2ICBcxgAa+DvIbS1ObjOY5AuzUvtJPPhgJmsID+YZLafDzHBnZwBNp3cAsTKGAGr7jX5BJN8zu4iXYWxXAEWvIuTKCdhf01S96FBayggg28zqJYS9qXORPty5yFCRQwgwWsoIIt0JJ3TEyggBm0s2iGFVSwgXYW1m/z4znD+fHcxAQKmMECVtD6ohuOQEvThXYWw1DADBawggperZOtL+wjnIUj0D7CWZhAAa/Pla5BX7WZd/1hF5d9WTPRxtwXWgRrs/mV68QMFrCCCjawg8NR5leuExMoYAYLWEEFGxg2m2PXryFmtTl2jhksoLVONlSwgR0cgfIAEyig2YphASuooNmqYQdHYH6AyTvL5tg5ZrCAFVSwgR2M68Fm0/Vr2FltNp1jAS2uNbV9ZXd9s6E2m86xgyPQPo3NprBPYxcKmMECVlBB++DuYWi2YTgC7Zu7hQkUMIMFvM4tmeK6NTs2sIMjsD3ABAp42ZJ195XzjhVUsIEdHIH2Pm5hAq0l7aqeX7ZPLKDZrN+62aw3ewM7OAKtPixMoIB2btbHo4AVVLCBHRyONgnP8bJdw9Fqk/AcM1jACirYwA6OwOvu36+ha7UdVx0FzGABK6hgA83WDEegVY2FCRQwgwWsoL3RNmpBPWg4zXfyRinIIk60Ix2GHbQqbcdvd/iFCRQwgwWsoIIt0L62vUbs1SbWdUtmm1jnmMECVlDBBl5nYVe5TaxbaDVgYQLNlg0zWMAKKtjADprNzs1qgN1zbSU1RwEzWMAKavRFo4caPWQ1YKLVgIUJFDCDBWxrRSK16XaOI9Cy3e6jNt3O0c5i/oEMFvA6i2Ida9m+sIHXWRTrAMt2Q5tu55hAAS+bPfnadDvHCirYwA6OQMv2hRZXDa8r1R6QbLJcv15tqE2Wc0ygHVk3zKAd2TCsoILXkVVT2B1+4Qi0O/zCBAqYwct2vcRQmyznqGADOzgCLbvnGdsdvlpT2x1+YQUVtLjZsIMj0LJ7YVpLfOlcWG1hBgtYQQUb2AMtj6/hJ7UJcI4ZLKCdxfxrCjawg2Mt76ZzxbWFCRQwgwWsoILWOnadzVk0ExNoZ2EXl2XswgLaWdh1ZnfthXYWdnHZXXvhCJwzaayP51SaiQJmsIAVVPCy2a9Sm0LnOBxtCp1jAgW82uwae1ObLGere6pNlrNlJtUmyzmOQFtUcWECBczg1RfXDGWdS7AtVLCBl81GCOpcydRwrmQ6MYECZrCAFVTwimsXl82Q69f0KrUZco4CZrCAFVTQ+sLOwrJ74QgsD/A6C7vO6lzmd2IGC1hBBRvYwRFo9+5rXFxthpxjAe0srB3s3r2wgXYWM9gItHv3NYysNm/OUUCzdcMCVlDBBnZwBNq9+xpGVps35yhgBgtYQet5u8AbPd/p+U7Pd3q+0/Odnu/0fKfnOz3f6flOzw96ftDzg54f9Pyg5wc9P+j5Qc8Pen5Ez+v8et3uSTo/X1+sxsm4wfNb9flnrvQK3uJI27hvPOC8xbE7Tpt4ta9VApu65ZjBAlbwal8bRra5Wt0GjG2ylmMCBcygxS2GFVSwgR0cgXb1LTRbNRQwgwWsoIIN7IF2IdpAv03TchQwgwWsoIIN7OAIHNgGNrv52LsEWzjNsYAVVLCBPVp9RGfZ/C7HBFqwbmjBhmEDOzgC7RnRhv9t+pajgBksYAUVbGAHR6BgE2yCTbDZU+ZCbPaUaa8gbPrWwjJzpxoPeK6YsjhtLBvnjcvGdWPduG28eevm1c2rm3euk2IPOm0ulLJY4UZtaXNNE3sEanNRk8V94wHPdU0Wp40LMfsWv+vGbeMZ366QPuBh8a3s20ylJ1v7D9k4b1w2rhvrxm3jvvEItilLwWlj2ThvXDauG+vGePtcxcRuO30uWGK3lZ64HnqqG+vGbeO+MddDl8fGaWPZOG+8eWXzyuaVzbvuHcV4wOveMTltLBvnjWe7Ta4bz3YzV24bd7jMflHjGacZ143n8VvblhbXUp/5u3jA9bHxjN+NZeO8cYlrvq/8nawbb966eevm1c0783fx/DNXLvS5YtHitLEdm92k+1y0aHHZ2I7N7sh95vhiOza7PfeZ44sHPHPcin6fOb5YNs4bl43rxrrx9Fpfz9xfPOCZ+4vTxrJxpq9Xjtsxrxy39l85PnkEj5Xjk9PGsnHemL4ej7qxbtw27pHXYy5gNHnl/uS0sWycNy4b1411Y2rmWLk/mWtpLXs2j23l/uTtvGQ7L9nOS7bzkr4x94KRHxunjTdv3rx58+bNmzdv3rx58+bNWzZv2bxl85bNWzZv2bxla89VKyZv/Vi2fqxbP9atH+vWj3Xrx7r1Y936sW7eunnr5q2bVzevbl7dvLp5dfPq5tXNq5tXN69u3rZ52+Ztm7dt3rZ51zNGMdaN28Z9Y+4pa+20xSnq/1o9bXHeeJ6XGo+oD2M9S0ye14kd23qWsBxZ9WRy2bhuvF2fY7s+x3Z9jqjt7fF4bJw2lo0zPHOtTe4bD3jm2lXD22Pm2mLxut0eM9cWl42jJrdH1o3bxn3jAZfHxmnjqMntMXNtcdm4bqwbt42791GzOUPjMVHBBnZwBNp3QAsTKGAGC4hNsSk2xabYGraGrWFr2Bq2ZjY1VLCBHRyB/QEmUMAMFhBbx9axdWwd28A2sA1sA9vANrANbAPbwDbCZhOQHBMoYAYLWEEFG9hBbAlbwpawJWwJW8KWsCVsCVvCJtgEm2ATbIJNsAk2wSbYBFvGlrFlbBlbxpaxZWwZW8aWsRVsBVvBVrAVbAVbwVawFWwFW8VWsVVsFVvFVrFVbBVbxVaxKTbFptgUm2JTbIpNsSk2xdawNWwNW8PWsFFLErUkUUsStSRRSxK1JFFLErUkUUsStSRRSxK1JFFLErUkUUsStSRRSxK1JFFLErUkUUsStSRRSxK1JFFLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItkVlLuuFlu2YzNZsw5VhBBRvYwRFotWRhAgXE1rA1bA1bw9awNWwdm9WS6wviZhOmHDNYwAoqaC05DDs4Aq2WXHOymk2YchTQbNaoVksWVlDBBnZwOOa5lsHD8LJdE5tanqsZTMxgASuoYAM7OALnqgYTsSVsCVvClrAlbAlbwpawCTbBJtgEm2ATbIJNsAk2wZaxZWwZW8aWsWVsGVvGlrFlbAVbwVawFWwFW8FWsBVsBVvBVrFVbBVbxVaxVWwVW8VWsVVsik2xKTbFptgUm2JTbIpNsTVsDVvD1rA1bA1bw9awNWwNW8fWsXVsHVvH1rF1bB1bx9axDWwD28A2sA1sA9vANrANbCNs5fEAEyhgBgtYQQUb2EFs1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi0p1JJCLSnUkkItKdSSQi2p1JJKLamzlmTDDBawggo20GxqOAKtllwTi5tNFHMUMIMFrKCCDeyg2a4nvDprycQECpjBAlbQbGLYwA6OQKslCxMooJ1bNSxgBe150sRWSxZ2cARaLVmYQAEzWMAKYivYCraCrWKr2Cq2iq1iq9gqtoqtYqvYFJtiU2yKTbEpNsWm2BSbYmvYGraGrWFr2Bq2hq1ha9gato6tY+vYOraOrWPr2Dq2jq1jG9gGtoFtYBvYBraBbWAb2EbY5nptCxMoYAYLWEEFG9hBbAlbwpawJWwJW8KWsCVsCVvCJtgEm2ATbIJNsAk2wSbYBFvGlrFlbBlbxpaxUUuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotWQu5natxt7mam4LR6DVkoUJFDCDl+1aGarZFEFHBRvYwRFotWRhAi/b9UFDsymCjgWsoIIN7OAItFqyMIHYOraOrWPr2Dq2jq1jG9gGtoFtYBvYBraBbWAb2EbYbLagYwIFzGABK6hgAzuILWFL2BK2hC1hS9gStoQtYUvYBJtgE2yCTbAJNsEm2ASbYMvYMraMLWPL2DK2jC1jy9gytoKtYCvYCraCrWAr2Aq2gq1gq9gqtoqtYqvYKraKrWKr2Co2xabYFJtiU2yKTbEpNsWm2Bq2ho1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWNWtKoJY1a0qgljVrSqCWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklnVrSqSWdWtKpJZ1a0qklNjVzXF8ENJuZudBqycLLdk27bTYt0zGDl+2ab9NsTqajgpftmjzcbEKm4wi0WmKzWWyWpqOAl00tmNWShRW8bDqDNbCDl80mn9ikTccECpjBAlZQwQZ2EJtiU2yKzWrJNSO/2SpzjhVUsIEdHIFWSxYmUEBsDVvD1rA1bA1bw9axdWwdW8fWsXVsHVvH1rF1bAPbwDawDWwDm9WS68ODZlM+HRvYweFo0z0dEyjgZbsm/Teb6ulYQQUb2MERaLVkYQIFxJawWS25liBqc+vahQ3s4Ai0WrIwgQLaA/2VWWP+LMmGAmawgBVUsIEdHIHzZ8lEbAVbwVawFWwFW8FWsBVsFVvFVrFVbBVbxVaxVWwVW8Wm2BSbYlNsik2xKTbFptgUW8PWsDVsDVvD1rA1bA1bw9awdWwdW8fWsXVsHVvH1rF1bB3bwDawDWwD28A2sA1sA9vANtzWH48HmEABM1jACirYwA5iS9gStoQtYUvYEraELWFL2BI2wSbYBJtgE2yCTbDZo0SfaMVGDUegPUosTKCAGSxgBRVsILaMrWAr2KyWXOuzdZtu6ljACirYQLMVwxFotWRhWSWzz5moCxVsYAdHoJWKa2G4PmeiLhTwOvRrNbg+Z6IurOBlu9aI63Mm6sIOjkArFQsTKGAGC1hBbA2blYprAbc+Z6JOtFKxMIECZrCAFVSwgT4Ho8+ZqBNnqZhoNrs8rVQszGABK6hgAzto53ZdXHMm6sIECpjBAlZQwRZoiX6tmNbnPNKFCvo7n57iHWtP8Y61p3jH2lO8Y+0p3rH2FO9Ye4p3rD3FO9ae4h1rT4JNsAm2jC1jy9gytowtY8vYMraMLWMr2Aq2gq34G6Y+55EurKDZhmEDO2h9fF1Gcx7pwgQKmMECVlBBf8PU5zzShSPQKsGwY7BKsFDADBawggo28Jou/3hMx4DtUw3ntLFsnDcuG9eNdeNmnI37xgPuj43TxrJx3rhsXDe2t3fVsIEdnNKrzNrU0uC0sWycNy4b141143mylpWjbzyCbZJpcNpYNs4bl43rxv4zvs85o9ev9D7njC4soP0efxgq2MB5sN14wPLY2A422Z+3j8Kc88Z2sMmk9lGYs27cNu4bD3juYrk4bTy9xThvXDauG+vGbeO+8YDnfpaLp9daeO5ouThvXDauG+vGbeO+8YCtrlTTWl1ZKOCUqnHZuG6sG7eN+8YD1sfG82SHsWycNy4b141147Zx33jAs8xYdZZZNq5967vMsrG4bdw3HvAsG4vTxrJx3tgSwpLHHigWKjil2bhvPOBZNhanjWXjvHHZeJ6sNfgsG4vbxn3jEZxn2VicNpaN88bT243rxrpx23h6h/GA02PjtLFsnDcuG9eNdWMbmnsYdnAEzrKTJ6eNZeO8cdm4bqwbt43tZK+l4vraO3fyLDuL08aycd64bFw31o1n/CvN1xa42TpolovFunHbuG884PrYOG0sG/tYaZ8zRxdWcEqbcdu4bzzgWS4Wp41l47yxnWyxBp/lYrFu3DbuGw94lovFaWPZ2LzX2nQ9z6eSxXVj3Xh6rYNmeVk84FleFqeNZeO8cdm4buxj0n3OK13YwSm1TpnlZXHaWDbOG5eN68a68TxZc83ysngEl1leFqeNZeO8cdm4bjzjD+MBzzKyOG0sG+eNLb49nJRZRhbbedlTjc0tDTbvtSBeL/MBZvKsJNcXu73MSrLYvHZvLbOSLJ7ealw3nl41bhtPr537rCSTZyW5vurtZVaSxdNr5zgryWLzWvUrs5IsNq/aOc4HmMXmVTvHWWEmzwcYtXOcDzCLzWuJX+YDzOLptXOcFWnx9No5zoq02F9u9BKvUnqJVym9xKuUXuJVSi/xKqXPjXcfduXPnXeddWMzNmuBWY4WD3iWo8VpY9k4b1w2rhvrxptXN+8sO81afpaXZq09y8s8r1leFreN+8YD7tvx9+34+3b8fTv+vh1/346/b8fft+Pv2/H3rd3G5h2bd1aSeY6zYsxzHNvxD46/zoqxOG0sG3P89VE2rhvrxm3jvjHHX9Nj47SxbLx50+adFcPOsc7KYOdYZTt+2Y5/VobFZeO68Xb8sh2/bMcv2/Hn7fjzdvx5O/68HX/ejj9v7ZY3b968swLMc5yZPs+xbMdftuMvunHbuG+89ft89ri+u+91Pnss9hdwfU4OXVjACs7YV6WpK3ft38/c7XbsM3cXl43rxrpx27hvPOD5KLE4bbx556NEtzabub64bqwbt437xgOeub44bSwbb96+efvmnbnerZ9nri/uGw945vritLFsnDcuG9eNN+/Aq7MG2Ki/zly3QXCdub64bqwbt437xgOeub44bSwbT281LhvXjXXjtnHfeMCzNixOG/tr3z6nfy4s4JSqsW7cNu4bD3gWhsVpY9l4nuwwLhvXjXXjtnHfeMCzYCxOG5vXhrl1FpLF5h3W+LOQDGuc4u+5+5wTurCDI7A+wAQKmMECVhBbxTYLiw2L63xYmDwfFhanjWXjvHHZuG6sG7eNp9eugVlwJs+CszhtLBtneC5aYyOnOhetWSwb543LxnVjNbb+motmTZ6L09hgpc7FaRbrxvPP2/HMxWkWj+A2F6exN39tLk6zWDbOG5eN68a6cdu4bzzgtHnnIlg2VtfmIliL88Zl47qxbtw27hsPeC6OtXjzyuaVzTsXx7o+TO5tLo61WDduG/eNBzwX7FmcNpaN88abN2/euWCPjTW2uWDP4r7xgOeCPYvTxrJx3rhsXDfevGXzls1bNm/dvHXz1s1bN2/dvHXz1s1bN2/dvHXz6ubVzaubVzevbl7dvHNxLBtSbXNxrMV94wHPxbEWp41l47xx2bhuPL3DeHqbcd94wLPOLE4by8Z547Jx3dhnG/U5B3RhB016fQff16qci9PGsnHeuGxcN9aN7WRteHWtyrl4BK9VORenjWXjvHHZuMLxAUrvs/ZcO2r3PmvP4rxx2bhurBu3jfvGA561Z/Hmlc0rm1c2r2xe2byyeWXzyubNmzdv3ll7rg1V+lqU00ac16Kci+vGunHbuG884Fl7FqeN/RuOPueBLizglDZj3bht3Dce8Cw8i9PGsrGdrI0grxU8F9eNdeO2cd94wLPwLE4bm/faRaX3WXgWl43rxrpx27hvPOBZeBb7lyt9zhBdmMEpFeO6sW7cNu4bD3hWncVp43mydnXNqrO4bFw31o3bxn3jAc/Cs3h67YqaBWZx3XjGt4tqFpjFM75VgFlgjNeSoIstvo1KryVBF+eNy8Z1Y924bdw3HvB8Glq8edPmTZs3bd60edPmTZs3bd60eWXzyuaVzSubVzbvrEh2Xa2lQhe3jfvGA54VabFNU6uGM6QY68Zt4xkyGw94FpvFaWPZOG9cNq4b68Zt480764qNya/VPu31/Vrtc3HZuG6sG7eN+8ZzlOa6hMcaHZ2cNpaN88Zl47qxbjzjW/PP+lHs388Hl8Wycd54nlczrhvrxm3jvvGAZwlZPM/L+neNmk7OG5eN68a6cdu4bzzgOWIyz31s5zVLyOK6sW68ndfYzmvEeY212ufitLFsnDeO8xqPR91YN24b940HnB4bp41l4+rnPh4pzms8VqmY3DcesGznJdt5yXZesp2XlI3rxrrxdl6ynZds55W388rbeeXtvHLeeGvPvLXnHDSZ55638yqPjdPGsvF2XmU7r7KdV9nOq7SN+8bbdVK386rbedXtvOp2XnU7r7qdV92uk7q1Z93acz6PXO/jxmM+jyzOG5eN68a6cdu4bzzgVU8mb962edvmbZu3bd62edvmbZu3bd6O1+ZGPv/nYSwb542LsRjXjXXjtnHfeMB2fTqnjWXjvPHmzZs3b94y42Tj+eeLsW7/fh5bNZ7HpsYDro+N08aycd64bDyPrRnrxm3j6e3G02vtb/csEWtnu/bkmiM0bMKjn4vmjbdznNfVsPjzupo8r6vFaWPZOG9cNq4b68Zt4+m1c5nX1bBzmdfV4rSxbGzn8rDztfuUc91YN24b940HbI+6zjOmteGYf9eukzH//HU9zNmIcg38jTkb0Vk2zhvrxjPOdS3ZYpbBM44az2NoxvPPX201JxY6p42ndxjnjcvGlfgz79a/bxv3jQc8887aYU4sdJaN88bb+ebGOea+8dYO87mu29+dz3Xd2nk+1y2uG+vGbWO7rrp5Zx3uFn/W4cV547Jx3XjGt7aadXhx33jAM18Wp41l4+m1Pp35srhurBu3jfvGA575sni67HqYPwcXl43rxrpx27hvPOD5c3Bx2njzjs07n/G6XT/zGW+xbtw27huP4DmFb/bLnMLnLBvnjWc9uXJ5TrdL16cVY063cy4b141nvcrGbeO+8YDnc9ritLFsnDeeXjGuG+vGbeO+8YDnT7rFwvnOgaXrJdOYs+mcG+c4f9MtHvB8Nls8z8Xacz6bLc4bz3NR47qxbnE2b9m8ZfPWzTt/6y3e+q5ufVe3vqtb39XNWzfXzP1mxzxzf3HZuG5scZqdy8z9xX3jAc/cv7b0GnOinbNsnDcuG9eNdeO2cd94wH3z9s3bN2/fvH3z9s3bN+/aEebK37x2frEcXLls19jK5cm6cdu4bzyCy8rlyTOXk7FsnDcuG9c4njKHfBa3jfvGA55DPovTxrJxhudGZRML+DyCbok2t8Nd2MAOjgvtwG3DzIUJFDCDBayggg3sIDbbA9cqw9wD1wrP3APX8nbugbuwgR0cgbYj4cIECpjBAmKzHQmtMNj0NMcOjkDbp3BhAgXMYAEriE2xKTbbp9Bqoi2O6JhAATNYwAoq2MAOYuvYbHNCew6eu93aY/Dc7XaibTi4MIECZrCAFVSwgWNtIjjmFrcLEyhgBgtYQQUb2ANt70F7ZJ/LFdrT9VyucGEFrxdi9sg9lytc2MEROJdkn5hAATNYwAqisNSz5865K609Rs5daRd2cATarrT2uGHLCjoKmMECVlDBBpqtGI5Ay8KFCRQwgwXUODdLPXsMnVvRLkxxQpZkCzNYQDv0ZqhgA+3QrectySZaks0IDVvD1rA1bJZkC+mWRrc0uqXRLR1bR2F7fVoFn5vOLuzgCJypZ9fkTL2JUavryGABK6hgAzsYtdomgjkmUEDLCzFsYBy6TftaODdGyIYJFDCDBayggg3s4AgUbIJNsAm2uQVCMeTk5w4H1VC8qXXeCycWsIIKNrCDKArtW2jfQvuWDBawgtGbc3deu7HO3XntxqrcC5V7oXIvVO6Fc3fehQ3sYNx55569CxOIjXuhci9U7oXKvVC5Fyr3wrln78T2ABMoILaGrWHjXqjcC5V7oXIvVO6Fc/vehQJmsIAVxNaxzeRthnEvVO6Fyr1wbr67MO68c/PdhQkUMIMFjHth417YuBeuLXkN0wNMoIAZLGAF7SyunJ9L5NktdC6Rt1DAuBc27oWNe+FcIm9hAzsYd965RN7CBAo4Ff/1X//wp7/+67/887//5V//9k///vc///lP//if8S/+7U//+D/+80//75///ue//fuf/vFv//HXv/7Dn/5///zX/7A/9G//75//Zv//7//89+d/fZ7Cn//2v5///wz4f/7y1z9f9F//wN9+fP5Xr19nuv76NbI0IkRKvwZJnwexdLcQz5+sBGj9lwByOAr7AHcexHNw/9MQpxN5Dub3iNF6+/REyuFExA+jZ1qi6S9/v37+9/WaBWB//1mYOAC9fwDqAXp/fHYA7fO/367xavv7LesrB2DrrayurJ8dwPj879frZYf9/eezx0sHUD3AM6c+O4B0uhjjen4+vr10BFdpXNdRSp8eQj70wojLKMmnh3C6mIvNgJ4H8fw9nT/PysPVKGX41STPHx9bDLkd4zkk5tXlOdqVthj11xiHi9IGSuZhPDiT/PEo+qFPH+W/ycvfIhyuS1uiZ15W48UIGj3yfG/+eYhTY9buMfLzefHTxpRDqXy+n/Bi+3yVsF0Y+UO1zadO9eviOUq1Fdv7l9ZztJAzye3zMznEeP6C8kvribSGfgihpzwZXi2e7wbl0xCnitmiXOz3rtpvR+jFT6Nr+jzC3dNon5/GqTHbI0XhfYzPQuR0Khc9R7ko6dMQ8m5T5MOl+XyRFpf381EgYpRfsywf76Febp4PuZ8fRD09S2jchy/mMJ6Zc/9UUm5xKjV9eiqHS0u6d+rzlc5nAc45NjQui5Q/7dP3694pRLZ1YFbBGZ/fREo65YhK5MjWGPLhOMrh8qzdO0QfdYuQvnFl9MGVMbZe/XhllNMTRul+iV5jhcTQD+dyurm3RyTK85cMPXu7V8ojIpTUPr8bleOtPR7Xnj8etnuJfHjcOtzc0/OVSLRpSVsZT/KhPcb710d9vHt9HM/l+RbjEeeS9we3D+dST/d42xR7VY4+tiMpv8bI714fp6v0fhU8R7mbMVXfz5ja3m6RY+9q5rFct575rXcPV6po9Zoszxbeenf8EkMPV+qz+np7PF/M7zHarzHS8dHeL/fnC+78eYzTcUiJR0nph+M4XKnPVy9+HM/3LePTGOee6dGoz6ep3j/tGT39fLepVrMAZPm8DunhSn2+Q31EVU39pRjVvrWaLXJV0pfOJYvHeA7qfl6H9PRjXqN3n28zPo9x7Jnn+woKcz+0ajvd/VOvmWGq9vgke5v8ofmvpcU41XPw+vMWaeUPvcs0WzdmHsdz/PTzOtQOV5lkfpfvvwPlw/2/vV1Tj0dRkueLlPL49ChOTyHP+2KcSWrp06eQfqpkOvwCyy3vLZpux3je/L0IlbwPAH6MIe8/x/T89hV2bNH45SHySwV63I8hmRinXtF3h456e3foqPd3h47OLdEjS54DJ5+2xHgcn5JjeLuU/Wn916eGcbzjS1zj+ZcR8nH/OMpWetIhxunZNMcw9XOkQT+NcWxTjbEG0f1cvnOFarSptP04PvbL21foePsKHX/sFdpqjFWMQ77bw83nYzeNAY/t7UH68CCXHodr9NpFzF9htNpfC3KtqxIDUTUdguT3K7EtbPEHluKR4+fCaPrahT7iMPJD+qF73x/Gf7w/jv8Yf+S1nh95xG+WLJ83xuktUxJ+G+e8X2H9G0FGiYR5bO/7fg9yukxrjyZJdSTC5A+PHbZ6yKftGmMw+0X2/I14v6orzwzt8XlVt0UlPj+bwU/sOrYC8PEN4LGa8YLjsf/i+O1IDtdqkXgnXZ418dMXLen00ujZw3Hnf2x3yw/jr7bcxOejpzFM9/h8PDvJ4UJ7/lZpvJh+fDoEk+T4kn6IMJIj+dNRmPNdosabCtF8qM1SfqBd6/vtqj/Rru1H2jUdX9+kqM91HIqJHF/fS4zF1G0s5reLPj/e75zTy6ibnXN6GXW7c04vce53zvk1TIxOPQdSPn21dnrj+hxMjnJU9okNH1/EZz3d+uK5KKdfXtu2bwSxD+7+m/vnb0H6229u0+kFxr1Xt8cQ915Y3j+TdjiTU5Paug2rSU/PqyW//XB1fDF1b5bEMcTNaRLH5qgaT2jHx/dyfLEfr7OvPUY/L2XHID3mOVy7Ox6CjPev9dOrqZvX+inEzWv99pkcrvVzk2r0Sx8v9ktPg/Zoh4ezenqZW2PY8DmKug3mfpwIc7xWR8zHeb7HPJTU06up21dIf/8K6W9fIbfP5NVqOOKHxPMdtX7epCrvN+npzdTNJj2FuNmkt8/k5SatPE89+ms3/mK7uawg5dQv/fQodGvWV9IfKKjt/YLa3i+o+gMF9dyi7z9ctnjsL62Nzx8u2+mNo8RAlZZ8qMmn10G26JY/bT8+Lcmnji3i3dLK9oxbPwyGtEOTPt97erpo3Z5iUv/wFNNOfctr/v1BqHwYg+jHc8lxryz9MLLTTz+lSP1E0j7H4D+EOE5IGbzK2V/R/xbk9FYqXkjX/HgxREzN1lRfPBXpI956bv3yvSAtKuFzrOlwMseLrDZ+n+416ONFdno5pS0GM9s+R/A5ZPghyHF+niaeYba7w3gt67aS/DHrTq+nrh2MvKCWVD49DFvQ4TBqz3uybR6ISPkQJN98KZ0//wZglNOFFi+Dn68/y+cxTiW1REXdfo+l9uF+O47zUbyClJ4PIY5TSeKNzONxCHG4THOP5/W8v1/K+rFXTgWVX8kpba/Xc/8wT/o0/GhfP86fuPs8st9CnEZT4/G0bWNTH0N8cYE9tlkP+tnFIcf3U63HQMyT2+cz6+T0hirRNc/szJ92zTGIpihl253/Y4hj/eDXet1q+4f6IacXVK2U7W6554t852mq8TTVX3wiuzcZ3xZ9O1whUT72YvhbjPT2c7It8Pbec/IxxM0PJG6fyeELiWOLMoNC9iehb8WoMYAqNefPY7TTQ0zMoKhDx4sx4i3ZOcbxCrv1vYfI27+ijiFuXh3Hb6LufTQip2+i7n01IqeXUvooiZf9+yTljy16mtd/65OP02HUEbON9LG/Dv7tMI4vpe5O2xY5zUy5OW9bTi+l7k0yPF8h977FkeP3Ue/3TItJA89n/3LomdtBxotBerwsfOLLQeLb0Lp/a/u9IOMRPwuHlBev1udgcbyle3I+XK3Hi/7uFw9fhGnxxHytbp1eDjN49di3UbvvpWATvqhWOaTg7SDj1SCsE9BGfS3I863S1kePfgpzfunemFD+2B6wvtlHfXs93Pdn32+G2RZA6Plw/d6/o3/+Re3pFU/j7Uz79E76xRP0rW8Opab3h5rPQfgW6zke2Q9Bjt9RxVyi56/4w9mU95/DTy+rbj5pnULcfNK6fSanL5WPLarcznt5KUa2kdc1kWG0V2M83o6ReSjI23j192LEo+cz3OcxNL//m+Ic495viuO5lBixys+BuPdjvHiNZYmR4lz6532rx699uNE8348cEuZ0IC2m7eSmn5eP03umu517jvEDndsS53JI3HacTxWziK9dzV5t1FgdJffDVdbenv0n7TxXla/BHodH19NxlHjhVfYv7H5rjuN9LqbLlLzPqPh4nzu9rbo73tQf79/nTm+rbt7nTiFu3udun8mhBh1b9OZ40zHGzfGm0zdUd1P/fHXcGyvq/f2efXuCyjfO5PPaMdKbz8jnlC2FtN+/zv2YsuPtCX8y3p7w98WpME++nJ6yx/uzBs8HYhv1zes8PeRwIP39Nn37C5VziB9ojmoz11dzlM+bIz/kj7zSa4mbU32Wn8NhlNNNMm7W2wqF8viwpM/j/fVSjkcRozr7rfr3o2inE4l7QpF9avz9EDY+wFhBfbwWZFQGHMY+a+hbQfqDMZRt4P07jRoDd2Ucuvb0fukHQlxjbYwq9fTpqZyD3OyZc5CbPfNFkFs9c85c3Z4b9tep3xmD0RRno78uMvStIMz7ef46fDFIiV8e+sunLd8KkmPUUGv7fGZ6Pr2MuHePyae3VffuMecQP3CP0RrHoZpOzfEDn/zl0wiqaszlbg893O3kBz75y/L+J385v/3JX84/8Mlfzj/yyd85zLViAa9ntH0e5osL5VG5ULbRg29UtZZjQlTL5XDJnmZC3xwUzvn9Of85v/2T6hji7pKN78/5/6JFbw0K5/NXVLcGhb+K8Xg7xr0B3Xxa3u+XH+1VXjyOW4PTXxzHrbHH++dyiHE8lxKvifOzTH8aoz7+6OO4NcB9P8aL+XJzgDsfX+bcHOA+H8i9Ae5c9f2LrOof3Ln3BrjzaXW/uwPcXxzIrQHurG9/QZ2PXx7dHOA+Hse9Ae4vnxC3JS5q+ewJUesPPGZqffv3+/H5sMUssSd+fqHq+19PZ3376+ljiJvPDrfP5FALz0/ccZ9LY3xeglr+gfJxeuTmR/cT0+GR+/R8ysyHtv98+FYQZY6Ytp5fDNLjh4z2ll/+BbHPIxz68i+IxNz/5+D5IcyxXeJ1irYirzYuP3r747Q2+OP9qnh6k/GITxkkPfpLqSOJRUPS4Y7X336TmvsPvEk9HsfNJj13bQwlPntZXrzk0yNvU8vKyz+a7Vttf5JoL2dOksf2QHLInONEb4n3ALwGyN8akRxbozzqS8Oaz784CCKfjtKO+gOj1uP954AvRs/vtcgxyO0WGT/RIuPdFjnPD+Uj9fHL/fNbk0xHvFl9BjlMdy3Ha+T2JNNTGO21cAf9bCT/HIIhLx3SXgsRn83pqJ/3TLn5dJRfnS4+WFtqlM+/SzivHjJyVKL9ZD4O0ZYf+Laq/MC3VeX9b6vK+99WlR/4tqr8wLdV5Qe+rSo/8G1V+YFvq8oPfFtV3v+2qrz/bVX5gTnl5fSq6d6c8nPax7BsG+OQ9qdPq27+8i4/sONUeX/LqfL+nlPlBzadOrfovV/e5fTMfTfdzsdx651bOa30d+9nTDntPHX3Z/fxOO79jDk2x81fhucY934ZltO7pbtNOt7/ZXg8jntN+sWCY7FYR0/9sO3ecRXIW5+Wn/dou/fkUt7/GqWUt79GOYa4WcJun0l7rUHvPbgcQ9x8bqnvT/EvP/F66+0H0uMGabe/xDxvs3b3C8ovotz8gPK4oOXN7yfvxxgvxrj39eR5M667v2vP7Xr328njsdy+Ur7YXuzml5PnKD9yRrev2i+i3Lxqjxum3bxq78cYL8a4d9WeYty/ar+4Um5+qnt/k9TPH63au5Oqj/tptpi793xTvC/1/fEoynEGAbNU0mevVM8h+PDol/1kPobQtwdST42h8bCb+6MeGuPtaf+l/cDGFO9P+y/p7S45LZseewTpPtf+444lpwjxZKfbp9u/RTgNSdVHlOO6TdaXb7REKsLDoeTPYxxfTA1hc40hW8fe3zXu3iX+xQ6p8dif8jjsCFiOy/zdy/hjiHuX10hvN8dxPRj2GWrts3kcp0fle9f4McK9a3z8wDU+fuAaP+0/dfcaP+5YK4/4GbXvF/fbjrWnGJUdvWr9PMZ5H9B9+cf9c5Dfdmg9rfB3L1POIW5lSn3kP7Rw/NIcdR+E+daGtbHZrGjer7LxYoz2fowin8Y4blj70HhaeOjnm83W0x5UqbMNaO+f75xbTwPrPd6G9ZJeDBHvS3ttL4aIrwT6NiPu1RB62EX4dKHnmPz9HMfLr3WKsJyu/LI68Ld6dsTOu88x5fTa2bCf8S87EX8nRtb4mZG1Hy7Tu/tMt8/TpR5fQt35rVLPN+tI2v44FI/TF1OtRsK1uq9w0D/EOC/VQkHeXyF9aNHTK2wZ2xpw+yfGH2McR8gebIicHtsG4B/P5tSqPW780n+5V36jnPb4ufFE/TTG+QbDBfLk0/32NA1txIcbz8GXfeHWX3/CHffd1rjOyi+T2b+zd3djIY1nVXstxrbg8i+LWH9n/+8c63HX3F7cu7vFBwJP7K/FYKXjX15YfCvG9lX+vozk9/YQf8Sd/3ps1lejMM3pyf3FKLK9dMh6eKQqp8H6W/uCHkPc/BFT3v4V88XG7NvcsfH4bJJTPQ5tp3jvMNLnz8rHEBKf9w+R/sqzcu1j+z5AX7zI9MGPKd0Xo/398uhv/wA5hrj3A6Q+/tAfIL82R3q9UStRRF6MkuKR+8mH+l7r2+Om5xA3u0b/2K75pTlqe7lryhbl86J6Gki+V8qOEe6NxxzPpAmXahufX2RV5e3BqeNnV89nKhb210/XkfgiSNs2am+friPxVRCq+5NfqqvaG1fIyJ8PXh7XWmuP7XQefbwURYR9bPJj/8lcX4uR5LUYNSYpS9X0Uozn8cfGc49ffjT/GuO0zNnNFw6nEOURWz88H3f39E/3Y6T4tfusa+XTGPW4oN+9unwMca8ut7cX+Dk2hkTyF/nloftjY5xm44/YgaIM0c+DnI6kstbJtoz8x1+p58NQDuOXHzLfOhd+yfy6ef33gsTcq0d9uVXjW7b60Mfn1/ppsaIcr3Kew16HGPnd2+Uxwq3bZZf3X18cY9x8fVHH4/3XF+k0Wv8cQ4ntH/YjSb+Nt8nbFegY4l4FGuXdCvRFa+g2sNwOraFvv21spwhxy8/5l4f+x4fDePvNfn1/Qb/6Awv6pccPxDh+65H4jSu/LArYP7xCOY2kMgi6zfluH2bTpvwDOXsMUrc122rflp/6bXvEc5i+rQuwb/L87TAUxP1NyO9hjrOUCkvI/TKDrH3nWEba1kuQl0+Jry5S/eVjum+FeV5M/AB4bM+IH8Po8ePPnwnzy7z2rJ828DmIbRSzXnfXx4tBnoOH8UOiPw5dnY6/RuLLh/LLCmwfEjq9v4DTFzHinvF8NEif3svPQW4+VHxxJPeeKlTSD1So00f+Nz840tNrq5uz9fX02uretO5jiHuz9e+fyWkf6+PD3q0PjvT0hfDNefLpNFH+7lIfxyB3l/o4H8nNb47OQW4u9ZHycWn/u0t9nMPcXizwqzA3Vwz5onnvrRjyRZB7K4ak/PY6Ssfsufld2DnGve/CtLy9NJWWH1ia6ngcd5v02LX3Vgz54lq9u2LIF2HurhjyVZibK4Z89djH9rT6S337+LxW3p60eg5x60e11vSHhrj5u/yLB3KWDNF9oY6PTXr6RXz7t+hplaoapf75auHzVd3PwwyJmWNZyovDDDd75u0J2ulx3D00bhNdazq0x9tvwc4hbo3rHU/l7jP4OcjdZ3AtP/AMfnpwvfsMru9/9K/69kf/xxA3n8Fvn8nhGfzYojefwdv7H/2n0wIGt5/BT0FuP4Mfj+TuM/gxyN1n8C+2tbz7DP7Ffqp3n8G/CHP3GfzcvDefwc9Bbj6Dy9tLzB2z5+4z+DHGzWfwXt5+Bu/1B57Be3m/SfUHnsHP1+rtZ/BzmNvP4F+EufsMfnwcqPFE8cvU/G89UYwIUT5/U/j+8+Y4fo8Tq349Xwrtr+fG/RgtlkHL45fvRO/HKI+IUR51fBpDR3v3F835MKKWPdPndBjj/UHfc4ybg77jBz6E++JI7j1wtscPvJYaxyffbZ5Sap9fZqcdcpXtJfZdyL8Vo0bui7byaYx2Wl7y3svT9ujvvjw9h7j5g1V+ZAuSlH5gC5J8XCmzx8/NtH8x8XHyV3p/W+qW3l8IqKW3FwI6hrj3s+b+mbTDmby/LfUxxs0dSL6K8Xg7xr0dSNopY27uQPLFcdzageSL47i1NNL9cznEOJ7LvR1ImrQ/+jhu7UByP8aL+XJzB5J2eqdxdweS84Hc24Gk5ff3T/8ixg907r0dSFo+LpdzbweSLw7k1g4k7f3l/9pPLP/XfmD5v/QDO5C0L95Z3dqB5Bjk7muE93cgaccVsm8+OxR9+9nhFOLms8PtMzkMiab3dyBpP7B8X5If2IHkGOT+kOgP7EByDnJ7SPRHdiD56gfE7bHMH9iB5Isgd8cyH+9Xxfd3IDnHuDeW2U6fKd280Wj+gRuNyvtjmT+wA8kX1+r9scwf2YHkqzA3xzKPXyzcGso8f/NwZyTz/NlW/HJ/4v6K9huffimfj+nIr8XosZSFjF8+H//O52Px9ecTPz+XelrJ8O43aMcg93bJOIe4tUvGFyHu7JLRzpvCFoZkHq/17C8xyosxhBj5cIX1t79lOYe4NTOj9fKHhrj3vHxuT/1vv+j9Xp/EA6Lsq6R8L8Z2HK/G6PE794mvxmCx/WOMt19MtbffS32xZkTcr4fIi8tOxIcAT/x05bzjGhy3muKLZTzutMV5tZhoivr8Lc2zy7dWnFFWnNEXY3SJ4+inVXyOMWJtledN+sVVa8iT2l9dgYc8eYZ7dfWcGA964qvtwVerIx365bTcROVD3qrj/RjttZWRisa7wrIvjPDbEg3Hefek3POS/fyzsX76Gq/wg6H8+oPhe0cSu1lp//xIvgjCXMyWP/9Iqx+3oirxi6GV/WOk34KcBg3jbPatFJ4l8n7/dt6NnZbg6cd3Unf7N+n7/fvVkdzq3y+C3O3f8QP9exoyeL9/6+PBF/SHdXz68W2OxChXlW0858Mnb/30MZI24Xf2vmxF/8a5xAvD+mjjcC71B85F/9hzYSr2E1+r7zWnOJUs+bUYwnH8MtHn5RjtxRhd/ttu+VaMWLTyiS+3qdKm8mIMIUY53DOPH7zGZ8my98vHtZl7fntFgHOIWz8Ie+5/aIh7vymP7ZlZACi3z9e67qfPl+6tz3I6isKv0jL64Sjy+xWslLcr2Hn1cGFjDqmfnss5RmUnJ/28PZ53sVOQe8uYH4PcHBM7hrg3JnYOcWdMrL7/4/bt37bH7ShuHcN5Q4tbYw2nbXBubm18jnFvZ+PSTh9Q399Lp719fZ5D3Lo+vwhx5/o8b2V1e1Ogc5Qf2ITq7jVyjnHzGtGfuUb0/WtE379G9O1r5PSetDBssd8kP8yjPbWnfVDtb477pz+cjiGYaJ22DvlOiBzztZ742lFUXuTVbf3Ub4VQZlvsr9C+cyJseZ/ltRPJcVGkXF86kefDvfKW5fHSUWjsRZG0vXYijX3r9iVLvxNi0JxDXgrRYqCzFX0lwFa16mvt8NjKuH6eH/34qujtTB/xxfu+6OJ3GkLZLa++2ZKvBag11vOtzyEwSv/tAMrQ+f649I0AeUSAbdz8dgBJzI1P9aXUfIaId6hpf+b7Tghe9Mvj80rXT4v51fiqpR5qzDlElP1fdkX5xonsi12VlwqEaPxG/HXSw3eOIorl813da52a4+XB82+l146CmRf5Ia8lWCwAWutWJe7nR41JF89kfSlD46fyE1/K0MJG1vWFI0iNiUWt7d/iffjQ6nF8H/7gg43txqXfuPPFE9Eo+ulRHE8kxgnT2DeV+e1EDmPz976yGqc9mO59ZXUOce8rq2PFi6P4ZRO43xrjvGxM43nk+fbm02/wvggSu46kayrqp0HqaSDnwSLdtRxO5zRxnBnKabTP1ywcpxXt7r7QOp9Oj0eDZ+XKh9M5vkuOx/c6trdi6ZHuB9ESi+1qya8GYY181f0t/8cg8vbAzlfH8eA48uE4jouUdEpR238sfxxAGMetpfrg89W0z/os3zihRsO2duid04dO+RG32vzY5kqX9PF0Tt99Mv30mWPtEOQ0NV/5dvzJvyzW+a1j2eYKbRNqfzuW0+dOt/P42LQs4ft8y3Y6kvNqtWX7FKWdwpQ/uDA9XwXFB4/yONw28nFqrvLJ9OFN+8h/dJ29OiVOZy9Mv53OcVZ8/J6VfUeE346kPH7idI4TB+K76Vb3GUgfy0E5TgWNacJbMfj4dHJ8y8QNvf6yN0t9fAhymk76iHqfH9tviN+CHBskDeZ07JvV/dYgx+1M0ravyv7xU/4Q5PQ1adTYur/W/S1E/4E6fVpf73adro8fqdPHE7pbHav8SHWs+QfyrxyXYPC69ss8xI+dXOsP1MbT26efOZnO4ub7YtW/nU3/gdJ42vvy/tno8ZIdPLQdTkfTMQPjU+zHOAWRH+hh/YnL9Xg6aXD327dY++106g90seoffffT+L3TmhyKvR6/g45B+vLYHnB+KyZ6XOCGzw/L9oN2/LrA5GjHAbCYSfjLYvHXtI1fg5xWnGcfXSnbhr65fDySH1g/+4sjiWEo2Vcx+P1Izo+wt6ZojtPGUfeG5M59U/iqQvd9kn/rm594gD0eiTL2rduY1u9HchooYB+L+tgfcPR+3pQUm3EX2SYl/pY3/Qd+c53eALcHWwvn8co4YdGYg1daOYwTnt5P3RwnPC3Zd3Oc8Bji7nJu5/E5tjnRzzcnHL3/wCBff3sq3/EH3+0G0eNQdOYl7OvDhPdK2TnIvdnm4/TO6e5sc/sy/9Pb5q3Z5sfb93NAOrr34vHq4M/2A2f7DPq7gz/3eucc5F7vPK/Ex/vd84yS3u6f8zDUr8upjZeHoW42bfmRpq0/0rT6dtPe/lF+umbPQe6Nej7P5gd+bH0Z5VYnfxXlbi//xNdSzyhvfy71xUjF7QT6YqTiXgKdg9xu2vYjTdvfT6B2fMkdb7r6p79j0+O4xkqOCXMl79sCfBxwPA7fKO8h9bCNxlfDNzd7WH+ih6X8RA9L/UN7eMRSPKPWUw+frpLEVIi0z2T4rYdPO1Lx4rzug5a/Bxk/0cM/Uh6PTym3e/j0XevNHj6NRglzG2WfWfh7H5+eDMojVuQsad/s5GP3HIfo7max/kSd1h+p06dvoL7Rx+MP7ePMAlJ5f/vwex8ft4LqGmN045dFpB73xy1v57H+RKXWH6nU5UceZsv7D7PHwU8+YUz753Ljt911Tj/1y7Yl+jYg1b8Ro8ZVsi8V+M0YjeUp9MUYGtu7//Lp38sx6qsxoj305fbQaA99uT1anEt7uT32GK+2R4v2aC+3R4v2aC+3R49z6S+3xx7j1fboMaO+t5ePo8Ub0P7qcYzHI34MP34gxsvH0fnE6/Pr4/jq5O7ynOf3L7Uwe+7x+bv29DgN0LcUXdNkH7X8PcppJZVYNmivyznrN07n5qqaXwS5t2TpOcjNJUu/eJ10Z4r4OcStOd5fhLjzHcYXL9fuPoa0HxkSaG8PCTxjHKdl3fumIz36afr8rY86vohx66uOL87m5ocdX0S5+SHc+Z1jTcy13l5uffft581Xue0nLtn+I5dsf38U6/wyt/JaeVud4WPDJlvK9/PfWDE9Oad9Bt9vQU6L/e/Ljm9v637bInMcZ2zH17z78jDfChGLXmjvr4Z4xC3406P44v04C909fnnM+3gY5zWqYjuqfb/PN4KMT9/U350y0B7pdJUdp7gwCb7sixB+XNv+uGbFI1aV17TPV/0tyOlSTVLjB+f1vfGPhEny+TSI449fPtw+zfw5TqV4xL28POrn8zyf53PcqcdrSd8+mv443eYZQ2/9+t2/Ls2/tWt794nxi+Ng8a59htnvMX5gUbWU0turqj1jpB94MElJ3n4wOce492ByPpubX1l+EeXug8k5cTpjv49xSJzTS60cv7bKdjofR6/S8Y1W/Dgp+6d1+qEI9J+YgdB/YgbCeY+J25kj778huP1VXPn8q7h03hK5s7FL31b4KB+mAB2/YLn7giD/xCNwbj/Sxf1Huvj9FwSndwy3R+W/+JbmXsOeg9xt2NOkmfsNe3qp9QO5kzNT1395u52+MXuuPBiWf6gcEvB0yf5MlHsrFn0R49aSRV/FuLNm0Rc/y28udvDVEMG9O/EXA0l3lgv4IsSdRUW+GN67t7PKF0Hu7bxz/gwtaeSN9M+/ZbsWizqUgahH2xdX99dIeQw+sdhOpHzcDLUeP/iP5xpJdd8epnwjSo+9Kvv4fPeeZ4zjJk993+SpHra+Sqc5TKPE+tOjPg57PKV62p/93ZUpJOWtYdOhd477NMRWgo9TiHOz3lzY7os4zwuF9ctKeznOg09prp/e5eU428aTj32L5e/GaWwL+NjnsX87ztiWIXz0Vy/fFr/gRlM5Xb63o4yXowzWshr1xSj31yL88kq+udDjF2d1c5HGr6LcW6bx+fjSfqZt9Acee/QHHnv07cee03TLwVy8fTP69EIAeSlAja1H9Jd9uW4H4LWd/rIp1/0AsZjCPiL8nQC3lst9e8Xe486Ed77JOS4yGWvYJd0/ycntdgiNwaOk+9dW3wjRYzXptO//8p0Q9nZ1Pgc8HumVEPJgXexfdgL8xlEwqyX9+uT8jRDbdzjppRN5jo6xGeF47SgymzyWfU+Pb4Qo8bT6fDCrn4ZI6fT+6AfWlM2Rps9nxddag2WY0r6h+asN+mIIqfERvehe8r4RIqpu2ldceTmEvhQix0P/E/trIZQlelt+KUTlgb2W19oisyFy+eUu9mKI1zq1xAvS58vA9FoI1tctqi+G4ER+2afhGyHiifH5e/61Ti2D5UgeLx1Fibeipb/UElxXVT4/ieeg/+l9qLCsiuyjdP32UUSAX9af/sZpxA1Vy0sNWeOzuvrL0839AOwsM/JrAR7/zZvLlwL8stDAdxoxnvBeK3SaYigujzeP4GM3/s/nP/7zv/zl7//013/9l3/+97/869/+7fn3/usK9fe//PP/+uuf1z/+n//4279s//Xf////z//L//r7X/7617/833/6f3//13/58//+j7//+Yp0/bc/Pdb//I/xHBf5h5Ee8j//4U/p+uf2fOp+DmD25z/n65/Tc/B1PAd5r/9+/QV9Pob+w/N/2vUv7G88h0GuP6H/87+uQ/7/AA=="
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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6ta1TdvGNn6eVvOqUR7d/Xr68mrvVaN+esX4i+1geZJ9Jtkfa9h3pLx+vDTQq4Z/x4WJXZ9fmBxrPLwwOe5NZiqZXPndKo8vTI4dpzHse/mh45yeYsm62yrb7vxh9Or4DGvdnJT9FTr9+TfnGyYa/KLI0+sj8+/oOe3jZwPP334rX7/99tqQ03tajTXp27Ysx8/LJhzfVHn4bOBXb6o8nPLwLZfATb/lEH/8dOD4zsyzMflfvTHzsFnbdzTraW7M82Y9Pc36hp4jwgT1Hx5np9+ZI3cxKH9pPnS/0wn7PVWeLSTzixqPVpL5VY0n5+svbsplTRt8HdT09gDBs9/hXwwj8Vx8/yTxb41EsfDo/kKu/M7g3rMl4X9R5NknA84vmyVd/Sa3r99YS+n4kGDl0fZe1Y/tcbpIY0mU+sNl+OMCj47I9eng4nFRAb4plerXV3fnEuuuNe3vef9OiYfX3ek0qefhdfe5xqPr7qffTzyMBp6/SXUx2CRvlXh40X7cEV1bke29Eg/j8/o8O0+T+a7tC1D61kHtgxdrAGK7MP2tEnyfL7X3tmIbwRB/bysqn7+o22T63yqhfKOo+Xs7whokkt/bEeEVUqnv7YiuE/x1//feVpixiJO/d3Yyqyp5fquErfEkK/pOAV83b/u8rj8G5/ETPh8vv8RyQZ7f243Vw9zqh+3wXoHXQOU6mFn3xeaer92U13p3aV/f4O0S+lYJWYs/vbC9V0JJK5O3StS1Pv0rrd5rC+GLauWH9QPfLPHeQS3rMcVrSD69V4K0KqpvlmBHflgF9jdKrDve1+/gewe1OC//X29tRVnPJkp7qyU4r378QO1PI4np9PpUyvwC5f1uuT3eilXgh5/i39iNtZChlrcasq73WOoPCzQ9L8Di1S7vFbj+i+cHbxX44bXe32nEtUjVe0Gnad0Si3+4Be8exicTXY4FnrxgfbwPfTJP5vp0eOO42u1rBHT/uGL9+rX317X4aaW+stbE9Hp9/YW4V5XjY5MPl0983VYbd+ZffhT89XD29EXDJ98V/1Wr8iN8Nfl6Lta5zOsXh/ufYu+WuVjs4TWyk8q7ZVQ5VfZvaf9mGeNLvNf+nvXvlnHuUNvV3j1xbQ2AuG2/SP/Fifu4ir9dxbkY9/pmlT4LlON0ta/r/Ooc3oYAmuR3G9gr805berdpttsMb6fDdHxW9rhpznUeDtefazwbrv9FjS+H6//76//8wz/+9V//x9/+5R//4d/++i///P9ef+8/e6l//es//M+//dP9f//3v//zP27/9d/+//93/pf/+a9//dvf/vp//sf//dd/+cd/+l///q//1Cv1//aX6/6f/9b6S2n+atP//nd/Sa//7/q6NHK1/v/l9f9ft9g19//W//ArVcvfvf7H+7+IP3297l1f/+P//T/75v5/"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "8272873033206518798": {
            "error_kind": "string",
            "string": "Tokens must be different"
          },
          "9049586825106884780": {
            "error_kind": "string",
            "string": "Function _fulfill_order can only be called internally"
          },
          "10492081608786484886": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14154006707395008989": {
            "error_kind": "string",
            "string": "Function _create_order can only be called internally"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    }
  ],
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Orderbook"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "orders",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "events": [
        {
          "fields": [
            {
              "name": "order_id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Orderbook::OrderCreated"
        },
        {
          "fields": [
            {
              "name": "order_id",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Orderbook::OrderFulfilled"
        }
      ],
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "order",
                    "type": {
                      "fields": [
                        {
                          "name": "bid_amount",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "ask_amount",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 128
                          }
                        },
                        {
                          "name": "bid_token_is_zero",
                          "type": {
                            "kind": "boolean"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "order::Order"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Orderbook::_create_order_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Orderbook::_create_order_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "taker_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "bid_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "bid_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Orderbook::_fulfill_order_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Orderbook::_fulfill_order_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token0",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Orderbook::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Orderbook::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "bid_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "ask_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "bid_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "ask_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Orderbook::create_order_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "field"
              }
            }
          ],
          "kind": "struct",
          "path": "Orderbook::create_order_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Orderbook::fulfill_order_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Orderbook::fulfill_order_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "order_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Orderbook::get_order_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "fields": [
                      {
                        "name": "bid_amount",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 128
                        }
                      },
                      {
                        "name": "ask_amount",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 128
                        }
                      },
                      {
                        "name": "bid_token_is_zero",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ],
                    "kind": "struct",
                    "path": "order::Order"
                  },
                  {
                    "kind": "boolean"
                  }
                ],
                "kind": "tuple"
              }
            }
          ],
          "kind": "struct",
          "path": "Orderbook::get_order_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Orderbook::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Orderbook::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Orderbook::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Orderbook::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "102": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n\n    if is_fn_private(f) {\n        if is_static_call {\n            create_private_static_stub(f)\n        } else {\n            create_private_stub(f)\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            create_public_static_stub(f)\n        } else {\n            create_public_stub(f)\n        }\n    } else {\n        create_utility_stub(f)\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "107": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "110": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY, call_interface_stubs::stub_fn, stub_registry,\n    },\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_authorize_once, fn_has_noinitcheck, get_fn_visibility,\n        is_fn_contract_library_method, is_fn_initializer, is_fn_internal, is_fn_private,\n        is_fn_public, is_fn_test, is_fn_utility, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\npub(crate) comptime fn create_authorize_once_check(f: FunctionDefinition) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[private] or #[public] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_fn_private(f) {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "112": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "113": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "115": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "116": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "117": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "118": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "119": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "121": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "122": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PlaintextLen * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let env = TestEnvironment::new();\n\n        // Log decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"utilityGetIndexedTaggingSecretAsSender\").returns(\n                IndexedTaggingSecret::deserialize([69420, 1337]),\n            );\n            let _ = OracleMock::mock(\"privateIncrementAppTaggingSecretIndexAsSender\").returns(());\n\n            // Encrypt the log\n            let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the log\n            let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec =\n                BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "138": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "150": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "153": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "157": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "158": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "159": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "160": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(utilityGetContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(utilityGetBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(utilityGetTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(utilityGetChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(utilityGetVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "161": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "162": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "166": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "167": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "168": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "172": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(utilityGetIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(privateIncrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "175": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "177": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "178": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 1;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. PXE is using version '1', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "182": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "190": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> HasStorageSlot<M + 1> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the historical block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   historical block header that is being referenced by this private function.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "208": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "211": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "212": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "214": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "215": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "217": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "219": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "224": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.historical_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "231": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "250": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "296": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "310": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "312": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "321": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        // Q: I don't understand this comment. We could still compute a siloed nullifier from a zero contract address.\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "331": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "335": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut result = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         result\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Serialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the serialized member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize(self.$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    result[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; _];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Serialize::serialize(self.$param_name)\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "336": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "337": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "347": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "349": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "362": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "364": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "365": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "382": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "385": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "415": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "50": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/orderbook_contract/src/config.nr",
      "source": "use dep::aztec::protocol_types::{address::AztecAddress, traits::{Deserialize, Packable, Serialize}};\nuse std::meta::derive;\n\n/// We store the tokens of the DEX in a struct such that to load it from PublicImmutable asserts only a single\n/// merkle proof.\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct Config {\n    token0: AztecAddress,\n    token1: AztecAddress,\n}\n\nimpl Config {\n    pub fn new(token0: AztecAddress, token1: AztecAddress) -> Self {\n        assert(!token0.eq(token1), \"Tokens must be different\");\n        Self { token0, token1 }\n    }\n\n    pub fn validate_input_tokens_and_get_direction(\n        self,\n        bid_token: AztecAddress,\n        ask_token: AztecAddress,\n    ) -> bool {\n        assert((bid_token == self.token0) | (bid_token == self.token1), \"BID_TOKEN_IS_INVALID\");\n        assert((ask_token == self.token0) | (ask_token == self.token1), \"ASK_TOKEN_IS_INVALID\");\n        assert(bid_token != ask_token, \"SAME_TOKEN_TRADE\");\n\n        bid_token == self.token0\n    }\n\n    /// Returns a tuple of (bid_token, ask_token) based on `bid_token_is_zero` param.\n    pub fn get_tokens(self, bid_token_is_zero: bool) -> (AztecAddress, AztecAddress) {\n        if bid_token_is_zero {\n            (self.token0, self.token1)\n        } else {\n            (self.token1, self.token0)\n        }\n    }\n}\n\nmod test {\n    use crate::config::Config;\n    use aztec::protocol_types::{address::AztecAddress, traits::FromField};\n\n    global token0: AztecAddress = AztecAddress::from_field(1);\n    global token1: AztecAddress = AztecAddress::from_field(2);\n    global token2: AztecAddress = AztecAddress::from_field(3);\n\n    #[test]\n    unconstrained fn new_config_valid_inputs() {\n        let _ = Config::new(token0, token1);\n    }\n\n    #[test(should_fail_with = \"Tokens must be different\")]\n    unconstrained fn new_config_same_tokens() {\n        let _ = Config::new(token0, token0);\n    }\n\n    #[test]\n    unconstrained fn validate_input_tokens_valid() {\n        let config = Config::new(token0, token1);\n\n        // Test token0 to token1 direction\n        let is_zero = config.validate_input_tokens_and_get_direction(token0, token1);\n        assert(is_zero);\n\n        // Test token1 to token0 direction\n        let is_zero = config.validate_input_tokens_and_get_direction(token1, token0);\n        assert(!is_zero);\n    }\n\n    #[test(should_fail_with = \"BID_TOKEN_IS_INVALID\")]\n    unconstrained fn validate_input_tokens_invalid_bid() {\n        let config = Config::new(token0, token1);\n        let _ = config.validate_input_tokens_and_get_direction(token2, token1);\n    }\n\n    #[test(should_fail_with = \"ASK_TOKEN_IS_INVALID\")]\n    unconstrained fn validate_input_tokens_invalid_ask() {\n        let config = Config::new(token0, token1);\n        let _ = config.validate_input_tokens_and_get_direction(token0, token2);\n    }\n\n    #[test(should_fail_with = \"SAME_TOKEN_TRADE\")]\n    unconstrained fn validate_input_tokens_same_token() {\n        let config = Config::new(token0, token1);\n        let _ = config.validate_input_tokens_and_get_direction(token0, token0);\n    }\n\n    #[test]\n    unconstrained fn get_tokens_correct_order() {\n        let config = Config::new(token0, token1);\n\n        let is_zero = config.validate_input_tokens_and_get_direction(token0, token1);\n        let (bid, ask) = config.get_tokens(is_zero);\n        assert(bid == token0);\n        assert(ask == token1);\n\n        let is_zero = config.validate_input_tokens_and_get_direction(token1, token0);\n        let (bid, ask) = config.get_tokens(is_zero);\n        assert(bid == token1);\n        assert(ask == token0);\n    }\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/orderbook_contract/src/main.nr",
      "source": "mod config;\nmod order;\nmod test;\n\nuse aztec::macros::aztec;\n\n/// ## Overview\n/// This contract demonstrates how to implement an **Orderbook** that maintains **public state**\n/// while still achieving **identity privacy**. However, it does **not provide function privacy**:\n/// - Anyone can observe **what actions** were performed.\n/// - All amounts involved are visible, but **who** performed the action remains private.\n///\n/// **Note:**\n/// This is purely a demonstration implemented to test various features of Aztec.nr. The **Aztec team** does not\n/// consider this the optimal design for building a DEX.\n///\n/// ## Reentrancy Guard Considerations\n///\n/// ### 1. Private Functions:\n/// Reentrancy protection is typically necessary if entering an intermediate state that is only valid when\n/// the action completes uninterrupted. This follows the **Checks-Effects-Interactions** pattern.\n///\n/// - In this contract, **private functions** do not introduce intermediate states.\n/// - All operations will be fully executed in **public** without needing intermediate checks.\n///\n/// ### 2. Public Functions:\n/// No **reentrancy guard** is required for public functions because:\n/// - All public functions are marked as **internal** with a **single callsite** - from a private function.\n/// - Public functions **cannot call private functions**, eliminating the risk of reentering into them from private.\n/// - Since public functions are internal-only, **external contracts cannot access them**, ensuring no external\n///   contract can trigger a reentrant call. This eliminates the following attack vector:\n///   `Orderbook.private_fn --> Orderbook.public_fn --> ExternalContract.fn --> Orderbook.public_fn`.\n#[aztec]\npub contract Orderbook {\n    use crate::{config::Config, order::Order};\n    use aztec::{\n        event::event_interface::emit_event_in_public,\n        macros::{\n            events::event,\n            functions::{initializer, internal, private, public, utility},\n            storage::storage,\n        },\n        oracle::notes::check_nullifier_exists,\n        protocol_types::{address::AztecAddress, traits::{FromField, ToField}},\n        state_vars::{Map, PublicImmutable},\n    };\n\n    use token::Token;\n    use uint_note::uint_note::PartialUintNote;\n\n    // The event contains only the `order_id` as the order itself can be retrieved via the `get_order` function.\n    #[event]\n    struct OrderCreated {\n        order_id: Field,\n    }\n\n    #[event]\n    struct OrderFulfilled {\n        order_id: Field,\n    }\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n        orders: Map<Field, PublicImmutable<Order, Context>, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(token0: AztecAddress, token1: AztecAddress) {\n        storage.config.initialize(Config::new(token0, token1));\n    }\n\n    /// Privately creates a new order in the orderbook\n    /// The maker specifies the tokens and amounts they want to trade\n    #[private]\n    fn create_order(\n        bid_token: AztecAddress,\n        ask_token: AztecAddress,\n        bid_amount: u128,\n        ask_amount: u128,\n        authwit_nonce: Field,\n    ) -> Field {\n        let config = storage.config.read();\n\n        // Create the order (this validates the input tokens and amounts).\n        let order = Order::new(config, bid_amount, ask_amount, bid_token, ask_token);\n\n        let maker = context.msg_sender();\n\n        // Transfer tokens from maker to the public balance of this contract.\n        Token::at(bid_token)\n            .transfer_to_public(maker, context.this_address(), bid_amount, authwit_nonce)\n            .call(&mut context);\n\n        // Prepare a partial note that will get completed once the order is fulfilled. Note that only the Orderbook\n        // contract can complete the partial note.\n        let maker_partial_note =\n            Token::at(ask_token).prepare_private_balance_increase(maker).call(&mut context);\n\n        // We use the partial note as the order ID. Because partial notes emit a nullifier when created they are\n        // unique, and so this guarantees that our order IDs are also unique without having to keep track of past\n        // ones.\n        let order_id = maker_partial_note.to_field();\n\n        // Store the order in public storage and emit an event.\n        Orderbook::at(context.this_address())._create_order(order_id, order).enqueue(&mut context);\n\n        order_id\n    }\n\n    #[public]\n    #[internal]\n    fn _create_order(order_id: Field, order: Order) {\n        // Note that PublicImmutable can be initialized only once so this is a secondary check that the order is\n        // unique.\n        storage.orders.at(order_id).initialize(order);\n\n        emit_event_in_public(OrderCreated { order_id }, &mut context);\n    }\n\n    /// Privately fulfills an existing order in the orderbook\n    /// The taker provides the order ID they want to fulfill\n    #[private]\n    fn fulfill_order(order_id: Field, authwit_nonce: Field) {\n        let config = storage.config.read();\n        let order = storage.orders.at(order_id).read();\n        let taker = context.msg_sender();\n\n        // Determine which tokens are being exchanged based on bid_token_is_zero flag\n        let (bid_token, ask_token) = config.get_tokens(order.bid_token_is_zero);\n\n        // The `order_id` is a serialized form of the maker's partial note.\n        let maker_partial_note = PartialUintNote::from_field(order_id);\n\n        // Transfer the ask_amount from taker directly to the maker's partial note.\n        Token::at(ask_token)\n            .finalize_transfer_to_private_from_private(\n                taker,\n                maker_partial_note,\n                order.ask_amount,\n                authwit_nonce,\n            )\n            .call(&mut context);\n\n        // Prepare partial note for taker to receive bid_token\n        let taker_partial_note =\n            Token::at(bid_token).prepare_private_balance_increase(taker).call(&mut context);\n\n        // Nullify the order such that it cannot be fulfilled again. We emit a nullifier instead of deleting the order\n        // from public storage because we get no refund for resetting public storage to zero and just emitting\n        // a nullifier is cheaper (1 Field in DA instead of multiple Fields for the order). We use the `order_id`\n        // itself as the nullifier because this contract does not work with notes and hence there is no risk of\n        // colliding with a real note nullifier.\n        context.push_nullifier(order_id);\n\n        // Enqueue the fulfillment to finalize both partial notes\n        Orderbook::at(context.this_address())\n            ._fulfill_order(order_id, taker_partial_note, bid_token, order.bid_amount)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _fulfill_order(\n        order_id: Field,\n        taker_partial_note: PartialUintNote,\n        bid_token: AztecAddress,\n        bid_amount: u128,\n    ) {\n        // Finalize transfer of bid_amount of bid_token to taker\n        Token::at(bid_token).finalize_transfer_to_private(bid_amount, taker_partial_note).call(\n            &mut context,\n        );\n\n        emit_event_in_public(OrderFulfilled { order_id }, &mut context);\n    }\n\n    /// Returns the order and whether it has been fulfilled.\n    #[utility]\n    unconstrained fn get_order(order_id: Field) -> pub (Order, bool) {\n        let order = storage.orders.at(order_id).read();\n        let is_fulfilled = check_nullifier_exists(order_id);\n\n        (order, is_fulfilled)\n    }\n}\n"
    },
    "52": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/orderbook_contract/src/order.nr",
      "source": "use crate::config::Config;\nuse aztec::protocol_types::{address::AztecAddress, traits::{Deserialize, Packable, Serialize}};\n\n// TODO: We do not necessarily need full 128 bits for the amounts so we could try to pack the whole order into 1 Field\n// and save on public storage costs.\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct Order {\n    // Amount of bid tokens\n    pub bid_amount: u128,\n    // Amount of ask tokens\n    pub ask_amount: u128,\n    // Whether the order is from token0 to token1 or from token1 to token0\n    pub bid_token_is_zero: bool,\n}\n\nimpl Order {\n    pub fn new(\n        config: Config,\n        bid_amount: u128,\n        ask_amount: u128,\n        bid_token: AztecAddress,\n        ask_token: AztecAddress,\n    ) -> Self {\n        assert(bid_amount > 0 as u128, \"ZERO_BID_AMOUNT\");\n        assert(ask_amount > 0 as u128, \"ZERO_ASK_AMOUNT\");\n\n        let bid_token_is_zero =\n            config.validate_input_tokens_and_get_direction(bid_token, ask_token);\n\n        Self { bid_amount, ask_amount, bid_token_is_zero }\n    }\n}\n\nmod test {\n    use crate::{config::Config, order::Order};\n    use aztec::protocol_types::{address::AztecAddress, traits::FromField};\n\n    #[test]\n    unconstrained fn new_order_valid_inputs() {\n        let token0 = AztecAddress::from_field(1);\n        let token1 = AztecAddress::from_field(2);\n        let config = Config::new(token0, token1);\n\n        let bid_amount = 100;\n        let ask_amount = 200;\n\n        // Test token0 to token1 direction\n        let order = Order::new(config, bid_amount, ask_amount, token0, token1);\n        assert(order.bid_amount == bid_amount);\n        assert(order.ask_amount == ask_amount);\n        assert(order.bid_token_is_zero);\n\n        // Test token1 to token0 direction\n        let order = Order::new(config, bid_amount, ask_amount, token1, token0);\n        assert(order.bid_amount == bid_amount);\n        assert(order.ask_amount == ask_amount);\n        assert(order.bid_token_is_zero == false);\n    }\n\n    #[test(should_fail_with = \"ZERO_BID_AMOUNT\")]\n    unconstrained fn new_order_zero_bid_amount() {\n        let token0 = AztecAddress::from_field(1);\n        let token1 = AztecAddress::from_field(2);\n        let config = Config::new(token0, token1);\n\n        let _ = Order::new(config, 0, 100, token0, token1);\n    }\n\n    #[test(should_fail_with = \"ZERO_ASK_AMOUNT\")]\n    unconstrained fn new_order_zero_ask_amount() {\n        let token0 = AztecAddress::from_field(1);\n        let token1 = AztecAddress::from_field(2);\n        let config = Config::new(token0, token1);\n\n        let _ = Order::new(config, 100, 0, token0, token1);\n    }\n\n    #[test(should_fail_with = \"BID_TOKEN_IS_INVALID\")]\n    unconstrained fn new_order_invalid_tokens() {\n        let token0 = AztecAddress::from_field(1);\n        let token1 = AztecAddress::from_field(2);\n        let token2 = AztecAddress::from_field(3);\n        let config = Config::new(token0, token1);\n\n        let _ = Order::new(config, 100, 100, token2, token1);\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "66": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "73": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between a #[private] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[private] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[private] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[private] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[private] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp =\n            inputs.historical_header.global_variables.timestamp + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// TODO(https://github.com/AztecProtocol/aztec-packages/issues/14025) - we\n    /// are considering making msg_sender: Option<AztecAddress>, since\n    /// a returned value of `Option:none` will be clearer to developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `-1` for the first function call of the tx.\n    ///\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[private] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[private]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some historical block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[private] macro.\n    ///\n    /// # Arguments\n    /// * `returns_hasher` - A hasher containing the return values to hash\n    ///\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[private] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a heft function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "74": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between a #[public] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[public] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[public] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[public]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases, and is enforced by the protocol's kernel circuits.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the account or contract that called\n    ///   this function\n    ///\n    /// # Examples\n    /// ```rust\n    /// #[aztec(public)]\n    /// fn transfer(context: &mut PublicContext, to: AztecAddress, amount: u64) {\n    ///     let sender = context.msg_sender();\n    ///     // Only the sender can transfer their own tokens\n    ///     assert(sender == get_token_owner(), \"Unauthorized\");\n    /// }\n    /// ```\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    /// * Globally visible unlike private execution where it's contract-local\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[public] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "75": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "76": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/event/event_interface.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext},\n    event::event_selector::EventSelector,\n    messages::{\n        logs::{event::to_encrypted_private_event_message, utils::prefix_with_tag},\n        offchain_messages::emit_offchain_message,\n    },\n    utils::remove_constraints::remove_constraints_if,\n};\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator,\n    traits::{Serialize, ToField},\n};\n\n/// Specifies the configuration parameters for message delivery. There are two fundamental aspects to consider:\n///\n/// +----------------------------------------------------------------------------------------------------------+\n/// | 1. Delivery Mechanism                                                                                    |\n/// | - Messages can be delivered either on-chain or out-of-band                                               |\n/// | - On-chain delivery uses the Aztec protocol's private log stream, submitted to L1 blobs and consuming DA |\n/// | - Out-of-band delivery is implemented by the application (e.g. storing ciphertexts in cloud storage)     |\n/// | - Out-of-band delivery cannot have any cryptographic constraints since messages are never stored on-chain|\n/// +----------------------------------------------------------------------------------------------------------+\n///\n/// For on-chain delivery, we must also consider:\n///\n/// +----------------------------------------------------------------------------------------------------------+\n/// | 2. Message Encryption and Tagging                                                                        |\n/// | - Messages can use either constrained or unconstrained encryption                                        |\n/// | - Constrained encryption guarantees the ciphertext is formed correctly but costs more in constraints,    |\n/// |   which results in slower proving times                                                                  |\n/// | - Unconstrained encryption trusts the sender but is cheaper constraint-wise and hence faster to prove    |\n/// | - Tagging is an indexing mechanism that helps recipients locate their messages                           |\n/// | - If tagging is not performed correctly by the sender, the recipient will not be able to find the message|\n/// +----------------------------------------------------------------------------------------------------------+\n///\n/// For off-chain delivery, constrained encryption is not relevant since it doesn't provide any additional guarantees\n/// over unconstrained encryption and is slower to prove (requiring more constraints).\n///\n/// There are three available delivery modes described below.\npub struct MessageDeliveryEnum {\n    /// 1. Constrained On-chain\n    /// - Uses constrained encryption and in the future constrained tagging (issue #14565) with on-chain delivery\n    /// - Provides cryptographic guarantees that recipients can discover and decrypt messages (once #14565 is tackled)\n    /// - Slowest proving times since encryption is constrained\n    /// - Expensive since it consumes L1 blob space\n    /// - Use when smart contracts need to make decisions based on message contents\n    /// - Example 1: An escrow contract facilitating a private NFT sale that needs to verify payment before releasing\n    ///   the NFT to the buyer.\n    /// - Example 2: An application with private configuration where changes must be broadcast to all participants.\n    ///   This ensures every user can access the latest configuration. Without notification of config changes,\n    ///   users would be unable to read updated variables and therefore blocked from using the application's\n    ///   functions. This pattern applies to all critical events that require universal broadcast.\n    ///\n    /// Safety: Despite being called CONSTRAINED_ONCHAIN, this delivery mode is currently NOT fully constrained.\n    /// The tag prefixing is unconstrained, meaning a malicious sender could manipulate the tag to prevent\n    /// recipient decryption. TODO(#14565): Implement proper constrained tag prefixing.\n    pub CONSTRAINED_ONCHAIN: u8,\n\n    /// 2. Unconstrained On-chain\n    /// - Uses unconstrained encryption and tagging with on-chain delivery\n    /// - Faster proving times since no constraints are used for encryption\n    /// - Expensive since it consumes L1 blob space\n    /// - Suitable when recipients can verify message validity through other means\n    /// - Use this if you don't need the cryptographic guarantees of constrained encryption and tagging but\n    ///   don't want to deal with setting up out-of-band delivery infrastructure as required by mode 3\n    /// - Example: Depositing a privately-held NFT into an NFT-sale escrow contract. The buyers know the escrow\n    ///   contract's decryption keys, they receive the message on-chain and are willing to buy the NFT only if the NFT\n    ///   contained in the message is legitimate.\n    pub UNCONSTRAINED_ONCHAIN: u8,\n\n    /// 3. Out-of-band\n    /// - Uses unconstrained encryption with off-chain delivery\n    /// - Lowest cost since no on-chain storage is needed and short proving times since no constraints are used\n    ///   for encryption\n    /// - Suitable when recipients can verify message validity through other means\n    /// - Requires setting up custom infrastructure for handling off-chain delivery (e.g. cloud storage)\n    /// - Example: A payment app where a merchant receives the message off-chain and is willing to release the goods\n    ///   once he verifies that the payment is correct (i.e. can decrypt the message and verify that it contains\n    ///   a legitimate token note - note with note commitment in the note hash tree).\n    pub UNCONSTRAINED_OFFCHAIN: u8,\n}\n\npub global MessageDelivery: MessageDeliveryEnum = MessageDeliveryEnum {\n    CONSTRAINED_ONCHAIN: 1,\n    UNCONSTRAINED_ONCHAIN: 2,\n    UNCONSTRAINED_OFFCHAIN: 3,\n};\n\n/// Emits an event that can be delivered either via private logs or offchain messages, with configurable encryption and\n/// tagging constraints.\n///\n/// # Arguments\n/// * `event` - The event to emit\n/// * `context` - The private context to emit the event in\n/// * `recipient` - The address that should receive this event\n/// * `delivery_mode` - Controls encryption, tagging, and delivery constraints. Must be a compile-time constant.\n///   See `MessageDeliveryEnum` for details on the available modes.\npub fn emit_event_in_private<Event>(\n    event: Event,\n    context: &mut PrivateContext,\n    recipient: AztecAddress,\n    delivery_mode: u8,\n)\nwhere\n    Event: EventInterface + Serialize,\n{\n    // This function relies on `delivery_mode` being a constant in order to reduce circuit constraints when unconstrained\n    // usage is requested. If `delivery_mode` were a runtime value then performance would suffer.\n    assert_constant(delivery_mode);\n\n    // The following maps out the 3 dimensions across which we configure message delivery.\n    let constrained_encryption = delivery_mode == MessageDelivery.CONSTRAINED_ONCHAIN;\n    let emit_as_offchain_message = delivery_mode == MessageDelivery.UNCONSTRAINED_OFFCHAIN;\n    // TODO(#14565): Add constrained tagging\n    let _constrained_tagging = delivery_mode == MessageDelivery.CONSTRAINED_ONCHAIN;\n\n    let (ciphertext, randomness) = remove_constraints_if(\n        !constrained_encryption,\n        || to_encrypted_private_event_message(event, recipient),\n    );\n\n    // We generate a cryptographic commitment to the event to ensure its authenticity during out-of-band delivery.\n    // The nullifier tree is chosen over the note hash tree for this purpose since it provides a simpler mechanism\n    // - nullifiers require no nonce, and events, being non-spendable, don't need the guarantee that a \"spending\"\n    // nullifier can be computed.\n    // TODO(#11571): with decryption happening in Noir we can now use the Packable trait instead.\n    let serialized_event_with_randomness = [randomness].concat(event.serialize());\n    let event_commitment = poseidon2_hash_with_separator(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n    context.push_nullifier(event_commitment);\n\n    if emit_as_offchain_message {\n        emit_offchain_message(ciphertext, recipient);\n    } else {\n        // Safety: Currently unsafe. See description of CONSTRAINED_ONCHAIN in MessageDeliveryEnum.\n        // TODO(#14565): Implement proper constrained tag prefixing to make this truly CONSTRAINED_ONCHAIN\n        let log_content = prefix_with_tag(ciphertext, recipient);\n\n        context.emit_private_log(log_content, log_content.len());\n    }\n}\n\npub fn emit_event_in_public<Event>(event: Event, context: &mut PublicContext)\nwhere\n    Event: EventInterface + Serialize,\n{\n    let mut log_content = [0; <Event as Serialize>::N + 1];\n\n    let serialized_event = event.serialize();\n    for i in 0..serialized_event.len() {\n        log_content[i] = serialized_event[i];\n    }\n\n    // We put the selector in the \"last\" place, to avoid reading or assigning to an expression in an index\n    log_content[serialized_event.len()] = Event::get_event_type_id().to_field();\n\n    context.emit_public_log(log_content);\n}\n\npub trait EventInterface {\n    fn get_event_type_id() -> EventSelector;\n}\n"
    },
    "78": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "80": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "92": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "97": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    }
  }
}
