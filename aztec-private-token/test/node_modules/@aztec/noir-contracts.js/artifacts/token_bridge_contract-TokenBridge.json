{
  "transpiled": true,
  "noir_version": "1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec",
  "name": "TokenBridge",
  "functions": [
    {
      "name": "claim_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "secret_for_L1_to_L2_message_consumption",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "285656119219400463": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 32 limbs"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2444923117917591088": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 39 limbs"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4456244908619624852": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6668324276689745315": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 4 limbs"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17288131482828810359": {
            "error_kind": "string",
            "string": "Message not in state"
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tL3Briy9bqX5LnfsQYgSSbFepdEouKvdDQOGXXC5emL43TtFSVzcZ9/Ujp2Z/8Tnu7/PWStCITIVEkP6z7/93//0f/3v//e///O//j//9r/+9t/+j//82//17//8L//yz//vf/+Xf/sf//gf//xv//r4r//5t2v8n9L+9t8Kaf+vf/hbGf/b5PG//+FvpvOPPv8w/6Nc1/qzrD9p/VnXn239yetPWX/q+rOvP5deWXpl6ZWlV5ZeWXpl6ZWlV5ZeWXpl6dHSo6VHS4+WHi09Wnq09Gjp0dKjpVeXXl16denVpVeXXl16denVpVeXXl16bem1pdeWXlt6bem1pdeWXlt6bem1pcdLj5ceLz1eerz0eOnx0uOlxw89Hn/a/FOu9WdZf9L6s64/2/qT15+y/tT159KTpacPPRl/lvUnrT/r+rOtP3n9+dCz8ee4vjqgb7AF/dpQNtCGcddtQNvAG2SDbugbbIFdG8oG2rCVbSvbVvZ4GffqEePQNwzlRzOTh41D2fBQJoe6oW3gDbJBN/QNtmAE0ISyYSuXrVy2ctnKI4yoDtANfYMtGKE0oWygDXVD28AbtjJtZdrKtJXrVq5buW7lupXrVq5buW7lupXrVq5buW3ltpXbVm5beYQY8QDeIBt0Q99gC0agTSgbaEPdsJV5K/NW5q3MW5m3smxl2cqylWUry1aWrSxbWbaybGXZyrqVdSvrVtatrFtZt7JuZd3KupV1K/et3Ldy38p9K/et3Ldy38p9K/et3LeybWXbyraVbSvbVratbFvZtrJtZVvK9bo2lA20oW4Yyn0Ab5ANuqFvsAUegw5lA22oG7Zy2cplK5etPGKwlgG2YMTghIdylQG0oW5oG3iDbNANfYMtGDE4YSvXrVy3ct3KdeWNWmWDbugbVkaq7dpQNtCGuqFt2MptK7et3LbyiMH6+FGoIwYnlA20oW5oG3iDbNANfcNWlq0sW1m2smzlEYPtGsAbZINu6BtswYjBCWUDbagbtrJuZd3KupVHDLY6wBaMGJwwlHUAbagb2gbeIBt0Q99gC0YMTtjKtpVtK9tWtq1sW9m2sm1lW8rtujaUDbShbmgbeINs0A19w1YuW7ls5bKVy1YuW7ls5bKVy1YuW7lsZdrKtJVpK9NWpq1MW5m2Mm1l2sq0letWrlu5buW6letWrlu5buW6letWrlu5beW2ldtWblu5beW2ldtWblu5beW2lXkr81bmrcxbmbcyb2XeyryVeSvzVpatLFtZtrJsZdnKspVlK8tWlq0sW1m3sm5l3cq6lXUr61bWraxbWbeybuW+lXcMth2Dbcdg8xi0AbxBNuiGvsEWeAw6lA20oW7YyraVbSvbVratbEuZr2tD2UAb6oa2gTfIBt3QN2zlspXLVi5buWzlspXLVi5buWzlspXLVqatTFuZtjJtZdrKtJVpK9NWpq1MW7lu5bqV61auW7lu5bqV61auW7lu5bqV21ZuW7lt5baV21ZuW7lt5baV21ZuW5m3Mm9l3sq8lXkr81bmrcxbmbcyb2XZyrKVZSvLVpatLFtZtrJsZdnKspV1K+tW1q2sW1m3sm5l3cq6lXUr61buW7lv5b6V+1beMcg7BnnHIO8Y5B2DvGOQdwzyjkHeMcg7BnnHIO8Y5B2DvGOQdwzyjkHZMSg7BmXHoOwYlB2DsmNQdgzKjkHZMSg7BmXHoIwYZBpAG+qGtoE3yAbd0DfYghGDE7YybWXayrSVaSvTVqatTFuZtnLdynUr161ct3LdynUr1608YpDrgL7BFowYZB5QNtCGuqFt4A2yQTf0DbaAtzJvZd7KvJV5K/NW5q3MW5m3Mm9l2cqylWUry1aWrSxbWbaybGXZyrKVRwxyH1A20IYxH3MNaBt4g2zQDX2DLRgxOKFsoA1buW/lvpX7Vh4xKON5jRicYAtGDE4oG2hD3dA28AbZsJVtK9tS1uvaMJTbANpQN7QNvEE26Ia+wRaMGJywlctWLlu5bOWylctWLlu5bOWylWkr01amrUxbmbYybWXayrSVaSvTVq5buW7lupXrVq5buW7lupXrVq5buW7ltpXbVm5buW3ltpXbVm5buW3ltpXbVuatzFuZtzJvZd7KvJV5K/NW5q3MW1m2smxl2cqylWUry1aWrSxbWbaybGXdyrqVdSvrVtatrFtZt7JuZd3KupX7Vu5buW/lvpX7Vu5buW/lvpX7Vu5b2baybWXbyraVbSt7DMoA2aAb+gab0D0GHcoG2lA3tA28QTbohr5hK5etXLZy2cplK5etXLZy2cplK5etXLYybWXayrSVaSvTVqatTFuZtjJtZdrKdSvXrVy3ct3KdSvXrVy3ct3KdSvXrdy2ctvKbSu3rdy2ctvKbSu3rdy2ctvKvJV5K/NW5q3MW5m3Mm9l3sq8lXkry1aWrSxbWbaybGXZyrKVZSvLVpatrFtZt7JuZd3KupV1K+tW1q2sW1m3ct/KfSv3rdy3ct/KfSv3rdy3ct/KfSvbVratbFvZtrJt5R2Dfcdg3zHYdwz2HYO2Y9B2DNqOQdsxaDsGbceg7Ri0HYO2Y9B2DNqOQdsxaDsGbceg7Ri0HYO2Y9B2DNqOQdsxaDsGbceg7Ri0HYO2Y9B2DNqOQdsxaDsGbceg7Ri0HYO2Y9B2DNqOQdsxaDsGbceg7Ri0HYO2Y9B2DNqOQdsxaDsGbceg7Ri0HYO2Y9B2DNqOQdsxaDsGbceg7Ri0HYO2Y9B2DNqOQdsxaDsGzWPQBtCGuqFt4A2yQTf0DbbAY9BhK+tW1q2sW3nEoF4DZINu6BtswYjBCWUDbagb2oat3Ldy38p9K/etbFvZtrJtZdvKtpVtK9tWtq1sW9mW8mNZ/QoqQRRUg1oQB0mQBvWg8CjhUcKjhEcJjxIeJTxKeJTwKOFRwoPCg8KDwoPCg8KDwoPCg8KDwoPCo4ZHDY8aHjU8Rphqc+IgCRoe6tSDbNMI1kUliIJqUAviIAkKjxYeLTw4PDg8ODw4PDg8ODw4PDg8ODw4PCQ8JDwkPCQ8JDwkPCQ8JDwkPCQ8NDw0PDQ8NDw0PDQ8NDw0PDQ8NDx6ePTw6OHRw6OHRw+PHh49PHp49PCw8LDwsPCw8LDwsPCw8LDwsPCw7eH1M4tKEAXVoBbEQRKkQT0oPEp4lPAo4VHCo4RHCY8SHiU8SniU8KDwoPCg8KDwoPCg8KDwoPCg8KDwqOFRw6OGRw2PGh41PGp4RJyXiPMScV4izkvEeYk4LxHnJeK8RJyXiPMScV4izkvEeYk4LxHnJeK8RJyXiPMScV4izkvEeYk4LxHnJeK8RJyXiPMScV4izkvEeYk4LxHnJeK8RJyXiPMScV4izkvEeYk4LxHnJeK8RJyXiPMScV4izkvEeYk4LxHnJeK8RJyXiPMScV4izkvEeYk4LxHnJeK8RJyXiPMScV4izkvEeYk4LxHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5xRxThHnFHFOEecUcU4R5zXi3KuK1JwoqAa1IA6SIA3qQbbJ43xSeJTwKOFRwqOERwmPEh4lPEp4UHhQeFB4UHhQeFB4UHhQeFB4UHjU8KjhUcOjhkcNjxoeNTxqeNTwqOHRwqOFRwuPFh4tPFp4tPBo4dHCo4UHhweHB4cHhweHB4cHhweHB4cHh4eEh4SHhIeEh4SHhIeEh4SHhIeEh4aHhoeGh4aHhoeGh4aHhoeGh4ZHD48eHj08enj08Ojh0cOjh0cPjx4eFh4WHiPO++VUg1oQB0mQBvUgW+SFS4tKEAXVoBbEQRKkQT0oPEp4lPAo4VHCo4RHCY8SHiU8SniU8KDwoPCg8KDwoPCg8KDwoPCg8KDwqOFRw6OGRw2PGh41PGp41PCo4VHDo4VHC48WHi08Wni08Gjh0cKjhUcLDw4PDg8ODw4PDg8ODw4PDg8ODw4PCQ8JDwkPCQ8JDwkPCY8R57059SDbNOK8q1MJoqAa1II4SII0qAfZph4ePTx6ePTw6OHRw6OHRw+PHh49PCw8LDwsPCw8LDwsPCw8LDwsPGx7eHHUohJEQTWoBXGQBGlQDwqPEh4lPEp4lPAo4VHCo4RHCY8SHiU8KDwoPCg8KDwoPCg8KDwoPCg8KDxqeNTwqOFRw6OGRw2PGh41PGp41PBo4dHCo4VHC48WHi08Wni08Gjh0cKDw4PDg8ODw4PDg8ODw4PDg8ODw0PCQ8JDwkPCQ8JDwkPCQ8JDwkPCI+KcI8454pwjzjninCPOOeKcI8454pwjzjninCPOOeKcI8454pwjzjninCPOOeKcI8454pwjzjninCPOOeKcI8454pwjzjninCPOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwiziXiXCLOJeJcIs4l4lwizjXiXCPONeJcI8414lwjzjXiXCPONeJcI8414lwjzjXiXCPONeJcI8414lwjzjXiXCPONeJcI8414lwjzjXiXCPONeJcI8414lwjzjXiXCPONeJcI8414lwjzjXiXCPONeJcI8414lwjzjXiXCPONeJcI8414lwjzjXiXCPONeJcI8414lwjzjXiXCPONeJcI8414lwjzjXiXCPONeLca8TscmpBHCRBGtSDbNOI80UliILCQ8NDw0PDY8S5FaceZJtGnC8qQRRUg1oQB0lQePTw6OFh4WHhYeFh4WHhYeFh4WHhYeFh28MLyRaVIAqqQS2IgyRIg3pQeJTwKOFRwqOERwmPEh4lPEp4lPAo4UHhQeFB4UHhQeFB4UHhQeFB4UHhUcOjhkcNjxoeNTxqeNTwqOEx4tzYyTaNOF80PNSJgmpQC+IgCdKgHmSbRpwvCg8ODw4PDg8ODw4PDg8ODw4PCQ8JDwkPCQ8JDwkPCQ8JDwkPCQ8NDw0PDQ8NDw0PDQ8NDw0PDQ8Njx4ePTx6ePTw6OHRw6OHRw+PHh49PCw8LDwsPCw8LDwsPCw8LDwsPGx7eLHaohJEQTWoBXGQBGlQDwqPEh4lPEp4lPAo4VHCo4RHCY8SHiU8KDwoPCg8KDwoPCg8KDwoPCg8KDxqeNTwqOFRw6OGRw2PGh41PGp41PBo4RFxbhHnFnFuEecWcW4R5xZxbhHnFnFuEecWcW4R5xZxbhHnFnFuEecWcW4R5xZxbhHnFnFuEecWcW4R5xZxbhHnFnFuEecWcW4R5xZxbhHnFnFuEecWcW4R5xZxbhHnFnFuEecWcW4R5xZxbhHnFnFuEecWcW4R5xZxbhHnFnFuEecWcW4R5xZxbhHnFnFuEee245yuHed07Tina8c5XTvO6dpxTteOc7p2nNO145yuHed0XeFRwqOERwmPEh4lPEp4lPAo4VHCo4QHhQeFB4UHhQeFB4UHhQeFB4UHhUcNjxoeNTxqeNTwqOFRw6OGRw2PGh4tPFp4tPBo4dHCo4VHC48WHi08WnhweHB4cHhweHB4cHhweHB4cHhweEh4SHhIeEh4SHhIeEh4SHhIeEh4aHhoeGh4aHhoeGh4aHhoeGh4aHj08Ojh0cOjh0cPjx4ePTx6ePTw6OFh4WHhYeFh4WHhYeFh4WHhYeERcV4izkvEeYk4LxHnJeK8RJyXiPMScV4izkvE+dxj6rocC5CAFdiADBSgAjvQAgluHvLiREE1qAVxkARpUA+yTR7yk8KjhkcNjxoeNTxqeNTwqOFRw6OFRwuPFh4tPFp4tPBo4dHCo4VHCw8ODw4PDg8ODw4PDg8ODw4PDg8ODwkPCQ8JDwkPCQ8JDwkPCQ8JDwkPDQ8NDw0P9f7VHRuQgaN/lbkfkwI70AJ9+6uFBUjACmxABsKtw63DrcPNt8Qq5liAtNFLynxDKy8pe/R+xyFANNDDYWEBErACG5CBAlRgB8Ktwq3CrcKtwq3CrcKtwq3CrcKtwq3BrcGtwa3BrcGtwa3BrcGtwa3BjeHGcGO4MdwYbgw3hhvDjeHGcBO4CdwEbgI3gZvATeAmcBO4CdwUbgo3dTd2rMAGZKAAFehu4miBHkILC5CAFdiADBSgAuHW4WZw8xAidSTgcKseOL673EIGClCBHWgbvSBtYwESsAIbkIECdLfi2IEW6D+tCwuQgO4293prQAa6mzgqsAMt0HPJwgJ0N3WswAZkoAAV2IEW6LlkYQHCrcKtws1zSe2OAtRAzxq1ObquOQ6F5m3m+aHNvyBABXagBXp+WDh0GzsSsAIbkIECVGAHWqDnh4VwE7gJ3Dw/NH9Ynh8WupvfvOeHhR1ogZ4fFhbgcGPvqZ4fFjYgAwWowA60QM8PCwsQbh1uHW6eH9gfoeeHhe5Gjh1ogZ4fFrqbt47nh4UV2IAMFKC7eUecu1BOtI1eyLaxAAlYgQ3IQAEqsAPh5vlhbDBBXtO2kYDu1hwbkAM95he6gjmOvyvkOC5H5laPCuxAC/SQXjjExC/SQ3phBTYgAwXobn4XPjxYaIEe6AsLkIAV2IAMFCDcGtwa3Dz8xVvHw38hAYfb+DKOvGJtIwOHm3qjevirN5SHv879Mi3Qw39hARKwAodbdwsP/4UCVGAHWqCH/8ICJGAFwk3hpnBTuCncFG4dbh7+3Xufh//CCmxABgrQdUdsev3axgIkYAW2jV5qVsa6Inmt2Ua3GE/eK8EeY3bHDrRAj6GFBUjACmxABgoQbgQ3gluFW4VbhVuFm4fTWKckr/kqY0GJvOjr8Y7hWIAEHApWHRuQgQJUYAdaoAfOwgIkINwYbgw3hhvDjeHGcPMQseboCnObWG/f+RcU2IEWOINhYgG6rncYD4aFfr3eYTwYFgrQr8y7kXdw88fiHXyh9wdvdd/H1Wc2vJRrowI70Ab60/QdXRcWIA10Xd/XdWEDws3gZnAzuPker45e2DWb2iu7NhKwAhuQgQJUYAfG0/QSr41wK3ArcCtwK3ArcPOI9a7hJVyza8iMTf8LMzYnMlCACuxA2/3BS7k2lt0JvJhrYwXK7hoyY3P0B5mxObHsruGlWusB+B6vCxuQgbI7gddrbexA253AS7Y2FiDcGG4MN4YbR9/xeqjHfLMjAwXol+Ot41seL7RA3/Z4YQESsAIbkIEChFuHW4ebwc3g5oFT/IY8cBY2IAMFqMDh5nM2Xig10SulNhYgASuwARkoQAV2INwK3ObG5eRIwAp0t+rIQAG6W3PsQAv0rcwXutvcC9t1xZGBAlSg63ZH1x0R4BVT5FNeXjK1kYAVONx883Uvm9ooQAUON9+s3AumaO3U7RZ+OR5v5Jcz9zX3f+bxtpCBAlRgB1qgx1v1Vvd4Wzjc/GXbq6c2NiADBahAd1NHC/SdzxcWIAErsAEZKEAFwk3gpnDz/dD9bdwLqjZWoLv5M/ZUsVCAw81f172sipo/LE8VEz1VLCxAAlbgcPM3d6+u2ihABXagBXqqWFiABKxAuBncDG4GN4ObhZsXW5G/xHu11UYCektWxwZkoAAV2IHuNpray642FiABK7ABGShABXYg3AhuBDeCm6cKf+H3gquNCuxAC/RUsbAACViBDQi3CrcKtwq3CrcGtwa3BrcGtwa3BrcGtwa3BrcGN4Ybw43hxnBjuDHcGG4MN4Ybw03gJnATuAncBG4CN4GbwE3gJnBTuCncFG4KN4Wbwk3hpnBTuCncOtw63DrcOtw63DrcOtw63DrcOtwMbgY3g5vBzeBmcDO4GdwMbhZudl3AAiRgBTYgAwWowA6EW4FbgVuBW4FbgVuBW4FbgVuBW4EbwY3gRnAjuBHckEsMucSQSwy5xJBLDLnEkEsMucSQSwy5xJBLbOaS4qjADrTAmUsmFqAnXXVsQAYKUIEdaIGeQBYWIAHhxnBjuDHcGG4MN4abwE3gJnATuAncBG4CN4GbwE3gpnBTuCncFG4KN4Wbwk3hpnBTuHW4dbh1uHW4dbh1uHW4dbh1uHW4GdwMbgY3g5vBzeBmcDO4Gdxsu9XruoAFSMAKbEAGClCBHQi3ArcCtwK3ArcCtwK3ArcCtwK3AjeCG8GN4EZwI7gR3AhuBDeCG8Gtwq3CrcKtwq3CrcKtwq3CrcKtwq3BrcGtwa3BrcGtwW0ORpqjAjvQ05Wf4DMHIxMLkIAV2ICeHN1tDkYmKtDdxNEC52BkYgESsAKH29jvunpR2UYBups5dqAFzsHIxAIk4HAb6yLVq8s2MtDdqqMCO9ACPWuIt6/nB/GG8vywUIGu4A3l+WGi54eF43plHptEwApsQHfzG/L8sFCBfaOXjdFYv6heI/Z47XdkoAC9feeJTR1ogXPQMLEACViBDchAdyNHBXagBXrMLyxAAlZgAzIQbgQ3ghvBrcKtwq3CzWN+rPlULxGjsU1i9RqxjR1ogR7dCwuQgBXYgAyEW4Nbg1uDG8ON4cZwY7gx3BhuDDeGG8ON4SZwE7gJ3ARuAjeBm8BN4CZwE7gp3BRuCjeFm8JN4aZwU7gp3BRuHW4dbh1uHW4dbh1uHW4dbh1uHW4GN4Obwc3gZnAzuBncDG4GNws3331tYwESsAIbkIECVGAHwq3ArcCtwK3ArcCtwK3ArcCtwK3AjeBGcCO4EdwIbgQ3ghvBjeBGcKtwq3CrcKtwq3CrcEMuIeQSQi4h5BJCLpkHOI714zqPcNTuWIENyEABKrADLXDmkokFCDeGG8ON4cZwY7jNXGKOFjhzycQCJGAFups4MlCACuxAC5y5ZGIBErAC4aZw81wy1prrPAhyYQcOt+537Fmj+6V7fhiL53Ue97hwKIxVrjqPfFxogZ4fFhYgAcf1mncNzw8LGShABXagbZxHQS4sQAJWYAMy0N3YUYEd6G6jJefxkAsL0N3UsQIbkIHu1h0fbnWsZ9V5OOTlZy/68ZALCViBbSA58sDqKAP9ev2oyMuvzA+LXGiBfmDkQnfzK/NDIxdWYAO6mzkOi+KXM8K/Fr+cEf61eKOO8H/coGMBErACG5CBAnQ3b7PWAz3mvad6kdxGAlZgAzJQgArsQAsUuAnc/GhJ8kfoh0subMBxQ+u8TQEqsAMtcMT8xgIkYAU2INwUbupu/li0Ay2wX8ACJKC7eefqDchAASqwAy3QLmABEhBuBjeDm7mb919TYAe62+glXiT36PuOBTjcRmFs9SK5jcPNz2j1IrmNAlRgB1rgyA8bC5CAFQi3ArcCtwK3ArcCN4IbwY3gRnAjuBHcCG4EN4Ibwa3CrcKtwq3CrcKtwq3CrcKtwq3CrcGtwa3BrcGtwa3BrcGtwa3BrcHNj6MdK6TVK+42ErAC2/7dbDOXTBSgAjvQAmcumViABPS7qI59/zR7FV0d1cbVq+g2FiABK7ABGejtMMLJK+NWO3Tccccde8wvZKC3rzgqsAMt0PA0DW6Gp2l4moanaXiahqfpMT+vwWN+oW30nd82ln0NPGN+YgWGGyPmGTHPiHlGzDNinhHzXKLvcCFgBTYgxzUUASoQboh5RswzYp4R84yYZ8Q8Uzw3njE/UYEdGM+NZ8xPREsi5hkxz4h5RswzYp4R84yYZ8Q8Nzy3hpZsaMmGlmxoyRnz6ihAd+uOHWiBM+YnDrfm1+Axv7ACG5CBAlRgBw635hfpx1Iv9Jj3v+AjBY9CLyGsfgi0lxBuVGAH4gkpnpDiCSn6uqKvz0wwEb1P8YQUT0jxhBRPqKP3IWtwR3/o6A8d/cHzwyg4qF5YuNECPT80bwfPD82vzPPDwgpsQAYKUIEdaBtlzh5UxwpsQAYKUIEdaIFz9mBiAcKtwK3ArcCtwK3ArcCtwI3gRnAjuBHcCG4EN4IbwY3gRnCrcKtwq3DDnKNUuFW4VbhVuFW4Vbg1uDW4Nbg1uDW4Nbg1uDW4Nbg1uDHcGG4MN4Ybw43hxnBjuDHcGG4CN4GbwE3gJnATuAncBG4CN4Gbwk3hpnBTuCncFG4KN4Wbwk3h1uHW4dbh1uHW4dbh1uHW4dbh1uFmcDO4GdwMbgY3g5vBzeBmcLNwm1WVCwuQgBXYgAwUoAI7EG7IJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXKLIJYpcosglilyiyCWKXNKRSzpySUcu6cglXnZZffHcyy43ClCBHWiB/oaysAAJWIFwK3ArcCtwK3ArcCO4EdwIbgS3mUsuRwa6W3dUYAdaoL+hLCxAAg43dl1/Q1nIwOE2KqGqF2Nu7EB3G/NGXoy5sQD9ufnfnblkYgMyUIAK7EALnLlkYgH66npzZKDfBTkqsAMt0N9FFhYgAb3NXNffUBYy0N3YUYEd6G7ef/0NZWEBeuWA/91Z6TCxARkoQAV2oAV61lhYgH4X4shAAfpdeJ/0N5SFFuhvKF4Y4AWWG73NvBP4G8rCBhxuXhLiBZYbFdiBttELLDcW4HCT4liBDchAASqwr09+qs2PnJqjf/Xif8FHFQsbkIECVGAH7k9+6iylXFiABKzr26jqpZQbGShABXagBc4PoiYWYDx5qwwUYDx5qx0YT96LJufj9qLJjfHkvX5yYwPGk/f6yY0K7EA8ecaTZzx5xpNnPHnGk2c8ecaTZzx5xpMXPHnBkxc8ecGTFzx5wZMXPHnBkxc8ecWTVzx5xZNXPHnFk1c8ecWTVzx5xZNXPPmOJ9/x5D3mvVTKayI3ClCB/iyqowV6zC8sQFpft1avidzYgAwUoAI70Ba2a37uONGfsTo2IAMFqMAO9LvoA/3Xf2EBErACG5CBAlRgB8KN4EZw81//UeXVvPpxYwMOt/Hr37z6caMCh9uobmpe/VjH2Kh59WMdpQXNqx83ErACG5CB7iaOCuxAC/RMsLAACViBDchAuDW4Nbg1uDHcGG6eCdQb1TPBwgYcbt0byjPBQgV2oAX6mGDhcOvevj4mWFiBDchAASqwAy3QxwQL4aZwU7j5rOX4Ar959eNGAbqbt47PWnbvUT5rOdFnLRcWIAErsAEZKMDhZt4nPWssHG4zeD1rLCxAAg4380v3kcJCBgpQgR1oG33XvY3uxo4EdDdxbEAGClCBbjFyiZdSbixAAlbgw6KNmobmpZQbBajADrTAkUDa+EFpXkq5kYAV2IAMFKACO9ACK9wq3CrcqruRYwMy0N2qowI70N38WTR38/Zt7uZt1ghYgQ3IQAGOn1t3mJ96OpUgCqpBbZO4eHdkoADHL7w3gP/AT7JN/vM+qQRRkCua42iG4s/V49H//x6Ok0qQF5841aAWxEESpEFuMmUscIRhK/6IRhhuJOC4zOLNYa7gQWS2cZYempMLsCMBK7ABGSirSWbh4aQetJtzVh1OKkFtN6LXEc5G9DrCNj5jbl5HuNBDZpTKNK8j3OhX2h29Wzm1IA6SIA3qmzwsil+IBwDN/zr+dXWSIA0a/5qcbJP3/UkliIJqkJt4G3i/XzhcaP4FBfZAdlF3Z1fwR8gMHAquxRoNwx1ogXIBXdafphCwAls0uEfSQgHCTeAmcFO4KdwUbgo3hZvCTeGmcFO4Kdw63HoB0u7qHZ26o1N3dOouQA00fyh+CR5MC23jrNNjpxJEQTWoBXGQBGlQD7JNJTxKeJTwKOFRwqOERwmPEh4lPEp4UHh4qHmjeaHexgoc7efpzQv1Nnq8NEcFdqAF+q/TwgIkYAU2IAPhVuFW4Vbh5hFa/d48RBcSsAIbkIHuJo4K7EAvghk0q/ecShAF1aAW5IremTxAq/9XD9Dq7e0BurACG3BcqecAL8bbqMAOtED/tfPL91+7SRQ0rDx1eSXeRga6lbewR+fCDnQrF/PoXDhurPntjujcWIH+9uTEQRKkQT3INvnPYPMG9J/B5u0zxp1tTIo2r6vb2IG20evq2pgtbF5Xt5GAFdiAPu50kiAN8uG7k23y0eekEkRBNchNqiMDBWiBHq9jJrN5idxGf4ly4iAJ8hYRxw60QA9W9mvxYF3oVn53HqwLx8WKN6QH65ijaV4f18TbyYN1zF02r4/baIEerAsLkIAV2IDu5tfrweqzBV4f1/xN3evjmr+TeyVc87dvr4TbWIENyEABaqDHqfptepwurMAGZKAANdB/J30ywKvbmk8GeHXbRgEqcNyb35qHnJNH3KQSREE1qAVxkARpUHj08LDwsPCw8LDwsPCw8LDwsPCw8LDt4TVvi0qQN4iTBGlQD7JNI9gWlSAKqkEtKDxKeJTwKOFRwoPCg8KDwoPCg8KDwoPCg8KDwsNjzad1vC5tYwMOofEZQ/O6tOZTKl6X1kY9VvMKtOazIF5V1nyCwavKeP5HDepBtmn8pi0qQRRUg1qQm/i1edgsVGAHWqD//i0sQAJW4Lh9nx3xErONAnRdb0AfdI5i0+ZlY+wCI8IWcZAEaVAPsk0juhaVIDfxDurhtbABvaP7U5qR449mho632oydiRXYgAwUoAI70DbKjKGJBUjACnS36shAASqwAy3QY21hARKwAuFW4FbgVuBW4Fbg5lHnM0JeLbaRgBXYgAx03dFlvAKs+YSPV4D5L50XgC1qQaPHzL8nQRrUg2zTiMBFfkHmOP6xTw95MdfGDhz/3idsvJhrYwESsAIbkIECVGAHwk3gJu7mjS0ErEB387YUBrqbN6u4m9+8uJvfvFigXsDh5jMdXsy1cbj59IYXc7FPb3gxlw82vJZrkQb1INs04naRKzbHcaX+uuelWexvnF6atdECR+Cyv1t6adZGAlZgA7ruuEEvt2KfbPByK/Z5AC+32liBDchAASqwAy2wuBs5FiAB3a06NiADBehuzbEDLXAEo/hfHbG4iIIeVj4K9FKrRRwkQRrUg9xkPCOvstpYgARkoF+mOFqgx6K/vnvl1EYCjiudf7UFcZAEaVAPsk0jYheVIAoKDw4PDg8ODw4PDg8ODwkPCQ8JDwkPCQ8JD49Qfwf1EqmNHTiazOcivURqYwGOJqv+gDxCF45+5C/OXiK1UYAK7EB38yvzn9eF7uZPpbubX5lHr79beYnURgYON5/o8xKpjR04mtD/6gjpRSWIgmpQC3LFEV9e8MT+PuwFT+zzhF7wtLECG3Bc6agLb17wtFGBHWiBI5r9tcPrndhHh17vxD4w9nqnjT668Wv0Y3v9X+2jO1vfZ/y0vs/4aX2f8dO8UIn95dELlTZ2oAV6OC4sQAJWYAMyEG4VbhVuFW4euj7e8kKljQSswAZkoO428NN+JtkmP+3H/56f9jOJglzcm8h/YhcyUIAK7EC/ldGHvVppo9+KP03/iV1YgW2eFNXi7M4WZ3e2OLuzxdmdLc7ubHF2Z4uzO1uc3dni7M4WZ3e2OLuzxdmdLc7ubHF2Z4uzO1uc3dni7M4WZ3e2OLuzxdmdzcuV2CcNvFxpowJHo/lvtZcrLfTf34UFOBrN5xq8XIn9N8PLlfyYq+blShsFONz8t8nLlTbaRi9X2liABKzABmSgABXYgXDzw/7MqQRRUA1qQRwkQRrUg2wThQeFB/n9NMcKbEAGClCBHWiBnhkWFqC7sWMFNqAGerT7VI6XKLFP5XiJ0sYKbEC/Xr83H2EvVGAHWqCPsBcWIAErsAHhxnBjuDHcGG4CNw9/z+teuLRxuPlkkBcubWSgv3p41/Hf74UdaIH++72wAAlYge7mD8t/vxcKUIHuJo4W6L/fCwuQgO7mN++/3wsZKEAFduBw8181L2faWIAErMAGZKAAFdiB2429nGljAbpbcazABnS36uhuzVGB7saOFujj9zGfwV7ktJGAFdiADBSgAjvQAgluBDeCG8GN4EZwI7gR3AhuBLcKtwq3CrcKtwq3CrcKtwq3CrcKtwa3BrcGtwa3BrcGtwa3BrcGtwY3hhvDzXPJmJJiL3La2IAMHL9T45WRvchpYwdaoB91srAACViBDeh30Qd6fuj+Xz0/LBzXa97BPT8sbEAGClCBPdAzgXkwdLRvxx17zC9UYAeO9h3TVOzFSBsLkIB4mgY3w9M0PE3D0zQ8TYunWWbMq2MBErAC274GL0baKECFbgfCDTFfEPMFMV8Q86VE3ymFgQJUYI9rKNGSXpe0EW6I+YKYL4j5gpgviPmCmC+I+TJj3q+hoiUrWrKiJSta0mN+zPKx1yVt9JZsjgrsQAv0mDcX85hfSMAKbEAGClCB7tYdLZCjg3uVEo/RFXuZ0sYGZCC6hg8aFuJhMR6W4GFJARIQD0vwsAQPS/CwBA9L8LAEHVHRERVdY4S/jAE0lzkBN1GAPgXn7TDn4PzK5iSc45yFm1iABKzABmSgAH1INX4sy3w5mFiAruv9wV/mF7qu35AxUIB+F/64rQNto5dRyagqY6+j2kjACmxABgpQgR1ogQVuI/x91OHFVIs46CHqIwqvr1rUg1xx9DuvrtpYgASswAYc11/cyqfsFipwmHkLjbifNMJ+UQmioBrUgjhIgjQoPGp4tPBo4dHCo4VHC48WHi08Wni08Gjh4VN6Y0qavTBrIwF9Bmb+3Qb06R5xFKACfYZgKligT+6NqW72eq2N7uZP0+f3FjbgeCv0R+FTBJM0qAfZJp8imOSK7OhP1y/PI7r4rXhEL7RAj+iFfqXeVTyiF1ZgAzLQp3/JUYEdaIE+Y7ewAIcbeRN5nC9sQAYKUIEdaBu9wmtjARKwAhvQ3ZqjABXobuLobqP5vNZro7t1RwK6mzk2IAMFqMAOtEDPAQsLkIBwI7gR3AhuBDeCG8Gtwq3CrcKtwq3CrcKtwq3CrcKtwq3BrcGtwa3BrcGtwa3BrcGtwa3BjeHmmWFMkLNXfm2swAYcE1Me1/No04UK7EALnAP+iQVIwAocdzFq9NiLv2RM0rMXf2306/W/qwSswAZkoAA10DNB9Q7e0b4dd+wxv1CAChztO5YE2Au7FnrMLyxAPE2Dm+FpGp6m4WkanqbhaVo8Ta8Cm5fjVWAbCViBDej3Jo4C9HtTxw60QI/5hcOtuZjH/MIKbEAGClCBHTjcxpIF++5qG2k/LK8Xk7GQwV4vtpGBAtT9ALxkbGM8LC8Z21iABKzAeFgNgd4Q6A2B3hDoDYHeEOgNgd4Q6F4cJmPhhb04bKMCvaG8HTykm1+Zh/TCAiRgBTYgAwWogf6z7r/7Xj22kYAV6LreNXzhbqEAFeg/zfOfWaAH+sICJGAFNiADBWhzAYq9vmxRCXqIqrfiCP1FLcivvzsKUIEdaIEe+AuHk3fcEfeLapA3lT9wj/qFAnxYqbfUCPpFtsgLzRaVIAqqQS2IgyRIg3pQeJTwKOFRwqOERwmPEh4lPEp4eICPulX2OrSFHuALxxMfJVnspWgbxxMf62nsxWgbGTgabSyXsdejbexAC/RYX1iABKxAdxNHBgpQge7WHS3QY31hARLQ3cyxARk42nGSBvUg2zSif1EJoqAa1II4KDw4PDg8ODwkPCQ8JDwkPCQ8JDw8B4g/Zc8BYw2JfTO1jRboOWBhARKwAhuQgQKEm8JN4dbh5i8D4n3KXwYWVmADMlCA7lYcO9ACPT/4m74XzYl475n7pzr1oPGPPFN5RdzGAiRgBTbguETPNl4Rt1GBHWiB/vu+sAAJWIENCLcCtwI3D/+xFsReEbfQw3+hu1VHAlaguzVHBgpQge7Gju42UpDXycn4Qpe9UG5jAzLQdc1x6PqEhVfLSffr9UD3RRKvl9tYgAQcbj6p4TulbWSgAN1NHN3CL8d/332i2yvqxKfuvKJOfPrQK+o2NiADBajADvQqE28z/9Vf6BbefP5Tv7AB3cIv0sN8oQI70AI9zBcWIAErsAHhpnAbYa4+i+eVdBstcI4AJhYgAUf+8kk63xNtIwMFqMAOtEC7gAVIQLgZ3Axu5m7ed3wksLAD3W08IS/SU58H9CK9je6mjhXobt2RgQJUYAda4CzrmViABKxAuBW4FbgVuBW4FbgR3AhuBDeCG8GN4EZwI7gR3AhuFW4VbhVuFW4VbhVuFW4VbhVuFW4Nbg1uDW4Nbg1uDW4Nbg1uDW4Nbj5E8FlRr/Ar678SsAIbkIECHLo+g7oK+Lwj+hjApxa9hG8jAwWowA60QPVRMznijlXiLmbMT+xAC/SY92kFL8zbSMAKRPt2uHW0b0f7drRvR/sanuaMeb+GGfMTK7ABOa7BY36hAuFm4davC1iABKzABuRt3C8BKrADbV/DLOVbWIBwQ8x3xHxHzHfEfEfMd8R8L/HcOl3AAiRgPDcvCNzIQLgh5jtiviPmO2K+I+Y7Yr4j5nuN59YrWrKiJStasqIlPeZ9uttLAjd6S7IjASuwAf3e/Bo85hcqsAMt0GN+YQES0N38Iv3VYKHHPDn2HYVeDaijFpy9GnBjARIQT0jwhARPSASowA5E71M8IcUTUjwhxRNS9D5kja7oD4r+oOgPnh9GETp7JeDGChy6PnXvxYDq0+ZeDLhRgR1ogZ4fFhYgASvQdb2XeCZY2IG20cv+dBSQs5f9bSRgBfoqDzkyUIAK7EALLBewAL11xJGBAlRgB1qgR7evJHgBn/rygRfwqU+LeQHfxg4cCj6d6QV8G0c7+CSyF/BtrMBxvf6e5fuRbRSgAjvQAj2OF7pbdSRgBTYgAwXoBe3eDh6xsx08YheidTxifRbUy/o2MlCACvS78E7gcTzR43hhAfpduJvH8cIGdDd/AB7HCxU43Hwu18v6FnocL3Q3v2OPY5/h9bI+nT3K49jnO72sb6MAXdfvzX/nFxYgAV3X721GrHeuGbETO9ACZ5hO9K9j/N68KmehAP0R+r15Vc5CWyhXfEkjsxJvIQErsAEZ6I0qjhboP80LC9BvXh0rsAEZuL8okllzt7ADLdDrbxYWIAErsAF1fUUm1/yAbaLfRR/owbuwAAnod+H/zIN3IQMFqMAOHHdxeUt6pc3CAiRgBTYgAwWowB7owcsTCViBDTjuYiyii9fRbVRgB9r66E+8jm5jARKwAhuQgQIcz2JMuIpX120sQL+L6liBDchAASqwr49LxbcFW+iffi8sQAJWoOs2R79e71z+w7qwAGl9tCrX/Dx1YgMyUIAK7EDbWObnqRMLkIAV2IAMFKACOxBuHsdjilm8jm5jAzLQW0cdFdiBFuhD7IUFSMAKdLfuyEABKtDdzNECPboXFiDth+V1dBsbkIECVGAHRn/wOrqNQ3dMO4tXzG1k4NAVb2ofTI9vMcQr5jZaoP80Lyzry27x4rmNFdiADBSgAt2tObrbiBYvnttYgASswAZkoN+bW/hP88IOtECP+YUFSMAKdDd/3B7zCwWowA60QP/BXliABKzrw3gp85P0iQz09SV/bv4zrv40/Wd8oQV6flhYgASsQF/L8mfsL+YLBajADrSNNFfmJhagu7FjBTYgAwWowA60wLlGN9HduiMBK7ABGShABXbgcBufBYgX4W0sQAJWYAMyUIDjd7M69SDb5KW3k0oQBbmit6zngD7/qwXOLST8+n1jloUErMAGZKAAFdgD/Rd+zNiLl9SpB7OX1G1sQAYKUIEd6HcxermX1G0sQAK6mzo2IAMFqMAOtEDPAfPePAf4b65vgbaxAhuQgQLUeBaKJ6R4Qp4DFhYgASuwARk4nsXsD77Ly0TfrGKhL1N6Z/NoX+gLlfMvNCADfT3UH6xH+8IO9CXR8QC83G5jARKwAt3NHBkoQAV2oAV6tC8sQK+rvRxHT/UBkhfL9bG0IV4st5GAXphLjg3opbnVUYAKHIWm17SwQC+ZXViABKzABnQ3dhSgAjvQAr14dmGJO/ZS2cub2mtlFwpQga6rjhbIF7AAR9bwdwgvi9vYgAwUoAI70ALFW6c7VmADMtDvYv4zBXagBfpWhtX/mW/RtJCAFdiADBSgBo6I7cX72YjYjQQcd1G8c42I3cjAcRfF+9n41d447qJ45xpxvNAuoLv5MzYCVmADMlCACnQ37ztmG72EbmMBErACR5uNuTfxYjnfllO8WM73hxQvllvo28ssLEACVmADjmcxKpRl7p22UIEd6G7jAXix3MYCJGAFNiADBaiBc39ev02P7lFeJV4ht7ECG5CBAlSgPwu/C4/uiR7dCwtw3IX3s7mp2sIGZKAAFdiBFjhifqPfRXdsQAb6XXg7sAI7cNzFbLPx271x3MWYRhavm9tYgcNtTC6L181tFKACO9AC9QK6W3UkYAU2IAMF6G3mHbzjyXc8+Y4n3/HkO558x5PvePIdT77jyXc8ecOTNzx5w5M3PHnDkzc8ecOTNzx5w5O3ePJzs7aJI94e78TiLM7dWcEjuPbfGdEVTIkrmP3ve+LzoqxgSlwTt8ScWBJr4p7YwJJ8JflK8pXkK1O/OmviDlbFfen8783ZwP1KXBJT4ppYoNmTfu+JDWxTn51L4qk//87UV+eWmBNLYk3cE1uwV18Fl8SUuCZuiTmxJNbEPXHyLVO/O08dc0Z/kKKJe2L0B6ErcUlMiWvilpgTJ19KvpR8KfnW6Xs5l8SUuCZuiTmx+9JkTey+NL0M3K7Eru950SusHlydNfHsb962zaIvyYrfySUxJZ76zbkl5sQSfV5W/E7uiZOvJF9JvpJ8V/w6q/8dHzd49VRwTTyvbf59TiyJZ5t435sxvni2rffDGeOLS+Lp6204Y3xxS8yJJbEm7ondt/qznrG/uCSmxDVxS8x41ivG/ZpnjPsz0hnji0tiSlwTt8ScGM9aL03cEyNnei3VimsvpgqmxDVxS8yJJbEm7mBCztQV+5PRl3TFvl/biv3J6b4o3Rel+6J0X/VKXBJT4po4+dbkW5NvTb41+dbk25JvS74t+bbk25JvS74t+bbk21J7rlzhzOk5cnqOnJ4jp+fI6Tlyeo6cniOn58jJl5OvJF9JvpJ8JflK8pXkK8lXkq8kX0m+mnw1+Wry1eSryVeTrybfmX885+saY0w2cL8Sl8SUuEb+15V/JnPimWfG74LOfOL5QWc+WTzHcn5tayzhMbLGEpMlsSZO/dPQP/t1JUZu7xclrolbYvj2GWuet/uMtcUlMUUO7zPWFrfI233G2mJJjJzca09s4PU7O7kkpsQ1cYuc3GesLZbEmrgnxm9Bn7Hmz8i3LTOZ2IEWOAJkYwESsAIbkIEChJvATeCmcFO4KdwUbgo3hZvCzfcw8+WmuYnZQgv0bcwWFiABK7ABGShAuHW4dbgZ3AxuBjeDm8HN4GZwM7gZ3CzcvKhpYwESsAIbkIECVGAHwq3ArcCtwK3ArcCtwK3ArcCtwK3AjeBGcCO4EdwIbgQ3ghvBjeBGcKtwq3CrcKtwq3CrcKtwq3CrcKtwa3BrcGtwa3BrcGtwa3BrcGtwa3BjuDHcGG4MN4Ybw43hxnBjuDHcBG4CN4GbwE3gJnATuAncBG4CN4Wbwk3hpnBTuCncFG7IJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxiyCWGXGLIJYZcYsglhlxikUv0ilyiV+QSvSKX6BW5RK/IJXpFLtErcolekUv0ilyi1wW3ArcCtwK3ArcCtwK3ArcCtwK3AjeCG8GN4EZwI7gR3AhuBDeCG8Gtwq3CrcKtwq3CrcKtwq3CrcKtwq3BrcGtwa3BrcGtwa3BrcGtwa3BjeHGcGO4MdwYbgw3hhvDjeHGcBO4CdwEbgK3mUuao7upowAV2IEWOHPJxAIkYAU2INwUbgo3hZvCrcOtw63DbeaS7tiADBSgAjvQ3XjgzCUTC3C4jZIO9eqvjQ043NQb1XPJQgV2oG306q+NBehu4uhu6tiADBSgAjvQAj2XLCxAAsKtwK3ArcCtwK3ArcCN4EZwI7gR3AhuBDeCG8GN4EZwq3CrcKtwq3CrcKtwq3CrcKtwq3BrcGtwa3BrcGtwa3BrcGtwa3BrcGO4MdwYbgw3hhvDjeHGcGO4MdwEbgI3gZvATeAmcBO4CdwEbgI3hZvCTeGmcFO4KdwUbgo3hZvCrcOtw63DrcOtw63DrcOtw63DrcPN4GZwM7gZ3AxuBjeDm8HN4GbhRtcFLEACVmADMlCACuxAuCGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxByCSGXEHIJIZcQcgkhlxBySUUuqcglFbmkIpfUmUvMkYECVGAHWqDnklF+qV6HtnG4jbpE9W3fNjYgAwWowA60QM8lC92NHQlYgQ3IQAEq0N26owV6LllYgASswAYcbqPAUL2SbaMCvSXdeOYSx5lLJhYgASuwARkoQAXCrcGN4cZwY7gx3BhuDDeGG8ON4cZwE7gJ3ARuAjeBm8BN4CZwE7gJ3BRuCjeFm8JN4aZwU7gp3BRuCrcOtw63DrcOtw63DrcOtw63DrcON4Obwc3gZnAzuBncDG4GN4ObhVu7LmABErACG5CBAlRgB8KtwK3ArcCtwK3ArcCtwK3ArcCtwI3gRnAjuBHcCG4EN4IbwY3gRnCrcKtwq3CrcKtwq3CrcKtwQy5pyCUNuaQhlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkkoZc0pBLGnJJQy5pyCUNuaQhlzTkEq+ms1FyrV5Nt7EACViBDchAAXpWVscOtEDPJQsLkIAV2IBjVesa1dXq5XTBmrgnNrCvbG4uiSlxTdwSJ9+efHvy7cm3J19LvpZ8Lfla8rXka8nXkq8lX0u+Bl8vvgsuiSlxTdwSc2JJrIl74uRbkm9JviX5luRbkm9JviX5luRbkm9JvpR8KflS8qXkS8mXki8lX0q+lHwp+dbkW5NvTb41+dbkW5NvTb41+dbkW5NvS74t+bbk25JvS74t+bbk25JvS74t+XLy5eTLyZeTLydfTr6cfDn5cvLl5CvJV5KvJF9JvpJ8JflK8pXkK8lXkq8mX02+mnw1+WryTfmKU77ilK845StO+YpTvuKUrzjlK075ilO+4pSvOOUrTvmKU77ilK845StO+YpTvuKUrzjlK075ilO+4pSvOOUrTvlKUr6SlK8k5StJ+UpSvpKUryTlK0n5SlK+kpSvJOUrSflKUr6SlK8k5StJ+UpSvpKUryTlK0n5SlK+kpSvJOUrSflKUr6SlK8k5StJ+UpSvpKUryTlK1n5Sp0pcU08fcWZE0ti9x3VQTqrRjcbeOarUe2sMvPVYkrsvsU1Z75azIndl6amJu6J3Zdcc+arxSWx+47KGZ1VpptbYk4siTVxT2zgma8Wl8TJV5KvJF9JvjNfjY1QVGa+WtwTG3jmq8UlMSWuiVtiTpx8Nflq8tXk25NvT749+fbk25NvT749+fbk25NvT76WfC35WvK15GvJ15KvJV9LvjNfjT1edFa0Tp4VrZtLYkpcE7fEnHj6irMm7okNPPPV4pKYEtfELTEnTr4l+c58NT5IU535avLMV4tLYkpcE7fEDJ7vaZejr02aIwMFqMAOtMC5gj2xAAlYgXBrcGtwa3BrcGtwY7gx3BhuDDeGG8ON4cZwY7gx3ARuAjeBm8BN4CZwE7gJ3ARuAjeFm8JN4aZwU7gp3BRuCjeFm8Ktw63DrcOtw63DrcOtw63DrcOtw83gZnAzuBncDG4GN4Obwc3gZuHWrwtYgASswAZkoAAV2IFwK3ArcCtwK3ArcCtwK3ArcCtwK3AjuBHcCG4EN4IbwY3gRnAjuBHc5lClTvaUM7au0ll4u7kmbok5sSTWxD2xgedQZXHybcm3Jd+WfOdQZeygpbPwdrMm7okNPIcqi6fv5UyJa2LdqXQW5y60wDlBPLEACTjV2Lkl5sTzLsRZE/fE8y7GgLHPAcjikpgS18QtMSeWxJq4J06+PfnOAcjY2Er7HIAsrolbYk4siTVxT2zgOQBZHCUrs3B3YQVOU+/Sc/SxWBJr4p7Ygm2OPhaXxH6zY0MptTn6WNwSc2JJrIl7YgPP0cfi+ferc09sYCxTG5apDcvUhmVqwzK1YZnasExtWKY2LFMblqkNy9SGZWrDMrVhmdqwTG1YpjYsUxuWqQ3L1IZlasMytWGZ2rBMbVimNixTG5apZymuL7zNUtyFHejLZiMMZynuwgKcz7s518QtMSeWxJq4JzawxGLdLMldSMBp6hczM8hiTiyJNXFPbOCZQRZ752b3mhlkcU3cEnNiSayJe2IDzwzCHkgzgyymxDVxS8yJJbEm7ol9Mny8hc9i3YUF6KZjEy21+f6yuCXmxJJYE/fEtrlfM4OMLyEeXBJT4pq4JebEklgT98Qx/9CvNWeizpJYE8+5C3E28JozmTyvuTlT4pp4XvP8+5xYEs9rdt85Z7LYwHMgsrgkpsQ1cUvsvuptPgciizVxT2zgORBZXBJT4prYfdXbeQ5EFktiTdwTG3gORBaXxJR4ztW478w2iznx9CVnTdwTG3jOmSwuiSlxTTzvl505sSTWxD2xgWfCWVwSU+Lp6890JpCxe1e/ZgKZPBPI4pKYEtfELTEnlsRzbs3jaCaQxQaeQ5BROtKvOQeymBLXxC0xJ5bEmth9u7f5zCHOZeaQxSUxJa6JW2JOLIndd2z71cvMIYsNPEchi6cvO1Pimrgl5sSSWBP3xAae+WfMQ/Yy889iSjx9J7fEnFgSa+Ke2MAz/yye92vOlLgmbok5sSTWxD2xgWeeGb9Hvcy8Yf6MZt5YbOCZNxaXxJS4Jm6JOXHM8fbCmrgnnr6j/5eZNxaXxJS4Jm6JObEknvfrbT7zxmIDz7yxuCSmxDVxS8yJp2931sQ9sYFnnjF/RjPPLKbENXFLzIklsSbuiWMuvRe7EpfEw7dc/lw8z2xuiTmxJNbEPbEFeyHvg6tzSUyJa+KWmBNLYk3cwWXqszMlrolbYk4siae+OPfE877G74gX8QZP3+5MiaevObfE7uu/s17KG+y+Y4eQ7sW8we47NgTrXs4b7L7+O+IFvcHuO76k7l7SGzx9/R6rJJ6+fo+1J56+fo/tSjx9/R4bJZ6+fo+tJXZfj30v7w12X/J79Ly02X3J79Hz0uZYi+mENaBOWAPqhDWgTlgD6oQ1oE7zUFbv/zRPZV1s4HkuK3k7zINZF1Pimrgl5sSSWBP3xAbW5KvJV6e+t79OHW9znTp+X2rgfiUuiSlxuv6err+n6+/p+nu6/p6uv6frt3T9lq7fUrtZ8rXkO/OJ32OdecPvsV64/npR4pq4JebEuP56aeKeGNfv5bvBJTElrolbYk6cfEvynXlj3uPMD/MeKV0/peuf+WGxJu6J0/XXdP01XX9N11/T9dd0/TVdf03XX9P119RuNfm25DvzwLzHFe9+jy1df0vX39BvK1+J03Pn9Nw93svY8aB7KW5wrAn2eQbzZk3cwevA5eI8deZ/93aofv0zfhdr4p7YwDN+F5fElLgmbomTr05fb7cZ74t7YgPPeF9cElPimrgl5sTJtyffnnxnvFd/1jPeF5fElLgmbok5sSTWxD0xfNt1JZ765uw6Y5K9txnvi3tiA894X1wSU+KauCXmxNO3OGvintjAMw8sLokpcU3cEscadG/zfWSxJp6+5GzgmR8Wl8SUuCZuiTnxvF921sQ9sYFnflhcElPimrglnr7+fGc+Wey+7O0/8wl7+7RYc++Nr8QlMSWuiVtiTiyJNXFPnHwl+c48M2bVe5vjh8U1cUvMiSWxJu6JDTzzz+Lp6/1h5p/FNXFLzIkFPPPGmGjts7Z2MyeWxJq4J57X6c9u5o3F/vd9bnPWxG624FkTW3xucNbEbqbEfp1jAbLPmtjNnFgSa+Ke2MAzPywuiSlx8p35wef0Zk3sZkmsiXtiA8/8sLgkpsQ1cfKl5EvJd44fxlfifdbEbjbwzA+LS2JKXBO3xJxYEiffmnxnfvA5yVkTu7kkpsQ1cUvMiSWxJu6Jky8nX06+nHw5+XLy5eTLyZeTLydfTr6SfCX5SvKV5CvJV5KvJF9JvpJ8Z37weddZE7u5JKbENXFLzIklsSbuiafvyOGzJraMs4r7rIndTIlr4paYE0tiTdwTR+1TXzWxi0vi6SvONXFLzIklsSbuiS141sQWn4OdNbGbKXFN3BJzYkmsiTs4vgLqs8S1jEMk+ixx3SyJNXFPbOCZfhaXxJS4Jk6+lHwp+VLypeRLybcm35p8a/Ktybcm35l+xlHUfZa4Fp+WniWum3tiA8/0s7gkpsQ1cUu8P6TpXuG6UYHTtDobeOaexSUxJa6JW2JOPG/W+93MPYt7YgPP3LO4JKbENXFLPH3VWRJr4p7YwDP3LC6JKXFNvD8f6l7eulGA07Q798QGnolncUlMiWvilthv1ifRZ3HrZk3cExt4DnAWl8SUuCZ2X59En0Wsm3viqT861Sxi3Tz12ZkS18RTX5w5sSTWxD2xgeeAaHFJTIlr4uRbkm9JviX5luRbki8lX0q+lHwp+VLypeRLyZeS78xI3q/mdq2LZ0ZaXBJT4prYa0SK45TszgaeyWbxlDRnSlwTt8ScWBJr4p7YwDPfLE6+c8dVn69fO676ev/acXWxJu6JDTx3XF1cEs+5AHKuiVtiTiyJNXFPbOCZP3y+ae2ses3/3hJzYkk876s698QGnjurLi6JKXFNPOfU/PmuudTJklgT98QGtitxSUyJGfdu6b7mjquLe2ILXjuu+jWvHVcXU+KauCXmxJIY99Wvnhj31cuVuCSmxDVxS8yJe9x7L+m+1mkEk0tiSpzui9J9UbovSvdFmrgnRj/pNd1XTfdV033VdF813VdN91UlcWrPmtpz5o157y3dV6uJW2JOnO6rpftq6b5aui9O/YRTP+HUTzjdF6f74nRfnO6L031xui9O/URSe0pqz7lTs6/VzXLXzZJYE/fEBp47NS8uiSlxTZx8Nflq8tXkq8lXk29Pvj359uTb4Wuzf3rNk83+uVgSu6+/V9vsn4sNPHdDXlwSU+KauCXmxJI4+dbkW5Pv7Ic+P2Kzv/l8hM0+Nv/77GP+u2mzj/k75KyS3FwTt8ScWBJrYr82fz+cVZKL52/W4unbnKevt//cJdzf62ahJHkt0SyUXPcy+97idI+zX/l83CyC3FwTt8ScWBJr4p7YwLNfLZ6+fi+zX7Hfy+xXi1tiTjx9/X7nCQSLe2IDzxMIFpfElLgmnpqPNrRZy0hjftBm/SKNOUGb9Ys05v5s1i9u5sSS2MDzhIBxcqld84SAxVOHnGe/rYPn78KYQ7RZg7i5JZ6+7CyJNXGH/oo7/+8r7iaXxJS4oh1m3C3mxJI43e/cbXze49xtfHFqhxkj1f/tjJHq7TxjZHFPbOAZI4tdv7nvjIXm+jMWFktiTdwTu37ztpp5eHFJTIlr4paYE09ff6YzXhb3xAae8bK4JKbENfH08v4wY2SxJu6JDTxjZHFJTIlr4pY4+VrynXHUvP/MMd5iC551fptLYkpc47nMOr/NnBjPtMz4Gp+P2KzJo/Hphs2avM2auCee1zb60qzJ21wSU+KauCXmxJJ4+nbnntjAMx4Xl8SUuCZm3O+KwcvZwDMG5z3OGFxMiWviGePennNstlgSzzxJzj2xQYeTLydfTr6cfOfv5uL07Dg9O07PjtOz4+QryWvGfvVrnrG/WBP3xDO3+L3M2F9cElNiv/5anVtiTiyJNXFPbOAZ+4tLYkqcfHvy7cm3J9+efHvy7cl3ncrTnKeOx+CM5ep9bMbyYguetXSbS2JKXBPPa1ZnTiyJNXGP66H5ezp5nsSzuCSmxDVxS8yJBezfBpFfpn8btHB8P0N+Mf5t0ET/NmhhAY4vWcYLgc0tLBc2IAMFqMAOtED/NmhhAcLNJ3lHJYrNHSpH8YnNHSq9v84dKif6pz8LC5CAFdiADBSgAuHmHw1655o7VC4sQAJWYAMyUIAK7EC4KdwUbv7dscf53KFyYQMyUIAK7EAL9O+OFxYg3Drc/Atjj7G5v+Tscv5Z38IKbEAGClCBHWgb5/6SC91CHCuwARkoQAV2oAX6p8ILC9At1NHFuqMCO9DFRqede0YuLEACVmADMlCACuyBFRYzIP16Z0BOFKACI/znPpATEZAVAVkRkHMfyIUNyEABKrADI/znPpALhxhPZCAunXHpHpD+6jK3eZzoAbmwAAlYgQ3IQAEqEG4CN4Wbwm1+8n854ubnF/0jWuZ+jbOpewESsAIbkIEChEVH+3a0r6F9DU/T8DQNT9PwND30POnO7Rg96c7tGD0Nzu0YFxKwAhuQgQJUYAdGMp/bMS6MhDe3Y1xYgQ3IQAEqsAMjvc7tGBfCjeBGcKNIr3M7xoUCVGAHRnqd2zEuLEACViDcKtw8eD3pzs0UPSPOzRQXMlCACuzASK9zM8WFBUjASK9zB8WFAlRgB0Z6nTsoLixAAlagW6hjpNe5QeLE+bM4MdLr3CBxYQU2IAMFqMAOjGTe+gWERcfNe0D6e4zXYm20QA/IheN6/T3K9zjcWIENyEABKrADbaPXcW0sQAJWYAMyUICeES/HHuih1yb6PyuOAlRgB1qgh57PKXiNlfnrv5dYbWSgABXous3RAj3IFhYgASuwAd2NHQWowA60QP/dXFiABHQLcWSgABXYgRbosbmwAAlYgXBjuHmY+mukl01t7EAL9DBdWIAUrS54WIKHJXhY3pX95doLeszfp72eZ2MH2kYv5rExl2pey7ORgBXYgAwUoALdrTpaoP/MLCxAAlZgA8q+N6/wsTGXa17Is7HEDfmvyMIKbEC/dHEUoAL90tXRAr2DT4UKtwq3CrcKN+/gCwWowA7EY2lwa9Piv/7hbw/4z7/5rY6PnvxGHeqGtoE3yIZhOD598ptzsAV+Y0Ue+tX1/S/o/gu6/8KAsoE2uLU+/m0b/9afU+mP/8nxP8c3R/7QHHyo87gez0jjkGJ/iMSPfyJQsP0XyuO/6/jvfnC8lxzbAj80fk4kbKANdUPbwBtkg27YyraVfWJxUQmioBrUgjjIDXSQ6z1+fPzD4EUliIJcb9zyaJ0+srtPJU4a7bOoBPnfK4NsU72CStDwGLnep/wWtSAOGtc8sohP4/WRmX2yro9c6lNyfWQ0n5BbVILcY9wv16AWxEES5HrjzsX/7bhzqUEtiIMkSPdVSQ+yTXoFlSAKqkEtiIOG3viR9am0SWMAsqgEDb2RinxKrI8Q9QmxRbbJu+ekEkRBNWhcy8hyPmW2SIJcb8Sv98mRn3x6rI+c5JNj3i4+NbaoBXGQBHn72SOq+ogqbxzfZaRuaBt4g2zQDX67NrbuWDAbakDZMJS9vL1uGP9KyorguZK0oWygDXVD28AbxvX44pZu6BtcOSJYIoIlIlgigiUiWCKCJSJ4kjt4LPdNHq3icTv+nkZkqsfj0Bursj6Jv0iCNKgH2SaP4EklaFzzWMGdETypBXGQBLnyiOBqm5qreCz7v5Ad35M0qAfZJo95jZjXiPlJflUR86NAdcb8JAnSoB5km8bgZ1EJGh6j+HXmhknuQTs3jArRmRsmuUfbuWGSe0RuGHWeMzeMKsyZG0Y55MwNk9zDdm4wzwjDY5Qy+vR7HwWLM19MGh5Wd74YZYszX0waHqNM0afcF7UgDpIgDXIP2XnFyYNmlOPNvDIq7WZeMdt5ZVILGoOBUQE3T6kadWvzkKrL88/4Rb52rnGaJ1RNGr/4V1u5xi5eucYuWbnGLl25ZpF79JVr7PKs40OKa5Bt8pHgpBJEQTWoBfnQoAzSoB5km3xEMb4in0dQTaKgGtSCOEiCNMg9xvjLfHykewjhE7uLetAeRfis7qISREE1qAVxUHj08IghEMUYiGIQRDEKohgGUYyDaA6EfFDneuP5zIGP0x6p1OsKcj0b5L8e1yAN6kF7pOLztD7u8GnaRT1oj1TqHNHQoBJEQTXIf8nqGGT632uD9i+3T636CMRnVhftkYrPq/pow6dVF1FQDWpBrjfufI5yxp3PUY4TBdWgFrRHEZUlSIN60B6p+OTpohJEQTXIf3xH63p2m9SD9kjFp0d9VFLn7/Zov/nD7aRBPWiPVGq/gkqQDwxG23s/ndSCXG88jznyGS0+Rz6jJS3az6L9LNrPov0s2s/mSOW/xg+th5j3Vp7vMRNkg27oG7zzjheIkUgebxD+j9v43/6+5D95YyrRf/EcdEPf4Bp1/Jv5DjT+DW1f2r60fWn7DvDfbYdxu2PK3H+1HeqGtoE3yAbd4MqjB9oC78UOZQNtqBvaBt7gyrbu06Fv8Pt8dBjv4w5lA22oG9oG3iALvDM69A1bWbeybmXdyv4jOyZU/TfWgTe4Mq1BpkPfYAtmPqU1yKwjIZe234g7rTfiCXVD2+Ct0/7r8Y/+5d/+xz/+xz//27/+9//493/6p/Hv93/4X3/7b//Hf/7tf/7jv//Tv/7H3/7bv/7vf/mXf/jb//eP//K//S/9r//5j//qf/7HP/774//7uJ1/+tf/+/HnQ/D/+ed/+adB//UP+NfX83/6WEPl9a8fa6gaAo9B5l2JR/bbF/BIcAUSD84S9FyijH285kVcNQTqH9dQnwv0MSxwgcfPxFOB9lzAN5N0AbPXBGRfwWO8T08VTu3IfUs8EnF/2o56eJpeuDIbsla05GOY/kWin57m7g+PTAgBkdu3IYTbqPr0NspB4zHBuLvUA9EU8odEOXSpNsab84Ew01OJQ69UlehUDffB7baCj0WmgpTnCndvQ5/fxqkxdYyyZ2PqZU8l5JQlxkvNyhKtPJXQt5vi0DPJdz6bF/F4Lw6NRl8l7HARsvPM463l6UXQoTHHlpgcgS6Cy3gMDO/fim8+sm6Fy7NboUPXor4f6mN0/LQtjjFmEt2i1GfPlN7PeSeJ6mtJK9/Y4cdDTjEiFDGSGoP+vI5D9+S+H8hjNSEp6C96Rjf0DEtP9c+eQYceOhYP9w8Rpyt5/Dh8/S08/abrFYGilHLG7afyWO/fCo/18+c/RfX4m86RuTqln5Ly9Trq4Wf9MW2k0aaP9X1KKn+0R3u/f4xfvvf6x/FeHkv/V9zL49Xt+b2cfuH9k/+VOTqS+SMjftXob/cP+0QWPKvcjZhW3o+YRu+2yPnpSo1k2CQ9mT+fbjv0VBLeOZkeLZyeLn/VOPTU6h9vzYz6GPkkjfpVQ45D+t3dH/MY9bnG6Tq86H1qPCaTnmscemqzuA6+LnuqcX4yPRr1MZrq/emT4UNOFf+MeCaASs/zEB96aiuRAFop/SUN9q0eZ4s8luNeu5dKW0NaeZ6HuJ1GD/F0WeSQy05PhrUhMfdTq55+/YvPA02Vx3z19SR6Wf/S+Jeme0D2WBBoh1a1v/RXRv1QgHkdeh3ykBx6GVW8kOfXQPrj91/ezqnHq2hlxwu1dj29itMo5DFlH3fyWGx5OgqRUyYT2x2sas0tqrc1Hj/+Owm1x4Trcw19fxwj/e0edmzRePN4rGRcz8d1Jw3/QGVpHJ6KlnfnjJTenTTS+u6s0bklekTJY+LkeUvwcZTc4weu5d+Vr6MGPf7iU/Txx5T6c43TdbSUespB4zQ2raVhpkGeahzbVGKugeTLvfyih0q0KemX6/iq0d/uof3tHtr/2h6qHHMVdoj3zqepG8V8R83vgl/Hcf3QQ8exl0tjHAf4ksbYYytmobg81+jvZ+Fuf2kW9qrj9VRUXuvjFpdRL+pPNeztmXt7e+re2l/Zx6ufoLfeVSo9b4nTOJTwSjzeX6HR7mt4qe1qzn491zj1T+7RHoWtQKX+Mdaw0zxUzLvk3jXWFG5ncsE4Qa/nmbxcpxTKhtdqthT28ofIMYNhTeP68pbx55Ucummjsm+nPfLg06WVcrXj841f+yv9Qn6bzT+NRmMWvF3P57D9JIWnL4Ac3Uzkup5PYV+n0ehjOp4we0P16czL8ZeBY3GCpD7PyH6iw7vNepoOv9msp7Wa2816WjK636x2XLApkZfZnicSP7Di6a9Uo5h94TT78q3LF/7As5H3n41+4tn0Tzyb88JLzEc9pk6eLqZdp5dJjlzUujxfYqVy+s2LsVAtX9Zp6y9E6NK//8P5p0j9wFJte3+ttr29Qnn7Tg6rtccmLS3Wz+kwRvVp3vcGVeW4EnVrVHWWuLc+eG4OlhianYbspR5X8mP9ehyW/TyTHUV6FDboLBB7JtLe7+untaibff0kcbOv376TQ18/N6nEc+n24nPpxdAeehiZtdPqLcc84WPaNM3e/lH4cu6rFuU3j4XLQ0o9rUXd7SGtvt1DThI3e8jtO3k1G1q8RTwWpeXQpPqBJu3vN2l/v0n1r25SxnDq6q/98Dc/ynGJtMNz4XoaCd0r8+IPJFR+P6Hy+wmVP5BQzy369thSY9DfVO352FJOK4wUs1PS6iEln5Z/rKTigOt5Rj63h6I9+otterd+7rSw32L55/Fq1p5r8Ps9XeTtnn6SuNnTb9/JoacfWxSLHo8Wldc0OF6BiOvTErhyWoZii0UPNrEXNWKS66hx7mE3SzTff4nS91+iTktRd+s89VRteqvQs5zmL+VqBZP0qa7oW4se3oDuVWmeLoMtFgjlypO5f17GcSXqdqVVOS1H3S21KqcVqXt1Aececq98thwnHt9/MhoT/qzaDh3ktoi9KNJjtu+BL4vEZxxjBeFFEf/GcmUyai/21scQOKbZHlwPvfXY6e+Xah9lNAYzD5bysoxh7rCncffvQlCjduuxMEOHELwtYq+KxP08kF8TecwLpWd09ZPMsXFNUQN2pQHWL59RT/O7PQ1cfysTa0VD5tB/7/+iP307otOqlWJ+RZ//kp5H0Pc+EzgtWd19WTyLoHz68UrRDyJ6aymQtB3upr89DqfTitW9kdZR4t5I6/6d6OFOji0q+Dnv7SWN6mOotRRh+qrG9bZGxaCgplfO32nE0PMh91zjtFh1853iB41b7xTne2ltd9PapL+v8WIfq2SxytT682d7+l6qpMHAY4rjEDCnC9FYeKsqz9PHaZnp7sM9a3zg4WrBvRwCl441AFH+U0Y1xYuNarHg1Q+97LTSdG+FmOpxBcBQwH09H7oer6PFnFXLRfHfmuP4OxcLXq3mNZE/f+dOZeA355voA0tV9P5SFb2/VEUfWKo6t+i9+aazxr35JjotVN0N/XPvuDVXRO3tj6OPEnef7O07eZ47Th8q3Rojn0O2NYT9lw9q/gjZ09LOvSV7Oi0w3Vuy/+FWUObWTqPs43Xc/C74eCG+te/s5+V6XlniOx682ab8dgH1WeIDzcGF4jXsseh6aA75K3s6t/hx4kf6OVzG6au+Ej/WlL7pu/6I+9OHUjc/YT1eRczq5J/qb1chxw/64jehUa5tuy/h8wOYK+DrNRFjTDhYXvf7lUi/MIeSJt5/06gxcdfs8GhP60sfkBhzbZhV6uXprZxF7j4Z+cSTkQ88mWPkSho3fPks8BdzMFLibuTrvgC/Eom3ucc1tRdFWrx5yJfa1F+J1Jg1FNbntWV0Woy4+RtzWq26+RtzlPjAb4xwXIdIOTRHP79G3arYp9MMqkhUY+klh1+709zy3Yp9Oq1W3Sxfpt7efjntx0dzr3yZ+jmP3CxfPsuMjwyxPCN6kDl3lIvRUdLswS+ymtYSQ5raDl3Wrvcnhe397abI3n+lsvdfqW7fyeFl+dyi9yaFTxp3J4V/0Lje1rg5oXv6murLSzvTi9dxb3L6fB335h5v38tJ43QvLZaJa6OnExD1an/1ddyb4L6t8WK83JzgrsfFnLsT3McLuTfBXY/ft9zrZD9ofODh3pvg9l+Qtye4zxdya4K7lre/+qunr6juTnAfr+PmBPdPI8T0gSq3Jz/89bST391h5lHk5vv7cXyoUSX2wOednd6v+K/0dsX/UeLe2OH+nRxy4XnEHb9zxex5CqIPLH4eh9x46X7gYTe/k4ii8kHz68OvRAQ1YqK9vijS40VGutaX3yByHWGaAPztG0Ts8jHeJvggc2yXWE4RbfRq4+Klt1+HjexOb3h3s+JpJeOy2LSkXP2l0KGCr37L4Revvr2SWtsHVlKP13G3SY+PNqYSH0+ZXuzy5aqptKy9/NJcOI0k9OXIKXSlAckhco6F3hTrAFgGqL+akbTUKBe/NK35+IcGEXo2rVmbvT83ehT5yDz+3RYpH2gRrh9okZPIvRY514fiMzP78vv5qyJTi5XVh8ih3NWOfeR2kelJRvyUif0L+mwm/yyBKS8x0tck4vNwMX4qcS7STqOj+mq5uGFzCGuH7xKO3//6Kb8zE+Wb+XOKtn7g26r6gW+r6vvfVtX3v62qH/i2qn7g26r6gW+r6ge+raof+LaqfuDbqvr+t1X1/W+r6gdqyutpqeleTfk57GNaVs0OYX/6tOrum/dxKuJm2J/Wqm4+2JPEzQd7+04OYX9s0Ztv3qcx991w0/e3c6pd336NOW30d/e1+3gd915jjs1x883wrHHzzfC0tnSzSa1+4M3wdB33mvSHLUNiP8pe+vNzcs7bON37tFzeH7nY+1+jVHv7a5SjxM0UZu9/jXJs0Lsfhb89bmnX+yX+7QPLW6dPQO5+ZHScqLv5Jeb5ZJS7X1D+oHLzA8rjllQ3v5+8r2Evatz7epI+8l57bte7304er+V+TzmfCHLzy8mzykfu6H6vtU/02uMZJzd77X0Ne1HjXq9t5SO99txT7n6qe/tcs6dDq0ZvF1WfysM0avceY7i8V+efV9GPFQSoUinPllTPEvjw6MsW8H9InL6hujmRemoMicHu432HnzdGfbvsv9W3y/7PEjdLMuXdR3JaCZXY1l++1NrrfYUY2Un6dPubwrHw4Ip0zKlYn37REqURBodUn2q048KUEbbGNkoP9v5BL/e6+A+HmsWw/8GHQ3zaaYO+mxF/lLgX8Y3fbo7TlJTibADVp3Uc/G4fPyrc6uPHTwxv9vHzZ4o3+/jpgKjbffx4jOwVr1H5iJdvh8ydNBiHcDAfNI7b6TZJJ5vY4VA15rcj5ShxL1JY/9LE8aU5vpzW/Ksz5uJ8OJKaz3bjFzX0fY1UvfGrs+4uidHCJc/Ph2tyataOk7t6Pxx2d5pY77Ea1tMCwe8kYr20s74oEV8J9FQR96qEHNri/GFdTBTWY3seP5XGr4IUfvHJWhyW95hTLq/dDY4g/HJ44G80qsRrRpV+6KZ3j4bUQ7gcF6HuvKu08491BG2/Dsnj9MWUcgScct7h4I8kpuetWpCQ8xKS/qFxOqHE0h5w+RPjPzWO8x4XzjAsVzqz8zcpuccPP/Uvv5W/SKc9XjceKE81zj8w6CAPPv3eHs+cig83HpMvSUO/vsIdj8qU6GftSzH7b47bVGyk8chqr2m0+L6o5Rn6Xx3ZWSX2j6364nGbGh8IPLC/poEDeb4sWPxKI32Vb1924//NsZ9X/PKPYbO8qoIypwf3F1UoLTpUOQypTidQ3TvP6yhx7yXmLHHrLeaHs1RT7Zhdz4qc2mkdx0qsO1h5PlY+SlB83m9E/ZWxMndL3wfIi51MLrxMSbmeq/DpAKp7LyBniVsvIHy1v/QF5GtzlNcblaFyOPb3rFJiyP3gU36/+vuP5u15Uy7XX/tovjQH68uPpiWVww+NvZvKjgr35mOOd6KErqp2OrFb3p2cOko8smHsVvzgp/tI/CCi6WxVfbqPxE8iyO4PfimvSlf0EKvPJy+Phc6fOaWaopqE6pVfmctrGoVe0+AoUiaW8pLG4/rj6Jjry0vzHxr89oKDnHdqjbfd8uUo4V8cdV3ibfeR19pTDT5u6HcvLx8l7uXl+vYGP8fGoAj+x+IbPW+M45qDxQkUzUgOIsdXiMjKaRv5P5Ph+TIEl/HlReZX94I3ma+Hzv5OREKEX27V+JaNrxePZL99rHt/9+fyqHDr5/J4tPzN5Yvz8fT3li+4tfeXL46nPHMsX/R8IX9uCsJN3k5AR4l7Ceg4+3grAZ0bQ9K08vMzyR5rNO82xvGEZYof/Frp+QnL/P52fvz+dn78ge38jidW35Q4vqrj/Za+bAjY/riV0ywqJkBTvbf+4rDpm+F6PrA67dbGPW089e3A6vOx12lDgHw+429VkAjzCshvDs8en4nG8/1SOFZ/cSUWn44/mF69H3xqUfjLF3S/UZELbStXGhf+qcLHDz4/I/Ollr0+P5z8LEI1xv3E14siVeLtMG8N9O05Hy8Epx218vzYeNb392z6QSN+KB6jgfL85/socnMc8cOV3BxIKL+fmc6HV9/7xoj1/cMnWd8+fPIoca9A//6dHAr0z8eB3/rGiE8fBd8tjT+eB35zd4+jyN3dPc5XcvMzo7PIzd09fjre/ObuHmeZ2/sD/iRzc5OQH5r33iYhP4jc2yTkeIr9ze+WTtFz81Ows8a9T8HY3t6Nio/j15ufgh2v426THh/tvU1CfuirdzcJ+UHm7iYhP8nc3CTkh0HfhRWFL+ntz8mN6+0y1bPErfdoufgvlbj3Kv7DYBx7hEjemePPFu3vv372YwFO5PnHUsLzXdyP8woFhWKV2ovzCvceS6G3Z0hOIyOJX4gu/HwP2f72kld/e8mr9/fH3keNm0NvKR+YFCjX+5/3C73/eb/Q25/3HyXuDb3v38lh6H29/3m/0Puf95dSPjH0Lp8YepdPDL3LJ4be9JmhN31m6E2fGXqXTwy9yyeG3tfb48Tr/V0Yzhr3ht5S+7tDb6n2/tD7eB13h97lE0Nv+szQmz4z9KZPDL2PYwGO0cSXo2l+M5qwUGhPFfT9YaYel9Bid6/H8k9eh+P7GhrbnVX78j3ofY12hUa72J5qyKmK9957zPkyIpM9gud0GfXtgcAPGvdmes8id1eMz1dyc7h5WsS6O9zU47g31SMVfd7NTp8TCI6RkC8Fp7/Q4Ah9Em3P+8iplujeMqkIvbtMepa4l0DK6WjQX4xnruOqxM2jRo7Vsz3eM8uXLyP+iDx5//hpkfc3/BF5e8Ofo8TNl5rbd3LIZfL+8dNHjZsnjfykcb2tce+kETn9yNw8aeSH67h10sgP13FrC6T793LQON7LvZNGpJe/+jpunTRyX+PFeLl50oic9vi7e9LI+ULunTQi/f1z0n/Q+MDDvXfSiNh5e6tbJ438cCG3ThqR97f5k09s8ycf2Obvh9/9WyeNyA8LVbdOGjmK3NxP+/T5zt0J0WNh0r2xg17Xu2OHo8TNscPtOzlNiLa3J0T1E9v0XfKBCdGTyO0J0eOV3J0QPYrcnRA9jvzvT4j+8AJxdybz3C43ZzLPIjdnMq/3V7xPXfb2TGZ7eyZTT/UQ935otOj7PzT6gbqM86O9OZN57qu3ZzLPMrdnMn+QuTmTefwy4dZM5vnbhjszmefPs+LN/YF5941ffOIl+ExMrL6m0WPLCspTmb/7TCy+8nzg83vh465yN781O4rcOw3jLHHrNIwfJO6chnF8Kho/4I8pmeu1J/tFo72oQdCozx+Kb0r65iR1ffujFa39L5W4+eHdsT3l7365+7tnEgNEyruh/E4jXcerGj3ecx/4qgY21T9p8NvrUvz2utQPe0PE77URvbi9RBT/P9CeSrR3m+KH7TrutMV5V5hoCn6EU5qT/s3OMoKdZeRFjU5xHf20W89RI/ZQefxIv7g7DeKE+6s77SBOHnKv7pIT80EPfLU98HWqlcNzOX2+zPhgl8Xe19DXdkBqEmuFLW+A8H1XqdMLLkLu0WWffySmpx3hGl4Y2pcXBv7dlcSpVdKfX8kPIqjB1EqH2zmJtHhj0JY/QPomcpo0jLvJRyaM1Hr7+XasjZ222tHjmtTd56vX+8/3pyu59Xx/ELn5fE9FGLef72nTv/efL18XvpQ/7Nejx9UcilkupjSf803j/DEH3rPz9hS/2I3tigVDvtQO92Lv38vpxKZP3AtqsB/4Wn5nP4d9alSqr2kQruNroc+rGvqiRqe/+1h+pRGbUz7w5TYVtCm9qEHQaM9/M8/7OMd3yJSfy597MKu9/e3/WeLeC6HRXypxc5OtU3tWbPRT9Tq056mE+s4+LMeraHgrbdYPV6HvZzDrb2ew8y7hhAM4iJ/ey1mDcWKTPG+PxsfjKu9tV34UuTcndpa4NSf2g8SdObHjdvi3Xm7PG+rfebc9Hjtx6xrOB1fcmms4HXdz8wjjs8a9E4zbqfjs/pk5R5mb/ZPe75/0dv88H1l19/CfH1Q+cNjU3T5y1rjZR8pn+kh5v4+U9/tIebuPnEbX8VQkH6nEelsgaq162hawcL0r0KP0pDO/JBCvspY3nv1DoJ9SYI0eUdPUTe3lJYlcEPCHxOE2LF5hrbVX2oEw6MoFwPevgLCHp710CxzTxazySmci7N75eKdILzfS70qkVWrLq9R2+yYoJmkemIq67bot0aKynFvau+83EhJrj48ZyfaaBOu7EooJDaXX2sLYYn425/1XJfhFCezHnjrWLyQEhUNy0UtXIS3eM6XxaxI4yUW+bJn1CwmK/QqEyksPVbB1ueSylt9I1NjcWlqaT3n1Rl6ViIQjlN5UfyURmxVIzeVKv5GIigfJG/T+qjkj+z9Q3n4i1/Pe2U8HQJXaUAX6uKbX+kaLjSlf7RvWcQKnlZcebGEc7zW+uiovijRsLEf8okhlfERWVV4UMdxOK/yaSPoAjL98aPQrkdQmTQ9d7XQCUykVXa3UQ1frp52HS8Mh5w/u+hEZq6/KUI2C3UZsL7cNtnUvNR+F+03mVD1cK27qMZ/YX5X5QFJ49BRKXa++2PX4QtdjejExyIVKd6EXr0QqriQf7PYrEe1IDLls5lciPcbtY0fQ+qoIbqfz8xTVT9913pxu7adFp5vTreebQb0s2/Vqi2SRV3+DuqV9ScuLXc3S58P5gLc3RPqrIvgNMuYPtMmrIhb1PGPzV/uASJdXRdLHN0YfaJMXReS60r6zRT4gQvXt23mIvPiDgaPeyiibevF2sAmAXNo+IPLaW/AQSUX8/bUAfKyloWFLoU+I2Iu3gy+TpJC83yYvi5Q4rG0c5nN9QkRfFUmHE0n9QJu8KlI0nT31aux8EbH2gdsxflGkptjhF3+8BMcKP/jFnwxJr3IiL84jxexL3mFB/9hNuxyPZ49KwzRd/afEcbYAn9Fdh2s47hqtOItLNX90Vu/POUfvyDsKFqHbT+TuyaTHJYjdmv3LA7k/9x/biPDTM1qN/uq7iMMEez4858+roOME534YubzpNwpRsyH5qMpfKVzRMesLz4I5jnbjx4gbffIX8+4xaZ5X1H8hEFMADy36vQAVbJ+Sf8/+rGU8S8RnNiWXBfxGAt+C0WVPJawey8yiKer1okTs5PDlgOxf3Eg+AyGfwP4LCfTKr9/F/UJCY/2BtL72UCkWDyjPdv9GokaJ+qNVymtXge/76vVSc7aGYvtc2lXsftbHdEU+wO0XF1EKBvWlv9SzSjVMr9lrV8GU51JfkxC82Xd77UZi+5jHzONrN1Ib5gj5tRsRwXuJvnYVGmWHJZ+G+RsJQ1sYvSSh8VuuTV4RSIUy/Fo7XKlySJ53bjttW/d+mFqs8OXz/H7TEBGjpvxmS74m8JhxjgJlzm+o9wVQCsD9pQFJFI8+8KUBSbxwcN75u96PKnxqr5p3p/w6TLfTRnmPXyxsYZbiSn4RmJFtrcnTqzjeSFTOl1xH8P1G+DTOvrPvoJ0+aLq37+BZ4t6+g8cBXlwFEV2HxjitDYkiXYqWpyej/SCSZl9Unm1caHrc/+DC8bTcnt+Onja2xZ49xfT5yV12/Jzp5ide59vpkbnq9eWDlT9v51SE3wWlN+k7MdP7Gl9W8+uLGjgb+jHxQs813t4h46fLuHAZ9ell9HMKQRrSXDr656yHnTbbK92wmWtJk3xy/eJ+FM2q+vzRnM7ZqFe8EdQrzeG08ufdnA56xF4sVlJVwXeR43572Ej5wV9Oq/vVtaQP59Nq6Pdr0Q+E8LFpcXZlpXq6kuMu5r2lfdn0IHP6NukjOamWyI6VrsMvxun7JGJBoevhs1OzvzrFjocSt/PlW/w/b+d4zlSMtOnLHPm325FP3A6f3jpiE2HltNT8Zzaw454msWVOygXf2uP0zSh+yjm/gZX25yaAp63zHqkovoO70lTHnyrnBimGD5zTyOSPBhnjp1O+jw9HS86x40PUP1QO/RW7iHP+yPG7Rns/U5frtLPa3VQ9vrP4RK7+4Z5upsjxpccncuRD5wPf5p+fdY9x6JfNOb4961LeT5IPFfrL7wc1Slc+ufX7DbX30+RDhT9yQ3TsvIYR3PGO9BiOsU3xZUeV/pEH/ZGOe7yjYvg9THOR3+/odAzU/SdN9Ff/Ikq8/mj+/uHbD8DpO75qMaXYrjTo+Z5a6FxfGhmqpRdcq3+KHA9ijs02vhyiPAYvf6gcP+/GBH7LxXHt27WcXsdu7+Z6vpaYmqK81/f3a6nnwe2tnUzKdVxoujVR98MTath+TFLbfn9CtX4inI/XIlgDlDTZ9Xeu5TSFgEPeOddPFflFDD066+5yjdIOHt9jqH7gpey08qQxmdG02itziE2iNLtpez6H+FjRv96dRHxolHdnEX/QuDeN+NP0Xatp+u7Z17TFDyh6dxLwrHLz+FL9QJMc5xENxwYZvT6PeCut/SByb4OmcvFxReveDk0PldML960tmo4/6Y85a3wG03P91C8nidJbUPog57eTRPeez1nk9vORjzyft7dI+2G66usZRPbydNW9pj2L3G3a046i95v2tPp1r2l/8ep+6LQ/qdybHy2XfORN7AeVmwO3s8rt59w/8pztA8+5fyKGfpzOuNm6l32idT+xxd9DpX2gdetxNTyWxPrhHfd4xmGNqp1W81na3yY5j5M8ghVLORw8/+Mkz82nfFa5+5T7R4YJvfy1T9niJIv8hdH3p3xav+GCuomSyx6+P+XTDrdYZuc8xfl3VD6SKctHMuVxyHL/Kff3n/JpxopQq0W5Uur7cz6NE9oVh9o9EqycnlD/SDR/JGeXj+Ts087d95/zaYHsE8+54hyWmhct/s5zPqi0LjGTZ/kslm/Pmcon4pk+krXpE1n7eH7Y7edcrg+McI+zpOmz97zz5J+zpMdDe1ocINby+qO0X2hw9JR86tYvNRQ7vcuLGnLF9xR5F82XNfhVjWgPebk9JNpDXm4PjXvRl9sja7zaHhrtoS+3h0Z76Mvt0eNe+svtkTVebY8elcJdX76O+Nqw91evw+LLVnu5PbLGy9fRsX3NoX8cV1juH3V3XKfhhtK767BOX04T+IpPQZXyfOZ3ldOpbvG5fc7MtdJv7uf2GXVnlbsnAB5Vbh8BeF53ulNh/oPGrRrxnzTufLf200rc3QFJ/cRkgX/l9uaApNRjdde9j+DGJj2Hlr31FdwPGrc+g/vhbm5+CfeDys0v2X5YneSCcu20BPbrldK7K7+fWCMp7SO9tn1giuu88stYhU7b8HxrW5/geP7SFYXOteRqQPlT5HS+Yj7ON3/W/K1NjqXfN75L/kHizofJP0nc+DL5p8V0nCB1fRn0/XEdfNrgn6Nmrkn7iIgdlvVvVhg8hiiHfnbcc7ChoL7l472+3c/phMQrbWmZz6L6JnI8DJQ4bbt22Udk8r7K8quXYXxdei4ZOr0MX/Gj3i4+FI2W0xoYxjk9b43yZ5FOOa2Apdfh/Fn+n4O/cjzX6t4A8nwdOBgnV6d91+BPpPrTJ1x3ByinU63uD1Ckvz9AOWrcHKAc7+bmt+U/qNwfoBwjp2NW+DqswZXTuleNt6+W7ufbfNZx0SteVVr+Sk++jcs/UKrwk8rdcZJ+Yvmg6NvLB/c/sWvPP7F7TD6fPgjr2Byzp60I2m++ibm5dvDTNzE3ayY+MhTun1g5KP3tlYPj1zl3J+t/+jrnZsPKRxrWPtGwx4Oq3o+dWlH9/mUF/NvnqacDFS9M1V9ChwA8ddnPqNw7EOQHjVsngvykcedIkB/e0G/u8vLTbMHNH+MfZpXubD7wk8adLZl+mvFTbCvbX583jHzyeB2Ug8rx67YSW4ZW6odv5Oi4fhBJKX3FdX+TqcvwmUa6kz9+th6XIKdp/70s2/NuCtz+1DiO1jS6meZtMaX8QqVcOEh4rEcfPkigU7WTtTg+xPh6frhQoXLc7OnNvS4IO0lSSTfz7emcanoo5jzqdZD4oVlvHh71g85jkgi7LTV9WefC1zhjUbu9rCPpFCkReVlHY++/UTJWXtexdNTX1V/tvhpvcqZCh+57X8VeVsEZDmr8osr9875+7Mk3D1P74a5uHoT2k8q9o9AKUf1M29D7Y5+zxr2xzw8abx6H1gwFe2nYc+kLAvSSAPeYBUm/Hr8QwEJe3hD1NwKxR0OeHP6NwK0jKY9XcGenltNTuPURz3nv8LyJeQr1+3teSUwiPaZa7CWJHie2PvC1qzCNGfbrKq9I0IWzZ/Msx2+uAuUu5evY+RcS6bOd8tKNPN6MQ6LYa1dRcaZDu9pLEi3tIp1P4flDotBpLekDO2CmM4WqvtYa2NmpNCpvN+iLEhTHwxVKg43HEPi+RGTdkjdyeVlCXpKoMegv9eqvSeBAiqr1JQnGgJ3ba21RsbV/PknsZYnXHmo6L6il07t+JYENRZvIixK4kS9nof9CIkaMJe/W/isJw/4m10tX0WJ9tPWXWgL9iun5TTxC+DQIJ+zTQnmq7vamhdxwNKe+dBvxgyrtpYZkHEWZRze/EOhYgKyvCVx/ZwXzJYEvexT8phFjhPdaopMSk3HV3ryC1x7j/DQrJgBSPUf7xVD9wlg9LS5cf770nM67Sicdpt0Vf3EZc8l8jYvSXOCfl3Hc0ztOcqAvO6F9u5N+mm+qimnn9MKv30ROC6YUR0zVPG31XeS0lwCn2glu5bBQQsctCW+O4H9QuTl8nmOQd8euP6jcHr6elqFuDl9/cUOHseNPjzodTvj4deiHR31cgs21kV/2M/vzak6rN/cf0m2VY8scVW4/6tO65e1HfWxcjGup9uul19gieD7HZGvH2URCo1w1FUSJ/UqmVUy8tTxl9qsXOLwviDxP3PPF4rlOFMQ/JNMP2VX/VDml3Y59fh4s19OGqcc1KcMyjJqlSvRfNEy7MNp9vATUV37RqnUU3qTlLS5/3s1xzviKYcYoFkqPqH97RP34wxjdPx+fOnbd/oVKylBN7aBSjuMeDMHzuOfvqHzik8Fa3v9ksJ5Owrq9Sl3L8cDde4eB/HAtdwvPajntrXnzDIuHip4WMu8cIXHWuHuKxEPlA4OFc6PcPJXjhxDi+NbtkVf6ofOfvro1HHt2pZm33v/U+ESdVaVP1FlVev8L7XosBb8dhqSfCMPjtdwOQ7JPhGG93g/Den0iDCt9IAyPjXI7DE8B9Bhc4ayg9Mb6PYKORzUYtlhLe+R8Ezl9VaUxTdnzYarfBmD1WLQchzGO9+iXVWI0SHmk8etrSSr9ZRV8P0R5c6fXr0Vfb13FKSVpYv6Na7Fj6x7PXImpmi4vanRMST/ePw4i7RPbvdWm7+f91j+R95sdl05unT/2eMH5QK7lj+Ra/kSuPTbK7R/D4wO6eXTh44b4Iw9IPvCA7mnosU30+HIYHf/ldr09yJAPnFf3UCnvt+tJ437Hl/qBji8fOIHvp/GB4iinVEL5bXwgx0Qbe3RI+jX93ibvL3qdLwQfmfTWThdy/OnBBhvXixqGBeov9SjfRE51/48Z+fje7DhjW0977N7/ETx+oHXzR/D0hdb9H8Hj1ra38/3xWm7nJdVP5KXTN1p389JJ435e6tcH8tKxUT6Ul1BYdsxLdDxEKRamKO8M9U3kuHSCQ+CL5K1U9JvK6VtY1thPKa9Hf0tv/fQpLM4kqNWenqH+EDmeyBETM4+57vqiCDbZfSQSe1UkRhiVyuFKTl9pPX4r8IxPt2Onn3WLSeNirb8mQldsiURfziL8JnLaTTMyypetzPqvrgOnRVxyeDbHTwI/cB0Fy1mltxcbNS1ovSESvfUNkfzzRc/7SLuOy1n4xaj5OJxfibRCf2/h8w0RflUEZwS11l4WQYEl2wdu53URLGS13t8X4etVES4QST8630Xs3Rj+4ToEdZKHyGmnZbC7ueSY5TlyiRxyWjstPN3N8keRu1m+lbez6w/XcS/Lt9PS1Seu42aW/0mkfEDkXpZvtxdKT1n+OHi9m+WPInez/H0RflXkZpb/QeRelr99O6+L3Mzyd0WOWf4ocjfL17ez6w/XcTPL1/rXZnmNeiHKM0nfr4M/EHyVPxB890X4VZGbwfeDyL3gu307r4vcDL67IsfgO4rcDb7W3g6+83XcDL7TUtfN4Du+jZPikNl+eLzndZR7b+PtuKRzd5x2Erk9TuP3c+v5Om6O07j+tddxd5z2g0j5gMjNcdpR5O44jfsHfiqOInd/Ku6L8KsiN38qfhC591Nx+3ZeF7n5U3FX5PhTcRS5+1Mh779rna/j5k+FvD8rcM7yN9/G9QNzrkeR21le38+u+oE516b8117H3SyvH5hz/UHkZpbXT8y59k/MufZPzLn2T8y59k/MufZPzLn2T8y59k/MufZPzLn2T8y59veza//EnKuVvzbL330bP3+kdTP4zt9o3Qy++yL8qsjN4PtB5F7w3b6d10VuBt9dkWPwHUVuBh9f9HanP1/HveDj6+1ZgXPpgkRNFWl5Xv/Ap40Hb5cu8On7rrulC3z6puRu6QKfFrTuli6cRW6WLvwgcq90gY87D96cLOFPLGrxJxa1+P1FLf7Eoha/v6jFn1jU4k8savEnFrX4E4ta/IlFLf7EohZ/YlGLP7GoxZ9Y1OJPLGrxJxa1+BOLWvyJRS1+f1GLP7Goxe8vav2Q5e9NlvBxkeBulj9uVX03y9f3s+v5Om5m+Wp/7XXczfI/iJQPiNzM8rd3Ij9l+dOC1u0sfxS5m+Xvi/CrIjez/A8i97L87dt5XeRmlr8rcszyR5G7Wf79Za0fruNmlmf+a7P8zckSPh6JdTf4jiJ3g+++CL8qcjP4fhC5F3y3b+d1kZvBd1fkGHxHkbvBJ2+XDPxwHTeD73gi1r3rOL6N3yxdYP3AhwT8iUUt/sSiFr+/qMWfWNTi9xe1+BOLWvyJRS3+xKIWf2JRiz+xqMWfWNTiTyxq8ScWtfgTi1r8iUUt/sSiFn9iUYs/sajF7y9q8ScWtfj9Ra0fsvzNt3H7xJyrfWLO9f3PtH64jptZ3vSvvY67Wd4+Medqn5hztQ/Mucr1gTnXs8jNLP8LEX5V5F6W/0nkVpa/fzuvi9zL8rdFTln+LHIzy8v7n2n9cB33sryU+tdm+Ztv41I+8CHBWeRu8JUPfEjwg8jN4Csf+JDg/u28LnIz+MoHPiQ4i9wNPnq7ZOCH67gZfPT+hwR0dyqsH7acO4r0OJGdeorgX4qUDpFXr8Sij9SrHjayPG+pGafyEKfyh1/ubSuxywdJq6+qGPY+scMOuaeNQq7YVbCVNFfy577Bcv5Qy9LBOul0zj9PpJXTTnFMOOch73z3LXROi1qihGNP84C+/+ZKJKpTWNKmda+L5NO2fyeiOH3DXhXBGSAPfPV2+hUi+STY7yLHkwHivLnSU7HN3+kox1MKcL5At+ug0k4qV0k7E6YDz75l2dPnWunwOE0bO9n1p8ZxF9gem6tTOgbw76icPinoXHHkGKeDd36ro1fsedU1Hz/8Tee0s6Di/Ent9SMq+ZTbX6l0vEz2cdLIi9eCPdb7dZ2eEx/XZf1ne41GvxTz/fKe+Lp3T+en3THW6JZPDvl+NYc+3DmOeO75IMe/o3LaQEviCF/Tq72q4sXQUyWPSn+pkg6q+aFd7qq8fkc9nrV1eTlDpIZ5sLzcZ0xxBIlpPkz4lzqGOZ4rz5z9Tufxb7GX8HXZqX2OGxeKD+znfYnk42W/65yeFsVJbkZVX1W5HQu3VUr5iMrLd3Q7FuQjsSAfie5zj1GcSvloo9MIQE/l3eXCK325hF7WKTi+7zGseEOH+TM6pUGnvtzOjyFJjEm0XJ/SsZd1Hu850JEP6RxHkGcdQuZSOmbkX+j01++r4pdGq14vZ/Zy4TzgchxF9tMvjQri6/GDxS/rKA5vVT1mn1/oqLyhg3bW4/M6nVd1+9X7tE5y+9X7fEc99ZzOx3eq49sdNu4teaz+7e3udBiYxl78PZ0L++2jm6NG71vjy+/MLzViQFFevQ7V2A355etQsbc1esxovH4v+WACelkjhjRdX9WIX8nXNQpWjx/YX70SnDByEjkeQt8wE5hmif6cCdTTjGTrOD+49ZwF/jxWTY/7HcYcq6Q+8ljG+UOjHN+P42U9HV7x57Gaejz16+6hRVo+sW+3lvf37dbyiX27tXxi3+7ztdzdt1vLJ/bt1vL+vt1Hjdv7dit9YN/uc6Pc3bf7GIPSYnopFz18i8HTqV+lxA9ooev5Cbl6XFC7OTjR05lfdwcn5yu5uS5wX+SwLvCDyL11gbPIzXWBs8jNdYFzP/lyZER73k/qBwaxWj8wiD1fyd1+clvk1E/OIjf7yVHkbj85inykn9QLB6nVw696uz7QT1r5QD85XsndfnJb5NRPziI3+8lR5G4/OYp8pp8o+km6ne/9pH+in9gn+kn/RD/pn+gn/RP9pH+in/S/up80lP+2dAj6t37CH6hbUP5A3cL5Su72E/5A3cIPIjf7CX+gbuEs8pl+EqsFX46W/9ZP5BPjWPnEOFY+MY6VT4xj5RPjWPnEOFb+8nEsc7zvcJrN/9ZP9BPjWP3EOFY/MY7VT4xj9RPjWP3EOFb/8nFst5idtnIYxx5FjPHtyqmz9eMxiDeroLQfGuVmFZT241xBfLVZjvUsejrjq1GcN9vqxa+q+GZcU+XR808qp5nuu1VHR5XbVUd6XFe5X3X0wz3drDo639Pd2rD7KqfasPOz7phZ7b293Htv1vCpnWrD7tfw/aBzu4ZP7SM92D7Sg+1DPdg+0oPtIz3YPtKDz0/7dg1fvw59+HYNXz9tmXi7bumscreG76xyt8rnvsrrd3S3bun8rO/X8P2gc7uG7wed2zV8R51f1PD14yaK92v4+ml56nYN31nldizcVjnV8P1C5eU7uh0L5ROxcP9ajtF97jG3a/j6cZe6+zV8P+jcruH7SeduDd9POndr+M7tfL+G71c69rLO7Rq+3+ic3n9+0Lldw/cbnf76fd2u4fshs9+u4fND359fz+0avh90btfw/UbnVMP3o87NGr5eP7Bc0esHlit+uKPbNXw/zE3crOHr7VR+c6+G76hxs4bvB41bNXw/3MutGr6zxr0avvO93KvhO2rcrOH7QeNWDd9Z414N31Hjdg3f+Uru1fCdy3YeP9aRlcZ3wBHB9TfFP4Wi+qfkSrFvKv20G6PGzvd564ZK3zTkbmkIPc9Ipwvp8a7T034Jf+dCThoSsZeL+H6lYUho11UOInJaIW+xSwG3lKO/p0U51TberUrscuiyN6sS/YPdpwOEu1WJ/bR+c7sq8Xwtd6sS+2lDxttVif30EcXNqsSjxu2qxH46aOxuVeK5UT5SlVhqbARRanov/2V6q3jF+rINy7f0puctqmJgS/y8yqRrO/4c36sx7sqfiObT51p3o1n1E9Gs/RPRfLyW29F83PDudjSfBrN3o/k8IL4bzaelitvRfGyU+9F8/FygR7M8OM1myreLkdMrplRMQkp6df4ucywmjzeoxwtOGjpJ/9XFaGxP8eAUjN8vxo6LJkgMZvS0aY7V5DFz0xo/39yln7ZqlNgDSFKF1KMr/kKj4rWyPsbbJ5XTjMSFNbY8fyTfRA75tlLse1VrGoN9S9p23KCpYgH/MR47Jdzjtz/oKmOBHSq1/qly3GwcE5iPlj6pHO+pYUXgh4GlHc/zRSxS6jHfrsau4664hsq8PM/8O5UmMVrIdVt/R4U+kDCPzVKxKWbtz5vlbjirPg1nuw6PuWmU47Q8afVnENnpOLIa7/+tpp3wWH9zIf1C6m92uJB+TE6xqiFV07LRn8n2LNMslj4fnAqMvsuc9nAtEYicJ4K/3dLpo7PHsNYQzSlBlV+JxLZeY7fAZyKHziblwv5xabnoMfD4r//6Px//8x//xz//+3//l3/7H//4H//8b//6v8a/pDLe0cdvKNEgG1SDWhA7PbohSZAGdZ9zGH/PNtXL6XHDtQSR0+Nx1BrUnB6PsrLToyXr8Kjjo6uqQT3IPcbguV1BJYiC3GP8FLYW5B5jTrZJkAb1/SybbeIryD3GFwZMQTXIPcZcEbvH+DKTJUiD3GNMkLDt3wG5gtxjvKMIBU2PRzuLe4z8KBwkQRrUg2yTXkEliIJqUHhoeGh4aHhoeGh49PDo4dHDo4dHD48eHj08enj08OjhYeFh4WHhYeFh4WHhYeFh4WHhYeHxGKkAC5CAFdiADHSrsU3qYxoc6GYj/T0WwQLLBSxAAlZgAzJQgAqEW4EbwY3gRnAjuBHcCG4EN4IbwY3gVuFW4VbhVuFW4VbhVuFW4VbhVuHW4Nbg1uDW4Nbg1uDW4Nbg1uDW4MZwY7gx3BhuDDeGG8ON4cZwY7gJ3ARuAjeBm8BN4CZwE7gJ3ARuCjeFm8JN4aZwU7gp3BRuCjeFW4dbh1uHW4dbh1uHW4dbh1uHW4ebwc3gZnAzuBncDG4GN4Obwc3Cja4LWIAErMAGZKAAFdiBcEMuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkEkIuIeQSQi4h5BJCLiHkkopcUpFLKnJJRS6pyCUVuaSuXFIHTrc+sAMtcOUSx+k2xuYrlzi626joqjOXjFmcOnPJRAG625hZqTOXTHS38RJeZy6ZWIDDrc2Xhwocbm18BlE9lywUoP5t7XRePZcsNMdxOZ5L2phrrp5LFrrbWK6onksWutv41KF6LlkoQHcbH35UzyUL3W2USFbPJQsL0N3GDE71XLLQ3ca+vtVzyUJ3a/7CpMAOdLfxllA9lyx0t1G5Vz2XtLFcUD2XLGxAdxv7oFbPJQvdjV2sAy3Qc0ljf20rQHcbQ+HquWRhA7rbGBVXzyUL3W18zFM9l7SxDlM9l0z0XNLGikj1XLLQ3cZW4dVzycIGdDePAM8lC93N/D2zAy3Qc4l/SFg9lyx0N+/VnksWDjceb+DVc8lCAarjeFieSxYON/ZO67lkYQESsDqOS/dcstDdvFd7LmHvyp5LFnbgdBvvutcFdLfRlZvnkoUV6G7kr9wMdLfRlZvnkoUd6G6jVzfPJQvdbfTq5rnEv59onksWutuoZmieSxa6W/OXfQV2oLuNYGieSxa62+jKzXPJwgp0t1HP0DyXLHS3UeXVPJcsdLcxK9g8l0z0XLLQ3cZKZfNcstDdRq9unkv8o7bmuWShAN1t9OrmuWShu42u3DyXLCxAdxu9unkuWehuoys3zyULBehuo1c3zyUL3W306ua5hEeubp5LFrrb+PSjeS5ZONxkJOjmuWShANVxPCzPJQuHm4wE3TyXLCxAchyX47lkobuNXt08lyx0t1EI3jyXLOxAdxsTqs1zyUJ3G8WKzXOJ1NE6nkt8nap5Llnobt7BPZcsVGAHupvPRnkuWViA023cUK/A6eZTUgwUoAI70ALtAhYgASsQbgY3g5vBzeBm4cbXBSxAAlZgAzJQgArsQLgVuBW4FbgVuBW4FbgVuBW4eS7xPZTYc8lEzyUL3W3OABKwAhuQgQIFBcKNLP5uvYBwq3CrcKtwq3CrcKtwq3CruLeGe2twa3BrcGtwa3BrAlRgB+LeGG5cgASswAaEG8ON4cZwY7gJWlJwb4J7E9ybwG3mkoloSUFLClpS4KZwU7gp3BRuipZU3Jvi3hT3pnBTPLeOluxoyY6W7HDrcOtw63DrcOtoyY57M9yb4d4MbobnZmhJQ0saWtLgZnCzcJPrAhYgASuwARkYbnIpsAOjJaVcQLgVuBW4FbgVuBUBKrADcW/IJUIFSMAKbEC4EdwIbgQ35BJBLhHkEkEuEeQSqXCrDERLIpcIcolUuDW4IZcIcokglwhyiSCXCHKJIJdIg1vDc0MuEeQSQS4RhhvDDblEkEsEuUSQSwS5RJBLBLlEBG6C54ZcIsglglwiAjeBG3KJIJcIcokglwhyiSCXCHKJKNwUzw25RJBLBLlEOtw63JBLBLlEkEsEuUSQSwS5RJBLxOBmeG7IJYJcIsglYnAzuCGXCHKJIJcocokilyhyiSKX6BVuejFQgArsQLgVuCGXKHKJIpcocokilyhyiSKXKMYlinGJIpcocokilyjGJYpxiSKXKHKJIpcocokilyhyiSKXaIVbrUC0JHKJIpdohVuFG3KJIpcocokilyhyiSKXKHKJNrg1PDfkEkUuUeQSZbgx3JBLFLlEkUsUuUSRSxS5RJFLVOAmeG7IJYpcosglKnATuCGXKHKJIpcocokilyhyiSKXqMJN8dyQSxS5RJFLVOHW4YZcosglilyiyCWKXKLIJYpcoh1uHc8NuUSRSxS5RA1uBjfkEkUuUeQSRS5R5JKOXNKRS/oVbv2qwAZkoAAVCh0IN+SSjlzSkUs6cklHLunIJb3ArSiwA6MlO3JJxztOxztORy7pyCUduaQjl3Tkko5c0pFLeoVbLUC0JHJJRy7peMfpFW7IJR25pCOXdOSSjlzSkUs6cklvcGt4bsglHbmkI5d0vON0hhtySUcu6cglHbmkI5d05JKOXNIZboznhlzSkUs6cknHO04XuCGXdOSSjlzSkUs6cklHLunIJV3hpnhuyCUduaQjl3S843SFG3JJRy7pyCUduaQjl3Tkko5c0jvcOp4bcklHLunIJR3vON3ghlzSkUs6cklHLunIJR25pCOX2BVudhUgASuwARkKAlRgB8INucSQSwy5xJBLrMCtMFCACuxAuCGXGMYlhnGJIZcY3nGM4Ib5EkMuMeQSQy4xjEts5ZI6cLrZwApsQAYKUIEdaIErlzgWoLuNNRSbuWTMINvMJRPdbXxlZjOXTFT8hQ60+Aszl0ws8RdmLplYw5jhNnPJRLjNXDIRbjOXOArcZi6ZCDfBvc1c4sYCt5lLJsJt5pKJcJu5ZCLcZi6ZCDfFvc1c4sYKN0VLKtwULdnh1tGSHW4zl0yEW8e9zVzixh1uHS3Z4WZoSYOboSUNbjOXTISb4d5mLnFjg5tFS47vWLfE+EIxMaW/UxO39Hc4saS/o4n7voIHJ99yJU6+hRIn39ISJ98iiZNv6YkN10DJl0ri5Es1cfIlTpx8SRMnX0r3O1PNvIaZa0aN+YMpcU3cEnNiSayJ3Veml4Fn0llcElPimrgl5sSSWBMn35l91K9npp/FJbH7qrfDzEDq7TZT0GJOLIndd3wA9mD3HatXDzbwTESLS2JKXBO3xJxYErtvd9+ZkPr87waeKWlxSUyJa+KWmBNLYk2cfGduGits5ZrJaXFJTIlr4paYE0tiTdwTJ9//v6272bEkORIr/C5c1+K6+Y+561UIYjBDUQIBYjigZgQIAt9dmeGWFd9Cm8bprKg4192LhxGXxu6D9+A9eA/eg/fgPXgP3oP3vN47XPvDDQ64wwOe8IIT3jDehrfhbXgb3oa34W14G96Gt+ENvIE38AbewBt4A+/Tq/z+3+bbHbz94fPw93+W7+jtDzc44A4PeMILTnjDeAfegXfgHXgH3oF34B14B96Bd+KdeCfeiXfinXgn3ol34p14F96Fd+Fd17sfHvCEr/c8nPCGz8v5gdt7nwwYbw6unzDexJt4E+/Gu/FuvBvvZr2b9W68G+/Gu/EevKfBAXeY9R68Z8EJb/j85jvAe+9zJ3h/OOAOD3jCC054w3jbB25wwB3G2/A2vA1vw9vefb5DvT/MeoP1Bt4Y8IQXnDDewNvxdrwdb2efO+vtrLez3o63b5h9HuzzYJ8H3oF34B14B97BPg/WO1jvZL0T7+R8J/s82efJPk+8E+/EO/EuvIt9Xqx3sd7FeulVLM53sc+LfV7sM72KxJt4Ey+9CnoV9CroVdCrSLyb86VXQa+CXsXGu/HSq6BXQa+CXgW9CnoV9CoO3sP50qugV0Gv4uA9r7fTq06vOr3q9KrTq06vOr3qn9fbPxt+97nTq06vesPb8NKrTq86ver0qtOrTq86veqBNwLu8IAnjDfw0qtOrzq96vSq06tOrzq96h1vXzD7TK86veoD78BLrzq96vSq06tOrzq96vSqD7yT86VXnV51etUn3omXXnV61elVp1edXnV61elV5/mq83zV6VWnV51edZ6vOs9XnV51etXpVadXnV51etXpVU+8yfnSq06vOr3qG+/GS686ver0qtOrTq86ver0qh+8h/OlV51edXrVD96Dl151ejXo1aBXg14NejXo1fi83vFZcMIbfvd5NLwNL70a9GrQq0GvBr0a9GrQq9HwxgducMAdxht46dWgV4NeDXo16NWgV4NejY63D5h9pleDXo2Ot+OlV4NeDXo16NWgV4NeDXo1Bt7B+dKrQa8GvRoT78RLrwa9GvRq0KtBrwa9GvRqLLyL86VXg14NejV4Hxy8Dw56NejVoFeDXg16NejVoFcj8SbnS68GvRr0avA+ODZeejXo1aBXg14NejXo1aBXY+M9nC+9GvRq0KvB++A4eOnVoFeDXg16NenVpFeTXs3P652fAU94wQlv7oOXXk16NenVpFeTXk16NenVbHjbht99nvRq0qvJ++AMvPRq0qtJrya9mvRq0qtJr2bH2wNmn+nVpFeT98HZ8dKrSa8mvZr0atKrSa8mvZoD7+B86dWkV5NeTd4H58RLrya9mvRq0qtJrya9mvRqTryL86VXk15NejV5H5z0avJ8NXm+mvRq8j44Ey/fX016NenVpFeT56s7OJ3f/9eMdienn39NQruj0z98Xr69Km5wwB0e8IQXjHfj3XgP3oP34D14D96D9+A9eA/e83rvQPUPNzjgDg94wgtOeMN4G97bq+//z1e7w9U/3OHrzYcnvOCEN3ze+9xeFeO9vbrX314V4w28gTfwBt7A2/F2vJ31dtbb8Xa8HW/H2/HeXl2+vSpuMOsdeG+viie84ITxDrwT78Q78U72ebLeyXon6514b6+K2efFPi/2eeFdeBfehXfhXezzYr2L9SbrTbzJ+Sb7nOxzss+JN/Em3sS78W72ebPezXo36914N+e72efNPm/2+eA9eA/eg/fgPezzYb2H9R7We15vfj5wgwPu8OvNz4QXnPCG333O9oEbHDDeNuAJLzhhvA1v4A289CrpVdKrpFdJrzLwxobZZ3qV9Co73o6XXiW9SnqV9CrpVdKrpFc58A7Ol14lvUp6lQPvwEuvkl4lvUp6lfQq6VXSq5x4J+dLr5JeJb3KhXfhpVdJr5JeJb1KepX0KulVLrzJ+dKrpFdJrzLxJl56lfQq6VXSq6RXSa+SXuXGuzlfepX0KulVbrwbL71KepX0KulV0qukV0mv8uA9nC+92vRq06v9eb370+EBT3jBCW/4Xe+mV5vnq83z1aZXm15terV5vto8X216tenVplebXm16tenVplc78MaCE94w+9zxdrz0atOrTa82vdr0atOrTa92xzs4X3q16dWmV3vgHXjp1aZXm15terXp1aZXm17tiXdyvvRq06tNr/bEO/HSq02vNr3a9GrTq02vNr3aC+/ifOnVplebXu3Em3jp1aZXm15terXp1aZXm17tjXdzvvRq06tNr/bGu/HSq02vNr3a9GrTq02vNr3aB+/hfOnVplebXp3P6z2fBgfc4QFPeMEJbxhv+8ANDrjDeHkfPPTq0KtDrw69OvTq0KtDr07gjQFPeMEJ4w289OrQq0OvDr069OrQq0OvTsfbN8w+06tDrw7vg2fgpVeHXh16dejVoVeHXh16dSbeyfnSq0OvDr06vA+eiZdeHXp16NWhV4deHXp16NVZeBfnS68OvTr06vA+eBIvvTr06tCrQ68OvTr06tCrk3g350uvDr069OrwPng2Xnp16NWhV4deHXp16NWhV+fgPZwvvTr06tCrw/vgOb+98Xl7FZ+3V/F5exWft1fxeXsVn7dX8Xl7FZ/Pb298Phs+L7+9is/bq/g0vG+v4vM+X8Xnfb6KT8Pb8Da8DW+w3mC9gTdYb/XqPPx4v/8pxHHn23844Q2fl2+vihsccIcHjLfj7Xg73o534B14B96Bd+AdeAfegXfgHXgn3ol34p14J96Jd+KdeCfe26vvf+pz3Pn2H27w9c6HOzzgCS84uc+G8d5e3etvr4rxJt7Em3gTb+JNvIl3s97NejfejXfj3Xg33tur4g2flw/rPXhvr4o7POAJ4z14D97zeu98+w83OOAOD/j13vn2H054w+8+3/n2uk/D2/A2vA1vm/CCE94w3vjADQ64w3gDb+ANvIE32OfOejvr7ay34+0DZp87+9zZ54634x14B96Bd7DPg/UO1jtY78A7ON/BPk/2ebLPE+/EO/FOvBPvZJ8n652sd7FeelXz7cXs82KfF/tMr2q+vRjvwkuvGr1q9KrRq0avar79epPzpVeNXjV6VfPt9z4bL71q9KrRq0avGr1q9KrRq5pvv97D+dKrRq8avar59nufg5deNXrV6FWjV0Gvgl4Fvar59sdb8+3FE15wwpv74KVXQa+CXgW9CnoV9CroVc23X2/b8LvPQa+CXtV8+71P4KVXQa+CXgW9CnoV9CroVc23X28PmH2mV0Gvar697oOXXgW9CnoV9CroVdCroFc13369g/OlV0Gvgl7VfPu9z8RLr4JeBb0KehX0KuhV0Kvg+Sp4vgp6FfQq6FXwfBU8XwW9CnoV9CroVdCroFdBr2q+/XqT86VXQa+CXtV8e90HL70KehX0KuhV0KugV0Gvar79ejfnS6+CXgW9qvn2e5+Dl14FvQp6FfQq6FXQq06var798dZ8e3GHBzzhxX0S3jBeetXpVadXnV51elXz7dfbFpzwht99rvn2e5/AS686ver0qtOrTq86ver0qubbr7d/YPaZXnV6VfPt9z4dL73q9KrTq06vOr3q9KrTq5pvv97B+dKrTq86var59roPXnrV6VWnV51edXrV6VWnVzXffr2T86VXnV51etV5H+y8D3Z61elVp1edXnV61elVp1c13369yfnSq06vOr3qvA/WfHsxXnrV6VWnV51edXrV6VXNt1/v5nzpVadXnV513gdrvr0YL73q9KrTq06vOr3q9Krm2x9vzbcXNzjgDr/emm8vXnDCG373edCrQa8Gvar59uttA57wghPG2/DSq0GvBr0a9GrQq0GvBr2q+fbrjQ2zz/Rq0KvB+2DNtxfjpVeDXg16NejVoFeDXtV8+/UOzpdeDXo16NXgfbDm24vx0qtBrwa9GvRq0KtBr2q+/Xon50uvBr0a9GrwPjjo1eD5avB8NejV4H2w5tuL8dKrQa8GvRo8X9V8+/e/7iBqvv3733cQNd9ePOEFJ7zh8/LtVXGDA8a78W68G+/Gu/FuvAfvwXvwHrwH78F78B68B+95vTXfXtzggDs84Akv+Hrj4Q2fl2+vvv8teFHz7cUBd3jAk/ssGO/tVV1/Xg68gTfwBt7AG3gDb+AN1hust+PteDvejrfjvb0qXnDCrLfjvb0qbnDAHcY78A68A+/AO9jnyXon652sd+K9vSpmnyf7PNnniXfiXXgX3oV3sc+L9S7Wu1jvwrs438U+J/uc7HPiTbyJN/Em3mSfk/Um692sd+PdnO9mnzf7vNnnjXfj3Xg33oP3sM+H9R7We1jvwXs438M+H/b5vPtc8+3PfWq+vTjgDg94wgtOeMN42wducMAdxtvwNrwNL71a9GrRq0WvFr2q+fbrjQFPeMEJ4w289GrRq0WvFr1a9GrRq0Wvar79evuG2Wd6tehVzbff+wy89GrRq0WvFr1a9GrRq0Wvar79eifnS68WvVr0qubb6z546dWiV4teLXq16NWiV4te1Xz79S7Ol14terXoVc233/skXnq16NWiV4teLXq16NWiVzXffr2b86VXi14telXz7fc+Gy+9WvRq0atFrxa9WvRq0auab7/ew/nSq0WvFr2q+fa6z+tNepX0KulV0qukV0mvkl4lz1fJ81XSq6RXSa+S56vk+SrpVdKrpFdJr5JeJb1KelXz7dcbAXd4wBPGG3jpVdKrpFdJr5JeJb1KelXz7dfbF8w+06ukVzXffu8z8NKrpFdJr5JeJb1KepX0qubbr3dyvvQq6VXSq5pvv/eZeOlV0qukV0mvkl4lvUp6VfPt17s4X3qV9CrpVc23133w0qukV0mvkl4lvUp6lfSq5tuvNzlfepX0KulVzbff+2y89CrpVdKrpFdJr5JeJb2q+fbrPZwvvUp6lfSq5tvrPnjpVdKrTa82vdr0atOrTa9qvv3x1nx7ccIbfvd58z64eR/c9GrTq02vNr3a9GrTq02var79euMDNzjgDuMNvPRq06tNrza92vRq06tNr2q+/Xr7gNlnerXp1eZ9sObbL9OrTa82vdr0atOrTa82var59usdnC+92vRq06vN+2DNtxfjpVebXm16tenVplebXtV8+/UuzpdebXq16dXmfbDm24vx0qtNrza92vRq06tNr2q+/XqT86VXm15terV5H6z59mK89GrTq02vNr3a9GrTq5pvv97D+dKrTa82vdq8D9Z8ezFeerXp1aZXh14denXoVc23P96aby+e8IIT3tznXe/h+erwfHXo1eF9sObbi/HSq0OvDr06PF/VfPv3P7s4ar79+99VGTXfXtzhAU94wQlv+LxcvbqMt+PteDvejrfj7Xg73o534B14B96Bd+AdeAfegXfgHXgn3ol34p14J97bq/V5eMEJP97vfxZ01Hz75dur4gYH3N/73F4V4729qusTxrvwJt7Em3gTb+JNvMl6k/Um3sS78W68G+/tVfGAJ8x6N97bq+Lz8u1VcYPxHrwH78F78B72+bDe83u9vebbi397e823F3d4wBNe3CfhDeNteFuDA+7wgPG2BSe84fNy4A28gTfwBt6YMOsN1husN/D2D8w+d/a5s88db8fb8Xa8HW9nnwfrHax3sN6Bd3C+g30e7PNgnwfegXfinXgn3sk+T9Y7We9kvRPv5Hwn+7zY58U+L7wL78K78C68i31erHex3mS9iTc532Sfk31O9jnxJt7Em3g33s0+b9a7We9mvRvv5nw3+7zZ580+H7wH78F78B68h30+rPew3sN6z+ut+fbiBgfc4ddb8+3FC054w+8+N3rV6FWjVzXffr1twBNecMJ4G1561ehVo1eNXjV61ehVo1c13369sWH2mV41elXz7fc+HS+9avSq0atGrxq9avSq0auab7/ewfnSq0avGr2q+fa6D1561ehVo1eNXjV61ehVo1dt4p2cL71q9KrRq7bwLrz0qtGrRq8avWr0qtGrRq9qvv16k/OlV41eNXrVEm/ipVeNXjV61ehVo1eNXjV6VfPt17s5X3rV6FWjVzXfXvfBS68avWr0qtGrRq8avWr0qubbr/dwvvQq6FXQq5pvf+5T8+3FA57wghPe8LveoFc13369LeAOD3jCeBteehX0KuhV0KugV0Gvgl7VfPv1xoIT3jD73PF2vPQq6FXQq6BXQa+CXgW9qvn26x2cL70KehX0qubb730GXnoV9CroVdCroFdBr4Je1Xz79U7Ol14FvQp6FRPvxEuvgl4FvQp6FfQq6FXQq5pvv97F+dKroFdBryLxJl56FfQq6FXQq6BXQa+CXtV8+/VuzpdeBb0KehUb78ZLr4JeBb0KehX0KuhV0Kuab7/ew/nSq6BXQa8674M1314ccIcHPOEFJ7xhvO0DNzjgDuNteOlVp1edXnV61elVp1edXtV8+/XGgCe84ITxBl561elVp1edXnV61elVp1c13369fcPsM73q9KrzPljz7cV46VWnV51edXrV6VWnVzXffr2T86VXnV51etV5H+z0qvN81Xm+6vSq8z5Y8+3FeOlVp1edXnWer2q+ffWHr3d9c/XqcoMD7vCAJ7zghDeMd+PdeDfejXfj3Xg33o134914D96D9+A9eA/eg/fgPXgP3vN6a769uMEBX+9+eMATvt7zcMIbPi9Xry639z7Vq8t4q1f3+gnjbXgb3oY38AbewBt4g/UG6w28gTfwBt6Ot3p1OeAOs96Ot3p1OeENn5cH3oF34B14B97BPg/WO1jvYL0Db/XqMvs82efJPk+8E+/EO/FOvJN9Xqx3sd7Fehfexfku9nmxz4t9XngX3sSbeBNvss/JepP1JutNvMn5Jvu82efNPm+8G+/Gu/FuvJt93qx3s97Deg/ew/ke9vmwz4d9PngP3oP3vN6aby9ucMAdHvDrrfn24oQ3/O7zpFc1316Mt+GlV5NeTXo16dWkVzXffr3xgRsccIfxBl56NenVpFeTXk16NenVpFc13369fcDsM72a9Krm2+s+eOnVpFeTXk16NenVpFeTXtV8+/UOzpdeTXo16VXNt9/7TLz0atKrSa8mvZr0atKrSa9qvv16F+dLrya9mvSq5tvrPnjp1aRXk15NejXp1aRXk17VfPv1JudLrya9mvSq5tvvfTZeejXp1aRXk15NejXp1aRXNd9+vYfzpVeTXk16VfPt9z4HL72a9GrSq0mvFr1a9GrRq8Xz1eL5atGrRa8WvVo8Xy2erxa9WvRq0atFrxa9WvRq0auab7/etuF3nxe9WvSq5tvvfQIvvVr0atGrRa8WvVr0atGrmm+/3h4w+0yvFr2q+fa6D156tejVoleLXi16tejVolc13369g/OlV4teLXpV8+33PhMvvVr0atGrRa8WvVr0atGrmm+/3sX50qtFrxa9qvn2e5+Fl14terXo1aJXi14terXoVc23X29yvvRq0atFr2q+ve6Dl14terXo1aJXi14terXoVc23X+/mfOnVoleLXtV8+73PwUuvFr1a9GrRq0WvFr1KelXz7Y+35tuLOzzgCS/uk/CG8dKrpFdJr5JeJb2q+fbrbQtOeMPvPifvgzXfXoyXXiW9SnqV9CrpVdKrmm+/3v6B2Wd6lfQqeR+s+fZivPQq6VXSq6RXSa+SXtV8+/UOzpdeJb1KepW8D9Z8+2V6lfQq6VXSq6RXSa+SXtV8+/VOzpdeJb1KepW8D9Z8ezFeepX0KulV0qukV0mvar79epPzpVdJr5JeJe+DNd9ejJdeJb1KepX0KulV0quab7/ezfnSq6RXSa+S98Gaby/GS6+SXiW9SnqV9CrpVc23P96aby9ucMAdfr2bXm2erzbPV5tebd4Ha769GC+92vRq06vN81XNt2d7+PHmeHjD5+Xbq+IGB9zhAU94wXgDb+DteDvejrfj7Xg73o634+14O96Bd+AdeAfegXfgHXgH3oF34J14b69yPRxwh683H57wghPe8Hnvc3tVjPf26l5/e1WMd+FdeBfehXfhTbyJN1lvst7Em3gTb+JNvLdXl2+vihvMejfe26viCS84Ybwb78F78B68h30+rPew3sN6D97bq+J3n2u+vbjBr7fm24sHPOEFJ7zhd701316MtwXc4QFPGG/D2/A2vIE3Gsx6g/UG6w28seCEN8w+d7wdb8fb8Xa8nX3urLez3s56O97B+Q72ebDPg30eeAfegXfgHXgH+zxZ72S9k/XSq5pvL2afJ/s82Wd6VfPtlxfehZdeHXp16NWhV4de1Xz79S7Ol14denXoVc233/skXnp16NWhV4deHXp16NWhVzXffr2b86VXh14delXz7XUfvPTq0KtDrw69OvTq0KtDr2q+/XoP50uvDr06b69Gzbd/32fUfHtxwB0e8IQXnPCG8bYP3OCAO4y34W14G96G9+3V+ATrDdYbrDfwxoAnvOCE8Qbejrfj7Xg7+9xZb2e9nfV2vH3D7PNgnwf7PPAOvAPvwDvwDvZ5sN7BeifrnXgn5zvZ58k+T/Z54p14J96Jd+Fd7PNivYv1Lta78C7Od7HPi31e7HPiTbyJN/Em3mSfk/Um603Wm3g357vZ580+b/Z54914N96Nd+Pd7PNhvYf1HtZ78B7O97DPh30+7PPBe15vo1eNXjV61ehVo1eNXjV6VfPtj7fm24vffW70qtGrmm+/92l46VWjV41eNXrV6FWjV41e1Xz79UbAHR7whPEGXnrV6FWjV41eNXrV6FWjVzXffr19wewzvWr0qubb730GXnrV6FWjV41eNXrV6FWjVzXffr2T86VXjV41etUm3omXXjV61ehVo1eNXjV61ehVzbdf7+J86VWjV41etYV34aVXjV41etXoVaNXjV41etUSb3K+9KrRq0av2sa78dKrRq8avWr0qtGrRq8avar59us9nC+9avSq0at28B689KrRq6BXQa+CXgW9CnpV8+2Pt+bbixPe8LvP0fA2vPQq6FXQq6BXQa+CXgW9qvn2640P3OCAO4w38NKroFdBr4JeBb0KehX0qubbr7cPmH2mV0GvouPteOlV0KugV0Gvgl4FvQp6VfPt1zs4X3oV9CroVUy89Cp4vgqer4JexcQ78U689CroVdCr4Pmq5tvzPPx493x4wQlv+Lx8e1Xc4IA7PGC8iTfxJt7Eu/FuvBvv7dX5PDzg633WfntVnFyz4fNec3tV3N5rbq+Krzcexnt7VYz39qoY7+3VwzXf/lxT8+3FwTUdHr8/Q823188XnNxnw3hvr4rx3l4V420Dnu9naHhbwnjbu881336viQbjvb0qxhus9/bqfobAGxvG29nnjrezzx3v7VUx3s56b6/uZ+h4O/s88A72eeAd7PPAOyaMd7De26v7GQbeyT5PvJN9nngn+zzxzgXjnaz39up+hoV3sc8L72KfF97FPi+8iz/PC+9ivbdX9zMk3mSfE2+yz4k32efEm/x5Tryb9d5e3c+w8dKrmm+/96FXNd9e17DPGy+9qvn2ew29qvn2+xkOXnpV8+11H/b54KVXNd/+XDPoVc23P9cMelXz7c9nqPn2+vmEF/dJeHPNu881336voVc1317XdPjtZM23188XjJde1Xz7vYZe1Xz7vYZe1Xx7XcN64+1kzbfXzxPGS69qvv1eQ69qvr2u6TBeelXz7fczdLz0qubb733oVc2332voVc231zUDxkuvar79foaBl17VfPu9D72q+fa6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",
      "verification_key": "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"
    },
    {
      "name": "claim_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "message_leaf_index",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2550444873539515884": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7043145299448266897": {
            "error_kind": "string",
            "string": "L1-to-L2 message is already nullified"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13293000217372736598": {
            "error_kind": "string",
            "string": "Tried to consume nonexistent L1-to-L2 message"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "portal",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "exit_to_l1_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_l1",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "285656119219400463": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 32 limbs"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4456244908619624852": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6668324276689745315": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 4 limbs"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17456365777023668047": {
            "error_kind": "string",
            "string": "Token address is not the same as seen in storage"
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "verification_key": "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"
    },
    {
      "name": "exit_to_l1_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_l1",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2550444873539515884": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBeJwAABAMnAgUEBCcCBgQAHwoABQAGgFodAIBbgFsGLgiAWgABLgiAWwACLgiAXAADLgiAXQAEJQAAAF4lAAABnSgCAAEEgF4nAgIEADsOAAIAASkAgEME/////ykAgEQEagnmZykAgEUEu2euhSkAgEYEPG7zcikAgEcEpU/1OikAgEgEUQ5SfykAgEkEmwVojCkAgEoEH4PZqykAgEsEW+DNGS4AAAGATCgAgE0EAAkBAAABgE0AASgBgEwEAAEBAIBMAAKATS4AgE2ATi4EgESATgEAgE4AAoBOLgSARYBOAQCATgACgE4uBIBGgE4BAIBOAAKATi4EgEeATgEAgE4AAoBOLgSASIBOAQCATgACgE4uBIBJgE4BAIBOAAKATi4EgEqATgEAgE4AAoBOLgSAS4BOKACATQQAQCgAgE4EAAQoAIBPBAA4KACAUAQAAygAgFEEABAoAIBSBAAOKACAUwQBACgAgFQCAAAoAIBVBAAAKACAVgEAASgAgFcEAAEoAIBYBAAIKACAWQQAZCYlAAATgh4CAAYAHgIABwAzKgAGAAcACCQCAAgAAAHBJQAAE6snAgYAACsCAAcAAAAAAAAAAAIAAAAAAAAAAC0IAQgnAgkEBQAIAQkBJwMIBAEAIggCCS0KCQotDgYKACIKAgotDgYKACIKAgotDgYKACIKAgotDgcKLQgBBwAAAQIBLQgBCQAAAQIBLQgBCgAAAQIBLQgBCwAAAQIBJwIMAAYnAg0AAS0IAQ4nAg8EBAAIAQ8BJwMOBAEAIg4CDy0KDxAtDgwQACIQAhAtDg0QACIQAhAtDgYQLQ4OBy0OCAknAggEAi0OCAonAggBAC0OCAsuCIBVAAUjAAACmw0iAAWAUAAIJAIACAAAEvMjAAACsC0LCQgtCwgMACIMAgwtDgwILQgBDCcCDgQFAAgBDgEnAwwEAQAiCAIOJwIPBAQAIgwCED8PAA4AEC0LBwgtCwoOLQ4IBy0ODAktDg4KLgyAVgALASIADIBXAAgtCwgHHgIACAAzKgAHAAgACSQCAAkAAAMpJQAAE70vCgANAAcnAggAAi8KAAgACS0IAQgAAAECAScCCwEALQgBCicCDAQhAAgBDAEnAwoEAQAiCgIMJwIOBCBDA6IAAYBTAA4ACwAMHAoCAQAnAgsBAC0IAQInAgwEIQAIAQwBJwMCBAEAIgICDCcCDgQgQwOiAAGAUwAOAAsADCcCDAEALQgBCycCDgQhAAgBDgEnAwsEAQAiCwIOJwIPBCBDA6IAA4BTAA8ADAAOJwIDAmknAgwCMicCDgKNJwIPAuwtCAEQJwIRBGUACAERAScDEAQBACIQAhEtChESLQ4DEgAiEgISLQ4MEgAiEgISLQ4OEgAiEgISLQ4PEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEgAiEgISLgyAVAASACISAhIuDIBUABIAIhICEi4MgFQAEi0OEAgnAgMEICcCDAQkJwIOBEQuCIBVAAUjAAAIYgwqBQMPJAIADwAAEe0jAAAIdC0LCAUuCYBMAAgAIggCCC4GAAiATC0LBQgAIggCCC0OCAUnAgsEDi0IAA4tCgUPLgiAWQAQLgiAVQARAAgACwAlAAATzy0CAAAtCg8ILQoQCi0LCAsAIgsCCy0OCwguCYBMAAsAIgsCCy4GAAuATC0IAQsnAgwECQAIAQwBJwMLBAEAIggCDAEggEwAAgAOACILAg9APwAPAA4ADCcCDgQPLQgADy0KBRAuCIBZABEuCIBNABIACAAOACUAABPPLQIAAC0KEAgtChEMLQsIBQAiBQIFLQ4FCAciAAyATgAFDSIABYBRAA4kAgAOAAAJaSUAABZnACIIAg8AKg8FEC0LEA4nAhAEBAYqDBARBCoREBICKgwSDwMogE4ADwAQDyIAD4BOABEkAgARAAAJqCUAABZ5BSiAWAAQABEnAhMEAAoqExASJAIAEgAACdwGKhEQFQsiABWAWAAUJAIAFAAACdwlAAAWiwwqEQMSJAIAEgAACfkjAAAJ7i4IgFUAAiMAAAoHGioOEQotCgoCIwAACgcNIgAQgE4ADiQCAA4AAAonIwAAChwuCIBVAAojAAAKNRgqAhEOLQoOCiMAAAo1AyiAUAAPAA4PIgAPgFAAECQCABAAAApSJQAAFnkNIgAOgE4ADyQCAA8AAApyIwAACmcuCIBVAAIjAAAKuQUogFgADgAPJwIRBAAKKhEOECQCABAAAAqm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CAUiAAKATgAJByIACYBOAAsKKgsCCiQCAAoAABU7JQAAFosuCIBVAAcjAAAVRg0iAAeATgAKJAIACgAAFbMjAAAVWy0LCActCwYIDSIAAoBRAAkkAgAJAAAVeCUAABZnLgIACIADKACABAQAESUAABavLgiABQAJACIJAgoAKgoCCy0OBwstDgkGASIAAoBXAActCgcCIwAAFO8AKgkHCw4qCQsMJAIADAAAFcolAAAWnQwqCwQMJAIADAAAFecjAAAV3C4IgFQACiMAABYqACoDCwwOKgMMDSQCAA0AABX+JQAAFp0NIgAMgFkACyQCAAsAABYTJQAAFmcAIgECDQAqDQwOLQsOCy0KCwojAAAWKi0LCAsZIgALgFgADBwKCgsEACoMCwoOKgwKDSQCAA0AABZSJQAAFp0tDgoIASIAB4BXAAotCgoHIwAAFUYqAQABBcVrxFoOEAACPAQCASYqAQABBSiGkrBH3P1DPAQCASYqAQABBWRhiKjGz5TLPAQCASYqAQABBUWnynEZQeQVPAQCASYuAYADgAYLAIAGAAKAByQAgAcAABbKIwAAFtUuAIADgAUjAAAXPC4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAABcoLgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAABb3KAGABQQAAQMAgAYAAoAGIwAAFzwm",
      "debug_symbols": "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"
    },
    {
      "name": "get_config",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5276036973553878575": {
            "error_kind": "string",
            "string": "Function get_config can only be called statically"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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EVkjskZkjcgWkS0iW0S2iGwR2SKyRWSLyBaRLSK3iNwicovILSK3iNwicovILSK3iNwico/IPSL3iBw52CIHW+RgixxskYMtcrBFDvbIwR452CMHe+RgjxzskYM9crBHDvbIwR452CMHe+RgjxzskYM9crBHDvbIwR452CMHe+RgjxzskYM9crBHDvbIwR452CMHe+RgjxzskYM9crBHDvbIwR452CMHe+RgjxzskYM9crBHDvbIwR452CMHe+RgjxzskYM9crBHDvbIwR452CMHe+RgjxzskYM9crBHDvbIwR452CMHu+dgH53BV0AJoIAawAESoAEW0AIiskVki8gWkUcO2jWAAyRAAyygBfQFIwcnlAAKiMgtIreI3CJyi8gtIreI3CNyj8g9IveI3CNyj8g9IveI3CNyX5EfHetXUkmipJrESZKkSZbUktJR0lHSUdJR0lHSUdJR0lHSUdJR0kHpoHRQOigdlA5KB6WD0kHpoHTUdNR0jCQ1dqpJnDQc5qRJltSSetBI1kUliZJqEielg9PB6eB0cDokHZIOSYekQ9Ih6ZB0SDokHZIOTYemQ9Oh6dB0aDo0HZoOTYemw9Jh6bB0WDosHZYOS4elw9Jh6WjpaOlo6WjpaOlo6WjpaOlo6Wjp6Ono6ejp6Ono6ejp6Ono6ejp6OHwETSLShIl1SROkiRNsqSWlI6SjpKOko6SjpKOko6SjpKOko6SDkoHpYPSQemgdFA6KB2UDkoHpaOmo6ajpqOmo6Yj87xknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl87xknpfM85J5XjLPS+Z5yTwvmecl85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynznDLPKfOcMs8p85wyzynz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",
      "verification_key": "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"
    },
    {
      "name": "get_config_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "config::Config",
            "fields": [
              {
                "name": "token",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "portal",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::eth_address::EthAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "2550444873539515884": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15520311074722577191": {
            "error_kind": "string",
            "string": "Function get_config_public can only be called statically"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAASyUAAABTLgIAAYBELgIAAoBFKAIAAwSARCcCBAQCOw4ABAADKACAQwQAAyYlAAACmx4CAAIAHgIAAwAzKgACAAMABCcCAgEBJAIABAAAAHwlAAACxB4CAAMJJAIAAwAAAI4lAAAC1icCAwAAKwIABAAAAAAAAAAAAgAAAAAAAAAALQgBBScCBgQFAAgBBgEnAwUEAQAiBQIGLQoGBy0OAwcAIgcCBy0OAwcAIgcCBy0OAwcAIgcCBy0OBActCAEEAAABAgEtCAEGAAABAgEtCAEHAAABAgEtCAEIAAABAgEnAgkABicCCgABLQgBCycCDAQEAAgBDAEnAwsEAQAiCwIMLQoMDS0OCQ0AIg0CDS0OCg0AIg0CDS0OAw0tDgsELQ4FBicCAwQCLQ4DBycCAwEALQ4DCCcCAwQAJwIFBAEtCgMBIwAAAXANIgABgEMAAyQCAAMAAAIPIwAAAYUtCwYBLQsBAwAiAwIDLQ4DAS0IAQMnAgkEBQAIAQkBJwMDBAEAIgECCScCCwQEACIDAgw/DwAJAAwtCwQBLQsHCS0OAQQtDgMGLQ4JBy0OAggAKgMFBC0LBAEeAgADADMqAAEAAwAEJAIABAAAAfklAAAC6C8KAAoAAScCAgACLwoAAgADLQoDAiYtCwcDDCoBAwkkAgAJAAACJSMAAAKNLQsGCQAiCQIMACoMAQ0tCw0LLQsEDAAiDAIOACoOAQ8tCw8NACoLDQ4tCwgLLgIACYADKACABAQABSUAAAL6LgiABQANACINAg8AKg8BEC0ODhAtDgwELQ4NBi0OAwctDgsIIwAAAo0AKgEFAy0KAwEjAAABcCgAgAQEeAANAAAAgASAAyQAgAMAAALDKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKgEAAQXXYzixPGZ7JzwEAgEmKgEAAQUjZQAZgon17DwEAgEmLgGAA4AGCwCABgACgAckAIAHAAADFSMAAAMgLgCAA4AFIwAAA4cuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAADcy4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAADQigBgAUEAAEDAIAGAAKABiMAAAOHJg==",
      "debug_symbols": "tZjhbuIwDMffpZ/5kMR2nPAqp2lirJuQECAGJ50m3v3sNi50UqId477Ar277r+04dtXP7rV/Ob8/b3Zv+49u+euzezluttvN+/N2v16dNvudWD87pz8pdUtcdBm6JcufHHm36LyLAl7Ae4NcIKAAKqiFBIALYOiWQU8hF4ipANsptlPJLMks2Sw5jhCcMyCDXMCjQXlECGCggiAA3iAWQGdABrkAoUEqEFUwKqQCbJYhCoUhigHMks2SiwWcN6AC3hmgQS4wRMEKXGCIYoBYYIhiACqgHoIsHCTRAVkm0BUdgUdAFwxEByRAVDdGoALBLMEsYBYwC5oFVScIkDPQcLJCKhCDQSzAejEqkIH6LFFgkttRokDNIYqrpAUwglyMkh/SghwhFtBEaeykiULRIV3TAagkgdSfAaJZYkkLsd6VFGKBZJakDxWfKTsDHO+K6tgIRSf6YFCeFQMYmAXsGl3KAdB00JRHny+XRWe79fl07HvdrDfbVzb1YXXsd6duuTtvt4vu92p7Hi76OKx2w/9pdZSzkph+9yr/Ivi22fZKl8X1ble/1QPpqg63e4iRJwnpDzMR3xBxYdJwGG4kYCYRGhKcUzQNzpkmEZ7HAnUN2VcuFQ3hgDWNZig5mxvSD6uh0ANCif87FErTqqT6qqS6BHMyCU5YdSI3ApFG5i0QQPxpID7UA2mVeUgOTEMaOtXLvFGkIbtkKsI5V4NpVSk4xikjLnNN5B/Cqe/alkiESSPSNa3k57E0yjRKJysS0jpuViZ9SSo3aiyi7TiOcl9Vo1GnGPTdZNBAQKhr5JYf2TSY4RoLeJ43sUZKGaeUMiZX12hUO5D1UvTXbMgLz1yhVaY+25YL8jJV12hUKWW2hfV0nxch2bpKMwt1jVYrpWCzzRPynRpx6uiU8n2xsLeOLu+Hrq6RWmOB4ToVGvlo1SiGqbziXQoZrcgzpbsUZsM+1msDGvmU10qrUMR89UMG7rfTKf3X3Mihns5m62GYWo+0oWrbgEdMe3jIuG820jwNa74dCV+j+fnAh4dM/G8PlvrKNDUYLJaYnK9qYGgO2qnKYNZK57Fga+C7mKyZyux3qZYQxJaIu2bVOXRVEWqNFqBJhCBVl6bZQZwFk8OdPShaA8lMP+1iXxWe5HC13hxn30EuKnXcrF62fTl8O+/WN2dPfw52xr6jHI77df96PvaqdP2YIj+/5NvHQj57POlHFD2UVicfSPTQD2dx4TE+XdSZvw=="
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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NsWm2BSbYTNshs2wGTbDZtgMm2EzbA1bw9awNWwNW8PWsDVsDVvD5tgcm2NzbI7NsTk2x+bYyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWpJElGhg2DzSwgb5wZMnABGZQwAJWEJthM2yGrWFr2Bq2hi2ypA8SWazoN1FBAxvoC0eWWGACM9htfdjSYkW/iRUMWzRqZMmNDfSJMTltYgIzGLYWGDYPrKCCBjbQF0aW3JjADAqILWFL2BK2hC1hy9gytowtY8vYMraMLWPL2DI2wSbYBJtgE2yCTbAJNsEm2Aq2gq1gK9gKtoKtYCvYCraCrWKr2Cq2iq1iq9gqtoqtYqvYFJtiU2yKTbEpNsWm2BSbYjNshs2wGTbDZtgMm2EzbIatYWvYGraGrWFr2Bq2hq1ha9gcm2NzbI7NsTk2x+bYHJsvm1wXmMAMCljACipoYAOxkSVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClhSypJAlhSwpZEkhS2JmXutjnxYz8yYa2EBfGFlyY7f1J0sWM/Mmdlsf67NYdnBiBRU0sIG+MLLkxgSGzQIFLGAFFTSwgd3WJytazNebmMAMCljACnZbnz5oMV9vYgPjuIV4ZMnABGZQwAJWUEEDG4itYqvYKraKrWKr2Cq2iq1iq9gUm2JTbIpNsSk2xabYFJtiM2yGzbAZNsNm2AybYTNshq1ha9gatoatYWvYGraGrWFr2BybY3Nsjs2xOTbH5tgcmy9bvS4wgRkUsIAVVNDABmJL2BK2hC1hS9gStoQtYUvY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8dN069qmbWMbP0+redUoj+5+PX14tfeqUd+9YvxkO1iWZJ9I9msN+46U17eXBHrV8O+4MLHr/QuTY42HFybHvclMJZMrf7XK4wuTY8dpDPtefug4p6dYsu62yrY7v4xeHZ9hrZuTsr86pz9fjX/DRINPijy9PjL/jp7T3n428Pytt/LxW2+vDTm9o9VYi75ty3GU33lN5eGzgc9eU3k45eFbLoGbfsshfvvpwPGFmWdj8p+9LvOwWdt3NOtpbszzZj09zfqGniPC/PQfHmf/Mr3tNEfuYlD+0nzofqcT9nuqPFtA5pMaj1aQ+azGk/P1k5tyWdMGXzf56csDBM9+hz8ZRuK5+P4p4t8aiWLB0f1d3N+ZWP5wKfhPijz7VMD5VbOkq9/k9vH7aikdHxKsPNpeq3q8vkJlKZT6w2X44wKPjsj17uDicTEBviWV6sdXd+cS66417a94/06Jh9fd6TSp5+F197nGo+vup99NPIwGnr9FdTHYJF8q8fCi/bgjurYi29dKPIzP6/3sPE3mu7YvP+mXDmofvFgDENuF6W+V4Lt8qX1tK7YRDPGvbUXlsxd1m0z/WyWUbxM1/9qOsPaI5K/tiPAGqdSv7YiuEzypfW0rzFi8yb92djKrKnn+Uglb40lW9CsFfN287fO6fg3O46d73l52iWWCPH9tN1YPc6tvtsPXCrwGKtfBzLp/eOD5mk15rXOX9sUNvlxCv1RC1qJPSa72tRJKWpl8qURd69K/0uprbSF8Sa388EWaL5b42kEt6zHFa0g+fa0EaVVUv1iCHflh9dffKLHueF+/g187qMV59//60laU9WyitC+1BOfVDx+m/alASqfXp1LmFyjvd8uPF/Kqq8APP8W/sRtrAUMtX2rIut5jqfuF+28UYNFql68VuP6b5wdfKvDDa72/04hrfaqvBZ2mdUss/uYWfPUwPpnocizw5AXr433ok3ky17vDG8dVbl8joPtHFevHr72/rsVPK/SVtRam1+vjL8O9qhwfm7y5bOLr+Bt35h9+DPz1cPb0JcMn3xP/rFX5Eb6afDwX61zm9YvD/U+xr5a5WOzhNbKTylfLqHKq7N/Q/s0yxhd4r/09698t49yhtqt99cS1NQDitv0i/Tcn7uMq/uUqzsW41y9W6bNAOU5X+7jOZ+fwNgTQJH+1gb0y77SlrzbNdpvh7XSYjs/KHjfNuc7D4fpzjWfD9Z/U+HC4/n++/s8//8tf/v5Pf/3Xf/nnf//Lv/7t315/7796qb//5Z//11//fP/f//Mff/uX7b/++////83/8r/+/pe//vUv//ef/t/f//Vf/vy//+Pvf+6V+n/703X/z/9o/aU0f7Xp//yHP6XX/3d9XRq5Wv//8vr/r1vsmvt/63/4larlH17/4/1fxJ++Xveur//x//lffXP/Pw=="
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2550444873539515884": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7043145299448266897": {
            "error_kind": "string",
            "string": "L1-to-L2 message is already nullified"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10492081608786484886": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "13293000217372736598": {
            "error_kind": "string",
            "string": "Tried to consume nonexistent L1-to-L2 message"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15520311074722577191": {
            "error_kind": "string",
            "string": "Function get_config_public can only be called statically"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBmJwAABAMnAgIEAScCAwQAHwoAAgADgGUuCIBlAAElAAAARSUAAAHfKAIAAQSAZicCAgQAOw4AAgABKACAQwQABigAgEQEAAUpAIBFBP////8pAIBGBGoJ5mcpAIBHBLtnroUpAIBIBDxu83IpAIBJBKVP9TopAIBKBFEOUn8pAIBLBJsFaIwpAIBMBB+D2aspAIBNBFvgzRkuAAABgE4oAIBPBAAJAQAAAYBPAAEoAYBOBAABAQCATgACgE8uAIBPgFAuBIBGgFABAIBQAAKAUC4EgEeAUAEAgFAAAoBQLgSASIBQAQCAUAACgFAuBIBJgFABAIBQAAKAUC4EgEqAUAEAgFAAAoBQLgSAS4BQAQCAUAACgFAuBIBMgFABAIBQAAKAUC4EgE2AUCgAgE8EAEAoAIBQBAAEKACAUQQAOCgAgFIEAAMoAIBTBAAQKACAVAQADigAgFUEAQAoAIBWAQAAKACAVwIAACgAgFgEAAAoAIBZAAAAKACAWgEAASgAgFsEAAEoAIBcAAABKACAXQQAAigAgF4EAAgoAIBfBAAPKACAYAQAICgAgGEEAEQoAIBiBABkKACAYwQA4CsAgGQAAAAAAAAAAAEAAAAAAAAAACYlAAAtQSkCAAIAQYzddQoqAQIDLQgBAicCBAQCAAgBBAEnAwIEAQAiAgIELQoEBS4MgFwABScCBAAGLQgBBScCBgQCAAgBBgEnAwUEAQAiBQIGLQoGBy0OBAcnAgYEACcCCAQDACoGCActCAEEAAgBBwEnAwQEAQAiBAIHLQ4GBwAiBwIHLQ4GBycCBwQDACoEBwYtCwQGACIGAgYtDgYEJAIAAwAAAowjAAAIpS0IAQYnAgcEAwAIAQcBJwMGBAEAIgYCBx8wgF2AWwAHLQgBBwAAAQIBLQ4GBy0IAQYAAAECAS4MgFgABicCCQQKLQgACi0KBwstCgYMAAgACQAlAAAtai0CAAAtCgsIASIACIBbAAotCwoJJwIKBAstCAALLQoHDC0KBg0ACAAKACUAAC1qLQIAAC0KDAgBIgAIgFsABy0LBwYeAgAHAC0IAQgnAgoEAwAIAQoBJwMIBAEAIggCCjYOAAcACgABIgAIgFsACy0LCwoBIgAIgF0ADC0LDAscCgoIAAQqCAsMJAIACgAAA30nAggEADwGCAEtCAEIJwIKBAMACAEKAScDCAQBACIIAgo2DgAHAAoCASIACIBbAAotCwoHASIACIBdAAstCwsKHAoHCAAEKggKCyQCAAcAAAPPJwIIBAA8BggBLQgBBycCCAQCAAgBCAEnAwcEAQAiBwIIHzCAW4BYAAgBIgAHgFsACi0LCggcCggKBBwKCgcALQgBCCcCCgQDAAgBCgEnAwgEAQAiCAIKHzCAXYBbAAoBIgAIgFsADS0LDQoBIgAIgF0ADi0LDg0tCAEIJwIOBAQACAEOAScDCAQBACIIAg4tCg4PLgyAWQAPACIPAg8uDIBZAA8AIg8CDy4MgFkADysCAA4AAAAAAAAAAAMAAAAAAAAAAC0IAQ8nAhAEBQAIARABJwMPBAEAIg8CEC0KEBEuDIBZABEAIhECES4MgFkAEQAiEQIRLgyAWQARACIRAhEtDg4RLQgBDgAAAQIBLQ4IDi0IAQgAAAECAS0ODwgtCAEPAAABAgEuDIBYAA8tCAEQAAABAgEuDIBWABAnAhEALCcCEgQTLQgAEy0KDhQtCggVLQoPFi0KEBctChEYAAgAEgAlAAAt4S0CAAAnAhEEEi0IABItCg4TLQoIFC0KDxUtChAWLQoKFwAIABEAJQAALeEtAgAAJwIKBBEtCAARLQoOEi0KCBMtCg8ULQoQFS0KDRYACAAKACUAAC3hLQIAACcCDQQRLQgAES0KDhItCggTLQoPFC0KEBUACAANACUAAC7/LQIAAC0KEgotCAEIJwINBAMACAENAScDCAQBACIIAg0tCg0OLQ4HDgAiDgIOLQ4KDicCBwANLQgBCicCDQQCAAgBDQEnAwoEAQAiCgINLQoNDi0OBw4nAg0EDi0IAA4tCgoPLQoIEAAIAA0AJQAAL3MtAgAALQoPBycCCgQNLQgADS0KBw4uCIBSAA8uCIBWABAACAAKACUAAC/TLQIAAC0KDggKKgsIByQCAAcAAAZiJQAAMYILIgAMgFkABx4CAAgBCioMCAoSKgcKCCQCAAgAAAaGJQAAMZQnAggECi0IAAotCgULLQoCDAAIAAgAJQAAMaYtAgAALQoLBycCCgQLLQgACy0KBwwuCIBdAA0uCIBWAA4ACAAKACUAADHxLQIAAC0KDAg0AgAILQgBBycCCAQEAAgBCAEnAwcEAQAiBwIILQoICi4MgFkACgAiCgIKLgyAWQAKACIKAgouDIBZAAorAgAIAAAAAAAAAAACAAAAAAAAAAAtCAEKJwILBAUACAELAScDCgQBACIKAgstCgsMLgyAWQAMACIMAgwuDIBZAAwAIgwCDC4MgFkADAAiDAIMLQ4IDC0IAQgAAAECAS0OBwgtCAEHAAABAgEtDgoHLQgBCgAAAQIBLgyAWAAKLQgBCwAAAQIBLgyAVgALJwIMBA0tCAANLQoIDi0KBw8tCgoQLQoLES0KCRIACAAMACUAAC3hLQIAACcCDAQNLQgADS0KCA4tCgcPLQoKEC0KCxEtCgYSAAgADAAlAAAt4S0CAAAnAg0EDi0IAA4tCggPLQoHEC0KChEtCgsSAAgADQAlAAAu/y0CAAAtCg8MLQgBBycCCAQEAAgBCAEnAwcEAQAiBwIILQoICi0OCQoAIgoCCi0OBgoAIgoCCi0ODAouCIBYAAMjAAAIXA0iAAOAUgAGJAIABgAALQ8jAAAIcR4CAAMANAIAAy0LBAMAIgMCAy0OAwQAIgQCBy0LBwYnAggEAgAqBwgDOw4ABgADIwAACKUpAgADACh3iP8KKgEDBi0LAgMAIgMCAy0OAwItCwUDACIDAgMtDgMFLQsCAwAiAwIDLQ4DAi0LBQMAIgMCAy0OAwUnAgMAAiQCAAYAAAj5IwAACiAeAgAGAB4CAAcAMyoABgAHAAgkAgAIAAAJGCUAADOgHgIABgkkAgAGAAAJKiUAADOyLQsCBgAiBgIGLQ4GAi0LBQYAIgYCBi0OBgUnAgcECC0IAAgtCgUJLQoCCgAIAAcAJQAAMaYtAgAALQoJBicCCAQJLQgACS0KBgouCIBdAAsuCIBWAAwACAAIACUAADHxLQIAAC0KCgceAgAGADMqAAcABgAIJAIACAAACawlAAAzxC8IgFwABi8KAAMABycCCQQCJwILBAMAKgkLCi0IAQgACAEKAScDCAQBACIIAgotDgkKACIKAgotDgkKJwIKBAMAKggKCS0KCQotDgYKACIKAgotDgcKACIIAgktCwkHJwIKBAIAKgkKBjsOAAcABiMAAAogKQIABgD4WLoMCioBBgcnAgYEJCcCCASAJAIABwAACkUjAAAbBS0IAQknAgoEBQAIAQoBJwMJBAEAIgkCCh8wgFCAWwAKLQgBCgAAAQIBLQ4JCi0IAQkAAAECAS4MgFgACScCDAQNLQgADS0KCg4tCgkPAAgADAAlAAAz1i0CAAAtCg4LASIAC4BbAA0tCw0MJwINBA4tCAAOLQoKDy0KCRAACAANACUAADPWLQIAAC0KDwsBIgALgFsADi0LDg0cCg0OBhwKDgsAJwIOBA8tCAAPLQoKEC0KCREACAAOACUAADPWLQIAAC0KEA0BIgANgFsADy0LDw4nAg8EEC0IABAtCgoRLQoJEgAIAA8AJQAAM9YtAgAALQoRDQEiAA2AWwAKLQsKCS0IAQoAAAECAS4MgFYACi0IAQoAAAECAS4MgFkACi0IAQoAAAECAScCDQB/LQ4NCi0IAQoAAAECAScCDQCALQ4NCh4CAAoAHgIADQAzKgAKAA0ADyQCAA8AAAuoJQAAM6AtCAEKAAABAgEnAg8BAC0IAQ0nAhAEIQAIARABJwMNBAEAIg0CECcCEQQgQwOiAAyAVQARAA8AECcCEAEALQgBDycCEQQhAAgBEQEnAw8EAQAiDwIRJwISBCBDA6IAC4BVABIAEAARJwIQArwnAhECaicCEgKbJwITAtMtCAEUJwIVBEUACAEVAScDFAQBACIUAhUtChUWLQ4QFgAiFgIWLQ4RFgAiFgIWLQ4SFgAiFgIWLQ4TFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWACIWAhYuDIBXABYAIhYCFi4MgFcAFgAiFgIWLgyAVwAWLQ4UCi4IgFgAByMAAA8tDSIAB4BgABAkAgAQAAAsVyMAAA9CLQsKDS4JgE4ACgAiCgIKLgYACoBOLQsNCgAiCgIKLQ4KDScCEAQRLQgAES0KDRIuCIBhABMuCIBYABQACAAQACUAADRNLQIAAC0KEgotChMPLQsKEAAiEAIQLQ4QCi4JgE4AEAAiEAIQLgYAEIBOLQgBECcCEQQJAAgBEQEnAxAEAQAiCgIRASCATgACABIAIhACE0A/ABMAEgARJwISBBMtCAATLQoNFC4IgGEAFS4IgE8AFgAIABIAJQAANE0tAgAALQoUCi0KFREtCwoNACINAg0tDg0KByIAEYBQAA0NIgANgFMAEiQCABIAABA3JQAANuUAIgoCEwAqEw0ULQsUEicCFAQEBioRFBUEKhUUFgIqERYTAyiAUAATABQPIgATgFAAFSQCABUAABB2JQAANvcFKIBeABQAFScCFwQACioXFBYkAgAWAAAQqgYqFRQZCyIAGYBeABgkAgAYAAAQqiUAADcJDSIAFYBgABYkAgAWAAAQyiMAABC/LgiAWAAHIwAAENgaKhIVDy0KDwcjAAAQ2A0iABSAUAASJAIAEgAAEPgjAAAQ7S4IgFgADyMAABEGGCoHFRItChIPIwAAEQYDKIBSABMAEg8iABOAUgAUJAIAFAAAESMlAAA29w0iABKAUAATJAIAEwAAEUMjAAAROC4IgFgAByMAABGFBSiAXgASABMnAhUEAAoqFRIUJAIAFAAAEXcGKhMSFwsiABeAXgAWJAIAFgAAEXclAAA3CRgqCBMSLQoSByMAABGFACoPBxQOKg8UFSQCABUAABGcJQAANxsuAgAKgAMoAIAEBAARJQAANy0uCIAFAAcAIgcCDwAqDw0VLQ4UFQ0iABGAUQAKJAIACgAAEh0jAAAR1y0LBwoAIgoCCi0OCgctCAEKJwINBAkACAENAScDCgQBACIHAg0AIhACDwAiCgIRQD8AEQAPAA0tCgoSLgiAWAATIwAAEkQBIgARgFsACg4qEQoNJAIADQAAEjclAAA3Gy0KEBItCgoTIwAAEkQtCxINACINAg0tDg0SLQsHDQAiDQINLQ4NBycCDwQULQgAFC0KBxUtChMWLgiAYQAXAAgADwAlAAA3uy0CAAAtChUNJwIPBBMtCAATLQoNFC0KEhUACAAPACUAADs1LQIAAC0KFAcnAg8EEC0IABAtCgcRAAgADwAlAAA87y0CAAAtChENJwIPBBAtCAAQLQoFES0KAhIACAAPACUAADGmLQIAAC0KEQcnAhAEES0IABEtCgcSLgiAXQATLgiAVgAUAAgAEAAlAAAx8S0CAAAtChIPHgIABwAzKgAPAAcAECQCABAAABMxJQAAM8QvCIBcAAcvCgADAA8tCAEQJwIRBAIACAERAScDEAQBACIQAhEtChESLQ4OEicCEQAULQgBEicCEwQCAAgBEwEnAxIEAQAiEgITLQoTFC0OERQnAhMEFC0IABQtChIVLQoQFgAIABMAJQAAMaYtAgAALQoVEScCEgQTLQgAEy0KERQuCIBdABUuCIBWABYACAASACUAADHxLQIAAC0KFBAeAgARAx4CABIAHgIAEwQtCAEUJwIVBOEACAEVAScDFAQBACIUAhUnAhYE4AAqFhUWLQoVFwwqFxYYFgoYGCQCABgAABQmLgyAVwAXACIXAhcjAAAUBS0IARUAAAECAS0OFBUnAhYBAC0IARQnAhcEIQAIARcBJwMUBAEAIhQCFycCGAQgQwOiAA+AVQAYABYAFycCFgEALQgBDycCFwQhAAgBFwEnAw8EAQAiDwIXJwIYBCBDA6IAEYBVABgAFgAXJwIWAQAtCAERJwIXBCEACAEXAScDEQQBACIRAhcnAhgEIEMDogASgFUAGAAWABcnAhYBAC0IARInAhcEIQAIARcBJwMSBAEAIhICFycCGAQgQwOiABOAVQAYABYAFycCFgEALQgBEycCFwQhAAgBFwEnAxMEAQAiEwIXJwIYBCBDA6IADYBVABgAFgAXJwIWAQAtCAENJwIXBCEACAEXAScDDQQBACINAhcnAhgEIEMDogAQgFUAGAAWABcnAhYBAC0IARAnAhcEIQAIARcBJwMQBAEAIhACFycCGAQgQwOiAAmAVQAYABYAFycCFgRgJwIXBKAnAhgEwC4IgFgACiMAABWWDSIACoBgABkkAgAZAAAqMCMAABWrLQsVDS4JgE4ADwAiDwIPLgYAD4BOLQgBDwAAAQIBLgyATgAPLgiAWAAKIwAAFdoNIgAKgFIAECQCABAAACmRIwAAFe8tCw8QJwISBBktCAAZLQoNGi4IgGMAGy0KGBwACAASACUAAD47LQIAAC0KGg8tChsRLQsPDQAiDQINLQ4NDwciABGAUAANDSIADYBTABIkAgASAAAWSiUAADblACIPAhMAKhMNFC0LFBInAhQEBAYqERQVBCoVFBYCKhEWEwMogFAAEwAUDyIAE4BQABUkAgAVAAAWiSUAADb3BSiAXgAUABUnAhcEAAoqFxQWJAIAFgAAFr0GKhUUGQsiABmAXgAYJAIAGAAAFr0lAAA3CQ0iABWAYAAWJAIAFgAAFt0jAAAW0i4IgFgACiMAABbrGioSFRYtChYKIwAAFusNIgAUgFAAFiQCABYAABcLIwAAFwAuCIBYABIjAAAXGRgqChUULQoUEiMAABcZAyiAUgATABQPIgATgFIAFSQCABUAABc2JQAANvcNIgAUgFAAEyQCABMAABdWIwAAF0suCIBYAAojAAAXmAUogF4AFAATJwIWBAAKKhYUFSQCABUAABeKBioTFBgLIgAYgF4AFyQCABcAABeKJQAANwkYKggTFC0KFAojAAAXmAAqEgoVDioSFRYkAgAWAAAXryUAADcbLgIAD4ADKACABAQAESUAADctLgiABQAKACIKAhIAKhINFi0OFRYNIgARgFEADSQCAA0AABgwIwAAF+otCwoNACINAg0tDg0KLQgBDScCDwQJAAgBDwEnAw0EAQAiCgIPACIQAhEAIg0CEkA/ABIAEQAPLQoNEy4IgFgAFCMAABhXASIAEYBbAA0OKhENDyQCAA8AABhKJQAANxstChATLQoNFCMAABhXLQsTDQAiDQINLQ4NEy0LCg0AIg0CDS0ODQonAg8EFS0IABUtCgoWLQoUFy4IgGMAGAAIAA8AJQAAN7stAgAALQoWDScCDwQULQgAFC0KDRUtChMWAAgADwAlAAA7NS0CAAAtChUKJwIPBBAtCAAQLQoKEQAIAA8AJQAAPO8tAgAALQoRDS0IAQonAg8EAwAIAQ8BJwMKBAEAIgoCDy0KDxAtDg0QACIQAhAtDg4QJwIOAAUtCAEPJwIQBAIACAEQAScDDwQBACIPAhAtChARLQ4OEScCEAQRLQgAES0KDxItCgoTAAgAEAAlAAAvcy0CAAAtChIOJwIPBBAtCAAQLQoOES4IgFIAEi4IgFYAEwAIAA8AJQAAL9MtAgAALQoRCh4CAA4AMyoACgAOAA8LIgAPgFYADiQCAA4AABmaJQAAQNMcCgkPBRwKDw4AHAoOCQU1KgANAAkADiQCAA4AABm+JQAAQOU0AgAKKQIACQBFG1+uJwINBAMnAg8EAwAqDQ8OLQgBCgAIAQ4BJwMKBAEAIgoCDi0ODQ4AIg4CDi0ODQ4nAg4EAwAqCg4NLQoNDi0OCQ4AIg4CDi0ODA4AIg4CDi0OCw4AIgoCDC0LDAsnAg0EAgAqDA0JOQOggEWARQAHAAsACSACAAchAgAJLQgBCwAiCwIOLQsODScCDwQCACoODwwiMgAJgFgADC0KCQ0nAg8EAwAqDQ8OAAgBDgEnAwsEAQAiCwIPLQ4NDwAiDwIPLQ4NDy0KDQoGIgoCCiQCAAcAABrOIwAAGqUtCwsHACIHAgctDgcLACILAgwtCwwJJwINBAIAKgwNBzwOCQcjAAAazgsiAAqAWAAHJAIABwAAGucnAgkEADwGCQEAIgQCCi0LCgknAgsEAgAqCgsHOw4ACQAHIwAAGwUpAgAHAP0Veh8KKgEHCSQCAAkAABsgIwAAJrwtCAEJJwIKBAUACAEKAScDCQQBACIJAgofMIBQgFsACi0IAQoAAAECAS0OCQotCAEJAAABAgEuDIBYAAknAgwEDS0IAA0tCgoOLQoJDwAIAAwAJQAAM9YtAgAALQoOCwEiAAuAWwANLQsNDCcCDQQOLQgADi0KCg8tCgkQAAgADQAlAAAz1i0CAAAtCg8LASIAC4BbAA4tCw4NHAoNDgYcCg4LACcCDgQPLQgADy0KChAtCgkRAAgADgAlAAAz1i0CAAAtChANASIADYBbAA8tCw8OJwIPBBAtCAAQLQoKES0KCRIACAAPACUAADPWLQIAAC0KEQ0BIgANgFsACi0LCgkeAgAKAB4CAA0AMyoACgANAA8kAgAPAAAcQSUAADOgJwINBA8tCAAPLQoFEC0KAhEACAANACUAADGmLQIAAC0KEAonAgUEDy0IAA8tCgoQLgiAXQARLgiAVgASAAgABQAlAAAx8S0CAAAtChACHgIABQAzKgACAAUACiQCAAoAABypJQAAM8QvCIBcAAIvCgADAAUtCAEDAAABAgEnAg0BAC0IAQonAg8EIQAIAQ8BJwMKBAEAIgoCDycCEAQgQwOiAAyAVQAQAA0ADycCDQEALQgBDCcCDwQhAAgBDwEnAwwEAQAiDAIPJwIQBCBDA6IAC4BVABAADQAPJwIPAQAtCAENJwIQBCEACAEQAScDDQQBACINAhAnAhEEIEMDogAOgFUAEQAPABAnAg4CaScCDwIyJwIQAo0nAhEC7C0IARInAhMEZQAIARMBJwMSBAEAIhICEy0KExQtDg4UACIUAhQtDg8UACIUAhQtDhAUACIUAhQtDhEUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAUACIUAhQuDIBXABQAIhQCFC4MgFcAFAAiFAIULgyAVwAULQ4SAy4IgFgAByMAACHJDSIAB4BgAA4kAgAOAAAoiCMAACHeLQsDBy4JgE4AAwAiAwIDLgYAA4BOLQsHAwAiAwIDLQ4DBycCDAQNLQgADS0KBw4uCIBiAA8uCIBYABAACAAMACUAAED3LQIAAC0KDgMtCg8KLQsDDAAiDAIMLQ4MAy4JgE4ADAAiDAIMLgYADIBOLQgBDCcCDQQJAAgBDQEnAwwEAQAiAwINASCATgACAA4AIgwCD0A/AA8ADgANJwIOBA8tCAAPLQoHEC4IgGIAES4IgE8AEgAIAA4AJQAAQPctAgAALQoQAy0KEQ0tCwMHACIHAgctDgcDByIADYBQAAcNIgAHgFMADiQCAA4AACLTJQAANuUAIgMCDwAqDwcQLQsQDicCEAQEBioNEBEEKhEQEgIqDRIPAyiAUAAPABAPIgAPgFAAESQCABEAACMSJQAANvcFKIBeABAAEScCEwQACioTEBIkAgASAAAjRgYqERAVCyIAFYBeABQkAgAUAAAjRiUAADcJDSIAEYBgABIkAgASAAAjZiMAACNbLgiAWAAGIwAAI3QaKg4RCi0KCgYjAAAjdA0iABCAUAAOJAIADgAAI5QjAAAjiS4IgFgACiMAACOiGCoGEQ4tCg4KIwAAI6IDKIBSAA8ADg8iAA+AUgAQJAIAEAAAI78lAAA29w0iAA6AUAAPJAIADwAAI98jAAAj1C4IgFgABiMAACQhBSiAXgAOAA8nAhEEAAoqEQ4QJAIAEAAAJBMGKg8OEwsiABOAXgASJAIAEgAAJBMlAAA3CRgqCA8OLQoOBiMAACQhACoKBg8OKgoPECQCABAAACQ4JQAANxsuAgADgAMoAIAEBAARJQAANy0uCIAFAAYAIgYCCgAqCgcQLQ4PEA0iAA2AUQADJAIAAwAAJLkjAAAkcy0LBgMAIgMCAy0OAwYtCAEDJwIHBAkACAEHAScDAwQBACIGAgcAIgwCCgAiAwINQD8ADQAKAActCgMILgiAWAAOIwAAJOABIgANgFsAAw4qDQMHJAIABwAAJNMlAAA3Gy0KDAgtCgMOIwAAJOAtCwgDACIDAgMtDgMILQsGAwAiAwIDLQ4DBicCBwQPLQgADy0KBhAtCg4RLgiAYgASAAgABwAlAAA3uy0CAAAtChADJwIHBAwtCAAMLQoDDS0KCA4ACAAHACUAADs1LQIAAC0KDQYnAgcEDC0IAAwtCgYNAAgABwAlAAA87y0CAAAtCg0DOAoABQADHgIAAwEpAgAFAMYRsMUnAgcEBCcCCgQDACoHCggtCAEGAAgBCAEnAwYEAQAiBgIILQ4HCAAiCAIILQ4HCCcCCAQDACoGCActCgcILQ4FCAAiCAIILQ4DCAAiCAIILQ4LCAAiCAIILQ4JCAAiBgIHLQsHBScCCAQCACoHCAM5A6CARYBFAAIABQADIAIAAiECAAMtCAEGACIGAgktCwkIJwIKBAIAKgkKByIyAAOAWAAHLQoDCCcCCgQDACoICgkACAEJAScDBgQBACIGAgotDggKACIKAgotDggKLQoIBQYiBQIFJAIAAgAAJoUjAAAmXC0LBgIAIgICAi0OAgYAIgYCBy0LBwMnAggEAgAqBwgCPA4DAiMAACaFCyIABYBYAAIkAgACAAAmnicCAwQAPAYDAQAiBAIFLQsFAycCBgQCACoFBgI7DgADAAIjAAAmvCcCAgJVJwIDAm4nAgQCaycCBQJvJwIGAncnAgcCICcCCAJzJwIJAmUnAgoCbCcCCwJjJwIMAnQnAg0CcicCDgJ7JwIPAn0tCAEQJwIRBBwACAERAScDEAQBACIQAhEtChESLQ4CEgAiEgISLQ4DEgAiEgISLQ4EEgAiEgISLQ4DEgAiEgISLQ4FEgAiEgISLQ4GEgAiEgISLQ4DEgAiEgISLQ4HEgAiEgISLQ4IEgAiEgISLQ4JEgAiEgISLQ4KEgAiEgISLQ4JEgAiEgISLQ4LEgAiEgISLQ4MEgAiEgISLQ4FEgAiEgISLQ4NEgAiEgISLQ4HEgAiEgISLQ4OEgAiEgISLQ4IEgAiEgISLQ4JEgAiEgISLQ4KEgAiEgISLQ4JEgAiEgISLQ4LEgAiEgISLQ4MEgAiEgISLQ4FEgAiEgISLQ4NEgAiEgISLQ4PEgsggFaAWgACJAIAAgAAKIgnAgMEHi0IAQQnAgUEHgAIAQUBLQoEBSoDAAUFkZtcoj4gnpYAIgUCBQAiEAIGJwIHBBsuAgAGgAMuAgAFgAQuAgAHgAUlAABDjycCBgQbACoFBgUuDIBcAAUAIgUCBS0OAQUAIgUCBTwOAwQBIgAHgFAADgAiCgIQACoQBxEtCxEPLQsDEA0iAA6AYgARJAIAEQAAKLclAAA25S4CABCAAygAgAQEAGUlAAA3LS4IgAUAEQAiEQISACoSDhMtDg8TACoHBg4AIgwCEAAqEAcSLQsSDw0iAA6AYgAQJAIAEAAAKQUlAAA25S4CABGAAygAgAQEAGUlAAA3LS4IgAUAEAAiEAISACoSDhMtDg8TASIAB4BhAA4AIg0CEQAqEQcSLQsSDw0iAA6AYgARJAIAEQAAKVYlAAA25S4CABCAAygAgAQEAGUlAAA3LS4IgAUAEQAiEQISACoSDhMtDg8TLQ4RAwEiAAeAWwAOLQoOByMAACHJLQsNEAAiEAIQLQ4QDQUogE8ACgAQJwITBBktCAAZLQoNGi4IgGMAGy0KEBwACAATACUAAD47LQIAAC0KGhEtChsSLQsREAAiEAIQLQ4QES0LDxAtCxATACITAhMtDhMQLQgBEycCFAQJAAgBFAEnAxMEAQAiEQIUACIQAhUAIhMCFkA/ABYAFQAULQ4TDwEiAAqAWwAQLQoQCiMAABXaACIUAhoAKhoKGy0LGxktCxUaLgIAGoADKACABAQA4SUAADctLgiABQAbACIbAhwAKhwKHS0OGR0BIgAKgGAAGQAiDwIcACocCh0tCx0aDSIAGYBjABwkAgAcAAAqkyUAADblLgIAG4ADKACABAQA4SUAADctLgiABQAcACIcAh0AKh0ZHi0OGh4BIgAKgE8AGQAiEQIbACobCh0tCx0aDSIAGYBjABskAgAbAAAq5CUAADblLgIAHIADKACABAQA4SUAADctLgiABQAbACIbAh0AKh0ZHi0OGh4AKgoWGQAiEgIcACocCh0tCx0aDSIAGYBjABwkAgAcAAArMiUAADblLgIAG4ADKACABAQA4SUAADctLgiABQAcACIcAh0AKh0ZHi0OGh4AKgoIGQAiEwIbACobCh0tCx0aDSIAGYBjABskAgAbAAArgCUAADblLgIAHIADKACABAQA4SUAADctLgiABQAbACIbAh0AKh0ZHi0OGh4AKgoXGQAiDQIcACocCh0tCx0aDSIAGYBjABwkAgAcAAArziUAADblLgIAG4ADKACABAQA4SUAADctLgiABQAcACIcAh0AKh0ZHi0OGh4AKgoYGQAiEAIbACobCh0tCx0aDSIAGYBjABskAgAbAAAsHCUAADblLgIAHIADKACABAQA4SUAADctLgiABQAbACIbAh0AKh0ZHi0OGh4tDhsVASIACoBbABktChkKIwAAFZYBIgAHgFAAEAAiDQISACoSBxMtCxMRLQsKEg0iABCAYQATJAIAEwAALIYlAAA25S4CABKAAygAgAQEAEUlAAA3LS4IgAUAEwAiEwIUACoUEBUtDhEVACoHBhAAIg8CEgAqEgcULQsUEQ0iABCAYQASJAIAEgAALNQlAAA25S4CABOAAygAgAQEAEUlAAA3LS4IgAUAEgAiEgIUACoUEBUtDhEVLQ4SCgEiAAeAWwAQLQoQByMAAA8tHAoDBgABKIBcAAYACAAiBwIJACoJAwotCwoGMAoABgAIASIAA4BbAAYtCgYDIwAACFwoAIAEBHgADQAAAIAEgAMkAIADAAAtaSoBAAEF96Hzr6Wt1Mo8BAIBJiUAAC1BLQsCAy0LAQQNIgADgF0ABSQCAAUAAC2MJQAANuUAIgQCBgAqBgMHLQsHBS0IAQYnAgcEAgAIAQcBJwMGBAEAIgYCBy0KBwgtDgUIASIAA4BbAAUOKgMFByQCAAcAAC3UJQAANxstDgQBLQ4FAi0KBgEmJQAALUEtCwQGCyIABoBWAAckAgAHAAAuAycCCAQAPAYIAS0LAwYLIgAGgFIAByQCAAcAAC6QIwAALhwtCwEHLQsCCA0iAAaAUgAJJAIACQAALjklAAA25S4CAAeAAygAgAQEAAQlAAA3LS4IgAUACQAiCQIKACoKBgstDgULASIABoBbAAUOKgYFByQCAAcAAC55JQAANxstDgkBLQ4IAi0OBQMuDIBWAAQjAAAu/icCBgQHLQgABy0KAQgtCgIJLQoDCi0KBAsACAAGACUAAEPVLQIAAC0LAQYtCwIHLQsECC4CAAaAAygAgAQEAAQlAAA3LS4IgAUACQEiAAmAWwAKLQ4FCi0OCQEtDgcCLgyAWwADLQ4IBCMAAC7+JiUAAC1BLQsEBQsiAAWAVgAGJAIABgAALyEnAgcEADwGBwEnAgUEBi0IAAYtCgEHLQoCCC0KAwktCgQKAAgABQAlAABD1S0CAAAtCwEFLQsCBi0LAwctDgUBLQ4GAi0OBwMuDIBaAAQBIgAGgFsAAi0LAgEmJQAALUEBIgABgFsABC0LBAMBIgACgFsABC0LBAEBIgACgF0ABS0LBQQtCAECJwIFBAQACAEFAScDAgQBACICAgUtCgUGLQ4DBgAiBgIGLQ4BBgAiBgIGLQ4EBi0KAgEmJQAALUEcCgIFAAUiAAWAZAAGLQgBBScCBwQEAAgBBwEnAwUEAQAiBQIHLQoHCC4MgFkACAAiCAIILgyAWQAIACIIAgguDIBZAAgtCAEHJwIIBAUACAEIAScDBwQBACIHAggtCggJLgyAWQAJACIJAgkuDIBZAAkAIgkCCS4MgFkACQAiCQIJLQ4GCS0IAQYAAAECAS0OBQYtCAEFAAABAgEtDgcFLQgBBwAAAQIBLgyAWAAHLQgBCAAAAQIBLgyAVgAILgiAWAAEIwAAMKENIgAEgFIACSQCAAkAADEhIwAAMLYkAgADAAAwwyMAADD1JwIBBAktCAAJLQoGCi0KBQstCgcMLQoIDS4IgFwADgAIAAEAJQAALeEtAgAAIwAAMPUnAgIECS0IAAktCgYKLQoFCy0KBwwtCggNAAgAAgAlAAAu/y0CAAAtCgoBJgwqBAIJJAIACQAAMTMjAAAxcQAiAQIKACoKBAstCwsJJwIKBAstCAALLQoGDC0KBQ0tCgcOLQoIDy0KCRAACAAKACUAAC3hLQIAACMAADFxASIABIBbAAktCgkEIwAAMKEqAQABBfSAAaZZ0ydCPAQCASYqAQABBR8AUBJAJCLuPAQCASYlAAAtQQEiAAGAWwAELQsEAwEiAAKAWwAELQsEAS0IAQInAgQEAwAIAQQBJwMCBAEAIgICBC0KBAUtDgMFACIFAgUtDgEFLQoCASYlAAAtQRwKAgUABSIABYBkAAYtCAEFJwIHBAQACAEHAScDBQQBACIFAgctCgcILgyAWQAIACIIAgguDIBZAAgAIggCCC4MgFkACC0IAQcnAggEBQAIAQgBJwMHBAEAIgcCCC0KCAkuDIBZAAkAIgkCCS4MgFkACQAiCQIJLgyAWQAJACIJAgktDgYJLQgBBgAAAQIBLQ4FBi0IAQUAAAECAS0OBwUtCAEHAAABAgEuDIBYAActCAEIAAABAgEuDIBWAAguCIBYAAQjAAAyvw0iAASAXQAJJAIACQAAMz8jAAAy1CQCAAMAADLhIwAAMxMnAgEECS0IAAktCgYKLQoFCy0KBwwtCggNLgiAXAAOAAgAAQAlAAAt4S0CAAAjAAAzEycCAgQJLQgACS0KBgotCgULLQoHDC0KCA0ACAACACUAAC7/LQIAAC0KCgEmDCoEAgkkAgAJAAAzUSMAADOPACIBAgoAKgoECy0LCwknAgoECy0IAAstCgYMLQoFDS0KBw4tCggPLQoJEAAIAAoAJQAALeEtAgAAIwAAM48BIgAEgFsACS0KCQQjAAAyvyoBAAEFvh4//z6k9vo8BAIBJioBAAEF12M4sTxmeyc8BAIBJioBAAEFI2UAGYKJ9ew8BAIBJiUAAC1BLQsCAy0LAQQNIgADgFAABSQCAAUAADP4JQAANuUAIgQCBgAqBgMHLQsHBS0IAQYnAgcEAgAIAQcBJwMGBAEAIgYCBy0KBwgtDgUIASIAA4BbAAUOKgMFByQCAAcAADRAJQAANxstDgQBLQ4FAi0KBgEmJQAALUEtCAEFJwIGBBEACAEGAScDBQQBACIFAgYnAgcEEAAqBwYHLQoGCAwqCAcJFgoJCSQCAAkAADSZLgyAWAAIACIIAggjAAA0eC0IAQYAAAECAS0OBQYMKgIDBSQCAAUAADUYIwAANLgBIgADgE8ABw4qAwcIJAIACAAANNIlAAA3GwwqAgcIJAIACAAANO8jAAA05C4IgE8ABSMAADUPAioCAwcOKgMCCCQCAAgAADUGJQAANvctCgcFIwAANQ8tCgUEIwAANSMuCIBYAAQjAAA1IwEiAASAUAAFDioEBQckAgAHAAA1PSUAADcbAyIABYBbAAcPKIBbAAUACCQCAAgAADVaJQAANvcHIgAHgFAABS4IgFgAAiMAADVtDCoCBQckAgAHAAA1iCMAADV/LQsGAS0KBAImLQgBCAAAAQIBLgyAWAAIBSIAAoBQAAkHIgAJgFAACwoqCwIKJAIACgAANbklAAA3CS4IgFgAByMAADXEDSIAB4BQAAokAgAKAAA2MSMAADXZLQsIBy0LBggNIgACgFMACSQCAAkAADX2JQAANuUuAgAIgAMoAIAEBAARJQAANy0uCIAFAAkAIgkCCgAqCgILLQ4HCy0OCQYBIgACgFsABy0KBwIjAAA1bQAqCQcLDioJCwwkAgAMAAA2SCUAADcbDCoLBAwkAgAMAAA2ZSMAADZaLgiAVwAKIwAANqgAKgMLDA4qAwwNJAIADQAANnwlAAA3Gw0iAAyAYQALJAIACwAANpElAAA25QAiAQINACoNDA4tCw4LLQoLCiMAADaoLQsICxkiAAuAXgAMHAoKCwQAKgwLCg4qDAoNJAIADQAANtAlAAA3Gy0OCggBIgAHgFsACi0KCgcjAAA1xCoBAAEFxWvEWg4QAAI8BAIBJioBAAEFKIaSsEfc/UM8BAIBJioBAAEFZGGIqMbPlMs8BAIBJioBAAEFRafKcRlB5BU8BAIBJi4BgAOABgsAgAYAAoAHJACABwAAN0gjAAA3Uy4AgAOABSMAADe6LgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAAN6YuAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAAN3UoAYAFBAABAwCABgACgAYjAAA3uiYlAAAtQS0IAQQAAAECAS0OAQQtCAEFAAABAgEtDgIFJwIHBAQGKgIHCAQqCAcJAioCCQYLIgAGgFgAByQCAAcAADklIwAAOAMHIgACgFAACAMogFAABgAJDyIABoBQAAokAgAKAAA4KCUAADb3DSIACIBTAAYkAgAGAAA4PSUAADblACIBAgoAKgoICy0LCwYFKIBeAAkACicCDAQACioMCQskAgALAAA4fwYqCgkOCyIADoBeAA0kAgANAAA4fyUAADcJDSIACoBgAAskAgALAAA4nyMAADiULgiAWAAHIwAAOK0aKgYKCy0KCwcjAAA4rQ0iAAmAUAALJAIACwAAOM0jAAA4wi4IgFgABiMAADjbGCoHCgstCgsGIwAAONsuAgABgAMoAIAEBAARJQAANy0uCIAFAAcAIgcCCgAqCggLLQ4GCy0OBwQAKgIJAQ4qAgEGJAIABgAAORwlAAA3Gy0OAQUjAAA5JS0LBQIHIgACgFAABS0KBQEjAAA5Og0iAAGAVAACJAIAAgAAOt8jAAA5TwUogF4AAwABJwIFBAAKKgUDAiQCAAIAADmDBioBAwcLIgAHgF4ABiQCAAYAADmDJQAANwkcCgECACcCAwEALQgBAScCBQQJAAgBBQEnAwEEAQAiAQIFJwIGBAhDA6IAAoBVAAYAAwAFASIAAYBbAAMtCwMCHAoCAwQnAgIEGBgqAwIFASIAAYBdAAYtCwYDHAoDBgQZIgAGgFMAAxIqBQMGASIAAYBSAAUtCwUDHAoDBQQZIgAFgF4AAxIqBgMFASIAAYBQAAYtCwYDHAoDBgQSKgUGAy0LBAUuAgAFgAMoAIAEBAARJQAANy0uCIAFAAYBIgAGgF8ABy0OAwcBIgABgEQABS0LBQMcCgMFBBgqBQIDASIAAYBDAAUtCwUCHAoCBQQZIgAFgFMAAhIqAwIFJwICBAcAKgECBy0LBwMcCgMCBBkiAAKAXgADEioFAwIBIgABgF4ABS0LBQMcCgMBBBIqAgEDLgIABoADKACABAQAESUAADctLgiABQABASIAAYBTAAItDgMCLQ4BBCYtCwQCDSIAAYBTAAUkAgAFAAA6+CUAADblLgIAAoADKACABAQAESUAADctLgiABQAFACIFAgYAKgYBBy4MgFgABy0OBQQBIgABgFsAAi0KAgEjAAA5OiUAAC1BLQgBBAAAAQIBLQgBBScCBgQhAAgBBgEnAwUEAQAiBQIGJwIHBCAAKgcGBy0KBggMKggHCRYKCQkkAgAJAAA7ii4MgFcACAAiCAIIIwAAO2ktCAEGAAABAgEtDgUGLQsCBQAiBQIFLQ4FAi0IAQUnAgcECQAIAQcBJwMFBAEAIgECBwAiAgIIACIFAglAPwAJAAgABy0OBQQuCIBYAAMjAAA73Q0iAAOAXgABJAIAAQAAO/cjAAA78i0LBgEmLQsEAgAiAgIHACoHAwgtCwgFHAoFAgAnAgcBAC0IAQUnAggEBQAIAQgBJwMFBAEAIgUCCCcCCQQEQwOiAAKAVQAJAAcACAUogFAAAwACLgiAWAABIwAAPFANIgABgFAAByQCAAcAADx2IwAAPGUBIgADgFsAAS0KAQMjAAA73QAqAgEHDioCBwgkAgAIAAA8jSUAADcbACIFAgkAKgkBCi0LCggtCwYJDSIAB4BgAAokAgAKAAA8tCUAADblLgIACYADKACABAQAISUAADctLgiABQAKACIKAgsAKgsHDC0OCAwtDgoGASIAAYBbAActCgcBIwAAPFAlAAAtQS0IAQMAAAECAS4MgFwAAy0IAQQAAAECAS4MgFkABC0IAQUAAAECAS4MgFkABScCBgQeKAIABwABAC4IgFgAAiMAAD04DSIAAoBfAAgkAgAIAAA9hyMAAD1NLQsFAgEiAAGAUwAHLQsHBhwKBgEALQsDBgQqAQYDACoCAwEtDgEFLQsEAgQqAgYDACoBAwItCgIBJi0LBQgCKgYCCQ0iAAmAYAAKJAIACgAAPaUlAAA25QAiAQILACoLCQwtCwwKHAoKCQAtCwMKBCoJCgsAKggLCS0OCQUEKgoHCC0OCAMtCwQJAyiAVAACAAoPIgACgFQACyQCAAsAAD30JQAANvcNIgAKgGAACyQCAAsAAD4JJQAANuUAIgECDAAqDAoNLQsNCxwKCwoABCoKCAsAKgkLCC0OCAQBIgACgFsACC0KCAIjAAA9OCUAAC1BLQgBBScCBgQRAAgBBgEnAwUEAQAiBQIGJwIHBBAAKgcGBy0KBggMKggHCRYKCQkkAgAJAAA+hy4MgFgACAAiCAIIIwAAPmYtCAEGAAABAgEtDgUGDCoCAwUkAgAFAAA/BiMAAD6mASIAA4BPAAcOKgMHCCQCAAgAAD7AJQAANxsMKgIHCCQCAAgAAD7dIwAAPtIuCIBPAAUjAAA+/QIqAgMHDioDAggkAgAIAAA+9CUAADb3LQoHBSMAAD79LQoFBCMAAD8RLgiAWAAEIwAAPxEBIgAEgFAABQ4qBAUHJAIABwAAPyslAAA3GwMiAAWAWwAHDyiAWwAFAAgkAgAIAAA/SCUAADb3ByIAB4BQAAUuCIBYAAIjAAA/WwwqAgUHJAIABwAAP3YjAAA/bS0LBgEtCgQCJi0IAQgAAAECAS4MgFgACAUiAAKAUAAJByIACYBQAAsKKgsCCiQCAAoAAD+nJQAANwkuCIBYAAcjAAA/sg0iAAeAUAAKJAIACgAAQB8jAAA/xy0LCActCwYIDSIAAoBTAAkkAgAJAAA/5CUAADblLgIACIADKACABAQAESUAADctLgiABQAJACIJAgoAKgoCCy0OBwstDgkGASIAAoBbAActCgcCIwAAP1sAKgkHCw4qCQsMJAIADAAAQDYlAAA3GwwqCwQMJAIADAAAQFMjAABASC4IgFcACiMAAECWACoDCwwOKgMMDSQCAA0AAEBqJQAANxsNIgAMgGMACyQCAAsAAEB/JQAANuUAIgECDQAqDQwOLQsOCy0KCwojAABAli0LCAsZIgALgF4ADBwKCgsEACoMCwoOKgwKDSQCAA0AAEC+JQAANxstDgoIASIAB4BbAAotCgoHIwAAP7IqAQABBWG+R1VrE4CRPAQCASYqAQABBbh6OUSzsTxWPAQCASYlAAAtQS0IAQUnAgYEEQAIAQYBJwMFBAEAIgUCBicCBwQQACoHBgctCgYIDCoIBwkWCgkJJAIACQAAQUMuDIBYAAgAIggCCCMAAEEiLQgBBgAAAQIBLQ4FBgwqAgMFJAIABQAAQcIjAABBYgEiAAOATwAHDioDBwgkAgAIAABBfCUAADcbDCoCBwgkAgAIAABBmSMAAEGOLgiATwAFIwAAQbkCKgIDBw4qAwIIJAIACAAAQbAlAAA29y0KBwUjAABBuS0KBQQjAABBzS4IgFgABCMAAEHNASIABIBQAAUOKgQFByQCAAcAAEHnJQAANxsDIgAFgFsABw8ogFsABQAIJAIACAAAQgQlAAA29wciAAeAUAAFLgiAWAACIwAAQhcMKgIFByQCAAcAAEIyIwAAQiktCwYBLQoEAiYtCAEIAAABAgEuDIBYAAgFIgACgFAACQciAAmAUAALCioLAgokAgAKAABCYyUAADcJLgiAWAAHIwAAQm4NIgAHgFAACiQCAAoAAELbIwAAQoMtCwgHLQsGCA0iAAKAUwAJJAIACQAAQqAlAAA25S4CAAiAAygAgAQEABElAAA3LS4IgAUACQAiCQIKACoKAgstDgcLLQ4JBgEiAAKAWwAHLQoHAiMAAEIXACoJBwsOKgkLDCQCAAwAAELyJQAANxsMKgsEDCQCAAwAAEMPIwAAQwQuCIBXAAojAABDUgAqAwsMDioDDA0kAgANAABDJiUAADcbDSIADIBiAAskAgALAABDOyUAADblACIBAg0AKg0MDi0LDgstCgsKIwAAQ1ItCwgLGSIAC4BeAAwcCgoLBAAqDAsKDioMCg0kAgANAABDeiUAADcbLQ4KCAEiAAeAWwAKLQoKByMAAEJuAQCAA4AFgAcuAIADgAguAIAEgAkLAIAIgAeACiQAgAoAAEPULgGACIAGLgSABoAJAQCACAACgAgBAIAJAAKACSMAAEOjJiUAAC1BLgiAWAAFIwAAQ+UNIgAFgFIABiQCAAYAAERQIwAAQ/otCwIFLQsFBgAiBgIGLQ4GBS0IAQYnAgcEBQAIAQcBJwMGBAEAIgUCBycCCAQEACIGAgk/DwAHAAktCwEFLQsDBy0LBAgtDgUBLQ4GAi0OBwMtDggEJi0LAwYMKgUGByQCAAcAAERmIwAARM4tCwIHACIHAgkAKgkFCi0LCggtCwEJACIJAgsAKgsFDC0LDAoAKggKCy0LBAguAgAHgAMoAIAEBAAFJQAANy0uCIAFAAoAIgoCDAAqDAUNLQ4LDS0OCQEtDgoCLQ4GAy0OCAQjAABEzgEiAAWAWwAGLQoGBSMAAEPl",
      "debug_symbols": "tZ3briS3zbbvZY5zUNpTuZUgCJzECQwYduA4P/AjyL1/pZcSX84atLq6Vs+J1zN0NbWlNqRK9d8vf//xr//5519++uUfv/77yx//9N8vf/3tp59//umff/n517/98PtPv/5ySv/75Rj/yZK//DH84Uvuaf6VL38sf/hSjjj/Nv0b5r/D/Hec/45V/6bz3238bfo3h/m36t8y/13mv+v8dy3zb//yRzn/tjz/zn/L/LeI/h35xF/9dz3S/Nv078gn/lb9G8P8O/+djvm36N9yPh+OAXXCyJnCkrQlaUuCWgsDZALqD9AU2hEW1AkjbyENaBNG7hTKgj4h5QVLktOC8fN6QikL1jN1/arKhLYSReYHyEpUlqQfC7IqlNH8Cucz8SyyhPNXMQ0oE+KxYEnSkqQlyaeemE8ox4I8oa7/NeoZMOpZYUhG6qOeFfqEUc+xD2gKfWRVYUnCkoQliaeedJaij26qUCfk9b+yTChpwZDEE0YOASOHCmcBUxnQJ4ysKixJX5I+JeEYWUx10KjFSeP/yiDkUumU5TgoJSNZlE2WTVZMNvpvhuZhU0otLRL7v3LmoARQXzSyPGnJzkSMTBaSkcmiPTe6waSVRhjjQRn5C6PdJ9VFzf5vM5mYTEw2OuqkJYtHMGqLQjSSRTEZjeeOQSkY1UX5MMpGfdGo50mmBSVSkkXNZM2ek/HbBJJF3WSjQ4MSSqRUjPqikIzsFxiNlUyWTAvKBkLZlLLRyksqpqXYL6r9olpemsmaaWmWPytlEstLt7x009LXL/KRjFZespUyo5R5EEqpVBehryllI1mU7RfZtBSTFdOCUlZQNuqLmsmaycRkaEtQj0ZtUkFbCqguCodRWRRNFk2WTIayKY3U+qAxCkxqi8YsO6ksQtmUKOuLxshQI0gWSTSqi7rJ+noOc+8kk4VoNH47WhBz8KS+aJSojjGxjjaqAhprh2EpmJVbALVFWCmARv9rSGMMw5P6otH/JrVFI/eTlgzz86ShZeSljZaZlI1kUTRZsueS/TabLNtzw7baKFsbJZIMqovGSD3JZM1kzWRyGJms23OjRCBM2pPG6mjkQEaNK42ZZJL932yybLJislH3StVk1Z7DSk3J0hhzitIYqSeN5xJIJnWs2pTaorHAmFQXDauYlI36IqzhlEyW7bmx4pAKKkZ9EUqk1Bah7pXsF81+gZWoksm6aUHZTooHWkGpLgqHUTayX0T7RWyLksnG6C1t0JhDJxWjvgjtptQWVftFNS3NZM20jFL2Y9CwnkmyqJusL1k4klFbNFpwUl00WnBSWTQspcdBI3+9gsYv+qCmK/QT8oI+YWTuXDABxbBHYlsYD5PGoHubGEdFK+C5MjAFYjUcWTxLBszEbliw3oey0gzHSmAhVv1p4CjRwmKoG4WhLCGvY5V94pCOpfOZsfHsWA/HNNYuC0fBI36WIB01k0bXWIhV/ajeVA5iIWKzAGU1EcVQtwwF2Ax126BYiN0Qm4eJJsXkvhDKRiazboUUq2E8iJQmPpuoIVOa+SxKnANwZDKPAmUUMyMP2MtNHD8bK7OYx4y3cNRDgQbs6SaatByJ2AxRoImURkpRIEV0uYnFEF1uopN2w8KEC7ODLjdWSic2QxRzYjUUSvs0hYpt6gDsPEcVVPQrJVmUTZZNVkxW5143YpZW0l4PykaySJLR3LvG2rPR3L2ephON6qIQjEwWD6O5h40tRSN7LttvczFaOWglGVkOqslqW6TVm4HdEGUqBSiG3X5vpRIrlVipJBxGK2dipZKYjaB6FEtQLMVsT1q5xMolVi7M6UrV8mDlwg58UjHVWixF9LAx+EgPxLoQm/GFlIZANA09Uhr5bKJUjUOxG2I8nkipjseKGCFHv8Qsr6MpJncdQjGnT4QjZ6yETxRDNNlYxUbM68B0qE9EsRkGSgOlkdJIKRpprHoTZvCF3bBkIqWV0kppoxTNUutA2PVEk4YjEilFs0yshpHSSGmiFM0ysRuiWSaKIZplIhOuzE5lEo1JND4rfFaot1NvtzzEw/IQYU0TLb+RZYssW0yRaAnHnIiWcCxMojDhyiQaE25MQpgwGyuysWK3JNKRiJZECpZwigfREk5sIWz4J+ZItIQTmyUVJlyZRGXCjUkIExYm0Zkwu1xml8OufmJIREsiR0sY+/mFlnDOgWgJYye/kAlXJlGZcGMSjQkLk+hMuFsS2L4vtCR0sp9oSZSYiJYEtu4T80G0hLFnX8iEaSI6rSs2JtGYsDAJYcLdkqjHQbQkKs2/Bkuixki0JHRJMNGSqLT5WphEYcKVSdDQa2MSNHRdEUxkwp1J0NCxY59IQ28cxBoNvUVLotHQW7IkGg1dVwKKNPRWmQQNvXG4ajT0xuGq0dAbh6tGQxcOV0JDFw5XQkMXDldCQxcOV0JDFw5XQkMXDldCQxcOV6LGcE6hSefu4ZQ5jXs80BKwGqJ+J448DHdH0rl7YjVEt28VWIjdEJmcSGnls40ampPyWaEG1LoiBqaJdWI+joNIaQhEaGgDtZiK1TBRmijNlGrZgOhGijDp1oHNEN1oYjEUSoXPdmroJg1HIBbiyIMcAzHoThRDGLqMmB8c9gvFECOtIsYoicBqWClFYw3fU8b+fSGlQin62fANZZ3GgXDjL+yGmPVEBmp+FZthohT9bGIxROdS1PwqohSjonTmHY6JnDCuD89Ehn/8zN5AzJB9ZCfhZ4qYUBRh8xNHzvpobp3f+kgtI7+KyO9ESpFfRQykE8VQEwaiwwxXScb0dbqZBo7pa6FJsVddKANHa5ZRqRNHB19YDUcmFzbDTGnGs6OiMDtNRPxuIh8Q5CwBM7Ebdkq7SeuRiZQGSjVno0fVXAwRZ5wohpodoPAB4c80O0BEGCeaBuxD4/ANndgMERSdWIjdMFKK4OhEJ+WzGQlXoBiWSKyG9SAWw0Zpy0QoG30SO9SFzbAHYl0oRyAWIvI7OqJoWyiKYYzEapgCkdJ8EIey4RDI2LZOHMa7sBlWSiufbdTQKBU+ixKH0ZoyBtI4doun3Yw8BAGK4Rgy49g4ntgN0ZojDJ3hhZ44VngLKc2UZkpRoIkjOxGpIRQ+sRrCnCZSKpQKpTD/iUi4A/vEcmAkmNgM0X8nVsNIqZZYcSgbHsRzVMlEMcT4MJHSwmcLNVRKK59t0KDHTkYmh0/vHLhwUCAAhzSngei0E+tCzIULKQ2UBkojpSimIsx0YjbUcwyKYojWnEhp5bPV8hv0cEMFVkOMRhOLYae0mzQeB5FSmF7uOJKTiM0Qg/lESjOlmdJCKYaVES8v2NIuzMRuKJQKpZ3SblLMsbHgyBCOZyiiLSZWw0RpojRTmilF5xox0oJ97EIxHHunhZQKpUJpN2lGN6oBR5oCsRjiGMxEShOlidJMKfpOzUAxRN+Z2AwbpY1SoVRMqtP4cAsVxIXjWNsXbDLjiJ6e2AyR2sSRh7GgP/9/JDZDtGbLOLo1CjTW9ieOWm84wBUzUQzR+yZSmilFJhULpZjqFDHVTUQSAhRDNOxEKBv9Vyd3RbQmEEHfhSOJsRQuOo1PpBQNO5a3RadxxURpohQNO+KOReduRZRCEVmfOOpsxPbO6m2GaM2JlML8gQLznyiGml8gbGjE84rOm4Jzc+hGY3l7LrlGwn00t85vY3lbsJVb2A0xVCiiscbytnSY/wjYlY78TmyGfUkr9lkLi6EmDNSEFUcpxrK5wkcaO470YVmnWCiFtShiITCWwhWO0YkYXhUxWU5shppJRZNi6khjrVyxNVpYDRMfGC2fxlK4wgU6UY+SKVJaKC2UVkorpR0Jx3FecVTfwmIYkqFmR5EPZP5Ms6MohoUaxkiQxmK6InC5sBq2g5gNhVIphp3Szmc7Es44eJmIzTAEYjGMB9FJu2GCsgIUwxyJ1bAEIqX1ICK/DSiGLREpFUqFUm03xbowa49SRClGP8vhIGZiN4yURkoTpVpiIEqMI6k44TQRJZ5YiN0QJZ5IKUo8EcpGE2KaWVgN0dwTTYpTwwtNA9ylC/ks2niE5yqOPJ2O/IFo2IgDuTkQuyHMKUZgN6yUokAjulMxfZ0daCB6qiKyHnH4Fz01DdPDYaaFYhgoDZRifJjYDBOliVKUYmI1HOPZwmJYKa3MWWXCjdlpTEKYMFoojfqtPRDLwoZhZSKlWrZRO03L1oBQNpoFs97CQuyGGGwmUloDkcoapY1SoVQo7Uy4M+FuSYi2GzBCgwCLoWZdcWQy49w2sq449t0LxbBQisFxrOIr3KULxRCDwsR1AqWKnUupGiEFdvi5JlIKn+MAuBkH6LETkCxaAfeqMU5QNVk1WZsnzk8HxmFUjPoiHlrvMzB/9o91gvw41qFyTNqT1sn1w46uq2cUlEyWihHczoPs2PpR7Lliv62HkeXADrHjAPMkk0k0Qvg4D0S8YOKKwbdwJOL6fbBSBStVsFIFO5Gv3lElylbdBI0eDNJADsies1IFK1WwUoXGFwIsB1aqYMfzsR9EBP7EFf1vesJpODFa1FNDB94owFmi8bOI8MEYCU8UQ4ywWVEMMZFMrIYYpiYWw0ophqmJUIbsYJia2Axh4BMp7Xy2mwZdLEy0Z3WxMI7pnDgyOY6ynEEdnLMfeUgYgieOn41wfksw8InD7McGrCEGunAkXPGzmojNcDTUQkqFUqG0m1Rn/RFRaTrrT8zEbhgpjZQmShOlY6OUxknZhsDnRAy2E6tho7RRKpQKpRhWx36wlTEMLKQ0UBooHX6HhWKYKE2UZkqxYFHEgmViNUQ/m1iITLgxO41JCJMQPtvtWYRDF5pehEMXWh50qp9o+a0sW2XZEA5daAnr/K7IAtXKJBoTbkxCmLAwic6E2ViNjYVw6EJLGOHQhZYwwqELLeHGFsJWdmJhEoUJs1nge17IJIQJC5PoTLhbEjqTT7QkhF0O4dCFljBcywstYYRDF1rCOqlPZMKVSbBz4QTURGHCwiQ6E+6WBE5ALbQksN9eaEnoa0mK6SBawj0HoiXcC5MoTLgyicqEaSL6qpKiMInOhPtK4vQ1BGIzDJEohmb+Ah/xxJQN80EshoVJFCZcmURlwo1JNCYsTEKYcLckghm6wBs80QxdMPFPNEM/0ZIIZuiiG31FM/QzWM8kChOuTKIy4cYkGhMWJiFMuDMJM3SJNlxJNEM/0ZKIZugSbbiSaIYu0YYriWboEjOTMEOXWJlEZcKNSTQmLExCmHBnEmbo54I8Ey3hZMOVJDN0STZcSTJDl2TDlSQzdEmZSZihSypMojLhxiQaExYmIUy4MwkzdMk2XEk2Q5dsw5VkM3TJNlxJNkM/0ZLIZuiSM5MwQ5dcmERlwpVJNCYsTEKYcGcSNPRiw5UUGnqx4UoKDb3YcCWFhl5suJJCQy+ZSdDQS2ESNPRSmQQNvTQmQUMvnUnQ0CuHq0pDrxyuKg29criqNPTK4WrO3XGg9pIExAMyUOtXsRiifofnWHS/DdT99sShYZynOLEboqonNsNIaeSziRoSpZnPZmpArU8shjDpiVTWKG18FsYw3NsnFkM0wESTynEQKdWyKYohTHocBRGduycWYjfMlBY+W6ihUlr5bKUG9KhxmOTEZojhaiKU1YEYdIE6jStipJ2IJNpAjFETnRQJ4/1kbSxFSjOl6GfDMy86jSuiFIrI+sRRfcMdL4j6TkSXm7ikHTv4hd0QnUsR+VXEaNTzQBjkcPN3eNDTcMd3bJfT8LZ3zJB5+L87tsQLxXDY/MTRWHl4mTvmtzy8wefKJxDrQpz8WdgNx0A6URMGasKKZWDG29342cg6pq+FlI6lxMQGZRUohlIM+0GsC5NmUpHSgGdHRWF2WlgMMx/IyJkAxRDvbU+ktFJaKW2UNpNmzVkHdkOtPqBWH1Czo8gHMn+m2VFshpUaxnImB7wvPxYCCwuxG6LlJ1I6jGyhSXFSaeFIeDijOjzHC6vhML2FmdgNE6XonooZyiKwGaKnTiyG9SA6aTdEW4QChFRwYcBIOCK1sfRZKAvhZV5IKYo5sRlGSiOl6GcTqyEadmIxLJSWTGTCldmpTKIx4cYkhAnDWoaPqVdYy8RM7Asx603UsuHWhAhlDQhlHdgN0YQTxVBvPlCkFI01kcoapY1SoVSclAl3JtwtCbywMxG9b4QPOl7KWdgNcWXDcMd3vGk7Eb1vYjMslOLehuGO75i+JrZmKJG4PMdd38OZWBbiVNNCSnGAFwO0HuCdSGmiNFGaKc2UFkoLpZXSSmmjtFEqlAqlcHZOLBPP/xyHYycPTo7ToouFjJP5ixsZhzEXV7IVeLBLq7i0iksLp5YnV5dWdXloLq3m8iAuLXF56C4tXw+daeFqDmOmpZ7txUxLj/wuZlohBcdMK+TDsUsruzwUl1Zxeagurery0FxazeVBXFri8iAure7y0JlWPJJjpqW+8MVMK8bgmGlhdWGcHTMP+lrQYpcHtWTc8oKNs7GQMWksbmRxvxUnx3pJGZtm404OTh6cHMPq5OT0JOpPOTp2clcWXZVMrsmxe7655zFj6M02CdPhiCUO7uTu5BhklfHO0GIsrRa7ZyLyIMqdjMlwcg6OG1nLNdnJdejtykNPRpvqCmexk2MSWSzkzmfw5lAe8cPBjYz2WtzJaK/JWOUu9nI8r/f9oFwj5ngyyrXYyVGuxZ3c3DPquJksZN1dg6fDfHIlqydtspNH97w6DZRxcm+cIRtcyDjdsxj1o4x1Zy7KjaztMrmQxcnFybFIWezl3bhhZbaYaeFsmHElx8Nxdizk5HTiQFVT1nqYXMnFyYuTVyevTt6cHMcxJ+NQozJ25nne+HQUcnBy7ZOTkX/Ymq5vJmMMWVzJGEMWN3Jx8oLnYWtwtufclTu5OTl2N5Olkrt7Bm2He5UOLHEWYy29uJExbiwWcnJyjI3rJizohK3hKhFjL+9k9M/JzT2DsQI3GR1Y5SzG/mCxLA7YvRt3cnBytBFuLgqHlqsoCzk5uZZLWculXNwzGOdxZ1FABH4xbG1xJWPOWtzI3ckxHo73s0PA8bqMO4wCnPGLg5OHQtZyKSf3DPoe7i4KOJVt3MkYQyZjLl5cyM3J0ffqoTz0jLDwyZi/Fjs52k5ZvReL+Yz6L3ATUkAg3riRx/rTWMjY5ix2ctgU7k/S68dyRR/A6T1jJ0fbLe5kcc/gMGStymKMq8cWh8NxJeME52InT+55HKKfjL02bn0KcMvnKUd/W+zkem3d5EbG2D65u2dgRxX9LcOOJqOPLa5k7LAXN3JycvQ33E8VdF1Ru3IlFyfH+DAZ66XJzT2j74uqTn1hdHIn64uv4KLv704u5ODkwT2vLyUrY/2AW7UC/PO5BeVRV7j/KuBmEWMnR7/CvBzgpM+YxwN8EDV05TIu/DqUO3nMBYuLe2bYY41BuZCbkw97rFHvCNRryZTHvGbs5N3JO+V4acu4Dkb+cbmXcSfHRk7RsfvtmAvqEZSHnmPeWxjJKMvi4riTUZYDOvEicD2yspBxmdrkeDh2zyToKcqdPPrn4tE/jRtZ8zzZyRuer8qdLJmMC+EWN2OcbzMujqmna1macnHcyVquyY2cg2P32+J0Fi93OqvTWZ1OLa8oN7KWd3In97I44sUq47baJeLVKuNCjk6OixmHn/3kjPx3ZSGXSq7B8dA5HKbj3svDcXYsZFzqt7iSu/ttp07Ezo2zY+oMITqmTlz6Zex+G91vcQHgcMyOqTKScT2joE4wdxvnwahnBNKNK1ncM7iWUVBXOFZv3Ixxgs7YyYOTh0rWSxonF8edrFc1KuNqzY7y6sWhHWXEi8hlBGAGFzIu1lzs5OLk4uWd3ClPx+G4kkNwPMrb0Q8xjxtXcnLy5OTZyXMhFycv7nlckLrYpduSYyELno/KlYxrRBcXx90Y876xkEN03Mi4Fnaxkyf3PK5/HaGxsRzD81VZyOhji6tx0baYnB3zt5i7jTs5OnlKNlbMS0CVccXpYo4npRyOs2P32+p0VidvTieur+2wqaJ1jr5dtVyTvRzjJPo83tY2FnKMjis5HY7db5P7bU6OnVznNXDTa1WRf0TSjZuNDzjGbkz7RYjBmGMIrgYzdvLq5JVjCPbmxhxDED+fY0LT+sSYgNNv0zYFY9Fk7beTnTw6eXTyFBw7eXbP67ikXFy6pZsNSk2OaZvibFaczYo4udDGcWG3MZ/vaguTmS5C7Isx3i6mXWP/vjglx7TfnoNjjiFd7WKy01k4hvRaHDt5c8/rWDTGhISAutppQkTdODsWco6OK7m43xYn1/lispPrHNHAcjjOjoXco2MbK1I4DsfUGYKTh+y4rzEhBa3zDtZyTXZyXX8eypVcD8fZsZBbdOx+K+63UsjdybuNRQnzqe5ZEvbCuh9JUfcUyqNNjfkMfO+6N9EruRYHJw+270i4jtu4kZOTJyfPTo51+2SsabHv0Hu6FmMdOxlr18WVLO638Jtpn9E9sjKOsBk7eXDy4OTRyaOTY7+8uJGxX17cydgjT4Z/ZrGXu+dbdox00Q/V3679EHOrcSfDBzgZ+33tk3pVtvYNnDlfXJ0ctq+MyH3Bvk9vzjKuZIxRi/FbtCNeB1uM9dJkvUx+8rBT7Af1VqyCPUKCv7pgX5YQSy/YQ50sZFyWvhjpon50vpuM+W6yXnE/WchYY2MvkxAdL9hrJITHF2M8V8YVIcZ8Bv7kmWfsW40bGeurxULG/LvYyYt7XttLGfMR9hRJ56PJ4uQYqxeP32KvkbD3LAH13/WjBZOdHPlZLGTkYTLqbfGoh4B21PlisZNjHA5ZGXpG2+VDP7XQlK0+86H1OdnJtT6VtT4nV2P9EME4nTK4kvF5hcXFcSfr5yAmo+zQibdzjJ08OLl+eOEAY32FcTIjzlgwvmVcSrwY643J+jmIyZWMeW0y6nAxdI66zYghGjs5bDZW5U6GzS52ctjsZMxrkzFHLxay5h9thxuYSkS9Ff1wA+oBb7SWhHrQC/oT8q9jzmIho28v7mTUw2In7+55/ZwEyl5RJ4udHGutybDTxdCZwVhfTUbZEefNiMEVxHlz1bwpa94mO7nmB9w0P8pYYywWMtbtiPlmxNQK4qoZMTXjRtZPPUx28uLkxcmrk2MdhRirXpFkjOdRn3hnpSBmmnHl/mScDCqIV2bE1IxHPSD2d/KoB8TXso6BiItlHQMRF9O7kIzx2648fov4lN6BVBCfyvDdFcSYMt5KNR6/1S9nwHdX9AsX8N0Zj/osmjfYuDJ8d8aVjD3IZPSTxfgtyoUv6xjjtyijrsMRu8m6DkfMJevae/HID+IvGT66ghiK3oBUEPvQK5AKYh96B5Kxk2NvhbhGho+uINaglx8VxAhORloNjLl7MsoFn7neelTgqy+6nof/vOi4OhnzwmIho1yT0UaL3W9RLvjhi67hJ6PvTe7uGcwR8MkXXOVr3Mnob5NRlsWFnJw8OZ3ZyTXPSbmSNc9ZuZCx71js5N3JO+W418LYyztZyzJZyPBNTUZ/W9zI2cmze74Exy7d4tKtLl2Mw4ihF51DFzeyOLk4eXfyTnk6KEdMbbG2Efpn0jyjT6o/bco1z+if+lGexV6OsqDf6qd5JCp3MvrYYiF3J++U68d5Fjs5fIb40oZea1Tw5ZGCszQz/1irF3wFpKjfbLGTo28rz4/lVOVKDk6uvp3Jnay+HeXkntG+3ZRZt4h5GQtZ+8DkTm5O3tzz2gfAuLMwa5vq8d7J2E8tHnsTbVO8imIsZBx+nToRF56MuPBknLnSdkf8K2u7Y57NgnEGNzwYj3QF4wniX8ZDv7Yp5tysbarnWCZjf7d47Lm0rXGOJWvb4ezKzA9eOMla/3o4d7GQcZZgMs7twEdXcPfD4u7kOLcDf51ehWSMsnRl7PtQXj3Tshh7RpRXdA87uZFxxgC+nYI42mKcaZms+1Zl3bdOFjLKNRnlgm+t6DmWyd3JUS74uApO7Wb4lIqeadE2xRsoxpmMtsC+uOCWXeNCLk5enLw6eXXy5uTcdxfsXxZLIvfg2Pb+FbflGzt5CI4rGWcksK+v+qk77Nkr/GOL0ccWdzLOD2BfXw/dnx7KYhwOykMIZN2PB3BJjoVcKxnzIPbsFWdFFksjd9vj6z1Ouq8/PUV4PoOT7YWrzlPYv1dcuWBcyOqXaMqd3BoZY9Hkbnv8qjEg7Otr4p6xanxncSHnRC7uGe67q8Z0Fndyy2Q5HBdyd/Lunu+236+4YU/37BVX7Bk7eUqOsQ9FG+HqPN2P16z738lOLoXcD8e2x686B01Gn8H+XW8xWhydHP5e7Ourxmiwr68672BfX4urz+l3Uq5OXju5ZcdiXGn7tdL2a6Xt6y1Dxk5enbw6eXNy2n6ttP1aaft6xZAxbbw522/O9puz/eZsvznbb872m7P95my/Odtvzvabs/3mbF+c7YuzfXG2L872xdm+ONsXZ/vibF+c7Yuz/e5svzvb7872u7P97my/O9vvzva7s/3ubL872++0/XbQ9pvzF+ldPcaFTNvXe3qMzfbbQdtvB22/HbT9dtD220Hbb0d38u6ep+23QNtvgbavd/Ispu23QNtvgbav9+sYOzltX+/WMTbbP7tkJdP2W6TttxidnLav9+qo7ettOmr7Lbr6jLT9FquT0/ZbpO23SNtveE29at7g76qaB9xVujgcjovjEb8IqGf4842FnJw8OXl28uzkxclx3kbrAT4x40ZGzGJxcex+K+63OOs1y4tzR1q3Rcs4OVsZi5ZROTq5llEZsRhtF1xyvjg7OWIx8H/qFTXGrE+M28ZOPz6sudjlR1x+xMm7ex7nqZTxarsx062zvP/73x++rM96/+X33378cXzV233n+0///fKvH3778Zffv/zxl//8/PMfvvy/H37+Dx76979++AV/f//ht/P/npb04y9/P/+eCv/x088/DvrfH/jr4/FP8zF8Yfj12QWzKehyVUPCiUNoOKM08khDfKwh4IZSaDiDdyxECV9pSI81nFutMDWM62VNQ5D6lYq8KcYZRls6Ts6sinZc1XFurFdBTmd5epiN+lhFq2W1x7hdyFScAdTLDdLS6hDjsyk3mnScfpoa4hmJfaSh7zpFDqscJ5eHtbnLBW4D01ycrv475RDLxDhc8UhD2PRN6asuz10dW0PCdQ1NTIM81rDpVuMk7eqa46Qrm/TcBXytpWwqo42dp1ZGE5eTGl4w1LHSm5Z6OsjYw4+ve/gYhB9qwREIVXLOAE5H+lqHbHSca0RT0k6H8aP+FXadNKZjtc34ktjDTrotTU3dSiPxYWlGCO1h02TrI/H0NFJH+TCG7tpGwuqp53Cz0XE5H+mhjuv10R/XR9kNgjYGNvaPHK9nosVkvaO1x5lou94hmfNBe1yhm24a8Z0ardDTO/BYx9V8bHRcrg/JD+sjhe/ZKJLZQ8tju0+biT4esVqNHtENYx9MNuU3TE77nKTInKR8V8lxOCUPh7G06yCl23TPOe7cvLzQMpUtI+Fxy/RdUaRUK4q4kfDj+mkzYQs+JgIdckZcHk4vObyhdbcZSYEZqZuM7Bq3i+XjcIbbPqjI29VgtNWgPF4N5rJbG5fCtTFrI72QC1ufN7+g/CYXmy7WcPuF6jjDGo91yK6jr8rIbtkQ4wcNu04aerDx+OgPdZRN1yhm9n6qfkmDLaLOjfe9ckTOK95OXtLRgtlr25RkP3CYmYw3jB4OHGXTP0/bsEXY4XrGazqC6Qh5k4/2+Z3XEx2X7HWv45q11ePz1lbDZ61t3zu4W+h+Oflxob/T0a02xntZD3XU3ba82NIln354lqVfX7yMmdrykeVxPuquLMWmt5Pz8WhmqtvlYGqFm5Z+3Nm0RNpL9FPTN6XZbvHN1xEiO0h5pWkzM7Fp2s/bW/28ubX0eXNr+bPmtvWByeqh5XTnP3Q+tV0PbfS5nNz6o87Vdj00IW6ydizp8aJ2U5hmnXwcH3hcmE0HHRfIrLIc1dfp19mQNwyk8umBVOLnly2SPrts2Wq4tGzZluPismWr4+KyZdu5WBdnQOBh55LdWvQMLNm2K56OsUedXHZDqFQbyqXlxz10m5FDIjNyPNzu9F0XHS8x2AIqOWP5oGTngErRBiC8h/Jw09S3bbMmpjN68nBK6PkNrsFe3uAa3JWlmkeupseOwd7eMB53ecN4vIspVHay5pZyHz3pxzZQJOaBTrk/7qk76+9lDUKxOzfUh1BRODY6Khf6tbb40PzDsZvya+5cedSNknfEnLZarkadwvGGuFPcrufoEAvyuG3kHW3T39A24XhH2+y0XG6bXQTpHW2T3NbjHN/b48jNNhJ1RNNy5MdjWtgFoq7HbkJ9R/BmXyDrs+NuqE2B3hKMek80al8g86aMe74eF2gXB2pNlpIzWvA4I7t41Av2c7E4IW6ia7ugpdj0N963L4+7/i4mFc/orQWT+9ltHtfKrtemozGac/R2Z6H1oUCPbTluw3Smo7pA7sfBOvY3DNbpeMNgvYtNXe9sOy2XB+uUPj9YP1Nyya/xRMk1z0ZI9fMb4LCPUF1yJW67SbOw8hl+zJu26e8YqHexoesD9b7fdxtjW3zsrgk5fn6g3oWprtvO9bFg0z5bJS3Z7k/89u+bOqnb4dGm9PSVs+Rjpex67FGlWVSiHfK4anc7r+Ng1R7HY4dv2AVqxpbNtJQkd85SpV7sTFhvD09CbTUckRoensYKJb5hB7hbEkTcoqzzcHZu44/nmK7r6Pd0fP481TmPB4syt3RrHu8upNDKw3m87Lqp+Vy8h+H06l9XkW1fkF044RsVdRtXpf86dr8Q+KAj7AYQy8c5CMlDHduimOEXN1l9W5T0hqLk71sUSWsBIE7DSw0rVhsiN/tGt8OkvdZ7KsZ3CLjvTJtW2cYDeELuSP3xUqZteqmb5lwkcYThvlax6aR0k4zPAWx0xO+rIzXnfT52hdlt0HCH0txHpHpXSbVdXgt3c9I4EvoV4mtKuu1GTndW2yjZnfrLjFn7KO9rSlq16OjZUPeUnMsYrmL6zZykYOf2xhVgd5UEBhjcLPONkl0EKoRi7xqE8U7sbTU1vENNDXQe1bKpXtmtV8fFYaYmlU3PlV2oIIdmpy3y+ehb1PR0V03kMeAcS79dN7GybtxBvG/U7MJb43o1nltPInfVZLZUytuW2vcbf5z/2NTNNs4Vq72bMO7HrHfVuHEztrLpN72+p4q3arK9jzSqON1W856WajZqjavE291R2F54OIfBeFMJT6SOHftNJZlDeW53c1K4Eyzb2XqrxNo51ePu9FZZJzVvirNfFtocOT6T8XhZ+CREc81ht1dyzWEXt8Gviw67uA1+XXPYbfNx0WEXdzVy2WEXQ3qHw24fVbzmsIu72NdFh13cRr6uR40vR1o3DrutkosOu7gLfF112MV4vMFhF3eBr8sOu7gNfV112O0OOhw2nZ6W2h/5dWLcTO29dO6842Pb2YW9KufjmsvjcXqrRAKdCO5o0Yc+Et9wOPuZkkuD9BMlFwfp9IZjhTF9+lzhvoc0a5nuD9N97CHbd5gi98zjUwb9sZbdUZhY+NbOVy9BftNbt+VpycrTN+Wp75hzUnvDnLMvjxwrK13C4zFt+2JWquZJPNm9Bv1Ryz7oVdyx89LDvfJUO87W+7HJyW5NEKK47fLD4WSvo1kTx2OjI3/ayRt372ZddPLuyxJ5zDm6hdY3ZWlvKIt857Kkg9u29HiqKJ+PI8QSvndZGsvi/CjflCW9oSz5O5clW6Aq5MevMsZS31CW9r3L0s3fUcJj2y/982XZxbveUpZi79wG/2bTx7LU+IaypO9dFsY0/Nnvl8Z1/8ZZqPd0dFu8nxHVTZ22z4eaYpXPhprizrdxMUwUdxGvd+i4GmqKLe59yjYI5btKLsar9kouhpr2Si6GmuLuha2roaa9kouhpq2Sq6GmvZKLoaYnSq6FmuLupa3roaZnai6Gmp6ouRpqwmUhnw81RSnvCDW9omYTanqi5mqo6VndXAw1xd0rXdfjIE/UXA1gPOs3F0NNscd3hJqeqLkaaorbiNX1Kt6ruRpqeqbmPS11NdT0ZBS+FmraK7kYatoruRhq2iu5GGp6ouRaqGmv5GKo6cmy8Fqoae9D6dF8dl3SIx9KOrYtzLdox6fH5JaWGLhuiOXhDjftIghXHbvPlFxy7D5Rcs2xm0L4vGM3hfhdHbvhDF7wPaCjPn4HP7zjVdoU3vEu7bMScYA8jlQf56V9Ov6Wgrwh/va0PNm1kNzUEirfyAvyuFZ2Ya96ZHu1f5OTJzqC09Ef60hvGJZeqJMY4k0t7lba4zSTxyV6x4UaKb7jRo3t3Qu8aS6WhwfFU9welYjN1cnBIb9+fQ437YJf59LPvb/WHoc1nmmxe+/G52M39+9t30g4bEl6cq/38pIO7h3SJmyc9tcSFrvmI+X6uN8+y4sNcfgk7GMt29Vbtbn9ZJG7eand5WVTu9tDS4zqpSzhbhsF4RvQcVMveX8wxjyu47br8Nie90eOCv2D1Z2K/2hHW0clb+Q8N9LufP9rr/1fO7d0vOEKpbQLhV1eOeX62ZXT/mKHi+eWUn7HG+Epv+WN8P1NFdfOLaXy+TfCU3nLG+HXb+/YnVvaKbl4bintLh28em4plb3b9Nq5pVS2rytePLeUtu+BveHc0rko6HQDt4fLjLq9+N0iUjG5Qenj2z57JTmaZzw7V9O3Sj4fG0tviI09KQyvyisxbQpT3lCY+p0Lg895amF8oO/bwsgbCtO/c2E6D9d0tzB/ra92Oyrw1a1GLyk55woOAb3fVBJsu3KulzZt0/Lno5+4yPJz0c+089ldjFym3WWG79BxNfqZtrcZXgxcPlFy7UW7vZKL0c+9kovRz7R7P+Nq9HOv5GL0c6vkavRzr+Ri9POJkmvRz7S7VPB69POZmovRzydqrkY/0/b1rcvRz7SNYl2Ofr6iZhP9fKLmavTzWd1cjH6m97wFlt7z+tazfnMx+pl6f0f084maq9FPbJM+X8VP1FyNfj5T856Wuhr9fDIKX4t+7pVcjH7ulVyMfu6VXIx+PlFyLfq5V3Ix+vlkWXgx+rmb3A6bZv2dux92lzlsX+rknRYh9MdelRy2V3cK98pJ+h2XfIqRrzzk8Lg077hTPod3XCq/bRs6MmKLj0vzjgBDju8IMDzTci3AkOM7Agz7vFwNMOT4jgDDs7xcCzDk+I4Aw7O8XAsw5PiOAMOTvFwMMOT0jgDDEzu6GGDI6fMBht31t8l28dmPKh8uDcu7sJhtRNx33HJ6xbnS+X2ZI911rnDiOeJtN49z9brLz17MSbb+cbiLO19Uwk52tHBXiV0vdeq7XbH2NsaJctdrxYVS2LhHnxzq5qTRwu78Xfy8g2X/BkLlG241P35zaK+DX2b66t3fl3TYED0+Bn9TB9+Cqv3mWx30BQZ/RuwlHY318dWK4CUdvP265Zv10SxQMz5aflMHvSrNXeX9mg5ujZvc1cFJ5qvDOi+9sWMhztPffLOfCt1DcveN0MY3h+Tum0P8AuIZSLxpt8JNktxtF7FPM53q8j0dne3S77ZLZ7v09LB/7C8PDKub9nDz8sAe7RPO6eYtiN3OTvXQbqqwzUSv5aYKW+t2ebx62H/nJYv7UF5/uOp+ooTL5ftKyuGc3Ue/mRN++zSU8Hhb1PYeEvv86Rnwf/xa+u5lzoOfrXFuxnb5et1qn5er3uf0ggIrg5+qX1Fgpxn8PP2CAvehczdgvKCg27HN7i7DvafAffrgJQU22ni//gsK7FurNxWE4+DGzccKX8hDz5/U0OyL0/7ba68osOsVmvN43FIgx80c2NW34ZY5NBtsbyqQuCpR0j17snY8p59bCuwMmr9r456Cm3Ug5XNDwukBETvmIY8DODsV2e6UKKcb6JaKak6IUnu+p8I+XHVbRTv4TcR4ry64CindH/e8q6LcVGGNuov9b+dbe1Ggen/MKyou3my1zQUn3aPeqs4azbFUY7jVqJWX2dQgt7pWTWaoZ3gnfbogd1XY7FljO+6p6Nao6aj3VHAhlI57vZPfxj2xfrpFNmG7sv3S1uXo7NZOuLa92zeuHbTbLYtK5H60xHTL1s4fWlT25HJTCX3aJ7d6U0lncXIo95Rks5eTa7upxNVJbpueFt9ys0CJb7lZ4BU1m7M1T9RcPVvzrG4unq0p8S03CzxR84Yx4ewp0XW9dLPr0QVwcjzuKam8MqzUeDMn3H6fvDngsFXShAND6/2eEuFNW0VyuquExZHNScKSPn/EuqT+fUd+6ayRftytEa8kHHeVHE7Jza7W7ePTJ+fwDiVyVwnnoF7KG+rkrpJOp3fprb9BidS7SnihWu/xDXVyU0k9OK6N3c4blMT06eKcSm5OGMJYYhFpN4vDF7vr0fIblNzbBA8lwSm5Z4A1cP6ru/OKLyjpN4vj7t4LsX6+Tm4rCYmx71COdyhpd5U0KqnpDXVyV0ngobga7trOV0p6fkNxermpJDnbKTcnL3fQ4uSbU4Y7WHAquVWcq0djj20c3e7fGHyvRlrlmqDdLMy5bYruyNfNsb6Jy8kZi76ZE56+bO3m5vZrJTf36qcSnulpGyd0kePzq2n5/LXE+7axQ1ujbY6bDRzYSyTc7SVf5eSuEl5z1OTeWFKKhbuKv9g8veDbN8d89S/EXVdgfobiP8Z9WUEMVpfRT5ofbz7Yq7DX4IIrxEsqbJMV41cvxH+tovTtK9dWFem4qcKO8lTnWXulIDGxIG5Mf0VF5Tvs1TmgXlHBy5BiS/caNVqAInqP+isqkh2LPGsl3MuFedRPbbeqM2dbeGR/4uRc714dKgJ9IsGNnS9kIrh7pYLc6lkh8ZhZ6vdyUaJ32N5TwVPzRfq9ghw8eB/vFSTxwwWp3CsIT70E/5r4Kyp49j+0fqtzhs666PGWimbfo2653lHQLeLUy716OHi41d8X+FFF3b0V9Xkz7RZF7PFeRbhDROWTNXlPgbu5wHvXJVxWYNNo8yHMFxQIFbRbCmx8+OryhesKmt1R2rwPeyj48/nPH/72029/+fnXv/3w+0+//vLv83f/G6p+++mHv/784/znP/7zy9/c//39//9r/Z+//vbTzz//9M+//Ou3X//249//89uPQ9P4f1+O+Z8/xXqGSs55V/78hy/p/Hca51RTLPH8d8AD47OjY70yBAG/OPeT58+OP/9vZPH/AA=="
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tb3Rru26cWD7L+c5D2KRLJL+lUYjcNLuwIBhB45zgYsg/95TRVUNrrUzubTmXOfFZ/icvWtIpKqmRFHkf/32f/70L//5b//857/+37/9x29/+F//9du//P3Pf/nLn//tn//yt3/94z/+/Le/Pv7tf/12nP8z0m9/yP/025Df/qCPf+Tf/tAf/yi//SEdj3/Wxz/l8U99/LM8/tke/zz/WL/+OeY/03E4JAdxyA7FoTqoQ3PoDh45eeTkkZNHTh45eeTkkZNHTh45eeTkkcUji0cWjyweWTyyeGTxyOKRxSOLR84eOXvk7JGzR84eOXvk7JGzR84eOXvk4pGLRy4euXjk4pGLRy4euXjk4pGLR64euXrk6pGrR64euXrk6pGrR64euT4iy+MaSno4JAdxyA7FoTqoQ3PoDh65eeR2Rk4niEN2KA7VQR3OyOWEM3I/YVzQD4fkIA7Z4Yw8TqgO6tAcusO4YBwOyUEcsoNHHh55eOQzA/N5ymcKThgT5MxB0ROSgzg8ImeD4lAd1KE5dIdxwZmDE5KDOHjk5JGTR04e+czB3E/oDuOCMwcnJAdxyA7FoTqog0cWjyweOXvk7JGzR84eOXvk7JGzR84eOXvk7JGLRy4euXjk4pGLRz5zsJy9c+bghObQHcYFZw5OSA7ikB2Kg0euHrl65OqRq0dWj6weWT2yemT1yOqR1SOrR1aPrB65eeTmkZtHbh65eeTmkZtHbh65eeTmkbtH7h65e+TukbtH7h65e+TukbtH7h55eOThkYdHHh55eOThkYdHHh55eORxRc7H4ZAcxCE7FIczcj5BHZpDdxgXnDk4ITmIQ3YoDh45eeTkkZNHPnOwPNIznzk4ITk8Itd0QnYoDtVBHZpDdxgXnDk4ITl45OyRs0fOHjlfdSPn5tAdroqUy+GQHMQhOxSH6uCRi0cuHrl45DMHazkhOYhDdigO1UEdmkN3GBeoR1aPrB5ZPbJ65DMHaz1BHZpDdxgXnDk4ITmIQ3YoDh65eeTmkZtHPnOwPspXPnNwQnI4bxTlhOxQHKqDOjSH7jAuOHNwQnLwyMMjD488PPLwyMMjD488rsjlOBySgzhkh+JQHdShOXQHj5w8cvLIySMnj5w8cvLIySMnj5w8cvLI4pHFI4tHFo8sHlk8snhk8cjikcUjZ4+cPXL2yNkjZ4+cPXL2yNkjZ4+cPXLxyMUjF49cPHLxyMUjF49cPHLxyMUjV49cPXL1yNUjV49cPXL1yNUjV49cPbJ6ZPXI6pHVI6tHVo+sHlk9snpk9cjNIzeP3Dxy88jNIzeP3Dxy88jNIzeP3D1y98ieg8VzsHgOFsvBcoI6NIfuMC6wHDRIDuKQHYqDRx4eeXjk4ZHHFbkeh0NyEIfsUByqgzo0h+7gkZNHTh45eeTkkZNHTh45eeTkkZNHTh5ZPLJ4ZPHI4pHFI4tHFo8sHlk8snjk7JGzR84eOXvk7JGzR84eOXvk7JGzRy4euXjk4pGLRy4euXjk4pGLRy4euXjk6pGrR64euXrk6pGrR64euXrk6pGrR1aPrB5ZPbJ6ZPXI6pHVI6tHVo+sHrl55OaRm0duHrl55OaRm0duHrl55OaRu0fuHrl75O6Ru0f2HKyeg9VzsHoOVs/B6jlYPQer52D1HKyeg9VzsHoOVs/B6jlYPQfVc1A9B9VzUD0H1XNQPQfVc1A9B9VzUD0H1XNQPQfVcrCdkB2KQ3VQh+bQHcYFloMGycEji0cWjyweWTyyeGTxyOKRs0fOHjl75OyRs0fOHjl75OyRLQf7CeMCy0GDR+R2nCAO2aE4VAd1aA7dYVxw5uAEj1w9cvXI1SNXj1w9cvXI1SNXj6weWT2yemT1yOqR1SOrR1aPrB5ZPXLzyGcOtnyCOGSHM3I9oTqoQ3PoDuOCMwcnJAdxyA4euXvk7pG7Rz5zsJ39deagwZmDE5KDOGSH4lAd1KE5eORxRW7H4ZAczsjjhOxQHKqDOjSH7jAuOHNwQnLwyMkjJ4+cPHLyyMkjJ4+cPLJ4ZPHI4pHFI4tHFo8sHlk8snhk8cjZI2ePnD1y9sjZI2ePnD1y9sjZI2ePXDxy8cjFIxePXDxy8cjFIxePXDxy8cjVI1ePXD1y9cjVI1ePXD1y9cjVI1ePrB5ZPbJ6ZPXI6pHVI6tHVo+sHlk9cvPIzSM3j9w8cvPIzSM3j9w8cvPIzSN3j9w9cvfI3SN3j9w9cvfI3SN3j9w98vDIwyMPjzw88vDIwyOfOdjTCc2hO4wJ/czBCclBHLJDcagO6tAcuoNHTh45eeTkkZNHTh45eeTkkZNHTh45eWTxyOKRxSOLRxaPLB5ZPLJ4ZPHI4pGzR84eOXvk7JGzR84eOXvk7JGzR84euXjk4pGLRy4euXjk4pGLRy4euXjk4pGrR64euXrk6pGrR64euXrk6pGrR64eWT2yemT1yOqR1SOrR1aPrB5ZPbJ65OaRm0duHrl55OaRm0duHrl55OaRm0fuHrl75O6Ru0fuHrl75O6Ru0fuHrl75OGRh0ceHnl45OGRh0f2HOyeg91zsHsODs/B4Tk4PAeH5+DwHByeg8NzcHgODs/B4Tk4PAeH5+DwHByeg8NzcHgODs/B4Tk4PAeH5+DwHByeg8NzcHgODs/B4Tk4PAeH5+DwHByeg8NzcHgODs/B4Tk4PAeH5+DwHByeg8NzcHgODs/B4Tk4PAeH5+DwHByeg8NzcHgODs/B4Tk4PAeH5+DwHByeg8NzcHgODs/B4Tk4PAeH5+DwHByeg8NysJyQHYpDdVCH5tAdxgWWgwbJwSM3j9w8cvPIloP1hObQHcYFloMGyUEcskNxqA4euXvk7pG7Rx4eeXjk4ZGHRx4eeXjk4ZGHRx4eeVyRH+/oj6AUJEE5qATVIA1qQT0oHCkcKRwpHCkcKRwpHCkcKRwpHCkcEg4Jh4RDwiHhkHBIOCQcEg4JRw5HDkcORw5HDofl6TDSoBb0cAwxGk5nsl6UgiQoB5WgGqRBLSgcJRw1HDUcNRw1HDUcNRw1HDUcNRw1HBoODYeGQ8Oh4dBwaDg0HBoODUcLRwtHC0cLRwtHC0cLRwtHC0cLRw9HD0cPRw9HD0cPRw9HD0cPRw/HCMcIxwjHCMcIxwjHCMcIxwjHcIdNxrkoBUlQDipBNUiDWlAPCkcKRwpHCkcKRwpHCkcKRwpHCkcKh4RDwiHhkHBIOCQcEg4Jh4RDwpHDkcORw5HDkcORw5HDkcMReZ4iz1PkeYo8T5HnKfI8RZ6nyPMUeZ4iz1PkeYo8T5HnKfI8RZ6nyPMUeZ4iz1PkeYo8T5HnKfI8RZ6nyPMUeZ4iz1PkeYo8T5HnKfI8RZ6nyPMUeZ4iz1PkeYo8T5HnKfI8RZ6nyPMUeZ4iz1PkeYo8T5HnKfI8RZ6nyPMUeZ4iz1PkeYo8T5HnKfI8RZ6nyPMUeZ4iz1PkeYo8T5HnKfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyXCLPJfJcIs8l8lwizyXyPEee58hzm1Y0ilEOKkE1SINaUA8aTpbnk1JQOFI4UjhSOFI4UjhSOFI4JBwSDgmHhEPCIeGQcEg4JBwSjhyOHI4cjhyOHI4cjhyOHI4cjhyOEo4SjhKOEo4SjhKOEo4SjhKOEo4ajhqOGo4ajhqOGo4ajhqOGo4aDg2HhkPDoeHQcGg4NBwaDg2HhqOFo4WjhaOFo4WjhaOFo4WjhaOFo4ejh6OHo4ejh6OHo4ejh6OHo4djhGOEY4TD8rwalaAapEEtqAeNi2zi0kUpSIJyUAmqQRrUgnpQOFI4UjhSOFI4UjhSOFI4UjhSOFI4JBwSDgmHhEPCIeGQcEg4JBwSjhyOHI4cjhyOHI4cjhyOHI4cjhyOEo4SjhKOEo4SjhKOEo4SjhKOEo4ajhqOGo4ajhqOGo4ajhqOGo4aDg2HhkPDoeHQcGg4NBwaDsvzYTScLM8npfPbETEUMIMFrKCCDezgCDwT3hFbx9axdWwdW8fWsXVsHdvANrANbAPbwDawDWwD28A2wmYzpxwTKGAGC1hBBRvYQWwJW8KWsCVsCVvClrAlbAlbwibYBJtgE2yCTbAJNsEm2ARbxpaxZWwZW8aWsWVsGVvGlrEVbAVbwVawFWwFW8FWsBVsBVvFVrFVbBVbxVaxVWwVW8VWsSk2xabYFJtiU2yKTbEpNsXWsFFLKrWkUksqtaRSSyq1pFJLKrWkUksqtaRSSyq1pFJLKrWkUksqtaRSSyq1pFJLKrWkUksqtaRSSyq1pFJLKrWkUksqtaRSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotaRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkzVpSDSuoYAM7OAJnLZmYQAEziK1ha9gatllL1HAEzloyMYECZrCAFVSwgdg6toFtYBvYBraBbWAb2Aa2gW2ErR8HmEABM1jACirYwA5iS9gStoQtYUvYEraELWFL2BI2wSbYBJtgE2yCTbAJNsEm2DK2jC1jy9gytowtY8vYMjarJediEMlm+Dkm8LSdq0Qkm+fnWMAKKtjADo5AqyUXJhBbxVaxVWwVW8VWsVVsik2xKTbFptgUm2JTbIpNsTVsDVvD1rA1bA1bw9awNWwNW8fWsXVsHVvH1rF1bB1bx9axDWwD28A2sA1sA9vANrANbCNsNrPQMYECZrCAFVSwgR3ElrAlbAlbwpawJWwJW8KWsCVsgk2wCTbBJtgEm2ATbIJNsGVsGVvGlrFlbBlbxpaxZWwZW8FWsFFLBrVkUEsGtWRQSwa1ZFBLBrVkUEsGtWRQSwa1ZFBLBrVkUEsGtWRQSwa1ZFBLBrVkUEsGtWRQSwa1ZFBLBrVkUEsGtWRQSwa1ZFBLBrVkUEsGtWRQSwa1ZFBLBrVkUEsGtWRQSwa1ZFBLBrVkUEsGtWRQSwa1ZFBLBrVkUEsGtWRQSwa1ZFBLBrVkUEtG1BI5opbIEbVEjqglckQtkSNqiRxRS+SIWiJH1BI5opbIcWBL2BK2hC1hS9gStoQtYUvYEjbBJtgEm2ATbIJNsAk2wSbYMraMLWPL2DK2jC1jy9gytoytYCvYCraCrWAr2Aq2gq1gK9gqtoqtYqvYKraKrWKr2Cq2ik2xKTbFptgUm2JTbIpNsSm2hq1ha9gatoatYWvYGraGrWHr2Dq2jq1j69g6to6tY+vYOraBbWAb2Aa2gW1gG9gGtoGNWpKoJYlakqgliVqSqCWJWpKoJYlakqgliVqSqCVznbRUDQXMYAErqGADOzgCZy2ZiG3WkmSYwQJWUMEGdnAEzloyMYHYMraMLWPL2DK2jC1jK9gKtoKtYCvYCraCrWAr2Aq2iq1iq9gqtoqtYqvYKraKrWJTbIpNsSk2xabYFJtiU2yKrWFr2Bq2hs1qiWTDCip42sTWDrNacuEItFpyYQIFzGABK6ggto6tYxvYrJbkYihgdrSJjrYKm010fFyXhvbfm2EBK6hgAzs4Ai1DLkyggNgytowtY8vYMraMrWAr2Aq2gq1gK9gKtoKtYCvYKraKrWKr2Cq2iq1iq9gqtopNsSk2xabYFJtiU2yKTbEptoatYWvYGraGrWGzDLElyGwupGMHR6BlyIUJPG0lGWawgBVUsIEdHIGWIRcmENvANrDZr20RQwXNZoljv7YXDkebIumYQAEzWMAKKtjADmJL2OzX9lw0TWy6pGMGC1hBBc02Vyrs4Ai0qnGujCY2b9JRwAwWsIKnrYphAzs4Aq2WXJhAATNYwApiy9gyNqsl9SzrNpXSMYHWZsPQ4hZDi2BtZvWh2h+w+nBhAgXMYAHPuHoYKtjADo5Aqw8XJlDADBYQm2JTbFYf1DrL6sNEqw9qJ2/14UIBM1jACprNrlSrDxd2cARafbgwgQJmsIAVxNaxdWxWH9S60OrDhWZrhgJmsICnrVnrWH24sIEdHI42tdLxtDUxFDCDBayggg3s4Ai0+nAhtoQtYbP6cK6KIjbT0lFBa8lh2MERONconmgRiqEd2dlmNlcytbk+aQIFzGABz2DdDtJS+sIGdnAEWkpfeNq6nYXdHlyYwQJWUMEGdnAEWvpfiK1iq9gs/bu1jqX/hQqarRp2cARa+ndrVEv/bg1l6T/mIq8ZLGAFFWzgaRtTMQIt/S9MoIAZLGAFFWwgtoatY+vYOraOrWOz9B929Vn6X9jADo5AS/8L87mKs+WmLXx8YQUVbGB3tLmNcr7mFZvbeOGZhY9hohPP383HGI6hgBksYAUVbGAHR2A+QGwZW8aWsWVsGVvGVixuNbQIamgRmmEFFbQI3bCDI7AeYAIFzGABK6ggtoqtYlNsik2xKba58vcwPCOkubaxXTD2B2YyTBQwgwWs4BnXHjdtVqDjebw2cmKzAi+09b8vPI8s2WVk63sn6xZb4ftCu8Ct1W2VbxsNsZl+jgkU0OJab9plf2EFzWZx7bK/sINhs5l+jgkUMIPRmzbTz1HBBnYwelPTASZQwAxiS9gStoQtYUvYBNvM2GGofmnM2Xtj/oEOjsB8gAkUMPv1YLP3HKtfBDZ7z7EFWm7apWEz8ub1YDPyHKtfGjYj7+oAy80LO0hvWm7aRWAz8hwFzH4R2Iw8xwpiq9gqtopNuXZmMlj7zmQwnMkw8TwcsdaxBfEvzGABK6hgAzs4Ai1xLsQ2sA1sA9vAZokjdkKWOBd2cDjatDbHBJpNDTNYwAoq2MAOjkBLnAsTiC1hS9gscaQZKthAs3XDEWiJc6HZhqGAGSzgactzJfczbk6GI9B+6i5M4Bk3Z8Mzrg1+2QQ2sSEvm8DmqGADzWZnnEegJdmFCTSbnZvl27XO/KmwgQSbtSbFDsfyrcy/1sERaPl2YQIFzKDZrNUt3y48bfawbbPWHDs4Ai3fLkzgabPnY5u15ljACirYwA6OQNsj48IEYmvYGjbbLcOexm3WmmMDzWZ9bKViopWKC81mbWalolpnWam4sIAVVLCBZrPL00rFRCsVFyZQwAwWsIIKNhDbCJvNWnNMoIAZPG32EG+z1hwVtGuyG3ZwBFqpuDCBAp42e8q3WWuOFVSwgR0cgVYqLkyggNgEm2ATbFYq7IHf5qc5JlDADBawggo2sIPYCraCrWAr2Aq2gq1gK9gKtoKtYqvYKraKrWKr2Cq2iq1iq9gUm2JTbIpNsSk2xabYFJtia9gatoatYWvYGraGrWFr2Bq2jq1j69g6to6tY+vYOraOrWMb2Aa2gW1gG9gGtoFtYBvYRtjGcYAJFDCDBayggg3sILaELWFL2BK2hC1hS9gStoQtYRNsgk2wCTbBJtgEm2ATbNSSQS0Z1JJBLRnUkkEtGdSSQS0Z1JJBLRnUkjFriRomUMAMFrCCphDDDo7AWUAmJlDADBawggpiq9gqNsWm2BSbYlNsik2xKTbFptgatoatYWvYGraGrWFr2Bq2hq1j69g6to6tY+vYOraOrWPr2Aa2gW1gG9gGtoFtYBvYBrbhtnwcB5hAATNYwAoq2MAOYkvYEraELWFL2BK2hC1hS9gSNsEm2ASbYBNsgk2wCTbBJtgytowtY8vYMraMLWPL2DK2jK1gK9gKtoKtYCvYCraCrWAr2GYtGYYJFPC0tbntVAErqGADO3jamtmsllyYwNN2vmTJNinNsYAVVLCBZquGI9BqyYVmK4YCZrCAFVTQbM2wgyPQasn5BiTbpDRHATNoca19rT50ayirDxcm8IzQraGsPlxYwPN4+9z0S8EGdtBs5wnZRDPHBApocauhRVDDEWg5f6Gd8dxmTMAMFrCCCjawgyPQcv58h5Jt8pijgBksYAUVbGAHR2DGlrFlbBlbxpaxZWyW8+c7n2zTxORc2jPbNDFHATNYwAoq2MAOjsCKrWKr2Cq2iq1iq9gqtoqtYlNsik2xKTbFptgUm2JTbIqtYWvYGraGrWFr2Bq2hq1ha9g6to6tY+vYOraOrWPr2Dq2jm1gG9gGtoFtYBvYBraBbWAbYZsbgF6YQAEzWMAKKtjADmJL2BK2hC1hS9gStoQtYUvYEjbBJtgEm2ATbIJNsAk2wSbYMraMLWPL2DK2jC1jy9gytoyNWiLUEqGWCLVEqCU2oU7O98fZJtQ9nl4MG9jBEWi15MIECpjBAlYQW8VWsVVsik2xWS05l87KNqHOsYAVVLCBZkuGI9BqyYUJFDCDBayggg3E1rCdtSSf75qzTahzFDCfaGd8Vo182KHPrYDP32OZmwFPtAjdUMAMFrCCCrYT7dKYmwNPHI42Sc4xgQJmsIAVVLCBHcRmmwafL+iyTZJzFPC0nW/ask2Sc6zgaTvftGWbJOfYwRFoGwmfr+KyTZLL5/usbNPhcrKdQ23z4AsVbKDFbYYW92xUmw6XxY7XNhIWOzLbSvjCDBbwtIkdmW1nemEDO3jazn2o89zNVOxwbD9TscOxHU3FGtX2NM3212xX0wsVbGAHR+CZ/o6nLVubnenvWPxKtUlyjgo2sIMjUA8wgQJmEJtiUzsh60JtYAfthKyh2gEmUMAMFrCCCjawg9g6Nsv5bN1iOX9hBgtYQQVPm20FbJPkHEfgWR8cEyhgBgtYQQWxDWwjbDZJLp9vz7JNknMU0GzZ0GzFsIJmq4YNNJsajkCrDxcmUMAMFrCCCjYQW8Im2ASbYBNsgk2wCTbBJtgEW8aWsWVsGVvGlrFlbBlbxpaxFWwFW8FWsBVsBVvBVrAVbAVbxVaxVWwVm9WS8w1pthl3jgo20GqJGI5APcAECpjBAlZQQTuLs67bLLr502yz6PI52zjbLDrHCirYwA6OQKsE1dKp076dM+6c8cz5iSPQct42wrblBh0FzCC9ObANenPQm4PeHNGb9TjA5MdQZ85PzGABqx+DLTfo2MBOXGzkfCXnKzlfyflKztcU105NCjawgyOOQQ4wgdjI+UrOV3K+kvOVnK/kfJXotzpzfiItmWnJHP1mEwAdaUlyvpLzlZyv5Hwl5ys5X8n5Ss7XQr8VWrLQkoWWLLSk5fw5GyDbZEFHa8lsKGAGC2jnZsdgOX9hAzs4Ai3nL0yggGazg7Scv9Du4ucf6J6FNoUw287lNoXQMYEC0kONHmr0UONab1zrVgku5Orr9FCnhzo91OmhztVH1aid66FzPXSuh1kfhqGAGTzjqrWD1Qe1I7P6cGEDOzgcbWKhYwIFzKA983bDBnZwBM7Rg4kJFDCDBawgtoQtYUvYBJtgE2yCTbAJNsEm2ASbYMvYMraMLWPL2DK2jI0xR83YMraCrWAr2Aq2gq1gK9gKtoKtYKvYKraKrWKr2Cq2iq1iq9gqNsWm2BSbYlNsik2xKTbFptgatoatYWvYGraGrWFr2Bq2hq1j69g6to6tY+vYOraOrWPr2Aa2gW1gG9gGtoFtYBvYBrYRtjmr8sIECpjBAlZQwQZ2EBu1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSxq1pFFLGrWkUUsataRRSzq1pFNLOrWkU0s6taRTSzq1pFNLbNpltpfnNu3yQntCuTCBAmawgBVUsIHYEjbBJtgEm2ATbIJNsAm2WUuq4Qi0JxTNhgkUMIMFrKCCZptxOzgC7QnlnAmVbTKmo4BmK4YFrKD12/yzDexgvMOekzEvTKCAGSxgBe1t9TAcgfYscn56mm3apaOAGSxgBRW0NptxOzgC7QnFZlvYtEtHAc1m1689oVxYQWuz+Wcb2MGYpzCnXV6YQAEzWMAKnmdhUzdsguWFNoJxoZ2FXZP2hHJhBs+zsIkBNsHS8Wwzm69hEywdO2i28zqzCZaOCRQwgwWsoNnUsIEdHIFWHy5MoH2aUwztI6dhaB/hzD/QwA6OQDnABAron/zkOZXywgoqaLbDsIMj0O4qLkyggBksYAWj523S5IXlAKPnbdKkYwaj523SpGP0vM2fdOwgPV/p+UrPV3q+0vOVnq/0fKXnKz1f6flKzys9r/S80vNKzys9r/S80vNKzzd6vtHzjZ5v9Hyj5xs93+j5Rs83er7R852e7/R8p+c7Pd/p+U7Pz5w328x5w5nzExNofdENM1jACp5ncdgZz698J3ZwXFjmnMgLEyhgBgt49vE52arY7EfHEWjZfWECBTzP4pyCVWz2o2MFFWxgB0eg/fpfmEABsQk2wWa//ucsr2KzHx07aLZ6ov36X5hAszVDs3XD03ZOLSg2+9FRwQZ2cARaJThfkxeb/egoYAYLWEEFG9jBEVixVWwVW8VWsVVsVgmGNapVggs7aDZrKKsEFyZQwAwW0GzWvnZPcGEDOzgC7Z7gwgQKmMECYmvYGjYbtTy/wC82+/FCG7W88GErh7XOWR/KYVfUWR8cC1hBBRvYwRF4Vg1Hs9k1OQQ0myXvKGAFFTSbHfro4HC0mZKOCRQwgwU8bWftK7Ykn+NpO+cpFJtV6TgCz1rimMBTcU5ZKDaV0rGCCjbQFNVwBMoBJlDADJpNDSuoYAM7OALzASZQwAxiy9gytmy2ZtjBEVjM1g0TKOBpE+uLs4AUsfY9C0gRa7OzgDg2sIMj8CwgjlYGjUpQDdKgFtSd1IJnwxHYDtCeIYwkKAeVoBqkQRbxTBabr1jE+tXy0f67peOkGnS2wfxzLagHDSdLxEkpyCQWxtLwQmtr6yJLwwsVtMM8m8OmHpZz4kqxqYeOZ4RidAY4vzQuNvPQsYEdHIHzGd0oBUlQDipBNah7I9o8wtmINo+wnJ8xF5tH6Hge6DlVptg8Qkc70mz4ONI6A/Sg4XTmy0UpSIIsoh2IJUCe//b829Z25/V/UQo6/3YzykElqAZpUAsyibWBXfcT7brP9gfOH05HAe0wzV4tgnVhHYHnj2G1WJqiYVTADBbwDFusN8/fQscG9mhwy6SJlkkXYmvYGraGrWFr2Bq2hq1h69g6to6tY+vYLPsuVL/UOxd156LuXNSWgRcmR5unV8418IrN03PMoP1OGdUgDWpBPWg42S/UpBQkQTkoHCkcKRwpHCkcKRwSDgmHhEPCIeGwVLNGs4l6jg08NVbebKLehfbrdM7BKDZRz1HADBawggo2sIMjsGAr2Aq2gs1+naqdm/06XahgAzs4Ai1Lz7fKxebsOQpoF6JRCapBGtSCupOlbbWLyRK0zn9rR2rtbQl6YQM7aEdqvWAJemECBcyg3SMY1SANMlUz7OAItOys1sKWnRcKaL+MFmz+NE6030Y7XcvOCxt4lvL5R4fTmZwXpSAJykEW0RrQfgbPccxi8+rKOShabF6do4AZtCNthhVUsIEdPA/VZGdSX5SCzkPNRjmoBNUgDWpBJumGI9DS+sIM2mEOwwaeDSpGw8l+GyedLXIOGRWbH+eYwbNFmh2LJeuFp6rZ2VmyXngebLOGtGQ9x2iKzY8rzdrJkvUcuyw2P84xgwWsoIIN7OBp63a8lqw2WmDz44o9qdv8uGLP5DYTrtjTt82Ec2xgB0egHmACLZidpuXphQ3s4Ai0PL0wgRbMGspyzgYDbHbbhZZzFybwcW7zSj9T7qISVIM0qAX1oOF0ZttFKSgcIxwjHCMcIxwjHCMcwx027+2iFCRBOagE1aAzytnBNp/tohQkQTmoBNUgDWpBPSgcEg4Jh4RDwiHhkHBIOCQcEg4JRw5HDkcOh+WaDevYvDTHDp5XyPkZQ7F5acWGVGxeWjnnYxWbgVZsFMRmlRUbYLBZZVa+bFLZRRKUg0pQDdKgFtSDzkJz2LHZ/emFCRQwgwWsoIINPKuajY7YFLML2wFaXGvAZhGy4SNCswBnhl00nM78uigFSVAOKkE1yCR2gfYG9kD76bJhFZsXVm3UxOaF1cNabSjYwA4OR5sX5phAATNYwAoq2ECzdcMRaD9qFyZQwAwWsIIKNhBbwibYBJtgE2xn1lUbEbLZYo4KNrCDI9AeCW1wyGaAVRvwsRlg9ktnE8Au6kHnFWN/7sy3i1KQBOWgEmQHdF4RNpmr2vCQTeZyFNDubNSwgBVUsIEdHIGWiRcmUEBsis0y0YZ8bDKXYwPt/sLa0jJxomWijQnZZK5qgzs2mava479N5nIs4GmzkQ6bzOV42mx4wyZzVRvesMlcdrNhc7kuSkESlINKkEU8y6BNzar2uGdTs6o9cdrULMcM2l2bXQOWuBcq2MDuaJOwqg022HSraoMNNt2q2jiATbdybGAHR6Al44UJFDCDZmuGFVTQbN2wgyPQkvFCsw1DATN4Nu/8ozVIg85EMumZiBcNp/Mn8KIUJEGnxJ5PbZaVYwUVHIE2YGPPMzZzytEiiGEFFXwcaZ9/tAcNpzNrL0pBEpSDSlAN0qBw1HDUcGg4NBwaDg2HhkPDoeHQcGg4NByWofYMalOkHAW0JrNL1TL0wgpak1kHWYZeaGNx1v5tBPYDTKCAp80e42yKlONpsycVmyJV7aHIpkhVe7ayKVKOI9By2gb6bIqUo4BnE84/WoJqkAa1oH6RTYOq9gxtE56qPQ/bhKdq44Q24cmxgR08j/ScF15swpNjAgXM4Hmo1eiU2d2hzXeqdmNs850cT5naMZ5pazeH7Hdaeuz6U3rs+lN67PpTbLJStQdIm6zkKGAGC1hBBRvYwRFYsBVsBVvBNkdcrUHmkOtEBRvYwRE4t0a2dphbI0/M4NlQaf7ZCipoCmso+7G9cATaj+2FCRTQRpCzYQHthKxf7cf2wgZaZ00cgbFtWGE708J2poXtTAvbmRa2My1sZ1rYzrSwnWlhO9PCdqaF7UwL25kWtjMtbGda2M60sJ1pYTvTwnamxWYzVRtTsNlMjgm0lrSr2n6eLyxgBa0lrWPt59l+Uq7tTOcfGI7XdqYTzdYNBcxgASuoYAM7OAIt+S/ElrAlbHPbsGJYQQUb2MEROLcNm5hAATOITbDZffU5Ma/YHCfHDo5AKyAXJlDADBawgqfNxndsuTjHHjjfzEw8I9ioj81mqjbqY7OZHBvYQXvfY+dmN+MXJlDADBawggo2sIPYFJtiU2yKTbFZfbCfAJvj5Gi2ZtjBEWg/9TZYZHOcHAXMYAErqGADzWadZT/1E+2n/sIEnjYbmbA5To4FrKCCp23YydtP/YUj0OrDhQkU0GzWUFYfLqyggg3s4Liw2swnxwQKmMECVtBsatjADpqtn2j14RysqTYfyvEcozlHQarNh3I8R2nOoY9q86EcFWxgB0egjXRdmEABM4hNsAk2wSbYBFvGlrFlbBlbxpaxZWwZW8aWsRVsBVvBVrAVbAVbwVawFWwFW8VWsVVsFVvFVrHZ+No5elVtPpRjB0fg3DStGCZQwAwWsIIKNrAHNjuLbGjHO/9tBe147QJvDezgCOwHmEABLa4lQ6d9O2dsI9QXJlBAa99mWMAKKkhvDmwjetPmLTkmUMAMFj8Gm7fkqGADux+DzVu60Ma0L8SWsCVs5Hwi5xM5n8j5lOLaSSlaMskBJlDiGCSDBcRGzidyPpHziZxP5Hwi5xM5n2bO2zFkWjLTkpmWzLTkzPluOAJnzg/DBAqYwdOWLJjl/IUKNrCDI9By/sIEnrZzXZxqE5sc4wK3CU163l1Vm9Hk2MERqFwamkA6S+kspbO0ggrSWUpnKZ3V6KxGZzU6q3EhNi7ExqVh6X/eTFebPHWhpf+F1lDWDpb+yY7M3mJdWMAKKtjADo5AKxUX5ut2sdosKscKWly7HqwoXGgvbOyErCgY2mJvjvbORgwFzKC9GsqGFVSwgR0cgfNF18QECphBbGf6212Hzbu6aDiduW93FDYV6yIJsojFsIAVVLCBHbTjN9V8wTUxgfbwbU1kW6BdWMAKKtjADo5A2wLtwgRiK9gKtoKtYCvYCraCrWKr2Cq2is1+7M8x7WozuxwVtJGS+Wc7aCMldrHN+V4TE2gjJRbBHhwuNFs3rKDZrI+tBlzYQTs36yEbWLgwgQJmsIBn3HNIvdokLs12kJbt2U7Isv3CDBbwPF6797BJXI4N7OAItGw/R7arzeJyFDCDBayg2ayhrAZc2MHhaAu6OSZQwAwWsIIKNrCDZju7xaaLOSbQXponQ3trLoYFtPfm2VBBeztfDDs4Au3G4MIECpjBAlZQQWyCTbBlbBlbxpaxZWwZW8aWsWVsGVvBVrAVbAVbwVawFWwFW8FWsFVsFVvFVrFVbFYfznH2ahPIHBvYwTNjLbvnDqkXJlDADBawggq2QLsbOKf6VZtDpudYf7U5ZI52vPPPKtjADo5Aqw8XJtDi2gXead/OGc/ZKoZzusrEBJ7te75ZqDY/zLGAFaQ3B7ZBb47ozXIcYAIFzGDxwylHBRVsYAdP2/n6o9psMsfTdr4JqTafzDGDBbRzs2CW8xc2sIMj0HL+wgQKaDY1LKB6Z9m0Mz3fh1SbduY4Ai3RL0zeATbzzDGDBayggg2MziokeiHRC4leSPRCohcSvZDohUS3OWZ6vr+pNsfMMYF2FtYOltJqR2YpfWEFFWxgB0eg3fZfmECLa5eG/bhfqGADLa5dGnaDP9FS+sIE2s+X/TVL9AsLWEEFG9jBEciNgE1T63ZB9RJUg86Xb9aKZ+pf1IPs+M/fsDlP7cIECpjBAp4mu3DtNd+kFmRNZR1uWW84p6tdeN4ri5EE5aASVIM0qAX1oOF0JvtF4UjhSOFI4UjhSOFI4UjhSOGQcEg4LMHP6a91Tme7sIB2fTVDBe36GoYdHIGW6+cbtzqntV0oYAYLWEEFG2jzzJLhCLRcvzCBZsuGGSxgBRU0m/W3/ahfOALPCjAmpSAJykElqAZpUAvqQcNJw6Hh0HBoODQcGg4Nh4ZDw6HhsBrQrJetBpzvmqqtyeaYwQJWUMEGdnAEWg24EFvH1rF1bPYw0OyasoeBCxvYwRFo9eFCs6mhgBk8bTYKYHPv9JwiUW1qnd3d2My6i86/ZJXKJtY5VlDBBnbwPESrNjaxzjGBAmawgBVUsIEdxCbYBJulf7dzs/S/sIBm64YKNtBsw3AEWvpfmMDTdk5brbYMm1oJsul2en7oW22+nWMHR6Alul29NudObTDDJt3psOO1RLcXKDbtzrGCCprNjswS/cIRaD/1F9qcULswqk0FtcOpNhfUDqfaZFBr1DPH2zH/WgM7OAL1ABMo4GlL1mZnrjueChtltNl4jh08FTbgaLPxHBMoYAYLWEEFG9hBbB2bzcezEb45Ie/CDBawggqazTq2d3AEjgNMoIAZLGAFFcQ2sI2w2dJq7Zz4WG1Wn6OANufzMLRJn8mwgqfNBgZtrp/jabNRO5vrd2E6wAQKmMECVlDBBmJL2ASbYBNsgk2wCTbBJtgEm2DL2DK2jC1jy9gytowtY8vYMraCrWAr2Aq2gq1gK9gKtoKtYKvYKraKrWKzAmIjpjZRMF3/VsEGdnAEzmf+iRa3Gqr/pNlEwGYDjDYT0HEEWn24MIECZtDawZKhccaW8/MsLOcvFDCDdsaWLZbzFyrYQNq3Yxu076B9B+07aN9Bb1rOz2OwnL+wgR0cfgy2BJpjAsPWjwwWsIIKNrCDw8U9HWACBcxxDKmAFcRGzndyvpPznZzv5Hwn57tEv3UpYAUVjH7rM+cn0pLkfCfnOznfyflOzndyvpPznZzvOfqtZ1qy0JKFliy05Mz5YVjA02aj1zar0LGBHTxt2Y7Bcv7CBAqYwQJWUEGz2UHaTcOFNpnrTD2bSjiz0KYStnNKebWphI4VVJAeUnpI6aHGtd641mclmMjV1+ihRg81eqjRQ42rj6rRO9dD53roXA9WH8657NUmDTo20FrH2sHqgw2b26RBxwQKmMECVlDB5mjTA5sNvNv0QEcBM3jGPeehV5se6KhgA21ucDMcgTb958IECpjBAlbwbB17O2ATAS+0nL8wgQJm0I5XDC3C2S02ua/ZsJhN7nMU0CJUwwJaO6ihgg2047VDtzyeaHl8YQIFzGABzWb9Znl8YQM7OAItjy+0efHWDpaxsx0sYy+kdSxjbRTUpvw5jkC7zb8wgfaZil0ElscXFrCCp81GeG3Kn2MH7YsY6wDL4wsTaDbrC8vjCwtoNjtjy2Mb4bUpf21eUZbHNt455vc3hvMDnIkW185tfm4zsYIKnnFtONOm8V0Xl2XshQJmsIL20Yqdm83SO1HnLL0L7aOVaihgBgtYQQUb2MERaD/N50Cr2nw8xwJW8Dz5c6BVbT6eYwdH4Pz05jBMoIAZLGAFFWxgD7SZuckaan4HN9HOIhsWsIIK2lnMv9bBEWjJe2ECBTzPIllL2izeCyuoYAM7OALjkzo94pM6PeKTOrU5dk0nKtjADtpZ6ImWvBcmUEA7C+u3+fHcxAoq2MAOjkCbr3uh9UUzLGAF7Sy6YQM7OAItTS9M4Nk6h/WFzcy9sIAVVLAFWvKeg75qM+9as4vLflgvrKBFsDabX7lO7OBwTPMr14kJFDCDBayggg3sILaELWFL2BI2y+NziFltjp1jB0eg/dyen2+ozbFzFDCDBayggg00WzYcgfNDuokJNFsxzGABK6jeWTbHzrGDI9Cy+8IECpjBAlrcatjBEWg/ws2a2m6mz2821GbTOWawgNbzprDZ+Bc2sIMjMD5S1xQfqatNrGvn+LHaxLp2DkarTaxzrKCCDezgCLSf5m4K+2m+UMAMFrCCCjbwtHXrbsv5iZbzFyZQwAwWsIIKWkvaVT2/bJ84Aq0SdOs3+xnv1pv2M35hBgtYQQUbaOdmfWwP5oY2Cc8xgQJmsIAVPG3ncLTaJDzHDo5AezC/MIECZrCAp+0culbbcdWxgR0cgVY1LkyggGZTwwJWUMEGdnAEWtW40AbrjSQoB5WgGqRBFtFa1mrAsH9rNeBCq9J2/PYLf6GCDezgCLRf+AsTKKC1wDA8X/BaMtvEOscOjkD75PbCBAp4vrW2q9wm1jlWUEGziWEHR2A7wAQKmEGz2bk1sxVDBRvYwRHYDzBFX3R6qNNDVgMurKCCDezgCLSFC+f1YAsXXlhAOwu72OwV/IV2FvMPdHA42nS7fr4RUZtu5yjg2Wbn56tq0+0cK6hgA0+b3fnadLsLz2x3TKCAGSxgBS3uWb7m4mt2g2ST5fr5akNtspyjgnZkzbCDdmTWDvkAE2hHZoqcwQJWUMEGdvC0nS8x1CbLOSZQwAwWsMYZ20f0Yk1tX9FPtM/oL0ygxRXDDBawgnot8aVzYbULOzgCbfWmCxMoYAbP1jmHn9QmwDl2cARaHov9NcvjCwXMYLmWd9O54tqFCjawgyNwrrk2MYHWOnad2SyaCxW0s7CLyybSXDgCh52FXWcjgXYWdnHZ5/IXFtBs1seWxxc2sIPD0abQOSbwtNlTqU2hcyxgBRVs4Nlm2YLZgoo2AGCT5WyZSbXJco4FrKCCDezg2RfnDGWdS7BdmEABT5uNEJS5kunECirYwA6OQFte8cIEnnHt4rIZcv2cXqU2Q86xgR0cgZbdFybQ+sLOwrL7wgJW8DwLu87m2mwXdnAEzmV+JyZQwAwW0M4iG3ZwBNpv9+xu++2+UEA7Cwtmv90X2lmooYINNFszHIGW8xcmUMAMFtBs3VDBBnZwBNpv94XWZnaBd3q+0/Odnu/0fKfnOz0/6PlBzw96ftDzg54f9Pyg5wc9P+j5ET1vE+gcEyhgBqPn6/x63X6T6vx83X4m6vx+/eKy/Jm6sC7c4Lm4g7Vdnas7XKwLt4X7wgPWY+G0sCycF168unh18erivRZ1UOO0sMBz/YV5XtcCDM04L1wWrgvrwg0eBzHHEn/IwnnhGb8b14Vn/PlnLL6V6ToXXrh4BOtceuHitLAsnBcuC9eFdeG2cF948abFmxZvWrxp8c4lFyxddF6flg4qXA8qaWFZOC9cFq4L68Jt4b4w16HNswpevHnx5sWbpzcb14V14bZwX3jAZbbb5LTwbDdzlbxwWXj2y5njNsPqwWqcFp7Hb21bc1xLeuXv5LqwLjzjN+O+8ICv/J2cFpaFF68uXl28univ/DWeq6tY5da5vMrFbeF5bPPPD3gusXKxHZvdf+jM8Yvt2IpdhzPHL64Lm7dYG84cv7gvPOCZ+xenhWXh6bW+nrl/cV1YF24L94VH9HW7cjwZ5+ijduX45LqwLtwW7gvT1y3R1y2lhWXhvHCJvG5ztZWLdeG2cF+YmtBmTbg4LSwLUzPblfuTuZbalft2bFfuG+flvPJyXnk5r7ycVy4L14V14bbw4s2LtyzesnjL4i2LtyzesnjL4i2Ltyzesnjr4q2Lty7tOWvFxUs/1qUf69KPdenHuvRjXfpRl37UpR918eri1cWri1cXry5eXby6eNvibYu3Ld62eNvibYu3Ld62eNvibYu3L95rjadsLAvnhcvCdWFdeHqLcV94wLPO2O9Cm/Vk1odZTy6e14kd26wnM0dmPTHu817i4rQw12c/8sJl4br8eV24LdwXXrwz1/LksnBdeNbGw7gtPGtjMh7wzLWLqcm9yMJ54bJwXVgXbgtTk/vMtckz1y5OC8vCeeESfWRrnvU2UcAMFrCCCjawgyPQnsIuxNawNWwNW8PWsDVsDVvD1rF1s1VDATNYwAoq2MAOjkB7NrsQ28A2sA1sA9vANrANbCNsNqnJMYECZrCAFVSwgR3ElrAlbAlbwpawJWwJW8KWsCVsgk2wCTbBJtgEm2ATbIJNsGVsGVvGlrFlbBlbxpaxZWwZW8FWsBVsBVvBVrAVbAVbwVawVWwVW8VWsVVsFVvFVrFVbBWbYlNsik2xKTbFptgUm2JTbA1bw9awNWwNW8PWsDVsDVvD1rFRSwa1ZFBLBrVkUEsGtWRQSwa1ZFBLBrVkUEsGtWRQSwa1ZFBLBrVkUEsGtWRELWlH1JJ2RC1pR9SSdkQtaUfUknZELWlH1JJ2RC1pR9SSdhzYEraELWFL2BK2hC1hS9gStoRNsAk2wSbYBJtgE2yCTbAJtowtY8vYMraMLWPL2DK2jC1jK9gKtoKtYCvYCraCrWAr2Aq2iq1iq9gqtoqtYqvYKraKrWJTbIpNsSk2xabYFJtim7WkGZ62cxZGs7lbjgkUMIMFrKCCDewgto6tY+vYOraOrWPr2KyWnF8+Nlt3zXEEWi25MIECWkt2wwJW0GzZsIEdNNvZqDb7yzGBAmawgBU02zA8beeEjGazvxxHoNWSCxMoYAYLWEEFsSVsCZtgE2yCTbAJNsEm2ASbYBNsGVvGlrFlbBlbxpaxZWwZW8ZWsBVsBVvBVrAVbAVbwVawFWwVW8VWsVVsFVvFVrFVbBVbxabYFJtiU2yKTbEpNsWm2BRbw9awNWwNW8PWsDVsDVvD1rB1bB1bx9axdWwdW8fWsXVsHdvANrANbAPbwDawDWwD28A2wmYzxRwTKGAGC1hBBRvYQWzUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZYItUSoJUItEWqJUEuEWiLUEqGWCLVEqCVCLRFqiVBLhFoi1BKhlgi1RKglQi0RaolQS4RaItQSoZZkakmmlmRqSaaWZGpJppZkakmmlsx5aOd6CG3OQ5s4a8nEBAqYQbNVwwqabRg2sIMjcNaSiQkUMIMFNFs3VLCBHRyBs5ZMTODDNs55lM1msjkWsIIKNrCD48Ry4llLHBNo95MmtlpyYQErqGADOzgCrZZcmEBsFVvFVrFVbBVbxVaxKTbFptgUm2JTbIpNsSk2xdawNWwNW8PWsDVsDVvD1rA1bB1bx9axdWwdW8fWsXVsHVvHNrANbAPbwDawDWwD28A2sI2wzblwFyZQwAwWsIIKNrCD2BK2hC1hS9gStoQtYUvYEraETbAJNsEm2ASbYBNsgk2wCbaMLWPL2DK2jC1jy9gytowtYyvYCjZqSaGWFGpJoZYUakmhlhRqSaGWFGpJoZYUakmhlhRqSaGWFGpJoZYUakmhlhRqSaGWFGqJzaYb5yrSzWbTOVZQwQZ2cAS2Azyr8rm4TbPZdI4ZLGAFFWxgB0/bOSe72Ww6xwQKmMECVlDBBnYQ28A2sA1sA9vANrANbAPbwDbCZnPsHBMoYAYLWEEFG9hBbAlbwpawJWwJW8KWsCVsCVvCJtgEm2ATbIJNsAk2wSbYBFvGlrFlbBlbxpaxZWwZW8aWsRVsBVvBVrAVbAVbwVawFWwFW8VWsVVsFVvFVrFVbBVbxVaxKTbFptgUm2JTbIpNsSk2xdawNWwNW8PWsDVsDVvD1rBRSyq1pFJLKrWkUksqtaRSSyq1pFJLKrWkUksqtaRSSyq1pFJLKrWkUksqtaRSSyq1pFJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZYotUSpJUotUWqJUkuUWqLUEqWWKLVEqSVKLVFqiVJLlFqi1BKllii1RKklSi1RaolSS5RaotQSpZbYzMxxfkrTbGKmYwPNNgxH4KwlE0/bOfWm2ZRMxwyetnMecbPF8RwVNNsM1sERaLUkWzCrJRcKeNqyBbNacmEFT9s5D6XpXAxzYgdH4FwPc2ICBcxgASuITbEpNsVmteRctqTZknmOAmawgBVUsIEdHIEdW8fWsXVsHVvH1rF1bB1bxzawDWwD28A2sA1sA9vANrCNsNmSeY4JNFszzGABK6hgAzs4Aq2WnGurNJvp6ShgBgtYQQUb2MERKNgEm9WScxWVZkvmORawggo2sIMjcD6sZEO7dRfDETgfSyYmUMAMFrCCCjYQW8FWsVVsFVvFVrFVbBVbxVaxVWyKTbEpNsWm2BSbYlNsik2xNWwNW8PWsDVsDVvD1rA1bA1bx9axdWwdW8fWsXVsHVvH1rENbAPbwDawDWwD28A2sA1sI2z9OMAECpjBAlZQwQZ2EFvClrAlbAlbwpawJWwJW8KWsAk2wSbYBJtgE2yCTbAJNsGWsWVsGVvGZrcSdaIVm2qoYAM7OALtVuLCBAqYwQJiK9gKtoLNbiXOJaaazTZ1TKCAGSyg2bKhgi1wloqJAmawgBVU0IJ1ww6OQLtTOBe0ajYT1VHA89DPZa6azUR1rKCCDezgCLQ7hQsTKCC2js3uFM41qJrNRHVsYAdHoN0pXJhAATNYwJiDMWeiXthAs9nlaXcKhjYT1TGBAmawgBW0c6uGDezgCLQ7hQsTKGAGS6D9zp+LPjWbR+qYwXjnM3jHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOnjHOueR2lujOY/0QgHN1g0LWEHr42bYwA6OQHtmuDCBAmYw3jANraCCZrNjsEpw4Qi0SnBhAgXMYAFPWzOFVYILG9jBEWiV4MIECpjB09YsRawSXKhgAzs4Aq0SXJhAAW1UuBgWsIJmy4YN7OC4sNs8UscECphBOzc1rKCCDezgCLRKcGECBfRn9H7MvTSOE+dmGhMTaI/2wzCDBbSDbIYKNtAOcv7ZEWgDCReetm42G0i4MIMFrKCCDezgaevWqPbrf2ECBcxgASuoYAPNZi1pv/4T7df/wgQKmMECVlBBG7YwmxWFC0egFYVzXaluE0IdBcxgASuoYAPt3LrhCLSicGECBcxgASuo4Gkb1lmW6Ocm2d0meToWsIIKNrCDI9AS/UK7qi0DLNEvzKDZxLCCCjawg8PRJnk6JtDOrRpmsIAVVLCBHRyBlugXmq0ZCpjBApqtGyrYwA6OwLnB5sQECphBG4wbhhVU0GwTOzgCrT5cmEABM1jA8xOx47Bmn5tsXtwW7gsPeG60eXFaWBbOC8/4Z5amuVfmYX0xN8u8OC9cFq4L68Jt4b7wgNXHKbvN2nQUcErVuCxcF9aF28J94QHPvTMvnidrDT53z7w4L1wWrgvrwm3hvvCA7dvN41zaqts8zmBZOC9s3mQdZN9uOuvCbeG+8IDHsXBaWBb28eBuczodKzil1imjLdwXHsE2rzM4LSwL54XnyapxXVgXbgv3hQecjoXTwrLwjN+NdeG2cF94wHIsPOMPY1nYzstuOmxeZ7B5z8VRus3sDDbv+eFst7mdwea1n0ab3Rls3nPRiO5b9U6e3mpcFp5eO/dru97J09uM+8LTa+d4bdk7eXrtHK9NeyebN9s5zm17LzZvtnOcFeZi82Y7x7l178XmtcS/Nu+92LzZznFWpIun185xVqSL/cVCl3iN0SVeY3SJ1xhd4jVGl3iN0W3a5yOatZLKwnnhabQWmOXoYl24LdwXHvAsRxenhWXhvPDibYt3lp1iLT/LS7HWnuVlntcsLxeXhevCuvBy/H05/r4c/1iOfyzHP5bjH8vxj+X4x3L8Y2m3sXgH3jwriZ1jnhXDzjEfHH8+dOG2cF94wInjzyktLAvnhcvCdWFduC28HH+i3bIsXlm8s2LMc5yVYZ6jLMcvy/HPynBxWlgWXo4/L8efl+PPy/Hn5fjzcvx5Of6yHH9Zjr8s7VYWb1m8swLMc5yZPs+xLsdfl+OveeGy8NLvden3ee9xfv7e87z3uNhffvWsB5hAAWfsYjxjzH9vbVDt2K9tuCenhWXhvHBZuC6sC7eF+8KLd95KVGuzmesXy8J54bJwXVgXbgv3hQc8Fu9YvGPxzlwv1s8z1y+uC+vCbeG+8Agu827i4rSwLJwXLgvP8zqvizJz/RyA7mXm+sWycF64LFwX1oXbwn3hAc9cP7d66GXm+sWycF64LFwX1oXbwn1hf+XabeqlYwKntBrnhcvCdWFduC3cFx7wLAznEHwvszBcLAvnhcvCdWFduC3cFzavWufOQnKxedUafxYStcap/o65l1rACirYwA6OQD3ABAqITbHNwnIOSfcybxYubgv3hQc8C87FaWFZOC9cFp5euwZmwbm4LdwXHvAsOBfbnz+HL3uZheLiAc9CcXFaWBa242zWX7NQGNeZ4DaEWGeCX5wXnn++GdeFdWE7zj5j9oUHPAvCxWlhWTgvXBauC+vCi3cWBBthm2smXjwLwsVpYVk4L1wWrgvrwm3hxSuLNy/eebNwfh/c66wJF+eFy8J1YV24LdwXHvCsCRcv3rJ4Z02wocI6a8LFdWFduC3cFx7wrAkXp4Vl4cVbF29dvHXx1sVbF29dvLp4dfHq4tXFq4tXF68uXl28unh18bbF2xZvW7yzPtjIaJ314eK6sC7cFu4LD3jWh4vTwrLw9Hbj6VXjurAu3BbuCw941pmL08KysM/06XP+5YUVnNJh3BbuC4/guSCmc1pYFs4L28naAOpcENNZF24L94UHPIvVxWlhWdg/Iug6a8+5IW+f62FePGvPxWlhWTgvXBauC+vCbeHFK4s3L968ePPizYs3L968ePPizYs3L95Ze879GPpcD/OwweW5HqazLJwXLgvXhXXhtnBf2L+f6HMO5oUJnFI1zguXhevCunBbuC884Fl4bAR5Lp7pLAvnhcvCdWFduC3cFz696dyEoetcEO/itLAsnBcuC9eFdeG2sH810ufszIlzpvfEKU3GsnBeuCxcF9aF28J94XmydnXN1TgvTgvLwnnhsnBdWBduC0/veUW1uUrexbLwjN+My8IzfjfWhdvCM/4wHvBcjfPitLAsnBcuC9eFdeG28OJNi1cWryxeWbyyeGXxyuKVxSuLVxavLN68ePPinat02nV1rdJ5cVm4LqwLt4VtitjZpdcCnDawfy3AeXFZeIYUY124LdwXHvBcFPDitLAsnBcuCy/eudCmjclfC23a2/Vroc2L08KycF64LFwXnk/+dgnPunJxX3jA84bm4rSwLJwXnvGt+Wf9SPPf94UHPBfUvHielxrLwnnhsnBdWBduC8/zsv6dNy6Tx7FwWlgWzguXhevCuvCIc78W2rTzuhbavFgWzgtzXtdCmxfrwm3hvvCAZwm5mPPqSRbOC5eF68K6cFu4L0x79nnzMs9dlvO6FqGfXBfWhZfzkuW8ZDmvvJxXTgvLwnnh5bzycl55Oa+8nFdezisv51WOhZf2LEt7zpuUee5lOa/SFu4Lc/1fi4nOY67LedXlvOpyXnW5TupyndTlOqnLedXlvOpyXrqcly7npct56XKd6NKeurTnXKDX3sf1eT8yed6PXJwWloXzwmXhurAu3BZevG3x9sXbF29fvH3x9sXbF29fvB3vmNenzTYa8/qcPK/Pi81rD9VjXp8X54XLwnVhXbgt3Bce8FwE9+LFWxZvWbzzOrTBkTGvNxuMGPMau/79PLZiPI+tGuvCbeG+8IDnb9bFaeF5bGqcFy4LT28znl5r/7k4tD3XjXnt2aSfMa+9eS7z2rt4Ocd5Xdlg3JjX1cVt4b7wgOd1dXFaWBbOC5eFp9fOZV5Xaucyr6uL+8IDnre6auc7b3UvloXzwmXhurAu3JzHMX+bzs0nxzF/g87BwXHM351zQHAc83fnHPgbx/zduXjA83fn4rzwjFOM28IzTj153nKeEwrHMX8XzgHEcczfhYv7wtPbT77ybnJaWIg/8+7692XhurAu3GiHmXcXD3jm3cXL+c77yXmO837y4qUdZo5U+7szR6q188yRi2XhvHBZ2OJX885cqBZ/5sLkmQsXp4Vl4Rnf2mrW4YvrwrpwW7gvPOCZL9X6dObLxbJwXrgsXBfWhdvC02XXw8yRi9PCsnBeuCxcF9aF28J9YbzpOBae3m4sC+eFy8J1YV24Rb+koy9Mn6Z0LDz/7jCedePM5TQf6S5OC8vCs26IcVm4LqwLt4X7wgOe+Xjx9CZjWTgvXBauC+vCbeHB+c4cPF8yjTmbzrlwjjMHL9aF28LzXKw9573Z5HlvdvE8l2osC2fi1MVbF29dvHXxzt/Ni5e+06XvdOk7XfpOF68urpn7xY555v7FaWFZ2OIUO5eZ+xfXhXVhO/6ixn3hAc/cvzgtLAvnhcvCdWFdePH2xdsX71i8Y/GOxTsW77UZi+XvzOty5uCcL5fOl4VjzpdzzguXhevCunBbeObyYTzgK5cnp4WF45m/pxeXhevCunBbuC+8nOOsD5Ptq5psh2lf1Vx4fnlS7GDsq5oLC1jB8zuX84FgzJULL+zgCLSvai5MoIAZLGAFsdlHM+eckzEXJjynmYy5MKFdr3NhwgsLWEEFG9jBEWhf2l6YQGz2+ZxdXHNhwgsrqGADOzgC7UvbCxMoILaGrWGzL20tz+fChBd2cATal7YXJlDADBawgtg6Nvum1nJsLis4Lzn7+O3CBnZwOM5lBS9MoIAZLKAphmEDOzgC7ePYCxMoYAYLWMFTYak7lwq0u7u5VOCFAp7B7BZuLhV4YQUVbGAHR6Al74UJFBDF3OrSjndudWlYDjCBkf5z+b8LIyEzCZlJyLn834UdjPSfy/9dmEABM4htrmA+cQQqh64c+lzB3M54rmA+sYAVVLCBHRyBczeEiQnE1rA1bA3b3PfgrFFzxb55bnNbg2IY5XUu03ehgg3s4Aic+TYRxaB9B+07aN9Bbw56c9CbI3pzrsJnRXeuwmdFd67CZ2VwrsJ3oYIN7GCU17kK34UJFDCD2FIUvLkK34UN7GCU17kK34UJFDCDBcQm2ASbRHmdq/BNzAeYQAEzWMAKKthAbBnbTN5mGOV1rqF3YZTXuYbehQkUMIMFrKCCUV7nwnkT9QATKGAGC1hBBRtoZfC81ucus1Ze5y6zFxYwyuvcZfbCBnYwyuvcZfbCBAqYwQKiGJy8JaQ9x8z9ZC/MYAHP49UZQcEGdnA42lp3jgkUMIMFrKCCDewgtoTNMtaev2zylqM16kRr1PPyrPMXcmICBcygNWo1tM5Sww6OwPlbODGBFrcZZrCAFVSwgR0023mt25wqxwQKmMECVlBBUwzDEWi5eWECBcxgASuoYAOxVWyWpvYYaXOmHAXMYAErqNHqSmcpnaV01ryUzz7WedFWwwQKmEETN8MKKtjADo7AedFOTKDZ1DCDBayggg3sgXaBz3OzC/wcyx02kcexxgnZr8iFDeygHfrZQzaFxzGBdgdyGGawRISMLWPL2DI2u8AnFrql0C2Fbil0S8FWpuK///uffvvL3/71j//489/++s//+Puf/vTbH/4r/sV//PaH//Vfv/37H//+p7/+47c//PU///KXf/rt//vjX/7T/tB//Psf/2r//Mcf//74r4+z+dNf/8/jn4+A//fPf/nTSf/9T/zt4/lfPUeV9frr59uNESEeg24fgqTnQWwNcQvxuJElQCsfAsjmKOyDwnkQh+rTELsTeQzY9ojxeMP99ETK5kTED+NxoxwBmnz4+/X539fz8y77+6p0xmN46/YBqAd4vKd7dgDt+d9v5xwG+/st6ysHMM6JFVdX1mcHMJ7//Xr+jtvfr62/dADVA4yH9ckBpN3FGNfz4xXlS0dwfrl9XUcpPT2EvOmFEZdRkqeHsLuYi80SnAfxuKHOz7NyczVKGX41PYaB1oTot2Pk3Ly6PJ59aY3H296PMTYXpb00modxcCb581H0TZ8e5X/Iy18ibK7L0f2qGOPFCBo9chzyPMSuMWv3GI+n8f60MWVTKkWqF9vHqONyYeRP1TbvOtWvi8dTLRH0/qX1GEHgTHJ7fiabGI+bJb+0Hkhr6KcQusuT4dXi8T5BnobYVcwW5WL97arldgQbS5gRND2PcPc02vPT2DVmO1IU3mM8C5HTrlz0HOWipKch5N2myJtLU464l5Cz1nmM8rH65u1vqJebPtrzg6i7ewmN3+GTOYzHCOL9U7Ed5K9TqenpqWwuLeneqY+B3WcB9jk2NC6LlJ/26ft1bxfiUWXiR2SM5z8iJe1yRCVyZGkM+XQcZXN51u4d8ngyWiK0b1wZfXBljKVXP18ZZXeHUbpfoufAAjHqp3PZ/bi3IxKlyVIzbvdKOSLCYyzw+a9R2f60x+3a4+Fh+S1Jn263Nj/ujzfWLdr0MVa53DE9fiM/RBnvXx/1ePf62J7LYxjziHPJ643bp3Opu994m1Z0VY5OMX9UxI8x8rvXx+4qvV8F91HuZkzV9zOmtrdbZNu7mrkt16VnfundzZX6eNvpNfnxtnO5zlL9EEM3V+rjzZu3x+Md2xojf4yRtrf2frk/Xnbl5zF2xyElbiUfbzqfx9hcqWXEcTwGZ8fTGPue6dGoj7up3p/2jO4e39PwVn0MGT2vQ7q5UkuKAlBS6i/FeAwVx1N0kuO1c8niMR5jU8/rkO4e5jV69zFw+TzGtmdqKxTmvmnVtvv1TzZG7sNU7XiSvU1+1/zX0mKcSh+j18/PpfyuvzLNFjKYx3Fus/z8ODZXmWSey9fnQPn0+9/erqnboyjJ80VKOZ4exe4uRGyazvV72dLTu5C+q2Q6/AJ7vKVeW7TdjvH48fci9HgZeTyPIe/fx/T89hW2bdF48hD5UIH0fgzJxNj1ir47dNTbu0NHvb87dLRviR5Z8hg4edoS49jeJcfw9uM99RLj413D2P7iS1zjeR0h/xxjOzS5lJ60ibG7N80xTP0YadCnMbZtqjHWIPrhXL5xhWq0qbQPx/GpX96+QsfbV+j4fa/QVmOsYmzy3W5uno/dNAY88vowmD8F2Vyj53Y0/gqj1f5akHPZgBiIqmkTJL9fie2T6N+xFNv6llfXNH3tQh9xGPmQvune94fxj/fH8Y/xe17r2ZZ4u55ZsjxvjN1bpiQ8G58PsgQp3whi611dTdqPTZDdZVp7NEmqIxEmf7rtsA+cn7ZrjMGsF9n5huF2VVfuGdrxvKrbN5jPz2bwiF3HUgA+d862mvGC4/jwxPH5SDbXapF4J10eNfHpi5a0e2mURjz8yLH8Wn4af02yuzONEfFyPB/PTrK50B7PKo0X08fTIZgk25f0Q4SRHMlPR2H2vxI13lSI5k1tlvID7Vrfb1f9iXZtP9Kuafv6JkV9rmNTTGT7+l5iLKYuYzG/XPT5eL9zdi+jbnbO7mXU7c7ZvcS53zn71zAxOvUYSHn6am33xvUxmBzlqKwTGz6/iM+6++mL+6KcPry2zd8IIkf7n38/Pwfpb7+5TbsXGPde3W5D3Hthef9M2uZMdk1q35pdTbq7Xy357Zur7Yupe7MktiFuTpPYNkfVuEPb3r6X7Yv9eJ197nz3vJRtg/SY53DuObYJMt6/1nevpm5e67sQN6/122eyudb3TarRL3282C/ncv/RHm1zc1Z3L3NrDBs+RlGXwdzPE2G21+qI+TiP95ibkrp7NXX7CunvXyH97Svk9pm8Wg1HPEg83lHr8yZVeb9Jd2+mbjbpLsTNJr19Ji83aeV+6uiv/fAX253iClJ2/dJ3t0K3Zn0l/YGC2t4vqO39gqo/UFD3Lfr+zWWL2/7S2nh+c9l2bxwlBqq05E1N3r0OGmmZLHA8L8n7Bmk0SH+xUe/Np7P1jJ4/kcXroMfDWXkaox/vX+o9vX2p70LcvNRvn8nmUt+2KC9BHi2qr8Wo8QwkNefnLbp7QT/iJUgdOl6MEQNd2xj7K+zWlE1bDerdq+P9p6jdq6mb8z7T2M0+vTXxM+3GMNUWbfPx+mWe0ecWHZtHoFuzNreHUUe8MNRjHdH95TB2Q6m3Z16l3eupu1Ov0u4N1b15Avsr5N50WtmOPb7fMy3G/WtrZdMzt4OMF4P0GO974MtB4vOOun4u870g44jpSkPKi1fr43kvBtoenDdX6/aivztp8YswLW5mHqzp5TCD0cO+3Hh/LwWb8FGUyiYFbwcZrwbhU7826mtBzq0N6aOj78JsG9d28b2umGO5wfpmH/VlhLcvN67fDbN8w9jz5vq9/4v+/KOY3ZurxgBLe/5Lur+DvvXZgOxeW919WtwHYTr145Gib4LIrdeB0srmbPLb9+Gye2l181OjXYib3xrdPpPNx0b7FlV+znt5KUa2PLjeRYz2aozj7RiZm4K8PHJ+L0bcej7CPY+xe11185niixi3nin251KKX6a5aH8/xovXWJb4DjeX/rxvd99PpeVm4DHEsUmY3YG0ePOWmz4vH7v3TLc7d/zOndsS57JJ3LKdBxATgc41ul9t1PjAOffNVbZ71XTvHbGU7SuAwYTu4/mt6/Y4SoxZlXWS/C/Nsf2dizdeJa8vRT7/zu2mhd8cb5IfeFcl77+rkvffVckPvKvat+i98aZ9jHvjTbJ7U3U39fdXx62xIqnvfyxd3/9a+v6ZbD4cP968R96nbCmk/YcPbD6l7O7dzr139rJ7w3Tvnf0Xp8JUt7K7y94ex70X//sDGTnGNNIhmwNp77fp2xOq9yF+oDmqTT67mqNsmqOl3/NKryV+nOqj/GwOY/eVX4of62WRITk+r7NQ3h1E3B9FjOqsP9W/HsX2A7/4TSiyzm67H8LGBxgrqMdrQUZlwGGsL/6+FaQfjKEsA+/fadQYuCtj07W790s/EOIca2NUqaenp7IPcrNn9kFu9swXQe71zDZzdblv+PCZ4DfGYDTF2ejHdQK+FSSe5h7HVF4MUuLJQz/MTv1WkByjhlrb88llsnsZcfM3Zve26uZvzDbED/zGaI3jUE275tg/Rt2atS+7EVTVmI7VDt382u3Glu/O2pfd26qbE5hljHcfTvOx7Zp7E5jzsa8jNycw78OcHx3yekbb0zBfXShH5UJZRg++UdVajkXqWi7PL9l81LcHhe2L3jcflvPx9iPVNsTNVZdun0nbnEl9e1B4G+PmoPBXMY63Y9wb0M27L6o+PLRXefE4bg1Of3Ect8Ye75/LJsb2XEq8Js6PMv38OMbvfRy3Brjvx3gxX24OcOfty5ybA9z7A7k3wJ23X7jcvMik/s6de2+AO0t/f4D7iwO5NcCd89tf/uXdd1R3B7i3x3FzgPurO8TlK9Vanvzw593KfndvM7dBbj6/b+8PW8wSe+DzCzW/P+U/57en/G9D3F2x8f0p/1/cccfvXBrjeQkq8gPlY3fLzUP3A9Pmlnt3f8rMh7Y+PnwriDJHTFvPLwbp8SCjveWXnyDWeYTLAOB3nyBi1Y/zaaJuwmzbJV6naCvyauPy0NuP53PEtk94d6vi7k3GMWIRk3T0l1JHEt/9ps0vXn37TWquP/AmdXsc95r0i66NocRHL8uLl3w68jK1rLz80GyfW/mdRHs5c2x9gLgheZ45sp3oLfEegNcA+VsjkmNplKO+NKz5+IuDIPJsWDNreX9sdBvkR8bxb7bINsjtFuk/0SL93RbZzw/lO7Px4ffzW5NMR7xZfQR5Pt1V0vYauTvJdBtGbZMd/wV9OpK/DcGQlw5pr4WI78N11Oc9k2/eHeVXp4sPlocYZfNdwvYD4JGjEq0n83mINv/At1X5B76tyu9/W5Xf/7Yq/8C3VfkHvq3KP/BtVf6Bb6vyD3xblX/g26r8/rdV+f1vq/IPzCnPu1dN9+aU79M+hmXbGJu0331adffJezsUcTPtd++qbnbsLsTNjr19Jpu037bovSfvsrvnvptu4/0Vncoh7z7GlN2if3cfu7fHcfMxZvsN4b0nw32Me0+GZfdu6W6T9vefDLfHca9Jv1gzJJan7Klvds7ZLuR069Py/TYrt+5cSnr/a5SS3v4aZRviXgm7fybttQa9eeOS3r5vKen9Kf7lJ15vydu/THU7UHfzS8z9Til3v6D8IsrNDyi3a1Ld/H7yfozxYox7X0+WH3mu3bfr3W8nt8dy+0r5YoeQm19O7qP8yBndvmq/iHLzqt3ueXLzqr0fY7wY495VW/UnrtovrpSbn+re3+fs6a1VKe9Oqt5uidVi7t7j2W1drfPzUeTtDAJmqaRnr1T3Ifjw6MOS8J9D1HeHDbeNoXGz+xjmqJvGeHvafynvr6Ne3p/2X9LbXbJb+TSW+dcPc+3b/QhxZ6fLp9u/RNhOPDiiHNdlsr58oyVSEW4OJT+PsX0xNYT1sYcsHXt/45d7l/gXm5zFbf+DN5v6lN0KfTczfhvi3uWlx9vNsRuSamwV0NqzeRy7LwTvXePbCPeu8fED1/j4gWt8t2HU3Wt8u+mcHPEYtW758sumc7sYlU05an0eY7+VV9Flp5PxfHOj0o63M2Ub4l6mNPldC8eH5viwjfO39pyL/eJE87rXW30xRns/xjJ741t73x0adwuHbvaLa7tm7ezk1XveBNmNzcfbsL68IPheiHhf2mt7MUR8JdCXGXGvhtDNRoD7D+tioDBv23P7qTS/Cprqiz07YvO8x5hyeu1s2JLww2aC34nxeNUemy1pf36Z3t4qsj1Pl7J9CXXnWaXuf6wjafvxvHiU3RdTrUbCtbqucPD5p3K/VAsFeX2F9Pkne7dLyVjWgFs/Mf4cYzvucbCnYTqWPTy/U5J7/PBL//Bb+Y1y2uNx44G6uT52PzBcIA/e/d5u96CKDzcegy9LjPbxEW67dabGdVY+TGb/zvabjYU0HlXttRglvi8q6wj9t7bwzBrrx+b24vabLT4QeGB/LQab8nx4YfGtGMtX+ePDcvzf2Qb0iF/+87ZZX43CNKcH9xejyPLSIevmlmq3E9W9rb22Ie4+xIx3n2K+2Ft1mTs2jmeTnOruPc5I8d5hpKf3yvsQEp/3D5H+yr1y7WP5PkBfvMj04GFK0/E8St1tQnXvAWQf4tYDSE3jd30A+dgc6fVGrUTZbAO8j5LilvvBm/pe5e1x032Ie10j9fftmg/NUdvLXVOWKM+L6m5xjnulbBvh3njM9kyacKm28fwiq9sXBPcGp7afXT3uqaJnmj5dR+KLIG3Za7U9XUfiqyBU9we/VFe1N66QkZ8PXm4nOv/MrtUSs0kkH+sjc3otRpLXYtSYpCxV00sxHscfe8ccHx6aP8bYTf28+cKh71dqjafd9GFr4W9sfZ3iafdR18rTGHW7oN+9urwNca8ul7cX+Nk2hkTyF/lw0/25MXbvHEbsQPF4KNZNkO0jRFTlZRn5z8VwfxjKYXx4kPnWufAk83H/2e8FiblXR325VeNbtnq8uEX77W3e87s/l9sIt34ut1vN33x9sd+u/t7ri1rH+68v9ns+13h/0dcj+bwqSNX0dgXSt1/f1u3w470PcfatocvActu0Rn3/HcouQvzk5yzP91qu7y/oV99f0K/+wIJ++82rb8bYbhqdeMaVD4sCfpziV3fvpZZlRZY53+07207fzdn93tXLmm21L8tP/bp39X4L7GVdgHWfxm+HoSCub0K+tZP2+b1o9PKHGWT5O8cy0rJegrx8Snx1keqHj+m+FUYPGliP5R7xc5i6/fjzZ8J8mNeen29Wvg8iOZ4BpB4vBskaT4rrMkG/dvX2SNj6qKTnW8nX/v4CTl/EiN+Mx61Bev5bvg1y86biiyO5eVcxjh+oUNu9rO99cFTH+1tR1vH2VpTbEPdm698/k91WlNtuufXBUd19IXx377Tt9uA3l/rYBrm71Mf+SG5+c7QPcnOpj692O7+51Mc+zO3FAr8Kc3PFkC+a996KIV8EubdiyHZT+5sfMe2y5+Z3YfsY974Le4wYbG4gb30XpukHlqbaHsfdJt127b0VQ764Vu+uGPJFmLsrhnwV5uaKIV/d9h28X/hQ3z7dr2l6e9LqPsSth2qV43cNcfO5/IsbcpYM0XWhjs9NOn7iWXQ7ISdK/ePVwmY35+0wQ2LmWJby4jDDzZ5p74+Y7G6PNH4muta0aY+334LtQ9wa19ueyt178H2Qm/fgmn9ilEDe/+hf8/sf/Wt++6P/bYh79+D3z2RzDy7vf/Rvl+K79+CiP3APvgty+x58eyR378G3Qe7eg0v7kXvwbZj79+BfhLl7D75v3pv34PsgN+/B97Mubt0wyvtrM+xj3LwHr/nte/BafuAevOb3m1R/4B58f63evgffh7l9D/5FmLv34NvbgRp3FB92rPnWHcWIEOX5m8L37zfH9s1arPr1eCm0vp6r92O0WAYtjw/fid6PUY6IUY46nsbQ3ezee080+8OIWvZIn91h9LdvBb6IcW/Qdx/k5g3nF0dy84Zz92Lr7g3n2N75LvOUUnt+me0+M1C2l9APE1G/EaNG7ou28vwa2c0xuvfyVFt79+XpPsTNB9bdlqHfuKNJ2xcU97YgydtZtT0eN9OHLyY+ZV5/f1tq7e8vBKT97YWAtiFuPtbcPpNNLevvb0u9jXFzB5KvYhxvx7i3A4nufmRu7kDyxXHc2oHki+O4tTTS/XPZxNiey70dSHTo730ct3YguR/jxXy5uQNJ2639d3cHkv2B3NuBpB3v75/+RYwf6Nx7O5C0Y7/s1a0dSL44kFs7kLT3l/9rP7H8X/uB5f+++N2/tQNJ++Kd1a0dSLZB7r5GGG8PibbtPKV79w4t1XfvHbYh7t073D+TzZDotkXvDYm2H1i+L0n6iSHR9BNDouknhkTTTwyJys8MicrPjGWmnxjLTD8xlvn+y+/dJXt3LHMb495YZttNjbj5Q5PlB35ofmCKxr5r745lys+MZcrPjGXKT4xlbr9YuDWUuf/m4c5I5v6zrXhyf+C6Ksc3Pv1SPh/TkV+L0WMpC1mHMr/3+Vh8/fnA5+dSt6vN3fwGbRvk3i4Z+xC3dsn4IsSdXTK2vdLiB/wxJHO81rMfYpQXYwgx8uYKq29/y7IPcWtmRqv5dw1x73553576P37R+70+iRtEWVdJ+V6M5ThejdHjOfeBr8Zgsf1tjLdfTLW330t9sWZE/F4PkReXnYgPAR74dOW87Roct5rii2U87rTFfrWYaIra8ourxXB9PvDFGF3iOPpuFZ9tjFhb5fEj/eKqNeRJ7a+uwEOePMK9unpOjAc98NX24KvVkTb9svusufIhb9Xxfoz22spIReNdYVkXRvh17Z3t+suRco9L9vlnY223UlzhgaF8eGCo3zuS2M1K+/Mj+SIIczFbfv6RVttuRVXiiaGV9WOkX4LsBg3jbNatFM7Sert/O+/GdkvwtO07qbv92+v7/fvVkdzq3y+C3O3f/hP9O37P/q3HwRf0m3V82vZtjsQoV5VlPOeXGPvvOnjOXpet+MYqbUe8MKxH2yxIslsN8Pa51N/3XJiK/cDX6nvNKU4lS34thnAcHyf6vBqjvRijy//YLd+KEYtWPvDlNlXaVF6MIcQom9/M7frO8VmyrP3yeW3mfry9IsA+xK0Hwn603zXEvWfKbXtmFgDK7fla1333+dK99Vl2R1F4Ki2jb45C3q5gPeW3K9h+9XBhYw6pT89lH6Oyk5M+b4+i220sby5jvgtyb0xsH+LWmNgXIe6MiW2Xyb/5cPvus+12O4pbx7Df0OLWWMNuG5ybWxvvY9zb2bjsJp99Yy+d/P71md+/PvPb1+d+K6vbmwLto/zAJlR3r5F9jJvXiPzMNSLvXyPy/jUib18ju1/ZGgtc1sczIW1xO4AylrTWj28EyCMCLANJtwNIYrJoWn+SPj257UPES4W0FsHvhODN1+PN8dMQvWyfl6Ip8vFiiJi39mGbgG+cyLr6y7oPxTdCaNw0fXwL+I0QLR4NHq95XutUic0wHn/rtRA5BuQerZJeOwreZubjpeYshaHF9UY2jbsRki16cL2jXu5Av3EQKfExROovXVkpx7X5wNeOovKyvS5rHH8rhDIjqo/XTiQmy6Ysr51IjsL9KF+vnYjG9Z20vXYUjY0h1zWBvxNi0BZDXgrR4k1CK/pKgOW2oL7WDsdyn6TPL+6+3xvh3TQdsaTEuqrpdxpC2Y6yvtmSrwV4PBPGcExdTuL+7UCNSRePe5OXbkjiUfmBL92QFDayri8cQWpMLGpt/Rbv48YyvdXdD+DBBxtLXuk3EjOq7Sj69Ci2JxLjhGmsm8r8ciKbsfl7X1n13R5M976y2oe495XV9gYvjuLDJnC/NMZ2TVhtlMvH25tn79S/ChK7jqRzKurTILuvrOvBIt21bE5n92jIDOU02vM1C/tuRbu7L7T2p9Ojcj3usvLmdPruXXLcGtSxvBUb7X4MLbHWrpb8YgxWyFddfpY/x9i9Rrr7ZfP+MA4OIz8/jLwtIZShtj4ofx486Nttpfrg09W0jEDo8Y3zaTRra8+7ZmwnFsYTQT6WadLl87r0uzX6BjNPR1o+1vw1yHbnAT4bf/CHdTq/dSzLNKFlLu3nYxm7L51up/C2aVm99/GCbXck25nOvSxfobRdmPw716THW6D41lGO578YY/dOSKrytfTmJbvtofv7no7ES/bHuy7ZnM5uH8MUd9qybobw6+mMnzid7ZyB+GS61eU116dqMNJ2EmhMEF5qwef22L5f4qe8ftiVpXxeMGE3kfSIYp+PZaTjc5B9e6TBbI7lxuSX9tjdD7S0bKiy3FSU8SnIduZB3L+v73N/CdHer9Jjt7De3So9tt9O3a7S+xO6Wxsl/Uht3H3xcDf7tp3c4+7zwwTEz528XSfobmXcrXn0MyfTWdV8XaX6l7NpP1AYpf/E2dTtJTu4Y9ucTt7uRBzjAI/Bsl2Q9AM9nH/ict2eThr89q17q/1yOuUHujjX3/u3T+NBpzV5Xuvz9vvnGDssx3J380styduFbfjssCwPsiN/irGbkpBjBuGHReLPe5QPQcp2pJ9h+rJs5JvLpyMpP/CB6hdHEsNPsq5e8OuR7O9fb03NHNtXSbeG4vZ9U/iaQtf9kX/pG/2JDN7uF80rPl3Gsn49kt0AAftX1GO9v9H7eVNSbMJdZJmM+Eve1B944Nq9VWoHWwrn8cr4YNGYe1daeT4+OHafMN0bHxy7pfrujQ/uQ9zcK+6LcTm2N9HnmxI+XtS/P7i3DXJzn7b+Ew1St0PQmXdDrw8P3iplXwS5N8t87PaeujvL3Jru6c/mrVnm21/vx0B0dO/J49WRn+X5Zvn8+bsjP/d+aPZB7vbO+IHeace7vfPFCNTHRdTGyyNQNxs2/0DD7r5FvN+w9e2Gvf08vrte90FuDne2n3jM+iLIvQ7eB7nZwT/xddR4/+uoL8YnbmfOF+MT9xp2H+Ruw+pPNGx7P3N0+0Y7Xmv158+uu4+jSo6JNyWvWwB8Hqfcjtgo7xx1s2XGVyM2N7u3/kD3jp+4Hxjld+3eEYvujGX5kV+6d+y/kIo5D2mdsvBL9+62nuINeV0HKX8N8hNlUX6gLD5ubY/3+/cRJb3dwdtdiZhjJesMp89dnI7dzUA5YunNktZdTT53z3ZI7m4K55+o0Fl+pI/bj/Rx/137OLNSVF7fNvzax9s9n7rGoNxYV4v6pY/LD+Rx/okynetP9HEqP9HH6f072O1oJ98qpvW7uPHLtkK7Z/uy7H2+jECVb8SocZWsawJ+M0ZjHQp9MYbGPu4fvvF7OUZ9NUa0h77cHhrtoS+3R4tzaS+3xxrj1fZo0R7t5fZo0R7t5fbocS795fZYY7zaHj1m9vb28nG0eOPZXz0OG0W5noCPH4jx8nF0vuV6fn1s35XcXYdz/8KlFibKHc/fradjNyLfUnRNk3WY8tcouyVTYn2gtS7nLN84nZvLZ34R5N7apPsgN9cm/eL90Z254PsQtyZzfxHizvdlX7xNu3sbUn5gNOAR5e3hgEeM7SSse9+qJZtX9LRhb32s9kWMW1+rfXE2Nz9Y+yLKzQ/O9i8Za2JS9fI267uvO2++u9WfuGTrj1yy9f0RrP3b28p75GUZhs8N+ziQ3Qo/KeYi57RO2Pu8F6be3fZ8eT33S5PodnZ2fLa7rgPzrRCxuoX2/mqII36Cnx7FFy/EWdHu+HCb9/kw9otRxb5T68aebwQZz1/N35wj0I60ucr2mzUx472sqw3+cjq7D7uPWD5e07o03ucgbfvNptR44Dw/WvyRMEmeN+724ZevP7dTfXbPvkf8lpejPp/X+Tif7ZY8Xkv68uXl5/k1jxj11tPv+tV8/nyhNH33jvGL42CVrnVG2a8x+k9U+fb28mnp6D/wEf25JMX7NybbGDdvTPoPfPr9RZTbNybbxOmM/R5jkzi791k5nrbKcjq/jF5t32bFw0lZv6HTT0Wg/sSUg/oDUw6SbQLwfuaMt98Q3P/8rTz//O1xILuPtTo7uPRlmYDyne9V7r4gOH7iFvj4kVvg8SMvCMb7Lwh27xhuj8p/8eXMzYYdP9CwaTdP5nbDbrdi/4HcyZmp6h9ebf/y6WjZFViG5Q99/nHU42z0945yb2miL2LcWpvoqxh3Fif64rH85gosXw0R3Psl/mIg6c66AF+EuLNY0hfDe/e2UPkiyL0tdvZfnSWNvJH+/NO1c3OVTRmIerR8YXV/7adj8EnFciLlc77svtHqsZ1kH8832Enb/Yakxd6Y0pbn8fzLbkGyXYekr7s51c0eV9tNaR7P7DFVrh6bzZyS7DbZfXcJCknxwbWk5WR+6Z3dVB1hk81jF2LfrDdXsPsiTiqNRZBKeznOwbcz6Xx3/XKcZYfJY91L+btxGvv/HevE9W/HGct6g0d/9fJt8QQ3msru8r0dZbwcZbCmzqgvRrm/6OCXV/LNFR2/OKubqzF+FeXeeoyPQSP9mbbJP3Dbk3/gtie/fduzm8QzmIu37jrfXgggLwWosceIrhtw3Q/Aaztdd9/6RoBYOmEdEf5OgFvr4r69NO92C8I7H+FsV6qLtTmTrt/g5PtLUWkMHj3GWMZLIXosG53WjV6+E8K+L5j3AceRXgkhBwtgf9jy7xtHwayW9PHO+Rshlg9v0ksnklJn18Hx2lFkdnMs6+Yd3whR4p73cWNWn4ZIaff+6AcWpsyRpo97xddagwWX0rpz+asN+mIIqfHRvOi6bdg3QkTVTev6Ki+H0JdC5LjpT/nor4VQ1vls+aUQlRv2Wl5ri8zOx+XDNpIvhnitU0u8IH28DEyvhWCdz6L6YghO5MOGDN8IEXeMqfTXOrUMlh85XjqKEm9FS3+pJbiuqjw/iUeR3mYZy6jIOkp3ey3BGgE+LGL7jdOIH1QtLzVkjW/p6np3840AbCEz8msBjv/hzeVLAT6sLPCdRow7vNcKnaYYisvjzSP43I3/+/F///ivf/77P//lb//6x3/8+W9//Y/H3/vvM9Tf//zHf/nLn67/+3//86//uvzXf/z//+7/5V/+/ue//OXP//bP//73v/3rn/7Pf/79T2ek87/9dlz/87/6+Zlxf4z1/+9/+i09/v84F3wYdRyP/5/P/z7S8fjvcv7/dP4FrUf7p8fYp5z/ItmfkHT+ify///s85P8H"
    }
  ],
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "TokenBridge"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_for_L1_to_L2_message_consumption",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::claim_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::claim_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "message_leaf_index",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::claim_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::claim_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "caller_on_l1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::exit_to_l1_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::exit_to_l1_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "caller_on_l1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::exit_to_l1_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::exit_to_l1_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "TokenBridge::get_config_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::get_config_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "TokenBridge::get_config_public_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "portal",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "config::Config"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::get_config_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "TokenBridge::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "TokenBridge::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "TokenBridge::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "102": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n\n    if is_fn_private(f) {\n        if is_static_call {\n            create_private_static_stub(f)\n        } else {\n            create_private_stub(f)\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            create_public_static_stub(f)\n        } else {\n            create_public_stub(f)\n        }\n    } else {\n        create_utility_stub(f)\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "103": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY, call_interface_stubs::stub_fn, stub_registry,\n    },\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_authorize_once, fn_has_noinitcheck, get_fn_visibility,\n        is_fn_contract_library_method, is_fn_initializer, is_fn_internal, is_fn_private,\n        is_fn_public, is_fn_test, is_fn_utility, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\npub(crate) comptime fn create_authorize_once_check(f: FunctionDefinition) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[private] or #[public] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_fn_private(f) {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "108": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "111": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "112": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "113": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "114": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "115": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "116": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "117": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "118": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PlaintextLen * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let env = TestEnvironment::new();\n\n        // Log decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"utilityGetIndexedTaggingSecretAsSender\").returns(\n                IndexedTaggingSecret::deserialize([69420, 1337]),\n            );\n            let _ = OracleMock::mock(\"privateIncrementAppTaggingSecretIndexAsSender\").returns(());\n\n            // Encrypt the log\n            let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the log\n            let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec =\n                BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "134": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "137": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messaging.nr",
      "source": "use crate::{\n    hash::{compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash},\n    oracle::get_l1_to_l2_membership_witness::get_l1_to_l2_membership_witness,\n};\n\nuse dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    merkle_tree::root::root_from_sibling_path,\n};\n\npub fn process_l1_to_l2_message(\n    l1_to_l2_root: Field,\n    contract_address: AztecAddress,\n    portal_contract_address: EthAddress,\n    chain_id: Field,\n    version: Field,\n    content: Field,\n    secret: Field,\n    leaf_index: Field,\n) -> Field {\n    let secret_hash = compute_secret_hash(secret);\n    let message_hash = compute_l1_to_l2_message_hash(\n        portal_contract_address,\n        chain_id,\n        contract_address,\n        version,\n        content,\n        secret_hash,\n        leaf_index,\n    );\n\n    // We prove that `message_hash` is in the tree by showing the derivation of the tree root, using a merkle path we\n    // get from an oracle.\n    // Safety: The witness is only used as a \"magical value\" that makes the merkle proof below pass. Hence it's safe.\n    let (_leaf_index, sibling_path) =\n        unsafe { get_l1_to_l2_membership_witness(contract_address, message_hash, secret) };\n\n    let root = root_from_sibling_path(message_hash, leaf_index, sibling_path);\n    assert_eq(root, l1_to_l2_root, \"Message not in state\");\n\n    compute_l1_to_l2_message_nullifier(message_hash, secret)\n}\n"
    },
    "146": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "149": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "153": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "154": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "156": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(utilityGetContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(utilityGetBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(utilityGetTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(utilityGetChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(utilityGetVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "157": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "158": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "159": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_l1_to_l2_membership_witness.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, constants::L1_TO_L2_MSG_TREE_HEIGHT};\n\n/// Returns the leaf index and sibling path of an entry in the L1 to L2 messaging tree, which can then be used to prove\n/// its existence.\npub unconstrained fn get_l1_to_l2_membership_witness(\n    contract_address: AztecAddress,\n    message_hash: Field,\n    secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {\n    get_l1_to_l2_membership_witness_oracle(contract_address, message_hash, secret)\n}\n\n// Obtains membership witness (index and sibling path) for a message in the L1 to L2 message tree.\n#[oracle(utilityGetL1ToL2MembershipWitness)]\nunconstrained fn get_l1_to_l2_membership_witness_oracle(\n    _contract_address: AztecAddress,\n    _message_hash: Field,\n    _secret: Field,\n) -> (Field, [Field; L1_TO_L2_MSG_TREE_HEIGHT]) {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "162": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "163": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "164": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "166": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "168": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(utilityGetIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(privateIncrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "171": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "173": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "174": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 1;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. PXE is using version '1', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "186": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> HasStorageSlot<M + 1> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the historical block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   historical block header that is being referenced by this private function.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "204": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "207": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "208": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "210": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "211": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "213": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "215": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "220": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.historical_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "227": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "246": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "292": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "306": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "308": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "317": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        // Q: I don't understand this comment. We could still compute a siloed nullifier from a zero contract address.\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "327": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "331": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut result = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         result\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Serialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the serialized member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize(self.$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    result[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; _];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Serialize::serialize(self.$param_name)\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "332": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "333": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "343": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "358": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "360": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "361": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "378": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "381": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "390": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.2.0/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block, mut msg_byte_ptr) =\n            process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks(msg, message_size, N, h, msg_block, msg_byte_ptr)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    mut h: STATE,\n) -> (STATE, MSG_BLOCK, u32) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    let mut msg_byte_ptr = 0;\n    let num_blocks = N / BLOCK_SIZE;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n        // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        // Verify the block we are compressing was appropriately constructed\n        let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n        if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n    (h, msg_block, msg_byte_ptr)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if 8 * shifts >= 32 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    total_len: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: u32,\n) -> HASH {\n    let modulo = total_len % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let num_blocks = total_len / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n        // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n        if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n            verify_msg_block_padding(msg_block, msg_byte_ptr);\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block, mut msg_byte_ptr) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks(msg, real_message_size, N, h, msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "411": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "412": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/libs/token_portal_content_hash_lib/src/lib.nr",
      "source": "// docs:start:mint_to_public_content_hash_nr\nuse dep::aztec::protocol_types::{address::{AztecAddress, EthAddress}, hash::sha256_to_field, traits::ToField};\n\n// Computes a content hash of a deposit/mint_to_public message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_to_public_content_hash(owner: AztecAddress, amount: u128) -> Field {\n    let mut hash_bytes = [0; 68];\n    let recipient_bytes: [u8; 32] = owner.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = (amount as Field).to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector =\n        comptime { keccak256::keccak256(\"mint_to_public(bytes32,uint256)\".as_bytes(), 31) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:mint_to_public_content_hash_nr\n\n// docs:start:get_mint_to_private_content_hash\n// Computes a content hash of a deposit/mint_to_private message.\n// Refer TokenPortal.sol for reference on L1.\npub fn get_mint_to_private_content_hash(amount: u128) -> Field {\n    let mut hash_bytes = [0; 36];\n    let amount_bytes: [u8; 32] = (amount as Field).to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime { keccak256::keccak256(\"mint_to_private(uint256)\".as_bytes(), 24) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = amount_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_mint_to_private_content_hash\n\n// docs:start:get_withdraw_content_hash\n// Computes a content hash of a withdraw message.\npub fn get_withdraw_content_hash(\n    recipient: EthAddress,\n    amount: u128,\n    caller_on_l1: EthAddress,\n) -> Field {\n    // Compute the content hash\n    // Compute sha256(selector || amount || recipient)\n    // then convert to a single field element\n    // add that to the l2 to l1 messages\n    let mut hash_bytes: [u8; 100] = [0; 100];\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let amount_bytes: [u8; 32] = (amount as Field).to_be_bytes();\n    let caller_on_l1_bytes: [u8; 32] = caller_on_l1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector =\n        comptime { keccak256::keccak256(\"withdraw(address,uint256,address)\".as_bytes(), 33) };\n\n    for i in 0..4 {\n        hash_bytes[i] = selector[i];\n    }\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = recipient_bytes[i];\n        hash_bytes[i + 36] = amount_bytes[i];\n        hash_bytes[i + 68] = caller_on_l1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:get_withdraw_content_hash\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/token_bridge_contract/src/main.nr",
      "source": "mod config;\n\n// docs:start:token_bridge_imports\n\n// Minimal implementation of the token bridge that can move funds between L1 <> L2.\n// The bridge has a corresponding Portal contract on L1 that it is attached to\n// And corresponds to a Token on L2 that uses the `AuthWit` accounts pattern.\n// Bridge has to be set as a minter on the token before it can be used\n\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract TokenBridge {\n    use crate::config::Config;\n\n    use dep::aztec::{\n        protocol_types::address::{AztecAddress, EthAddress},\n        state_vars::PublicImmutable,\n    };\n\n    use dep::token_portal_content_hash_lib::{\n        get_mint_to_private_content_hash, get_mint_to_public_content_hash,\n        get_withdraw_content_hash,\n    };\n\n    use dep::token::Token;\n\n    use dep::aztec::macros::{functions::{initializer, private, public, view}, storage::storage};\n    // docs:end:token_bridge_imports\n\n    // docs:start:token_bridge_storage_and_constructor\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n    }\n\n    // Constructs the contract.\n    #[public]\n    #[initializer]\n    fn constructor(token: AztecAddress, portal: EthAddress) {\n        storage.config.initialize(Config { token, portal });\n    }\n    // docs:end:token_bridge_storage_and_constructor\n\n    // docs:start:get_config\n    #[private]\n    #[view]\n    fn get_config() -> Config {\n        storage.config.read()\n    }\n    // docs:end:get_config\n\n    #[public]\n    #[view]\n    fn get_config_public() -> Config {\n        storage.config.read()\n    }\n\n    // docs:start:claim_public\n    // Consumes a L1->L2 message and calls the token contract to mint the appropriate amount publicly\n    #[public]\n    fn claim_public(to: AztecAddress, amount: u128, secret: Field, message_leaf_index: Field) {\n        let content_hash = get_mint_to_public_content_hash(to, amount);\n\n        let config = storage.config.read();\n\n        // Consume message and emit nullifier\n        context.consume_l1_to_l2_message(content_hash, secret, config.portal, message_leaf_index);\n\n        // Mint tokens\n        Token::at(config.token).mint_to_public(to, amount).call(&mut context);\n    }\n    // docs:end:claim_public\n\n    // docs:start:exit_to_l1_public\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message publicly\n    // Requires `msg.sender` to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[public]\n    fn exit_to_l1_public(\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: u128,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        authwit_nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        let config = storage.config.read();\n\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(config.portal, content);\n\n        // Burn tokens\n        Token::at(config.token).burn_public(context.msg_sender(), amount, authwit_nonce).call(\n            &mut context,\n        );\n    }\n    // docs:end:exit_to_l1_public\n\n    // docs:start:claim_private\n    /// Claims the bridged tokens and makes them accessible in private. Note that recipient's address is not revealed\n    /// but the amount is. Hence it's most likely possible to determine to which L1 deposit this claim corresponds to\n    /// (unless there are multiple pending deposits of the same amount).\n    #[private]\n    fn claim_private(\n        recipient: AztecAddress, // recipient of the bridged tokens\n        amount: u128,\n        secret_for_L1_to_L2_message_consumption: Field, // secret used to consume the L1 to L2 message\n        message_leaf_index: Field,\n    ) {\n        let config = storage.config.read();\n\n        // Consume L1 to L2 message and emit nullifier\n        let content_hash = get_mint_to_private_content_hash(amount);\n        context.consume_l1_to_l2_message(\n            content_hash,\n            secret_for_L1_to_L2_message_consumption,\n            config.portal,\n            message_leaf_index,\n        );\n\n        // At last we mint the tokens\n        // docs:start:call_mint_on_token\n        Token::at(config.token).mint_to_private(recipient, amount).call(&mut context);\n        // docs:end:call_mint_on_token\n    }\n    // docs:end:claim_private\n\n    // docs:start:exit_to_l1_private\n    // Burns the appropriate amount of tokens and creates a L2 to L1 withdraw message privately\n    // Requires `msg.sender` (caller of the method) to give approval to the bridge to burn tokens on their behalf using witness signatures\n    #[private]\n    fn exit_to_l1_private(\n        token: AztecAddress,\n        recipient: EthAddress, // ethereum address to withdraw to\n        amount: u128,\n        caller_on_l1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n        authwit_nonce: Field, // nonce used in the approval message by `msg.sender` to let bridge burn their tokens on L2\n    ) {\n        // docs:start:assert_token_is_same\n        let config = storage.config.read();\n\n        // Assert that user provided token address is same as seen in storage.\n        assert_eq(config.token, token, \"Token address is not the same as seen in storage\");\n        // docs:end:assert_token_is_same\n\n        // Send an L2 to L1 message\n        let content = get_withdraw_content_hash(recipient, amount, caller_on_l1);\n        context.message_portal(config.portal, content);\n\n        // Burn tokens\n        Token::at(token).burn_private(context.msg_sender(), amount, authwit_nonce).call(&mut context);\n    }\n    // docs:end:exit_to_l1_private\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "61": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "62": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "69": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between a #[private] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[private] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[private] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[private] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[private] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp =\n            inputs.historical_header.global_variables.timestamp + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// TODO(https://github.com/AztecProtocol/aztec-packages/issues/14025) - we\n    /// are considering making msg_sender: Option<AztecAddress>, since\n    /// a returned value of `Option:none` will be clearer to developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `-1` for the first function call of the tx.\n    ///\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[private] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[private]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some historical block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[private] macro.\n    ///\n    /// # Arguments\n    /// * `returns_hasher` - A hasher containing the return values to hash\n    ///\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[private] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a heft function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "70": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between a #[public] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[public] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[public] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[public]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases, and is enforced by the protocol's kernel circuits.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the account or contract that called\n    ///   this function\n    ///\n    /// # Examples\n    /// ```rust\n    /// #[aztec(public)]\n    /// fn transfer(context: &mut PublicContext, to: AztecAddress, amount: u64) {\n    ///     let sender = context.msg_sender();\n    ///     // Only the sender can transfer their own tokens\n    ///     assert(sender == get_token_owner(), \"Unauthorized\");\n    /// }\n    /// ```\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    /// * Globally visible unlike private execution where it's contract-local\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[public] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "71": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "72": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "74": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "76": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "88": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "93": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "97": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "98": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    }
  }
}
