{
  "transpiled": true,
  "noir_version": "1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec",
  "name": "Lending",
  "functions": [
    {
      "name": "_borrow",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1602191554767750373": {
            "error_kind": "string",
            "string": "Function _borrow can only be called internally"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "_deposit",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "16022896159229267359": {
            "error_kind": "string",
            "string": "Function _deposit can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgQEAycCBQQAHwoABAAFgEUdAIBGgEYGLgiARQABLgiARgACLgiARwADJQAAAFglAAAAaSgCAAEEgEgnAgIEADsOAAIAASkAgEME/////ygAgEQEAAMmJQAABBAeAgAEAB4CAAUAMyoABAAFAAYnAgQBASQCAAYAAACSJQAABDkeAgAFAR4CAAYACioFBgckAgAHAAAAriUAAARLHgIABQApAgAGAAW016snAggEAScCCgQDACoICgktCAEHAAgBCQEnAwcEAQAiBwIJLQ4ICQAiCQIJLQ4ICScCCQQDACoHCQgtCggJLQ4GCScCBgQBACIHAgotCwoJJwILBAIAKgoLCDkDoIBDgEMABQAJAAggAgAFIQIABycCCAQALQgBCgAiCgINLQsNDCcCDgQCACoNDgsiOgAHAAgACy0KBwwnAg4EAwAqDA4NAAgBDQEnAwoEAQAiCgIOLQ4MDgAiDgIOLQ4MDi0KDAkGIgkCCSQCAAUAAAG3IwAAAY4tCwoFACIFAgUtDgUKACIKAgstCwsHJwIMBAIAKgsMBTwOBwUjAAABtycCBwQECioJBwokAgAKAAAB0icCCwQAPAYLAScCBwABLwoABwAJCioJAwckAgAHAAAB8ycCCgQAPAYKAScCAwAAKwIABwAAAAAAAAAAAgAAAAAAAAAALQgBCScCCgQFAAgBCgEnAwkEAQAiCQIKLQoKCy0OAwsAIgsCCy0OAwsAIgsCCy0OAwsAIgsCCy0OBwstCAEHAAABAgEtCAEKAAABAgEtCAELAAABAgEtCAEMAAABAgEnAg0ABC0IAQ4nAg8EBAAIAQ8BJwMOBAEAIg4CDy0KDxAtDg0QACIQAhAtDgEQACIQAhAtDgMQLQ4OBy0OCQonAgEEAi0OAQsnAgEBAC0OAQwtCggFIwAAAsYNIgAFgEQACCQCAAgAAAOEIwAAAtstCwoFLQsFCAAiCAIILQ4IBS0IAQgnAgkEBQAIAQkBJwMIBAEAIgUCCScCDQQEACIIAg4/DwAJAA4tCwcFLQsLCS0OBQctDggKLQ4JCy0OBAwAKggGBS0LBQQKKgQDBQoqBQEDJAIAAwAAA0wlAAAEXS8KAAQAARwKAQUGHAoFAwAcCgMBBgAqAQIDDioBAwUkAgAFAAADeCUAAARvHAoDAQAwCgABAAQmLQsLCAwqBQgJJAIACQAAA5ojAAAEAi0LCgkAIgkCDgAqDgUPLQsPDS0LBw4AIg4CEAAqEAURLQsRDwAqDQ8QLQsMDS4CAAmAAygAgAQEAAUlAAAEgS4IgAUADwAiDwIRACoRBRItDhASLQ4OBy0ODwotDggLLQ4NDCMAAAQCACoFBggtCggFIwAAAsYoAIAEBHgADQAAAIAEgAMkAIADAAAEOCoBAAEF96Hzr6Wt1Mo8BAIBJioBAAEFvh4//z6k9vo8BAIBJioBAAEF3lzDKfPUzZ88BAIBJioBAAEFAtxuJ4B2Ep08BAIBJioBAAEFRafKcRlB5BU8BAIBJi4BgAOABgsAgAYAAoAHJACABwAABJwjAAAEpy4AgAOABSMAAAUOLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABPouAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAABMkoAYAFBAABAwCABgACgAYjAAAFDiY=",
      "debug_symbols": "tZnRTis5DIbfpddcJHZsJ7zKEUIFylGlqqAeWGmFePe1O3FmipQsGnpu6FeX/GM7jpO0H5un3cP77/v98fnlz+b218fm4bQ/HPa/7w8vj9u3/ctRrR+bYH9i1Jd0o6+0uRV9BX0fg0FWiAqIFVJ0YAUbRGaxUWSWrMDRoVSQtLkFGyVqARuVc4WCDtUCAR2kQgQHt4BbgCtgdKAKKTg0S306kD2CDXIFdgtLBQEHtxQTzAYaDgYDHY5ws0HzeQKpYD5PwBUgOrgFfXjy4ckt5BZyC7uF/RHijxAXzKHC2TFNeArgIBWiuZEMuIJN9wRUAd2CmjHU2FNKDm4hqcDgoILJHiHRQf8nqT8pQwXL4QTkoIKp3GwopArmxgT+EfpH6JbkluQWy9gEUsEcm4ArnB07gz/CMjaBCWaDXMEqcwKZgC2ZE3AFS+YEVMGSSdGAHEoFi2ICtyS3JLdYFBNIBYtiAq5gUUxgjwCDUiGjQ65QwEEmEFvtRAq2ZIgNyKFUODt2BtPRuITAQSqwW9gt4hZxS3bL2R/tEnL25wwWjtZYDsEhOeQKtoioGEgFW0QMBlwB3WLOn8GcZ31EJlVmG0VUgd3C1up0CWcJDm6xHE6gboi5YZUgKlhCTV0xV0XjKtaIJuApY8WzWtAt1ogmsFHFoFQgt9gyz/rQYst8AqmjBCtk18l1vkrxZ5X6rBhCbESNilPERuI0ef75ebPxreH+7bTb2c6w2Ct0B3ndnnbHt83t8f1wuNn8sz28n//pz+v2eH592570U/V9d3zSVxV83h92Rp838+jQHxq17UEdHpFZmkQM5UIkDkQCNI2QYCHBFxIwkJCS2TWkFGoighca2NdAwJCrhjKknsYwlFLcjRhLNxS6Qij8t0Oh3GYl92cl9yVEm0iVEF3jPSfKIBBMIXogmNJPA4nQD2RU5gAtkqi55X6Zj4q0LBaLNpLQDWZcpULz1JauyDAcjDCHg9AP5xqFGq9Rqd+fHUzdcAYiSTeYqpFynmOhL7GUKyQEwt9NSMqEHkuJqRcLwLAntzKLQU/LTYTpUgRHEyMB28RIzN2EjEWo9VQo2E0IDGpV20hbesqFV3mCAdr8YuivX5CRJ1RaR0scYaUnc8WjNriuyKi36vE/zZ7kvNITLgtPuonFOPJEBJsnOa6cnZjnowj0c4Kj7qpXGZ9i5Ry7ngzXDlNoa0dvAb21g8Puym3p6D7aJNK3Ny29sHHrAv2OhqNi1Rtr233L4nBX4qXG4BCgBZLFRYKEbpnhqFZDmM8BYbD00qi1ElITIcxrWivpw6sEBewmdajA0BQy9hTSoEo5kUtopS1273w5LSkN6qsVBywUdPVdKgwqVBJ6heqlc54RXXuXGjxcb16ii1WvW+ClwqBEIbZ2ChBKX2NQovp9gacz0jovIHsX1GHQ1aDRMYagdQ1KslJj7saUy7pYJLbSEAx9P0bNeG7oehIa5CON6gtaefEqhZL8CKO39VUKF1dT7tcGDfKZdJf3ItdGvGii309nCW1aC/TTOWwaJK3KeXlG/tI0eFBeLOh+aGXMm6Peqy41Bps95NQWbKbc3VNGLTRGD4XiokK/tFDGn+9snK6wszFdYWdjvsLO9j/hyCIcwK7IoJXGXNoRucRZQr8M//7s0jy7wmu22Nhah4p1FWR0JC1tavUbCOzWh8DoKhdjaVc5vbv0EirDTlraPSwvSuxrQseOhHY0VkdCtzxkVKgxtXsY6m9I3UKVYaEmDq1QKXTP18O2Hnxq9DvcdRtDO4IVoZ9uLV8V7vTt9nF/uvjd7tOkTvvtw2FX3z6/Hx8Xn779++qf+O9+r6eXx93T+2lnSvOPf/rnF+hvc5Dgzr4Ntrd6zdY5trfR3upPeHoYuvs0Z/4D"
    },
    {
      "name": "_repay",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "stable_coin",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13135008234568508716": {
            "error_kind": "string",
            "string": "Function _repay can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "_withdraw",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10435052277855889085": {
            "error_kind": "string",
            "string": "Function _withdraw can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "borrow_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+1dCZhdRZWu1/260y/p9MtKErJ1NggkBMImCEJCwh4gJOwIGEiEGCCQhSSsLyEJu4ig4zLjMoq4oaODjjruuyDjuKKO+zLquKG4r3Mreaf777/Pve8upysP6fq++t59t6r+/9SpU+utW7fkdruu+u+la9etW7vpkmvWrb5uxYZVR7Y6N611d0gp8q3135bId9M9+cXrNiXeUOVep3KvS7k3Qrk3Wrk3NvIL6N74yNfo3gTl3hQFb6pyr1u5N025N13hmKHcm6ncm6Xc20fh2K8er+xSuFL9t7v+e9DK09d9d/5r9nvP0uPfvXXreRfNPuTHJ2157zX3Lfrub+9/Mgrfq7U3bgM3twjPuMY8ZcTuhBulupz+d9/6/9n1X48r8cZH1xMiv3fkJ7b2BW8leRu40n4Z4o5vTa+HSen1rephUl0PE+q/e9d/J4IeJkfXUyI/1XORHlrqv90unQhjXfq8TUubt9KZtT4Vq3V3hS4i5z4uvZzT05dBqU9lV9JllXN6BluZkVNOSVd2vQ1JvwQZ5S6lj6u67nTROk3S+oz73qmkxMqa8X1dtgorbmZrAcKZUGTd9d9G1uIz3eJsMp0hbk8N8G5WXe592OSyNr8Yt1HGZ8VXqedS3NI+GZpfS4VmsSJU6L51xc0uqlAUoJFC982g0NkZ+7OOyFfgXnf9t+OYLSO/eljluv2ebN84/y9jH/3rlje+8hePHfmiY1efO/eytadcgHH3vuXiPz18y/znznrT+Kc6P/3EIcd+9i3XP/GZ6phvbX3/J2b/8f6LMG4aJ3HbTnnjC9Y/duehyy6+8INf+cFRr53wwp3VS45cus+91377+Ps+8IMWjNv9L5/70Nw/n/vH35XXLn5i70/+6Q/rznr7pxbcWP7ppXtfetujH9kH42aR4YA/vHfBD+/oOn30pu8sX/+n/33F5I1nrD7sfx+qvfv5D2yY/+vHH8e48x6//fPnX/7+5e/Zcd+84XvtXHHWW9/95o9+8Q8X7/vozb9850dedCvGbeTa67+7Bqb1McU+Muaq/4oRdrtUriVD3Cy4pf0iOfaP/ByqFFnHpHPT2+6cIjwHpOS5bP78dxbhmdeYpw2xeWw5t17OB9R/96v/zoOx5YHR9UGRnx/5gwuOsWdniHtghnHTIa3Z7E7cQM4RDsog/6EF5wiH1Mvt0Prv/PrvwVCOh0XXh0f+WZE/on6/1eljRXHdLpUrl1z8ZLXbNXZYD7J2tPvlKPusHBnsNjdHBtsqxHNYzrrS47JOgGZkqAhH5pwAHQkTIPH9EmSUO+8EKFSBZOWZEYin1RkbWCOjwbiNhNvf5RMuq0wZjKc0x4WRqcWll2muCyNTBmMpHeBsZGrEM8+ll39yoEp1oAvDc5ALwzPfhSnLg136spwWqCwPcWF4DnVheA5zYXgOd2F4nuXC8BzhwvAc6cLwPNuF4TnKheE52oXheY4Lw3OMC8NzrAvDs8CF4VnowvAc58LwLHJheBa7MDzHuzA8J7gwPCe6MDwnuTA8J7swPKe4MDynujA8S1wYntNcGJ7TXRieM1wYnqUuDM+ZLgzPMheGZ7nLxzOQazBnORuZGvGc7dLLPz3QfPQcF4bnXBeG5zwXhud8F4bnAheG50IXhue5LgzPRS4Mz8UuDM8lLgzP81wYnhUuDM+lLgzPZS4Mz0oXhmeVC8PzfBeG53IXhucKF4ZntQvD8wIXhmeNC8NzpQvDc5ULw3O1C8Oz1oXhucaF4bnWheFZ58LwrHdheDa49HOYIjwbXZj8XOfC8GxyYXg2uzA8W1wYnutdGJ4bXBieG10YnptcGJ6bXRieW1wYnpoLw7PVheHZ5sLw3OrC8Gx3YXh2uDA8O10YnttcGJ7bXRieO1wYnjtdGJ67XBieu10YnntcGJ4XujA897owPC9yYXjuc2F4XuzC8NzvwvA84MLwvMSF4XmpC8PzTy4Mz8tcGJ6XuzA8r3BheF7pwvD8swvD8y8uDM+rXBieV7swPK9xYXhe68Lw/KsLw/M6F4bn9S4Mz4MuDM8bXBieh1wYnje6MDxvcmF43uzC8LzFheF5qwvD87ALw/M2F4bn7S4Mz7+5MDzvcGF43unC8Py7C8PziAvD8y4XhufdLgzPf7gwPO9xYXje68LwvM+F4flPF4bn/S4MzwdcGJ4PujA8H3JheD7swvB8xIXh+agLw/MxF4bn4y4MzydcGJ5PujA8n3JheD7twvB8xoXhedSF4XnMheH5rAvD87gLw/NfLgzP51wYnv92YXg+78LwfMGF4fmiC8PzJReG58suDM9XXBieJ1wYnq+6MDxfc2F4vu7C8PyPC8PzDReG55suDM+3XBieb7swPN9xYXi+68LwfM+F4fm+C8PzAxeG54cuDM//ujA8P3JheH7swvD8xIXh+T8XhuenLgzPz1wYnp+7MDy/cGF4funC8DzpwvD8yoXh+bULw/OUC8PzGxeG57cuDM/vXBie37swPH9wYXj+6MLw/MmF4fmzC8PzFxeG568uDM/fXBiev7swPD5ByriUMBtPKRBPSyCe1kA85UA8bYF42gPxDAnE0xGIpxKIZ2ggnmGBeDoD8QwPxNMViKcaiGdEIJ6RgXhGBeIZHYhnTCCesYF49grEMy4Qz/hAPBMC8ewdiGdiIJ5JgXgmB+KZEohnaiCe7kA80wLxTA/EMyMQz8xAPLMC8ewTiGffQDyzA/HsF4hn/0A8cwLxzA3Ec0AgnnmBeA4MxHNQIJ75gXgODsRzSCCeQwPxHBaI5/BAPM8KxHNEIJ4jA/E8OxDPUYF4jg7E85xAPMcE4jk2EM+CnDwD+X2ChU0o03GBZMryjchFRjI14llcSi9/3g+8ZpXp+AwyhfoY7AmB6uyJgXhOCsRzciCeUwLxnBqIZ0kgntMC8ZweiOeMQDxLA/GcGYhnWSCe5YF4zgrEc3YgnnMC8ZwbiOe8QDznB+K5IBDPhYF4nhuI56JAPBcH4rkkEM/zAvGsCMRzaSCeywLxrAzEsyoQz/MD8VweiOeKQDyrA/G8IBDPmkA8VwbiuSoQz9WBeNYG4rkmEM+1gXjWBeJZH4hnQyCejYF4rgvEsykQz+ZAPFsC8VwfiOeGQDw3BuK5KRDPzYF4bgnEUwvEszUQz7ZAPLcG4tkeiGdHIJ6dgXhuC8RzeyCeOwLx3BmI565APHcH4rknEM8LA/HcG4jnRYF47gOegfxG6YsD5ef+QDwPBOJ5SSCelwbi+adAPC8LxPPyQDyvCMTzykA8/xyI518C8bwqEM+rA/G8JhDPawPx/GsgntcF4nl9IJ4HA/G8IRDPQ4F43hiI502BeN4ciOctgXjeGojn4UA8bwvE8/ZAPP8WiOcdgXjeGYjn3wPxPBKI512BeN4diOc/AvG8JxDPewPxvC8Qz38G4nl/IJ4PBOL5YCCeDwXi+XAgno8E4vloIJ6PBeL5eCCeTwTi+WQgnk8F4vl0IJ7PBOJ5NBDPY4F4PhuI5/FAPP8ViOdzgXj+OxDP5wPxfCEQzxcD8XwpEM+XA/F8JRDPE4F4vhqI52uBeL4eiOd/AvF8IxDPNwPxfCsQz7cD8XwnEM93A/F8LxDP9wPx/CAQzw8D8fxvIJ4fBeL5cSCenwTi+b9APD8NxPOzQDw/D8Tzi0A8vwzE82Qgnl8F4vl1IJ6nAvH8JhDPbwPx/C4Qz+8D8fwhEM8fA/H8KRDPnwPx/CUQz18D8fwtEM/fA/H4Q8VSxqWE2XhKgXhaAvG0BuIpB+JpC8TTHohnSCCejkA8lUA8QwPxDAvE0xmIZ3ggnq5APNVAPCMC8YwMxDMqEM/oQDxjAvGMDcSzVyCecYF4xgfimRCIZ+9APBMD8UwKxDM5EM+UQDxTA/F0B+KZFohneiCeGYF4ZgbimRWIZ59APPsG4pkdiGe/QDz7B+KZE4hnbiCeAwLxzAvEc2AgnoMC8cwPxHNwIJ5DAvEcGojnsEA8hwfieVYgniMC8RwZiOfZgXiOCsRzdCCe5wTiOSYQz7GBeBYE4lkYiOe4QDyLAvEsDsRzfCCeEwLxnBiI56RAPCcH4jklEM+pgXiWBOI5LRDP6YF4zgjEszQQz5mBeJYF4lkeiOesQDxnB+I5JxDPuYF4zgvEc34gngsC8VwYiOe5gXguCsRzcSCeSwLxPC8Qz4pAPJcG4rksEM/KQDyrAvE8PxDP5YF4rgjEszoQzwsC8awJxHNlIJ6rAvFcHYhnbSCeawLxXBuIZ10gnvWBeDYE4tkYiOe6QDybAvFsDsSzJRDP9YF4bgjEc2MgnpsC8dwciOeWQDy1QDxbA/FsC8RzayCe7YF4dgTi2RmI57ZAPLcH4rkjEM+dgXjuCsRzdyCeewLxvDAQz72BeF4UiOe+QDwvDsRzfyCeBwLxvCQQz0sD8fxTIJ6XBeJ5eSCeVwTieWUgnn8OxPMvgXheFYjn1YF4XhOI57WBeP41EM/rAvG8PhDPg4F43hCI56FAPG8MxPOmQDxvDsTzlkA8bw3E83AgnrcF4nl7IJ5/C8TzjkA87wzE8++BeB4JxPOuQDzvDsTzH4F43hOI572BeN4XiOc/A/G8PxDPBwLxfDAQz4cC8Xw4EM9HAvF8NBDPxwLxfDwQzycC8XwyEM+nAvF8OhDPZwLxPBqI57FAPJ8NxPN4IJ7/CsTzuUA8/x2I5/OBeL4QiOeLgXi+FIjny4F4vhKI54lAPF8NxPO1QDxfD8TzP4F4vhGI55uBeL4ViOfbgXi+E4jnu4F4vheI5/uBeH4QiOeHgXj+NxDPjwLx/DgQz08C8fxfIJ6fBuL5WSCenwfi+UUgnl8G4nkyEM+vcvK0EM9BK09f9935r9nvPUuPf/fWreddNPuQH5+05b3X3Lfou7+9/8kofB+XXqZfG8nUiOeplvTyH9kaRk9ll17+3wQquzaXXqbfBpKp3aWX6XeBZBri0sv0+0Aydbj0Mv0hkEwVl16mPwaSaahLL9OfAsk0zKWX6c+BZOp06WX6SyCZhrv0Mv01kExdLr1MfwskU9Wll+nvgWQa4dLL5AL1wSNdeplKgWQa5dLL1BJIptEuvUytgWQa49LLVA4k01iXXqa2QDLt5dLL1B5IpnEuvUxDAsk03qWXqSOQTBNcepkqgWTa26WXaWggmSa69DINCyTTJJdeps5AMk126WUaHkimKS69TF2BZJrq0stUDSRTt0sv04hAMk1z6WUaGUim6S69TKMCyTTDpZdpdCCZZrr0Mo0JJNMsl16msRlkanW710t/Vhdo/8jPifzcyB8Q+XmRP9DLF/n5kT848odE/tDIHxb5wyP/rMgfEfkjI//syB8V+aMj/5zIHxP5YyO/IPILI39c5BdFfnHkj4/8CZE/MfInRf7kyJ8S+VMjvyTyp0X+9MifEfmlkT8z8ssivzzyZ0X+7MifE/lzI39e5M+P/AWRvzDyz438RZG/OPKXRP55kV8R+Usjf1nkV0Z+VeSfH/nLI39F5FdH/gWRXxP5KyN/VeSvjvzayF8T+Wsjvy7y6yO/IfIbI39d5DdFfnPkt0T++sjfEPkbI39T5G+O/C2Rr0V+a+S3Rf7WyG+P/I7I74z8bZG/PfJ3RP7OyN8V+bsjf0/kXxj5eyP/osjfF/kXR/7+yD8Q+ZdE/qWR/6fIvyzyL4/8KyL/ysj/c+T/JfKvivyrI/+ayL828v8a+ddF/vWRfzDyb4j8Q5F/Y+TfFPk3R/4tkX9r5B+O/Nsi//bI/1vk3xH5d0b+3yP/SOTfFfl3R/4/Iv+eyL838u+L/H9G/v2R/0DkPxj5D0X+w5H/SOQ/GvmPRf7jkf9E5D8Z+U9F/tOR/0zkH438Y5H/bOQfj/x/Rf5zkf/vyH8+8l+I/Bcj/6XIfznyX4n8E5H/auS/FvmvR/5/Iv+NyH8z8t+K/Lcj/53Ifzfy34v89yP/g8j/MPL/G/kfRf7Hkf9J5P8v8j+N/M8i//PI/yLyv4y8r4O/ivyvI/9U5H8T+d9G/neR/33k/xD5P0b+T5H/c+T/Evm/Rv5vkf975H0lK0W+JfKtkS9Hvi3y7ZEfEvmOyFciPzTywyLfGfnhke+KfDXyIyI/MvKjIj868mMiPzbye0V+XOTHR35C5PeO/MTIT4r85MhPifzUyHdHflrkp0d+RuRnRn5W5PeJ/L6Rnx35/SK/f+TnRH5u5A+I/LzIHxj5gyI/P/IHR/6QyB8a+cMif3jknxX5IyJ/ZOSfHfmjIn905J8T+WMif2zkF0R+YeSPi/yiyC+O/PGRPyHyJ0b+pMifHPlTIn9q5JdE/rTInx75MyK/NPJnRn5Z5JdH/qzInx35cyJ/buTPi/z5kb8g8hdG/rmRvyjyF0f+ksg/L/IrIn9p5C+L/MrIr4r88yN/eeSviPzqyL8g8msif2Xkr4r81ZFfG/lrIn9t5NdFfn3kN0R+Y+Svi/ymyG+O/JbIXx/5GyJ/Y+RvivzNkb8l8rXIb438tsjfGvntkd8R+Z2Rvy3yt0f+jsjfGfm7In935O+J/Asjf2/kXxT5+yL/4sjfH/kHIv+SyL808v8U+ZdF/uWRf0XkXxn5f478v0T+VZF/deRfE/nXRv5fI/+6yL8+8g9G/g2Rfyjyb4z8myL/5si/JfJvjfzDkX9b5N8e+X+L/Dsi/87I/3vkH4n8uyL/7sj/R+TfE/n3Rv59kf/PyL8/8h+I/Acj/6HIfzjyH4n8RyP/sch/PPKfiPwnI/+pyH868p+J/KORfyzyn43845H/r8h/LvL/HfnPR/4Lkf9i5L8U+S9H/iuRfyLyX4381yL/9cj/T+S/EflvRv5bkf925L8T+e9G/nuR/37kfxD5H0b+fyP/o8j/OPI/ifz/Rf6nkf9Z5H8e+V9E/peRfzLyv4r8ryP/VOR/E/nfRv53kf995P8Q+T9G/k+R/3Pk/xL5v0b+b5H336v3Hb7/zrv/Brv/Prr/drn/rrj/5rf/Hrf/Vrb/jrX/xrT//rP/NrP/brL/prH/3rD/FrD/Tq//hq7/vq3/9qz/Lqz/Zqv/nqr/1qn/Dqn/Rqj/fqf/tqb/7qX/JuWu70VG3n9n0X8D0X+f0H870H/Xz39zz38Pz3+rzn9Hzn/jzX9/zX8bzX+3zH9TzH/vy3+Ly38ny3/Dyn9fyn/7yX+XyX8zyX/PyH9ryH8HyH+jx38/x3/bxn93xn8Txn+vZUHk/XdO/DdI/PdB/Lc7/Hc1/Dcv/Pco/Lci/Hcc/DcW/PcP/LcJ/HcD/Jn+/rx9fxa+P6fenyHvz3f3Z6/7c9H9meX+PHF/1rc/h9ufke3Pr/ZnS/tzn/2ZzP685OdF3p8z7M8A9ufz+rNz/bm2/sxZfx6sP6vVn6Pqzzj154/6s0H9uZ3+TE1/3qU/i9KfE+nPcPTnK/qzD/25hP7MQH+enz9rz5+D58+o8+fH+bPd/Llr/kw0f15ZLfL+nC9/Bpc/H8ufXeXPlfJnPvnzmPxZSf4cI3/GkD//x5/N48/N8Wfa+PNm/Fkw/pwWf4aKP9/Enz3izwXxZ3b48zT8WRf+HAp/RoQ/v8GfreDPPfBnEvjzAl4Tef+evX8H3r+f7t8d9+91+3eu/fvQ/l1l/x6xf8fXv3/r34317636d0r9+57+XUz/nqR/h9G/X+jf/fPv5fl35vz7bP5dM/8emH9Hy78/5d9t8u8d+XeC/Ps6H468f8/Fv4Pi3w/x72749yr8Ow/+fQT/roDfx+/32Pv9735vut837vd0+/3Wfi+036fs9xD7/b1+763fF+v3rPr9pH6vp9+H6fdI+v2Lfm+h3/fn9+T5/XLfibzfZ+b3gPn9WX7vlN/X5Pcc+f1Afq+O30fj97j4/Sd+POz3bfg9FX6/g9+L4PcJ+Ofy/pm5f+7sn/P656r+OaZ/buif0/nnYv45lH/u45+z+Oca/jmCH2j7dXK/Lu3Xgf26q1/n9OuKfh3Pr5v5dSq/LuTXYfy6h19n8PN6P4/281Y/T/TzMj8P8vMOP8730H7MLq7e1Owa1/vn6P65tX9O7J/L+ueg/rmjf87nn6v551j+uZF/TuOfi/jnEH7d36+z+3Vtv47s1239Oqlfl/TrgH7dza9z+XUlv47j1038OoWsC0xzu+eZfl7n51F+3uL3Pewb+dmR38/1d2W4nlT/HfuDhROuffSh4zHelISw7oSwg2PC2uu/s+u/K9avX7VuwyWXrb3qmhUbVl965apL1q5bcVn0c92qdetXr736kk3rVlxzzap1e9Xjd9R/W+q/XvetLsNaKaTLnr62uIMBM6V3rR31NPn4d+df7C1PetH/4lpvepRFcL3tDoPr4cRfRH9F5B+VILOUzaJab/xul8qVfP30+RxRv+HzPrN+vXHD6itXb9iycJepLuqx1DN2Geo5u+20HyD9F5n4/lCQuwxx0utkcw9ma233b1s9PTvBL1P8sfX/FdfLL79p9gX9/rVPvf3Bh7/06EhK752UzVDgWbl6/WVro/p9ydWrNl1y1ar161dcvmr9w7N2B+7hCv6AVQUvF0zfli99TwW/r9abHmUR3E7XtyJhGglrgbAXUxga2P31MF+Bulzv9UX164KNxgPN2mhI2sU1Je1v1j/xhsfu+fePv3HDQw++dOTXh7982Nyht+zY8cuJv5j0iid3vE7SHl/rlSnDJrweuU+o5UrfI/uJtVzpWyT9SbXem91yccx/tF5wxTv+tHbYibe+fdPXv3b6xuGTVnx06u0PXvCJ+6b+5JKdkvZkLe2P737lLdW3v/g13XMe/237iff+7JKnTm474uuP3zjhY9v+8pMn75e0p2hpv3DBX775SPX+6zff894bjpg9esVb73/iV//3qcfeVn3quw9f+8RhkvZULa3ueqqHpF1S6w3I0y6dVsuVfoSkP73We7NbLra+/o3fXHjP4wd9/y9D7zxtxfbNh9z1xXN/fv34h2b98AUPT3rrSEl7hpb2exsW3bdh3FWH/7zjc/fMf+3Eyd/+zUOP/Oh3W1Yd8bMf/fjd056StEu1tA2cpD2ztvs3T1vo3bJaf+7xB+975DUv++8x35g9/X8WfPit8x6Y8JuZR3/jPSe99sk/feYPwL08H3ePfZ9Vy5W+LOnPrvWmL7ns9nJOLVf6Ht2dW8uVvif/59V602fIf1XSn1/rvdntUrk2SXtBTU1bunX6+n+q3FM67aPbDnikc+hHf7Lw1cctevyx7XdOrb711ZL2QiXt/kdXnnzwzpt3uO889NMX/m7/9y84YOSUhSPnfemVX5l49boLJzwpaZ9bT5sxz5Mk/UW13vQke6KT9BfXcvH3pL+k1ps+A3+PzT2v1nuz26VyPfayotbLnUH2njK/tJYrfbukv6yWK/0QSb+ylit9h6RfVcuVviLpn1/LlX6opL+8liv9MEl/RS1X+k5Jv7qWK/1wSf+CWq70XZJ+Ta03fYb2rlvSX1nLlf4ASX9VLVf6gyT91bVc6edL+rW13vQZ9LdA0l9Ty8W/UNJfW8uV/nhJv66WK/0Jkn59LVf60yX9hlqu9JdI+o21XOlXSPrrarnSXyrpN9Vypb9M0m+u5Uq/UtJvqeVKv0rSX1/Llf75kv6GWq70l0v6G2u50l8h6W+q5Uq/WtLfXMuVfo2kv6WWK/2Vkr5Wy5X+Kkm/tZYr/dWSflstV/q1kv7WWq7010j67bVc6ddJ+h21XOnXS/qdtVzpN0j622q50m+U9LfXcqW/TtLfUcuVfrOkv7OWK/0WSX9XLVf6GyT93bVc6W+S9PfUem92u1Tua5L2hbXMab8uae+tZU1b6hkzvqiWOe0wWTC/fMLuO9q6Zwb9LZV1xTZkcX2x2+F+hrHN5BLhOde7folhgl8hWTLylUqEJ3ycP1mDlLwPUWSpKmGs4yEKzxCFp6qEcX9dBGu7Idb1hljbDLG2G2LVDLFuMsTaaoh1gyHWGkMsS91b1qEdTYq10RDL0iYsdW9pX5sNsSzrtqVNbDLEsmyjbzfEatb+UcbJHa7/+CDPhpJKvvStkhd8bt6qyCT4MtbBsVEp5lewOEy4KoSVUfZSkuwoH5cD7jHAPMZhdWTE6lDC8pTJkIR8MX5cfG28KvGHJuBj/C7X38YkreR1GIRleU6XpPehgCn4/rdav65v7Fm86tKNly9Zezljo+mheiZRPHlc0+L6q7USg+Xo/yS61wp46Lz4e/UV/4RVGy674qwVl1++amWUifWUoB/C4pp+nychGKegQbbkrdg5G7VSmkZpl2D1X6/VUfXrulaXrF2xctGKa9ZvvHIVboPBKsEsJULFe1zuGNZK9+JKTJxsQWh18U40JiU3lO53u1RumFjFMCVQwjoBm7cXDYewIRTWBViybCJhVQiTZRHWi3esA8yr57tqQi8ux+N8YDl2Uhg2XcOBm+2hQ+GRfLco8SuEFde1tKbg07pdXsJIWmZJU0slH95VFQ4u4wFoTcY0e2tScEg1ukTpkQ8xRR7R9VAlTLCk/rY5vXusQB4wPtf9Mt37Sv23SpjeyZahpOEC3msBGf+b8oa6ZzsqomfEE7nwHuJXXCG7LSWVqzZELNh2j0qjd5SH23rWLbaLaEcYfyjkAePjtXdluveD+m/V9bc5tqNhSn7wHtrRtyhvqHu2o5x6XpjWjgS/4grZbSmpXDF/bEc5h9gL0ugd5dHGBahb7EPRjjD+MMgDxsdr78p079f136rrb3NsR51KfvAe2tHP6tcdMfnpdqncJm08xXaIesiy/SytHQp+xRWyi1KSHrX6qI0JJW1VCePHHMMVnuEKT1UJ216zw9pmiLXJEGuLIdaOJsW6yRBrqyHWDYZYawyxbjHEsrT7ZtRXUj+VFcs7S1vdaYh1oyGWpa1a5nGjIVaz1u27DLGuMsSSLTQ8DhR87zpc/7qXdW6DeCIn3kP8CsmSd6yj6UUbM0r+uvLxjSxReuRDTJGH181Yt97Lu6045sb4XZAHjI/X3pXp3tF1hVcJ0zsec1eV/OA9HHMfXsftUvLD6xtZ7RXTsw4xHdtrkfJEPJET7yF+xRWqH6Uk+9H0Ivmr5uMbkaZ8UR7R9QglTLDkfWK0V4xfhTxgfLz2rkz3TiN7Rdtmex2h5Afvob2eWOqbN9Q921FOPR+f1o4Ev+IK2W0pqVwxf2xHI/LxLU6jd5RHdD1SCRMsebKDdoTxR0AeMD5ee1emexeSHaHNsR2NVPKD99COzq7jdsTkp9ulc1zHBAOxUQ/py6n0q7R2KPgVV8guSkl61Oqj5G9ULr7Sk2w7yIeYIo/oerQSJlhj6v/RDjH+KMgDxsdr78p07wVkh4jJtjNayQ/eQztcSe0Z6p7tKJ+edx1N1wdP5MJ7iF9xRey21460ctXqo+RvdD6+hWn0jvKIrscoYYIl52igHWH80ZAHjI/X3pXp3mayI7Q5bs/GKPnBe2hH6+q4XUp++PlCUn1D3KqSXuJpNpmh3TxLK/MM6a/lMhQMlA3LJIM9zU9bX/BMF7aPPPVlLPHFlbfkfS9FlqoSxmW0l8Kzl8JTVcJ4XaMI1hZDrDWGWJsMsW4xxNpoiHWTIVbNEMvSJjYbYm0wxNphhKW1n0Xk2l6zw9ppiGVZt+8yxLJsCy3r41ZDLMtyvNsQy9ImLHVvVbedcR4tbWKbIVazthOWcj0TxkyDfdqe071lfbzeEMsyj3c0qVyW4wnLPPLzQZxbluq/Ha5/3cswbz2mRHgiJ95D/ArJkpGvlKQXzB/Pk8cpslSVMJ4nj1N4xik8VSWM2/wiWFsMsdYYYlnm8SZDrK2GWDsNsSx1f5ch1mA5ZsO62xDL0iY2G2JtM8SybL92GGJZ6t7SVi1136ztl6WtWtpXzRDLshwt7cuyDlna13ZDrI2GWJZ5bNaxnGUeLccTzVqOzTqWu8MQq1nHOZZjzMHxxD9GHbJsJyzlsrIvf83rokXkuq1mh2Wp++2GWNLX8r4xwfeu4BrYtBLhiZx4D/Errn9ZWq2BaXvMJH/j8vF1pykHlEd0PV4JE6z6cRF99lZh/HGQB4yP196V6d7aeqarCmaVZBiv5AfvtYCMq+t/upT8FH1WgelZh5iO7TVnebamtVfBr7hC9aOUZD+aXjT7kbRaubL+05ZrElaXs297Ryv56VTScTmjfBn0nvpdCMGvuEJ2VUrSv6YXyd+EfHwjuC1BPsQUeUTXeythgjWx/h/bJYw/AfKA8fHauzLdu5vaJcTkdmlvJT94D9ulndQuaXUmb73A9KxDTMf2mrM829Laq+BXXKH6UUqyH00vmv1IWq1cWf9py/XpiCX2NyGBJ6meajyYXuJ1KunY/lC+9PZQ+k5a+xP8iitk76Uk/Wt6kfxNzMVX+ja3cciHmCKP6HqSEiZYk+v/sb3E+BMhDxgfr70r072Hqb1ETG4vJyn5wXvYXj7U0jdvqHu2o3x6dtW0diT4FVfEbnvtSCtXrR5L/ibl4+tKo3eUR3Q9WQkTLPn+MdoRxp8EecD4eO1dme79J9kR2hy/azFZyQ/eQzt6V/1PR0x+ul0q912tLDKkf02H66+rDOn3k/RT8qV/j6Sfmi/9uzsofsb0WyX9tHzpz5P00/Olv0jSz8iXfrakn5kv/SGSfla+9D+W9PvkS3+SpN83X/r3SvrZ+dLfJ+n3y5d+kaTfP1/630r6OfnS3y/p5+ZL/6Sknwfps6ztSPqD8qXvOQL5QLypyCT40hccAPFLMb+CxWHCVSGsvP2mJjvKx+PSA4EP8xiHdWBGrA4lLE+ZzHPx+UL8zgRZWE7v+AyTvHn2brMh1npDrO1GWP6axwZF5LraUK5JRnL568mGWFMMscpGWN7xJxeLyDXVSC7sK5oNa5oh1nRDrBmGWDMNsWYZYu1jhOUdfyquiFz7Gsp1q6Fcs43k8tf7GWJZ9R3+en9DrDmGWHMNsapNiOWdfJ6+4HrByQXXC55dcL3gtILrBcsLrhecWHC9YHHB+f4SGSvPgJul+q82l88wbj+9RHjO6fMfwa+QLBn5euY/M4mP88fPP2YpslSVMLbxWQrPLIWnqoTxXqgiWLcbYm00xLrFEOsmQ6zNhlhrDLFqhlhbDLF2NCmWpa3eYIhlpXutX2wWW7WsjzsNsZq1Pt5miGVZh5pV9zcaYlm2E5Z9rWUbbal7S301q31Zjk0sy9FS98+EduIuIyx/zXPIInJdayjXFCO5LLG8u6ZmJ9dUQ7msdO/dBkMsS5uY5uywykZY3lnZhHfrjbD8dbezwfLOshy7DeWystVmbgtHGcpl2X51N6lczagv7yxtdbqzwfLOsu+war+8u9sQy3L8db0hluWaguWY3HKuYLn2uKOOJevY0yCsVP8tuIbfVSI8kRPvIX6FZMnIl7iGj/njvb+z8vENT1MOKI/oeh8lTLDkmXAbYGH8WZAHjI/X3pXp3uN1xVcJ0zve+7uPkh+8h3t/P9XaN2+oe7ajnHpO/Y1Jwa+4QnZbSipXzB8/C9LKqaqE8Zg5rb61sttes8PaZoi1yRBriyHWjibFuskQa6sh1g2GWGsMsW41xNpuiGVZjrcbYm00xNppiGVZty3ty7IOWbarzwTd1wyxLNtoaQvl/U4cz7S7vjxZx+aYXuIVfJ9lWcH3Wc4p+D7LGTIumg03S/Vf7V2TDGO0rSXCc04fEwp+hWTJyNczJtyf+Dh/PCaco8hSVcJ4f9AchWeOwlNVwrjtKoJ1uyHWRkOsWwyxbjLE2myItcYQ61ZDrO2GWJa6b1Zb3WmItcUQy9K+LNucbYZYzwTd1wyxLPO4o0mxLOv2DYZYVrr317z3r1lstVnHAJZYg/32YL/9dOk7BvvtwX57sN/+x9R9s9rqbYZYlvqybHMsdX+jIZZlHbLst5u1jW7W8YRlHi3HvpblaKn7Z0I7cZcRlr/mPQpFsGYZYlmtk/vrfYywvOP9jUXkGmUo17VGcnm3wRBrvRGWv+bnU4O6T84j788ugjXFEGuqEZZ3lvraz0guS1v1zrIONavdN2se/9HbQku5vBvsO57+fYd364yw/LXlngcrffnr6UZy+etuQyyrvtY7y/7RSl/eNWPf4d3dhliWc77rDbEsn+lYrgNYrk9Y7s/ZUceSvV64N6xU/9XORPY83S6Vm1siPJET7yF+hWTJyFdK0gvmT/QieZ+ryFJVwrrhGsOQZ67CU1XC2F6LYO0wxNpkiLXNEOt2Q6wthljbDbEs5dpsiLXGEOsuQ6yrDLHuNsSy1NdWQyzL+rjTEMvS7i3bQstyvN4Qa7shlqVN1AyxLHW/sUnlutUQa7shluXYxLLftizHZm2/LO3Lsj42axttiWVpXzcYYvG3j3F+U6r/at+fyTB3mlkiPJET7yF+hWTJyFdK0os2h5W8z1NkqSph/AxY+4bKPIWnqoRtr9lhbTPE2mSItcUQa0eTYt1kiLXVEOsGQ6w1hli3GmJtNMTaboi10xDL0r4s9XWLIZalfVnWIct21dImLNvVZq3b2w2xLOvQ7YZYlvXxmWBfNUMsyzEAn4OA42U+ByHrmB3TS7xOJV2p/lvwm4/3lQhP5MR7iF9x/fOcZ8yu6V/Ti+T9QEWWqhJm+X097luKYN1uiLXREOsWQ6ybDLEsvwW5xhDL6jtj3m03xLLUfbPa6k5DrC2GWJb2ZdnmbDPEeibovmaIZZnHHU2KZVm3bzDEstK9v7b6Lq53lrbarGMAS6xm7bctdb/dEMuyjbYcTzSrrQ7223uuT2vWur3dEGtwTP6PYV+D48I9Z1/NOC70zlJfzWqrtxliWerLss2x1P2NhliWdciy72jWNrpZ+zTLPFqOfS3L0VL3z4R24i4jLH/Ne5SKyHWNoVyzjOTy16MMsSyfD1nqa7qhXBuM5PJuvRGWv+Z3jZvBJrzjdy6bQfeWddu6PlrVIX+9jxGWd5b18ZlgX3wOShGsKYZYU42wvLPU135Gclm2hd5ZttHNavfNmsd/9L7WUi7vBscmT/++w7t1RliW4wnvrPTlr63G5P662xDLqq/1zrJ/tNKXd83Yd3h3tyHWGkOs6w2xLJ9bWa4zWa5/We4v3FHH4vfLBN+7Dte/vniebpfKdZYIT+TEe4hfIVky8pWS9KLtk5b8HZSPb1iJ0iMfYoo8ouv5SphgHVz/j98SxvgHQR4wPl57V6Z7v6xv0q4Spnf8LeH5Sn7wXgvI+JP2vnlD3bMd5dTz5LR2JPgVV8huS0nlqtUvrVwlbVUJ4zWStPrWym57zQ5rmyHWJkOsLYZYO5oU6yZDrK2GWDcYYq0xxLrVEGu7IZZlOd5uiLXREGunIZZl3ba0L0u5LMvRUi7LdsLSJizLsWaIZdne8/t4ODbi9/GSxpcaD6aXeJ1KulL9t8P1H6NkGC/tKBGeyIn3EL/i+uc5z/hM07+mF8n7wYosVSWM13YOVngOVniqShjXsSJYtxtibTTEusUQ6yZDrM2GWGsMsW41xNpuiGWp+2a11Z2GWFsMsSzty1Iuy3K0lMuyXbW0CctyrBliWep+R5NiWbYTNxhiWeneX/O7fc1iq806nrDEGhwDDI4BBrJdHRwDDI4BBscAg2OARliW+mpWW73NEMtSX83aTtxoiGVZh5q172jWsW+z2pflONqyHC11/0xoJ+4ywvLXvI+hCNYsQyyr9Xt/vY8Rlnf8rkcRuUYZynWtkVzebTDEspLLuhwt9bXeCMvaJqzK0V9PNpLLX08xxJpqhOWdpb72M5LLX+9rhOVds9rqYH3cc3lsRvvybrAfGrR7DltnhOWvLfeIWNrXdCO5/HW3IZZVv+2dZV9rpS/vmrE+ene3IZblXPR6QyzL51aW6xOW6yaW+5l21LFkb1wZwkr1X9kXOArue55ul8qVS4QncuI9xK+QLBn5evYFjiI+zp/oRfI+UZGlSmHe8XsyExWeiQpPKCytvLAdb+DOZn0IBmLj/oMMZTM+rS0IfsX1L5s8tjCJ+OL0KnmfrMhSVcJYx5MVnskKT1UJ4+eYRbBuNsSylGubEZa/HupssKzzuMYQq2aItcMQ6wZDLEt97TTEutMQ61ZDrC2GWJa6v8kQa7MhlmUe7zLEusoQS8b28h4J9kvTXF8ebVw0KoEH00u8TiWd0RhheN4xQs7xaeIYQdOL5G9yPr7ONOWN8oiupyhhgiVr2Pi+OMafDHnA+HjtXZnu3d2x+7dKmN7x2HWKkh+81wIy7qzjdin5YXvVymWSgqvZq8TrUNJ1y8Vv1j/xhsfu+fePv3HDQw++dOTXh7982Nyht+zY8cuJv5j0iid3vL5geZ8r6afkSz9a0k/Nl36UpJ+eL/1IST8rX/rFkn4fuNktF8f8R+sFV7zjT2uHnXjr2zd9/Wunbxw+acVHp97+4AWfuG/qTy65TdLum497YbF32ko9dnOwJnuy69HbIT1omWSfKukPzZW+9KSkPwzSt6RO7zok/eH50h8u6Z+VL/2zJP0RkD6D/rol/ZG50pe+LemfjaD135lfed+Q37/53vI7v/rk2k2/3f/+R0+854NvOfrFjx9wTG3591/6i9Mk7VFK2ga8PTZ3tJb2x3e/8pbq21/8mu45j/+2/cR7f3bJUye3HfH1x2+c8LFtf/nJkw9I2udoaZPdUZL2mB5JMul7jKQ/VuP+wgV/+eYj1fuv33zPe284YvboFW+9/4lf/d+nHntb9anvPnztE4f7PuEh6hMWgBxtcO39wvp/6e+8u7jWG0fSlin+8BG96d5S50uz9oX8GXQyIe1YRvCt1r7aiI/zx+sd7YosVQrzjse/7QpPu8KjYd1tiLXGEOtWQ6wthlhbDbE2G2LdZIhlmccbDLGa1b42GmJtN8TaaYhlaV+W+rrFEMvSvizr0DZDLEubsGxXd9SxOpUwHgcMgfsZ+uWWtOMAwa+4/v1ynnHAEOKL08sw17vWsXHD6itXb9iyZO2KlYtWXLN+45WrWhDa9R+NoVYQFe+VXN/cY1gr3eN4J9X6/l9S65/OKdg+XEpuGN3vdqncsWIVxyqBErYAsNsobCGEtVPYcYB1T61v2CIIe2GtF4Md6wDz6svlqgm9uByP84HluIDCOiBsIXCzPQxReCTfLUr8DsIaoqSTMmvEV7CWlgraSqvYbgfeVGQS/KQWJ22LIVxWLYYme1JLinaBeYzD6siI1aGE5SmTpJYQ8TsTZNHk5LYw7cxL4g9LkAvjdyncklZ01AlhWXunOB1hXRB8f69av673FotXXbrx8iVrL2dsNFlUz3iKJ016i+tvSh0xWI7+j6d7rYCHLmnCn6baiZzeVRUsWYgYHFDsdoMDCnCDAwr39BlQaB0FLwXyEqF33XKx9fVv/ObCex4/6Pt/GXrnaSu2bz7kri+e+/Prxz8064cveHjSW0f5NDMru6N2KfLyq3WSt7YG+StT/NdVe9PNrvP5Mh1XD6/X0OM2Xrlm2aoN61avum5V1Javd+QaVavTa33/n1Hrn05zYhJthO9cr3pzNlypG0rBrzi9mLtdKtfTUGozUsxfvoaSDQK1gqh4r0hDKSUoLk9DmXPklrmhLFPYQgjjRnSgGkrJa9aGEstxAYVhBeeGEu2hXeGRfLco8YcQVlIj14hvcKiz2w0OdcANDnXc02eow+naXP8aL2nLFPfc+pCiYE13IyEdyzg4RtjtBscI4AbHCO7pM0bQWiDe5zCQSzPInThp+96GRfdtGHfV4T/v+Nw98187cfK3f/PQIz/63ZZVR/zsRz9+97TfFGxtzinYSp7tZd5Ak0asP1z/pUeL2ysjacsU//pKb7rNMGmcVQ+vt0TnrLhy9coVG1Ydf/W1G1dtXLXy9LUbVq1fePXK469bdfWGzFPIk2t9/59S659Oc0MBbwzga8vO0kBJ/LH1++3Ag3FYQRL/5rpSfEHurFdkzehEnk5KL+HO9RrkXiR7t0vlUndhgl8hWfJ2YXsRH+cvXxeG5sxaQVS8t6e7sPF0v9ulcpm7MH5QsRDCxlLYQHVhktesXRiW4wIKGwdh3IWhPeyl8Ei+W5T44whrLyUdd2FxfK1KOh66lOg+rtWNUbh5re5l0KrcMSFeD2NcvB7kvzZZYH1LuHOFbfnctK2Q4Fdc/7LP0wqNJz7OX75WCC0FWc4hVImDcdGdA5K5mHha6bUr6diJxjpdf01wqU6gNN0ulRuVtlQFv+IKWVFPqU4gPs4fv5Czdz6+kSVKj3yIKfJoL4yjbr2XF02w9mP8vSEPGB+vvSvTvbfVWwfLl8m9jG+kASXmp0J508plgoJbVdJLPI1nfEGe8Sl5BiI/Uk7SZnwaBs/vJd3ulZBnrbfZK2We93LxPJWCPBWFR+oBbmG4qNY3rDMhbDhgjifMLkjHz9OrELaUwkYAZoUwRyZgjlYwfdmtG9qL5/1MiKf1NDJylDKYAfJgWvzfRnG9W1THKVPcL4NdPV7pmwcsP9a1Vs8kDNs91ovWvkgYtlms68kJmNpLhD4/q4f2jcf68q7gy2jnpO3LBL9CsuTty2YRH+eP+7LZ+fjOLlF65ENMkUd0vb8SJlhz6v+xL8P4syEPGB+vvSvTve9TX7Y/xOW+bH8lP3gP+7JvUr1A3ZdifgWX73E7iLqR8hMerL9i816eH1f65gXrfavr307IwhDX/RfBU/yfUp+C6blstXqUN/8zlTwm6bmgPY9OW18Fv+IKtQ+lpPqD+eP6un8+vlFp7BvlEV3PUcIEa279P9oXxt8f8oDx8dq7Mt37K9VXrNtcX+co+cF7WF9/T/UVdV/UXpPaPOy3sb62UJ8/C2TlPt9fy4vZZYq/BeprWx2zy/W3Ty7bgco/9/vjDXkQCxeX42wB8y/6E92g3c+hdGirXOc0W5+rcGv4gtHINkYP1fMWZxvCxX3fxWAbe6WwjS4XX55d9B/b6aT2BePzIcgiZ3tM/Lh8Ta7nxfdhd0/oiynp48YR3O9J/G7AvHeCLifmC/th3m6t2YPWNmo6nesac6Oe+TmDpG93ybbI7e6+ik65P8b0nYos3B+z3Xe7VO64NO0D4ldcof6xlFbX3B/Pzce3MMlOEJN1fYASJljz6v/R7jH+XMgDxsdr78p07/C6XVQJ0zvujw9Q8oP3sD8+iOZhqPui/YRW1xq1uUdRm7s/yKq1ufvWr8sU/0Roc4+hNlerhwOdf54zzzXkQSzuj+cRFudf9Ce6QVudR+kOhDCMh/0x2vOBCreGn7Y/XjJUz1ucbQgX16W5YBtnkG1geik/zW7mUhiWNffHjfohPlBd5G53yeOcMsU/J6E/1sYu2MZxfyzxz0/oj7V2Jqk/1mxRaxs1nc4jrBkKFuqZ+2NNp5j/GZR/if+8lP2xpNfW5y6p9Q3D9Tmep+AzCJ4r4DMFHt/j+tw4CsPDrLgdxoOq0EZ4fW5YQn46AYPXi3Hdl5+pdEHY3hRWhbCJFIbrvnxwGm4rnExhoyFsCuRV1n15U8zG+v2C+zXUrY5J6+qlmF/n0vUHuIW3RDx7GfIglmw9TnrinJcH22Q+zGYg5rUliM911oKHnx8izwAcxJx6v9CeOog525N6bCFZK4iK91DTHNZK9ziexX6hnMcBZt4vxK3oQgjjVnSg9gtJXrPuF8JyXEBh2IMtBG62h0kKj+S7RYk/mbAmKemkzBrxtSrpeJdCie7H7RcSjDLF/xcYjbyYRmMaF9Y2HhGJ7HE7IVkGif9akGHnBB2zHJOvvWMwHxnaq4/XD9UxnYKp5Wsy5YtlmEQySPw3KiO9Vtff/jQbm0T/cS8WfwqNjxZlmxlD8ac0yA+Xk8R/W0I5TVRkwKe4rFOWgeNMjpHhnYoMSmu/aO01W+qtvSPHm8NL9J81z/uqJio4cU604UtPLLKVcNGKXcw9tgBJ63MuJddzlMKVqzasisk792SlGM4Wp7vOGNm8k54pZx+fekwh+BWnt1LdLpUrseUKH+ePx4dai15VwrB82Y6SeHyZyryiXqbLN6xdF1ekaQcbJUUsTu8aYMn/Z7IZZBtashGgVhAV7yVpvlFpy6RJXJ6hZc6TqjMPLXm7+UII42HnQA0tJa9Zh5ZYjgsoDBuBhcDN9jBR4eGNnRh/EmElDQsb8WlDT97Ozi1G3NCSh2AS/2vQVd8xoW8+uVPdB655q/kATGBHpm1lnt4T2BGEKnEwLroRIJmLicel591ptf7p2HErk3NLT7AJ7L21vmHYyryo1ovBTmtlJK++JrwkQyuDNXIBhWmtjDa5PY7CcOFgEYXNgLDFFIZL08dTGG45OKF+za3BU7T0mbO/Vpc+BavL9dcbLhez7bYq93hpDdOPTeAZUZBnhMJTUFelgnWt5/S7Rj0HP1bQXlFM2+LyuK7oK4aa7EnlENerxmGl+b4eYhUcH/eUyd4J+dLaNk0WTU5ezJB26pb6MwA/CqgM64uNr8dyD53z9I/D09qL4FdIlrz2op2oqJ06qT2qkrRVCvOOvxvcqfB0Kjwa1jZDrNsMsbYaYm02xFpjiGWZR8tytMzjJkMsyzzWDLFuNcS6xRBriyHWTkOsmwyxLG3Csj5a1iFLm7DU1w2GWDsMsSx1f70hlqXutxtiWerLsi3caIi13RCrWdtCS31ZtjnPhDGTpU1Y9ttWuvfXQ50NlneWdm+p+xsNsSzt3jKPlu2E5RjAUl93GWLdTVhp5/USv0uJr60byVogrhNKWlkDwa2nWZ+FxukBt7oKfoEvK4h6DqN4/GUFbFqGx2A5+n8Y3WsFPHR4NF1nPTzp4U/OZc2DS4THeXCEb/XwR3srWFs+lLxrb/BWlbD94BrDkEd726mqhHH3WgSrZoh1qyHWLYZYWwyxdhpi3WSIZWkTWw2x1hhiWdqEpb5uMMSy1Nf1hliW+rrNEMvSVjcbYj0TynG7IZalviz7oY2GWNsNsZq1H7LUl2V7b2lflm2OZX20tAnLMZOV7v31UGeD5Z2l3Vvq/kZDLEu7t8yjZTvRrOOvuwyxZKlEOyWGNzAnnQyn8WD62SmwtPmwxJ+rxE9aktHecJe1Az5toNulci1J+p4LmIJfYElG1DOf4vGSDDZhc2KwHP2fT/filmR4F9Cv6+tEosacu7PUXXy8uw6Xmma4vvJnXRnE9J0JPMML8gxPyTOqIM8ohadTSVeK+RUevpf0JGEU8eTd5afxIJYc0CF6w2U3toOsO/Iw/cQYLPzSxRW13jh8CIfUz7KC6Z0colqm+B11pfrdwJ+ob8UTnWqHqXp5hnYmy4ppUdYyxe+q9qYbXsfU9CzlrtkBv/Q0VuHVMLluZS274YoMSVhYXl0UX8qiPSY+vwIp8cdB2fGBKHwwp3doPxNjZED7wQMy4+xnYg77mdyZLCvbT5fryy3xn+zqTddN9oM6TrKfLgrTdq1qbSbvsM7aZo5Q5NN4xlEYyseH5uFBEnxo+HglzyUKQ9nHJ8jepchQcHd45jcpRlDYQggbSWHHQdhoClsEYdx3LYYwfj/seAjjA2lOgDA+pOVECJtCYSdBWBeFnQxh/N4eulb6j2Xi6+inoY5yPEecaDMLKAwP+UDdox7xNXk8YETaAh7PjYL6vKCzL99IRVaxOTz4JoPNHVIiPOf0R2+CXyFZMvL1PHobTXycP370NlaRRWuvuuEaw5An6W0DDOMlgyJYOwyxNhlibTPEut0Qa4sh1nZDLEu5NhtirTHEussQ6ypDrLsNsSz1tdUQy7I+7jTEsrR7y7bQshyvN8SyLMfthliW+rrVEGujIdZ2QyzLOmQ5nrDU1y2GWIPt6p5rV61076/50Vuz2L2l7m80xLK0e8s8WrYTNxhiNet49WpDLBmvSjqco+NaQMF1oxZJn/OjVj1vsOOHvJLWsIs+b0Auq1MFNNmTyglP3eBTBTSsKRmxCh4LmvpUAV4/02TR5ERbLJrnSYSVdm0na9l1KXyStmAdaEnSN+ZV8As8Rhb1HEzxltfqsrj+ZjkpBsvR/4PpXtxjZFElLuPNIKyRlIe4YtQe5Y1M4OkqyNOVkmd4QZ7hKXlGFOQZkZJnWkGeaQpPq8KDj+60R9j4GOsL9BhLbBsfY+GjHP6+qsTfa3hvui/TYyxML2/FdNF/f83nreMLQ2L/Fi8AIZ5zevcm+BXX32bzdG9V4uP8SVlnO6aMawhqBVHxXsn1b01KIBne440PwyhdnsMQcz54yPxwbTiFLYQwfjB1HGBZHoYoec16GCKW4wIKw9ZmIXCzPVQVHsl3ixJ/BGFVlXRSZo34WpV0wwmjRPfjDkPkB+cS/0l4aM/nbGtcWNv47GSRPe7sZJZB4v8GZODzm6uQRsvXcJAH9S//sa7x14d7Widodf/QqfM7hZ/zh7Yad4Y15gfj/0XZwKH1Spo9Vum/1pPG/ce4eEQV/9dskc/vHt0g71z+Er91eG/eufy7FBnw9VjWP8vAcTpiZBiiyFDs/G5u9bmUuCS6FJw4J9rYdehZXXLWDtcO7V6cBRQ9v7szhrPF6a7T6bI519vj5Rw7pB6rCH7F6a1ft0vlSmy5wsf540f7Wk9RVcLiamkjnoLnd8cNYrTGgtM7SltS7nmHL1pru5xmEEbWVSlML/E0nq6CPF0peZ7OZ4AyljbV8W5tbfcvn7s6Cxpc/tzaWJBDwzyz1je+tstS27Um8Rt9zIR1qS1BJHGjLuM+MJFW1plKfFyJ4Z2JKN/MjLIuDyzrWEXWToWbu4Iiq1uIJ3LiPcSvKHnI0xUk6WWXYPXfbNNW3reLWkFUvFdyfXOPYdzij6N4J9f6/s8zbd2f7ne7VC7ztJVPmV0IYbxWPFDTVslr1mkrluMCCsNXlRYCN9vDTIVH8t2ixJ9NWDOVdFJmjfiSar5gaOn8/6OVNElHrqSp0d7xYMviY/R8HArGK/hB6rFpW6o99UFqyftcRZaqEob70TEMeeYqPBrWZEOsvY2wvOOPUw9iDWINYg1iPd2wJAz77P0pHfafMhvTZks8k9aeK++dIJ/24WSNZ1pBnmkKT6eSrhTzKzx8j3k0mbWPrrPesr5Gj+n3p/zgvgR8iHnHcJ0TZ/aY9op62jLFb4V3d+4eHp9H1POudLX+Mvcs10JYhnFNlx97PzK9lwfHKbtkrPXixtUfjL+6Hl8bS8iCrlbWgtGoDF5KZaB9PnW0Ig9/PvVn8Ejj5VQGuOeFjz7Q6o3GxzbSrsRHPLaRV8Hqjzzu0OTjOa5mk6jnY2L4/lVZbdLsTrgL2t1Yze6wvrLdpR13p7FT1Ilmp2n2KaEdNPqcLpeB4PGnbx9WyjyNnWvlKvH/LWW5GrUnarmirrhctZVGrR9KsgMsL37nD8s8bmUWsbCs05TraAWfy/U/E8pV2wiDcnK5SvwPpixX3Ge4CwfCipYr6ipNuWJ8Llet/9Y+ylp1/fvJKmEl7YX0Lk25YhnEfar6Mwnlqq36J7XDEv+zTdAOo67SlKv2ZCRtuXI7jOU6i8K0JxB522jBSttGS/yvKmXOY35uF+Lk0/RW8CHkOPo/M0aMMUp6R2lLdC9uN4Pg+Hu4aM8ql+y2O30JlFUu8b+tqFyrpiiP1kRJfopuoy8RnsiD9xC/4vqbRJ6lx0ZDT156TPvhuKzd4gCYqnfy9KSkiMXpHWGVlHsYpplqJ9wTU+VtrNxDf4G2nGrfUkxq+bSRv8SXEWjc6ELwyhT/Vwm9UKPZGrfWByjxcWQs8mj5P4DCMN3EGB7sHbHl595R4v8hZe8o3APRO6KOuHecB2GtSnzW94FK/HkQh1eVDoSwpCp9APE0ajrY/jU71Wbf2mhc226cxh41+0KbmEth2mxOswWJNxArJZgftoWkuuQd6ybJdlA3VdfYTrBeziWepHbJuyRbwNUFWQ3rAGzk6Xap3L7Coz2NF2zsXjOU2WUokzitq5Z7FZIlb1fdSnycP+6qy4osVQrz7ppabzwOa1XutSRgrTHEutUQa6Mh1nZDrJ2GWDcZYlnq6xZDLEv72mqItc0Qy9ImthhhSXoruXbU7LAsbWKTIZalTdQMsSzbVcu6bWWr3jVru2ppE5btl2UdsrQJS33dYIhlqa/NhliWtmop12C/vef0td0Qy7KNthwD3GaIZdl+NatNWLYTzdoPWc5hLPN4pyHWYLv6j9F+WZbjdYZYlvpq1janWceF1xtiWdZHy77Wshybdbx6pSGWpVyW7eqNhliW7USzttGWclnqvlnbCcsx+TNhXmvZb99uiGUp13ZDLMtytKyPlnMYy3VfSyxLm+A6VKrfxzjyJSXvLqn1hmN8+bJRwWfFK/lZrGAgdltO7BLhOddXTkf4nQqfyFWJCet2ye43l3246213nvvWEqUXWfge709oV+Jrz7RFV0MgfQZdXart4RBuCStDWBuFtUGYyOB/H53eV772nPKl0R/iV5X4/FZa2rIY6fraAtq77IuZCWGdFJb0gVBtXwjG5/1qsq+mPSY+71eT+L+r11ftzRbc0zM8hg/l0/ayVZX0c2Kw4nZnT4+R/S8g+70p9tppxwxJ/EZ77fhtPswD7++aq+QHy5PfRJP4LdX++dHqn9hUwT1Uw/f0HireJ4V7qPjtfNwDOpfCsO7wvs+ZigzaTnR+OwbT4pf/kr7y2Ez1egzYUlK9nhHDh/Il1WtMn6Vee3d5TZd9b6UeJNXrGYp8zVSvu1PWa7GpwXrduF5rZ0Olrdf41Vf+Iuw8CBNcPA1k3/p1meIfmGCzByqyJr0teZAS/0CIw1/WRP0eRGGYbg6FHQRhvC91vqIHlIvPSZP4zwI9fBlscFdear0cIldBW1+o2Tp+lZttHY9ab1Xic1kcosQ/GOKITqoUn8slrt6gTvkVHdFRuxIf8coU/zil7Rf5sH2bT7LPzSj7OEX2Tte/zmCdWlL/RI22p3wmcc5N4OS02Aa1x8QXvDLFX6Loi/trrAeopyGEKfHPSGgPtPY2qQ9r1N7yXnzUyzwKQ9nxLf9d2LX+mAXr53F7+p0NKf+q698ecj+V1Pdr47a09o82dNTQvrjaGAnTTq1f8xhpRcYx0iy4l3WMxP2NpifNvmZTGOp0PMmg9bsYn+eAEn91yv7GyJ5HafaMNsv2nGSf3mXt+0UnVde/P4gbfyMWljX3N9o7bwco+Dy+3ZDQ3+C4bR7JPj6j7GnrG9ap0dTfzIJ43N8k1XFOizxx/U3c3OzmhP5mFsjOY0Wtv5H4WxPaA02XSf1No/fCRB5Np0l9kdjCAJ54Mdr6BJ28bWXV9a8//AY91g22/1kKT1r7Rxtqof6G10MQC+2iRDKiPWK9kXXVMsV/IMEeG/WlrPOk02ZQHm39hec8KLvoaQDX2M7Z0yfrSHlqY/zZFIb1mMfW2joatiFsj2hHuI7240rfeMMAo1T/lWcCuDaQQeepjwQQ/ArJkpGv5z3DTuLj/EnZZTs3mQ/QR60gKt4rub65x7BWusfxTqr1/Z/n3OQuut/tUrnM5yZ3UNhCCBtGYccBluW5yZLXrOcmYzkuoDB8WrIQuNkeNB7Jd4sSfzhhdSrppMwa8bUq6bRPsOB97EWGKNxliv9+6EXumBCvhyEuXg/yfx9FTi4LCXeu15ZzflhjZNpWSPArrlCr19MKDSc+zp9NKyQsIwhV4mBcdPjBKRcTj0vPu9Nq/dOx41ZoDN3vdqmcaSvUSWHYCt1b6xuGrdCLar0Y7LRWSPLqa8JLMrRCWHsXUJjWCkkYtvDHUVgVwhZRGH6bYzGF4YejjqcwPPfghPp1mfLwRJ1Yyp9bo26XzqEczullPDhuabZxy+m1vv/zjFtyfs/4aTlukbxajluwxV0I3GwPWcctYwhroMctWjr/v01J00n/Jdy5wj1Ra9oWQfArrlDL19MijCE+zp/UXcn7WEUW7Sku1/O832nn3gn/N5K54EFpJfrfGSNGi5LeJWBhmpIivtYw8wKuyNLuks28TPH/qixIJqV3Lp3Zh+4Ii5q91kwkmf1wRRZtwxt/fG5YSh5DU/VOesiSIhandw2wuCZrpoqzsiUx3O1OnxGyqUr8YfUBpPasoayk9y32zEpf7pMhnnAvcPGynkKycpwFJKvEHwmy7iRZsScReTopvYQ711ulTiXZu10ql7pKCX6FZMlbpU4lPs5fvrHlArhmrSAq3kuy4kY1Z3Gt7/88Y8vT6H63S+VOF6s4XQmUsDMAewGFLYWwUyjsTMDiseUyCMs6tpS8Zh1bYjmeQWFLIGwpcLM9nKrwSL5blPhLCOtUJZ2UWSO+ViXdAsIo0X1cEztZ4S5T/DnQqvCaGHKd7Po6rWWZpMjJ+pZw7wra8nlpWyHBr7j+ZZ+nFTqN+Dh/+VohtBRkOZdQJQ7GRXcuSOZi4mmlN1lJx040ViaZF9etyFvfYfXrLtffenkWjzIktedVJb3E03gqBXkqCg/Prr2Td5h4do2yarPriyndYghbSmHHK/mSsBMSME9MwDxJCfNl95kRfeNha1SK+fWuVbnHOj1VkVXKDlsAHLfF1bbTEngwvcTrVNIVzY8mszbmwi/cnDGiNw32wthqox3LEeplir90Qm+6ZVTfTof0IqOmZ66LWfXcofAMtJ65Tp1hyINYUmaimzMJi/Us5SR6xlHSmZRuGYRhPBwRnAn3lyncGr5gNLLBy0boeYuzQeEqU/zDwAafn9MGz6AwHHlyfyhyoB4w/hSn56s9Jn5cvq5KmBOeqqTXZOcvmJ2RILt3bIuYnkeuA2HzyNnIfq4j+xE9xNmP7AMpU/wpYD9byH5whDYQ+U+q1ziSk5lZUr3W2g9Oh3V0ZAoZzlRkrirpJZ42AytqG5rMjWzjNrINabvibIPff5H4Q8A27iTbwPZTZNT0zGPArHquKDwDrWce3y035EEs7t/OJizWs5ST6PksCDub0p0DYRgP+7ez4f45CreGn7Z/e+UIPW9xNihcZYr/s/G96V6VMKdJssHlFIY6xbaXyyepDEokd3tM/OWUL4n/oNK/JdXX5YDJbbnEfyNg8v5M4cV8abPlJFs8S8mXptOzXWNu1DOvzUr6dqfnP85W3p6gU0nfFpMf1qnEf2eCTjUdJelUq2NnK/nqUvJ8DmEtUbBQz2l0ivlfQvmX+O9NGIedoaTXxg48htTGYRif9+RrdUwbm3Ad+1DKMSSPbRaCfHImira2cDqlWwRhPBdbDGFLKQzXFnid4wQI4/7vRAhbRmEnQRjavqwtlCmvn63fL/hMQt1ncyrJhvotxfw6l64/XQhxSsQzEOsmJdf/keESQx5eFUWegZrPs95ON+RBrMW13b/aXI0fp2adq2H6pPnscQV5jlN4GEv6GO9wjCftQ5ni/wDaqa9O74upzbdx9xDPcbS5tdRpXqPodqlcSdIvz5e+VfKiraFo4zR+yiXh2q9gcZhwVQgra96TZEf52E60+VES1rKMWB1KWJ4yOTMhX1q/osmiyRlXN5BH248o8ZcnyIXxtfGnpBUd8fyn26VyLUk60sajPj/1XTfypGnxqks3Xr5k7eWMjSaL6plI8aR6t7j+prQsBsvR/4l0rxXw0IVqLjWezoI8nQrPQC/V8TbwuKlw28jeNGjGcVPheg/Qb6nu6zAV7qhjalPhuKpXAj7pirzjqYLwxW2NWRQj3/C6TLg1pkRpMM/TE2TGZWHm9U4e+bEMo+oyFOzy1GEsLzHgcH8hhS2EsFMpDIeSSdMmLFMMcy55ullV0i+JwYobqvCUakn9/0Qo4zRDFawTPFRZAjLxMr62wSWJJ6krPiUlz/CCPMMVnk4lXdE2SJNZeHBoiG3QbGqDtMdNmFZezeHHMp+GNmhOQhuEMvJ/rT3nNogfG3Ectk+Jf1BCG6QNz0+rxct8JnAwr3fcBvU8kqM2KOcQTW2DBEvrQ0eQ/Fn7UEwfqg8dQTwDsaTvHW91wDLh9iXr8BzT83A5rj4uGqlzavWR+0OM/yKojydQfUR7Thp7JS2dx9UJ59I9vol7RK61Qd4l9UES//SEPihpOuNd0nQ5Tj48DhnjVyHPcVhOuSfxsf9bQnGXUdwzE+LGTS/9tRxrVnAKf5bY81lKoISdrcgkYbj0vazWG49dK/1HmX15/w8cu8DxWB7tkQRjanV+Ua1vXMlzi4LLjwaxHrO+ltZ0GbiMvTu/Hpfr+1Uje/Evo34m5zT3bC4/dFx+rDt2WvmJXL78hs7oxeV4zIl6PofCsF3l7X9ae+z1tWkP6QvrJ7s9oS9+pNFIXxIm+W1R0vHGZuF7Odjr9YR3HHCx/fPx3ecAPqf3jsdiEv9m6CvOnpHMj+3X8pj8vJRsCMs5gw0tFN2f6/rKhNjn5cROM15C/E6FT+SqKGFpjsL/2CPnnb/xN6+8tkTpRRa+x8t/5yvxtZcIRVcXQPoMunqO1Cs8Jki4JawMYedRWBuEiQzaUfjn55Qvjf4Qv6rEf16tN16WsqgqPDxWLoJ1Zk4sOaL/XEjP7R3259w/aH2ybwMeadA+aeMbbh/eQe1DzvHWodq4iduHc3Nip20fBL/Txeu7ooSlaR+G/2rpjBN3XrO45Pq3g63KPW4fNFsZo8QvWP8O0toHbgPKEHYuhWH7IDJo7UPOtv6gNPpD/KoSn9uHtGVRVXi4fSiCdWZOLGkftDGr1j7weOgsJT/YPvCY/D+ozud8vVJd7+HXg/C1Ve9wLsXzlDMTcPAejqkwDc+/Jf6HYEz3/pG6fJKHpYp8PCZlPX9kZHy8s5R4/rHbXvX79cduJ67asPyKFetWrVy+6rJ1qza0Uu55NYtXnfjJmuYkh/wxo5PoP8/WjyMcHLk2csLZ5fprBg/TYR5thZdr3mhFRo1nr4I8eyk82iylFPMrPHwv6cnjXsSzROGx2OSAeJqciG/1GqT2oBzzx5uVtE2cVSWMn8hpmzjPUng0LF5h1DYOllz/uplm1XqJIjPPbL3D1devjdQ5tSey3i2vp+WNO38f15vuG7T6inIl1Sc85DVPfRqXkmd8QZ7xCs9A19vxlB+0G9ZbVrvB9Gnt5qdGdvMusJtfpLCbpDxiXefV7aTNao1eullOWGmfGByXgifpicFxKXnS5CeJZ0/mR7C0J01YBmfW4uVaRliN+oGzCEtbxdZskGVe0oAn7ikcxtN4lhXkWZaSJ1R+lhbkWZqSZ1xBnnEKT9I4KW+7rsncqL0dM6o3DdppXHvLuxYk/uugvR1Xx9ResvhH1/NZhjyIxYcexJXnDCrPpJfCvOPylPh3QXnuk6I8Nd3EjX2RN6mssb3l1SltrLwsIb72IpHWpwzgqmDqo435yUDOJyA98xdtJQ/zJ3n3s3xZ4avP8heuWj//4CMWR1P8LddsiFshHIGkrv9BLhLf0X9O52UrU5wlCod3bD9nUTwud7nP+GlkahS3UbjW1qV52SyprcP0S2Kw4nZ9SPnwzsMj6vU87a4PtKGknYdnUrozY2RvVfIw1On1dWVNlw/zvCQhzxL/2IQ8L2uQZx6/x+0cx/8cr1XJQ4frbwOIoel4gusre1Z7wvSh+s4JxBPXp51KfVqjl+2PrF/zKvJm6NNOpz5NGwsOdP7jdnBivo6EOHFzm7KC6R0/sZf459bzXnA9Tl1N56cA2gvkPn/nU5k22rHPZSrxXwBl+twUZZpUP7Sdx0ltwRkJ8bW5orb2kzRulPLhgwG6XRpX+k4aG0X8CsmS0R56xhtJBx14l3e8Ibjfhgyh/I3GG5wuabzBcePqHo8BltP9RuMNTaa4uFnHG9pTnZLrb4tp1iYxvcQT+8y5vt4tspwBcogsaPNcd5eCjFwXtfjHkXyMH7eOUHa6bqRv4vHTNTCWOG/G7mutLPaOkc+5dGWB6UOtE+9NPAPRJ3rHu8ixXNmGs65HJz17aWSDR9SvG41VbsnYr/ETYIm/N/Rr26hf094e1Owsaa2F8591vJhU39LWH9ZRWcH0Lu5NtFfROCbnm2hLtR0LYq8Fx0hL09QJxO9U+PhFawxLsxPoX794+McWrH3ufdxHiSx8L81aywwlfrHxijutUzhqvelxR4N3ZQhbTmFtECYyaDuBco5vTkujP8SvKvEXgYxZykLDWpITS3bvJB0wFrqtiFurkHaD+9rXJ8zbkw5Q9C7NW5I8J+A8cpvjXbfT3d/JCV7PIXAKF+9+lLhvgXxfOKOvrHHrKuWY/CS9QVNy8bphDm031LNdX9mWpZBNWz9BjLhnTB4jzcFjWd86O0ORR+OZVpBnmsKT1Cfxr/DwvaTnd9OIJ24884GMz4dW19Py86EOGM98mMYz2tsRwqe9WY9jCW4DJX3cW63cnkj8T0C94rdaj6M8Yz6T7CztmxQS/9EA6zKcp7Lr37Z6d3zNqXlq9CahxNfGDElvqmv9J2PFre3yGFrydvnY3nSfJzte6JLzf0KtL6bEv2hML+aXMmKeGIP5y1G9mE9Q3ZA4/nqi0/m8a1Xucf3H9BJPbI3nyN0ules5uGhxvvQ9h+QswpuKTPzRQ8xnlnYRuSquv47zrHdpsieVwyLgwzzGYS3KiNWhhOUpk+MS8oX4nQmyaHLyGEPjwRN1eD5yfIJcGF/qENqmpBUd4eF/GXTUklReeNig4Bc4uEjUM47i8cFFqOLFMViO/o+je61OP7jIN03frDen2lLDgTEyiwx8j80Y0yctabQX5GlXeJKwDlSwJP6JSvx2Jb7kA01N0lp8nyquSuDZlYJvYIaTKJ6MAlpcvPU3MsNJdC/ODLUaFvdpASxeVE+XgsHv1ByfwCl59U47n0Li8VGpY+vb/zsU/gxFfpu0tvhJFNGTYJ+YEzttDyr4nQqfyFVRwtKsVv2yesAXz591/GeTqhne42qpfVjqICV+wacX27XVKjyG1bsyhJ1IYW0QJjJoq1U5m4btafSH+FUlPq9WpS0LDWtJTixZrcLmU+pOqLqchKWtLJVI5rhPc3BbIfEn1dsK7cuimh6ccq/F9W8nTq3t/tW6JH5SeYKSV7zHesP0Em8A26q2rG1VxfXPc57Rvma3ml4k76cqslRd/7aKz2PQ2rFTFZ6nCxbaZqfrb7+lmF/h4XvMg3W1TDwnGvJofV2SneflSfrk2UB9rkxWpgr2jT1P1JYqgRKGs0C2C1wF5LEGrhSx/nHliI9Ex6dSz4Frdq30n/vni2f04nI8caHOmtRWQ3D19uTROieu3i4EXF5Jk/jHw6rXktHxeYz7lFXWJ7tn0lg555PdxDNG/5FsPI8dvySnHfPYa6mSD21HrORDa6/5LQJsY5dSmPa5Bq0tkzMHSq5/e8pPw7zjFWltHquNm7heZx03naLwFBwbZbZN/iQGPnXCMS07zcZEZm9jn01hY9x3smyaHrCtYhkxP2nPNpX462DczU+B8PwEwbyi1j/fEv9U4HCE4R23fRJ/E7V9Odsnte3jfkMbRxTkTf3JdMGvuP5tWZ5xudafauPSbB8rjuu1S4SK90quf20pgWR4bxHFO6XW93+eT6bn/BDDmdwyoNN6LW41sNfi0Rc+D+RPpuO7WVk/mS55zfrJdCxHfuaOM/TlwM32sEThkXy3KPHPIKy4kVNrCr5WJR2fiqOl8/+PVdJo+wBKMb/OJc8sWI8WWNrp3gVHh6PTtlSCb/Whk0Yn6HLe034QZBFcYxjypP0IynFGWN7xCsIg1iDWINYgVggsbZbFM0rsp/idTmwHcYaCYShf0sNnTJ/0kHtaQZ5pCs9Avx8yjfKDfSTrLetXPzA9f/VjIaTDla/HRuuc2sqXdzKT45Wow2Hl679G95VZe6DvXRfd43LYhVHrn7aj/luGsAzjiy4/Bn5kei8P67Wt1ouLY4ld8ijxZY+jdi4Lr+agLaQto69RGfE+S07Le0sl/lQoo2/Q6uRCkIv3KCbtb0K+EuW53emrp7y3VOJ/V3map8kXt5IU98WKqTF8PwS+e2lOhHYn3AXtbrRmd7jixXaX9glaUnuh1S3tXB9+grtQwUraTyzp251eBoJXpvhPKmWexs61cpX4T6UsV1xF3IUDYUXLFXXF5ao9Hdf6qSQ7wPISnWirwosJa7GChWWdplwXKvhcrn9LKFdJj+WKcnK59vCN6cVMKlfc37kLB8KKlivqKk25YnwuV20FHMtVdKL17ydRGLaJC4lHa7/RDtKUOZYPt98SfziUT9IHuo9LIZ+mN78iWTcrWZFcvmHtulX1JUlHLmkJ0f9fEiPGKCW9o7QlujeKwrTmExdZWeXC3e70JStuPiX+GEXlSc2vd0lbwwtuU0+9qC34VlvLGzVrvFSUVM0wrAlM1TtZ7S4pYnF6R1gl5Z53jbYq8yhQa62w2FhV0gvF9RyCV6b4MxWTZkyUIek0Em3kjr2jyKPln9/0xHSnxPBgj4atNfdoEn9Oyh7NaOaj9mioI+7RtJUF7TQ4ia+9WYurpTwbwichPDrVTsRJWw2leeWmDtNqMyvNXpJG3En60exL+5x10kmvmi3gvgzvyhBWdBaM+WFbSCpb71g32pttWN6iG+3UCV55wnrJbz5qs560toCrHY/RjHigv/vKe4dOgbaA39RO2o/kHc/4Jf5pSvuSlIdTlDwk1Q3UEdu69hZy6CevvJcI7Y/3EqH98V4i3BPHT2zjThhk1+ipbJr9cmwPgpvF5tGWTiabx3o2hzizrq5i+qRV3PaCPFlfVZqjYEl8bYyT9KqStvep4J6knleVtCGttpJq8KrSDIrHryppLwYylqP/M+heq9NfVdJM4pQYOYW3kUlg+jiTwO1J8jDDh8e9JL2t3pQWnCHdzzMQwUDsnFvv7y8RnnP67CtuOzbKpb0GkOa1pC/8euvtF172w68lVamkIZU2xJ+rxC/42s+LkobZ2mtJJ1BYG4SJDNprSTmbgRel0R/ia9vh+bWkrFsuMWx5Tix5LUmbcYeq+3yAxG3KUCu0LDLcuDth2Kd1AdpHPTTZWceLE/Kl8SxOma8knnkFeeYpPJ1KulLMr/DwPebRZG70UO7lY3rToH3HDdEvr6flRdOz4PCNf65jasOLuIX8EvBpD+i5vuJW36R+T+K/FuyTt/rygzfMpybzicDhXP82g7f6Svw3UN87EJ+1S3oFqiBv6lVRwddeCc6zKnoK8XH+cLUy/VZf3qbAH9rj+BjXKWGNFj9PqvX9n2erb85N2pk/Ns8jK5wc8oQTPxjJW33xUwRZt/riyytZtvpiOZ5NYTjKOge42R5OUXgk3y1K/FMJ6xQlnZRZIz5tgZdH0lo6/38fJY32iD5vT5P0IkFerCUKltg7HwfW7VK51J/eEHyrTwdqR9RqL/lpL+VIWm37Dc/+sn4yC7GWG2ItNcLyjrcDDmINYg1i7XksbdsGv8CJ/QF/Yg/bLt6elXUmqj3T1nhGFeQZpfAM9JbaUZQf7SXcEoVhfpJeJtdevm00M/zdGJ0z7cyw52VymBn+cUxfmbWZoXfaLDzpYaLEK/gwcbj2MBH12lbrxU3T38s2Y237kORds4W0ZVQe21ceXhXmtLztWeLPgzIaQpspFoJc/MJ/owfY+MIsllPaLbU9qyV1mRptqeU5naTXttR6x5/Dk/gjgC/AltqRmt1hfWC707boaStQSe2F1pZWXf+2h7fooY55ZWShwoP6ttpuO0mxB+6L2Dbi5NP0ZrxF75QYMUYo6R2lLdG9ETFYguPvJZ3DpW3R0/YScRMxQ1F5UpF5N7hF72m3RU9WqUqKWJzeEVZJueddoy163KskqVhTVd7N3YcoJp3UwmojLImvjQS0ze1JWxSTHsczj7bp3Dvu0ST+s1P2aHhg7i4cCCvao6GOuEdr9BEH1nejbTxc1bTVFK1Hy/rSUNotejxSS7IXLb9J+tHsC3vwpRSmbWLXbEHiDcSousiLaqybtNsXtRffeSaL9TLNB8fT2gLOnn4X88wtDjfuGRi2AYjB2+gk/nlKGyCY2n6FpG102rGAOIzgY6O01fKk54MD2DZ1avaI+Wd7TMqrd2lG29qoVBtt89ZiHB7xkUON7CbJHvE578vpeS3KMzNF3pJWHjC9xNN42gvytCs8SVgzFSyJr33QMmn7HD45k7QFPx7ektQW4tM4wS+wfU7UM5Hi8fY5bFLPjsFy9H8i3Wu0fW6gF71CndTI22NeWG96Cz7IvZUfHAkGYuf8HtutJcJzTp9R8UNV5OOzczAszba7r7/3qA+O3vqlrhKlF1n4XpqqO1uJX7B61rTuSbi1bXdnUxh2MSKDtu3unJzypdEf4leV+LztLm1ZaFhLcmKNdP3bnj1Vl2XYeD8Mo3jb3UDLUvAMrMwbQXhbEdavrCdFisxZT4pEnaJsrCNt2sh2JzKkPSlS4v8rlDlvH+MpuXe48B33lh1uH0OZefuYxH+I+pBllPdul86NhHSOsLQpIg+ntKmrNlXXhrc4pSyQh8x2zG/QYLvKG2WwT+DNTudB2EIKOx/C+O2aCyBsEYVdCGH8XdjnQhifs3IRhPEDo4shjDe2odPqKX6n8tN79+JyPEecaDM8RsD2SnSvPcDZH64xTGTle2xrmH5hTDqUx7uCryuUCm7h7/n+VtI5KZpNaa9e8K9gcRh/JSHn12kSv5KQ9NWNuM1tcVhpvjqCWAVfW+gpk0ZnW3D7oMmiyYm2GGfn+8O9NMsvmr61t74lbcG3GFuSdIR1QfALTFFFPXMoHn8TTXujpNEUdQ7dazRFxaJbEiOn8DZqrjB9UnOFK3HaPpQ+x2zRSrO2ox9XOfnTwxJ/yl696b4B+wO+mbA/4DTXNwx5Tif5tTcfCn4sK/VDQX47LOdDyBLrWPg4f/l2qC+Ca9YKouI9tnIM42d/C+n/cZQuzw71nA3uKbx7G522e5sHUViT+B2b0wCLd6ifDmFZd6jj0fdZdqhjOXKnru2yE4tCezhe4ZF8tyjxTyCsuHdyWlPwtSrpFhFGie5j63Oywl2m+H+ACdeLacKlcWU5CIrjxD0f/kvCpA8/5aXlaxHIg/qX/1jXZKGF+UdCC+z20vmdws/5Q1ttj5EX84Pxy3VebduH9rzHxdxj2+b3k05MiLvA9c0L/tds8WSKf1KDvHP5S/xhkHcuf+29tQWu17H+WQaOsyBGhqoig9KLLFp7zZaYHR9luNZafS4lLonFCk6cE214ixXrZe1w7dDuxVmAz3n9YVXvEPLKVRvidrtwD7kwhrPF6a7T6bJ5t6c2MC3Kx5e4gQnzl3cD0wK45tqQxFNwAxMX6XExYpSU9I7SlpR73nlzfqijb7yk01q9W1vb/csP4adBhb435kXUlhhM2Vov8bXXxpI2zWizRu17REmzxiRu7OS4Acy6wUfb1KGdZdSlyLcso6zLA8t6giKrtjGGm5qcq6WpmxrBt/ryRZJedglW/y32jR7UCqLivZKLr93conDndHKt7/8806Kcz2TP0Z67iNPWq/l5Da5X8/rx+YDF06ILICzrtEjymnVahOV4LoXhqVbnATfbwzKFR/LdosQ/i7CWKemkzBrxJdV8wdDS+f9HK2m0KXEp5te5/jXaO+7MzzLEOlvBKvjcemzalkrwtX0GeVoqbd+A9jxaq3P8DB3DeAnnXIXnXIVHw1puiHWiEZZ3/NLhINYg1iDWINbTDUvbd3M2pcP+k190xjZ1musrX9Znmpg+7hmjhGu/wsP3kp6dTiMeXBjCB0y30FKk6ChuOzq/dCrx/wjLm9vq19qWWj7ODvfcSbyCW8LVU4RxTNBW68WNszeMz9/Swb53oesbhmWAewiTyuBuKgPBSPtKgMT/HpTBvVQGuLiD4+84e9b42EbanUt8js428oCy/KzJx3NCzSZRz8fE8L1MWZ0ZwFcRxmp2h+NOtru049Q0doo60eyUV3y0Rw5Jb5pK+rg3TfmRg8R/nVLmaexcK9eeo9dSlqtRezJ2oF8x0ewAy4sPF9D2u5XoP2JhWacpV+2VRS7XdySUq7ZJAeXkcpX4j6QsV9HlQJQr6ipNuSa95qfti8Zy5T1F2E/GHVOIWEkrtFq5ao/suFw/lFCu2ip5Ujss8T/aBO1w0jfNtHJNOg64UblyO4zlmvSNJK7LWdtowUrbRkv8/1LKnMfI3C7EyafpzfgAhmUxYoxR0jtKW6J7Y2KwBMffw0VuVrn2WUHtE3ZcJb6c8CReO/nau6StohYHvCOeyIP3ED/0VlNePtWqWVJVatQtDoCpeidPG0qKWJzeEVZJuYdhmqkeB/f4hVF8loo99NdoCyCaEM8UtJZPG/lLfBmBxo0uBK9M8X+U0As1mq1xa32eEh9HxvxyM+bhPArTns4wD/aO2PJz7yjxf5GydxTugegdUUfcO+KTpVYlPuv7AiU+vk3BqzD4NkVSlT6PeBo1HWz/mp1qs29tNL7Exee30ayM7Qtt4lwKizuadxd2rTcMX0z2rgxhRVdKMD9sC0l1yTvWTZLtoG6qrrGdYL08l3iS2iXvkmwBVxd4NUz7vtQpCq7EPwuwWhWMF9Tj8xvFneN2/2r7SLS8Je1fSFpVQHm6XP82nt/mwXS4t2EXdq03rFlX7rL2BVK2VdffVs+iMByG8koftluib28THxjVN5725jf/iqx8j1d/teM++Wm8BQ9iXUQ8OFTGFc7p43pxWSfasPmI+nWZ4h8zrjfdrPp10nfsyhQ2G+pZ68z49PydRe3AoS7X3w74FRItn6g/bg8k/jyQ88tQH7zDemf03b2qVu+w3eJ6p7UxGD9rHyk60VYu+eAebT8X6rTRW8JcZvztO4l/JJQBz4pxLL2cZF+SUXatP9HaEfwu4C31dqSLZOD2PK4P08pKm/Evj8FqUeTHesvl3qpwa/HFJnAjvtY+lyn+CVBW7TN1TBcjw9IYmdtj4p9DMkj8UxR7SWoH0P55HiTxTwNM/hBPI8wjYzCXJow1tHqKT0mz9qc8nkA98twKZed+8Vzg57hHET+GoZ0zr0uQl/vURvJyfyNhl0N/dWH9uoPwMrbVrUlldYAib9qyWpqQP8aSdGXX3x6T6gjq49JxOmZbRsxVSp+ujVUuqfXiXx4zHvEuadmPxzlcD6fTmEQbG/CY5CqlPmp9vWAV6+tL39H6+qQD/BrphtuERt/Y5TE29jdVCgvRl54/qi/usgRcfz2d5Ega4/nrQ+vX3A7fmNAOazpM0rk2R0S98okgWB5nU5hms6HtEfPP9piUV++yzofZHrX+Q7NHHmcl2Y13SfYoab0NnUpjO5SVT0s6J0GeRmPuuPXL9pj43OZL/PsSxj3a+k/SPKHR2iG/e4H90gVO58Z6iTrhw3Ul/j+lbI+N1jzUw3VRb2z/STryjnV6oRIfdSU6qVJ81K9m/+dTmLaOlFRn09YNXJ+bQW215fqc1lZL/Icyrs8ltdUDtT6X1FYPpK026/oc2mra9bkxKcYCSc8CNHtcpsivrStxuWO6ca6xXMsUuapKen5HbSDWBpFTG3NwfrKuUWB6PmVruWF+NJn5hCzvcK3zkzS30NocTMv9kMT/DsyVPkPzCjydi8d2aW0K17Awrra2493ymuvJv3f2Y0HXtqfHgjzew36MD5PXTs5D28M+bVecWm96kXEg9IX1mfWV1D55l2ZegXVCdKDtdDqTwtDeeAuPpsu04wM8sfGnIxvLr30yLa198McdmujZ2R7vm9kWsj474/YSebT2kssY21csF36WJPGfTBjTaXaQZDeN5loiT5o9ANr6+wC2IU1tN7wHQFsPTGs33IZge459tPTfSeM3f439JPa5/F6/hnMm4ZTo/lC4j+kOg2sMc04/2f1wii/6a4+Jz+vYEn/I+Pqvi3+2ESfDs0iGsxrIsJxkkPjDFBm0MQ8/g8362UxMf2ZMOtZ90li6w/Wv1wOxNVPwK063w26XypWS6pM2VuA3XbT2XhsXFNTL2dobNo5k0p7RaG99Y5mza6X/KLO3xcrMXlyOx/JoJ+eG1sOZFIbtubwFqe0LlL0eeXQ0OYOOtLHBnqznyxUZtTnmnqrny/PxJdZzbe79dKnnvB4wWM+bs55rYzlNR951u3QuaV9dwdN7pqWtn4Jfcf1tIU/9TDuHLXhaS/cIt3vcyW3wfLjWvjaC5WVVfknjqNDlV3QcpZWfNo6yLD+sW1nKT1urHQ3XGIb5SVqrxfSh1mpHE0/cWu2F43vToB6yrtWuGd+b7uL6tbZWy+ux2r7SAdzn2TrQ64VF9n7wOkCI9cKvjdTlLwHuEUpartsY/yxFDokvdS7u4FhJy/vIroG5786YvSJx7x3x+pfEXw+YA73+xXtMUM9J78AkrX8ZvQMzbU+/A8N2j/sdeE8H1y/vcD2U7VOTdVkBWbkcsazOJ6y867I7FLscwPfhpmU9tUPTadKpHY10ynMo1CPvR9X2bSW1vXnWPy+k/gvL7JQUnNrzN+19Pm7rxC5fAuXPe55xn5Tw4Tuv3D9L/JcltHVaHpI+lttor13S+yFnJ6TDetmhcHXLxd+TneCJ7QxRuHi/ucR9Dejpwhm6LCWWp4HTnuOWKJ95x7wlwnNOH9PzCZM55+CJJ0xqdl/wy5RT08zJtD16WF7aWBvHwG+mMbBWx7DdOaR+zXXs32AM/HAMpnN6vU16Vx3lWZTi+a7F83+t7iY93+Xnwto6jMiA+9y1sdKh9Wve5/4eqJtJ74TZPE8u/WpPj4u478N+kecDmn1hWcd9sTRurys/B5P4H1OeQYl82J/ynsozM8oet4+E6yLWDa7H2nq4VueS6j3KXTeFfvX+swl9a6P9mVnnj/xeJuoyaQ0DT8vehV3rDZN4A/EcPeTeJSlbbe8Sv1+J71L0vIPu+re9om9vE7Op7U37/kVJwWpV5Jhav+b3ML+VYF+N+pWs+zP5Hai0e+mk7g/g3rhRWd/RTftcJ409Ytmm2eulrXk1eg+nLaZvR3vBtPvWr7mN/mXGdY2k+XDadyiynu3B7RiO2/idW+1cGZSLv00i8X+fcrxgtI6ycE+fK8N9Lr7jwHNlzdZRp43W7bjM4uZTLXX708YL2rulaeb5Vu9SvHLE7uuk9ixNP85psd1oj4kft8enU9EXt/Vx85JZhNnT5wFmmrn/EriXtY1M6iN47Uwb1wzg+OS4Zn7PjscnWDcG6j2728j+cSzCp+WemcDJaZEnzv75M60Sf0aC/WNfqY3PJxOmxN8nwf6t32/hfk17T1obWyWNn4yefR3fzM++llKY9n4H2wHy5Hnv+boRfXG18TmmnVK/5vH5ERnt63S4F+r9Kf6UsfYOA5djXD/D8xSJvwD0kDTeMpoPjG7md2V4zUtrP7U1jqT2U+svuf08NWG8dRqk52cuZ2SUPW19wzp1GfU3p0M87m+Snm9zWqzXcf2N4HHfcHZCf3M6yM7Pk7T+RuKfl9AeaG1XUn+j6X6pki9Np9wXoexiC1r9lHgF6+eYrOdsJOXVO9aN1rai7XJ/g+3h6RSGdYPHMqcrPGntH23ojLr9F9Pr5l3xd8lS68VuVWIKfpniX1m3yQrIKb/lFHL8/rVPvf3Bh7/06EhK752UkX9m48v/8gm9MpQg7voJvbJfA8+4S/V74vh8vXYIkzP+fPxbJ/TeF31KmORLnHwdUOTpgDAp3xa4J+Ur9WgI8PSUJfHeDPnbTLK1JMgmXycsU9wb6xgdxJOxTjouM8QSHWPYEJC1NiFfPCxPOYOIyxPxsDwlHtb99gR5hcvbX177nr3zxf924jf+uqiRfefFf2zN6e9fccKhwwcK//iHHr12wsIfjB0o/E+s+fgFXSNcy0DhH/CtMeNe9oPTXpKlfRFbwH3Xkk7qzHC4n6HOdKL84lrpHuJXSJaMfD3P2IcTH+ePn7F35eMbVqL0yIeYIo/ouqqECVa9q+szdsL4XZAHjI/X3pXp3utpTFuFuNIflJSwVuUetsOviumn3gHt+BvonTsseyxrDENuzY6rMemdy98fStiQhLCOhLCKki8JGwrpLqZ0wxRML/uDe/fe9/GkXmv937213njej4awNH3zKODhfdtjGmAtJyxMP4awxjbA4q/pYXpJK7Ym+lhY15PXy/tozJCksxfVdLwP0phhLOAVHTMIVqciTynm17n+7aZ3XBcQi9/TGanwFMzf8LTtu+BXSJa87btmQ5g/bt/3ysfXWaL0yIeYXKbjlDDBqj9a69O+Y/y9IA8YH6+9K9O9z1H7Pg7icvs+TskP3sP2/TM0TkDdF7VX1I2UnzYewT1nX6J1AazfWl9/RT0t1/H9oc14gvontE8uWy3/FnaGeM7p9UjwK65QvS0l2TXmj+vRuHx8w9LYHcojuh6vhAmWNPNY7hh/HOQB4+O1d2W6979Uj7DOcT0ar+QH72E9+g7VI9R90XqU1BYNRH31Tupkki6wTZZ6KHUMy308pcOyYpvTynqCwq3hC0ajNuapCXretDYGubhNrkIb8ztqYzC9lF9S+9Pl+tf5susrZ6P6LGXA9bFdiY94ZYr/14S1X0mPukK5eJ99j3x792Ly2q/WbuCYkdc3NVvU2hlNp+MJq0XBwvzw8wdNp1g/BY91OgTyz88fykp6bQ1nFIVhneb3GnHeOYbCcO7K8xici3KfjXNRtIN/2bv3fqP65B332RJ/VIKNaG2ANiaU+Hsr8Sco+e5y/e1ibwrDdGxbe0MYjwUn1v+jHlCuy2u7f8sUf2/QQ9LzQpGr4POITu15xESI0FbrxfV+EoS1KvG5LCYr8SdBHNFJleJr9VWr+6hTrq+io3YlPuLxOGFWQn3F+j6RZB+bUfZORXbuv7hOPZUwnk3TZyDuSIqvtW9aX8bt24GKvkrEkbbPkPgH78E+A/UynsLixmO7sGv9MQvWz+Fa/cT8c/1Myqt3rButbUXblbxVXf/2cCSFof3zWa4jFZ609o829CUaa2trH/wrnHyPx8CIJWssSXUJbe6senxt3MHzm0b2u4KwMD3rdXwDrEsJK27sHGcLiHUZYWnj9KQ+GLFWEham35uwJjbAWkVYmH4iYU1qgPV8wsL0kwhrcgOsywkL008mrCkNsHiOhemnENbUBlirCQvTTyWs7gZYLyAsTN9NWNMaYJ1HWJhe0nYqWFKnZS1jOtwfiDVPwa+QLBn5etZqphMf54/nBTMUWapKGI9JZyg8MxQeDWsvQ6xxhljjDbEmGGLtbYg10RBrkiHWZEOsKYZYUw2xuuvXA71GznPxTkMebS1MGwd3wzWux2njjzgMXifXnoXhetx2Wj+Q9DhfKCv8ZYr/MKzH3Va/7lLSJ6258bpA0lwpaW7lXZr1uDRzqxcmzK0Geh6kzUFLCg/biXdWa2cvSZiLj1TSh1o7K1MYrp3xOj2unYlOce0s754w3tOAeeM9DZg3bU9DF4UNhbAqhQ2DMNzT8iDlJ2l/GuZnKIVhfe2gMCy7IQl6GEZhaA9tFNYGYaKToS653kyDe1nn1JI/bX43gcIwHbdd2pqmyCDjD2xHUS5ef5T470q5/ihyDcT6I84d22q9uN5rc0GMz2WRtF6JOqlSfC4Xbt80nXKbJzpqd/o6NLf5Ev/DCW0e9le8dtqZUfayIrtWB7FPlv467z7GD1xZmf/1h4Zc0ST7GD+C8ovT5nxP032MHy5ReuTT9jEKXzUfXyuvy3HZYH+MbRPG532QuH9tFJCV6d43qf/BfpfXKnE/JT/7x7BW5V7LHsLS1lBRb1JmXq9fIF2gvZVifgWX77GMWJ6h5y1affC+26VyB/N4TTAQG+0mg+2fm7YtEfyKK1TXSkk2pu3p1eqmpNXWwK+p9cZrZH/Io2HtbFKsLYZYNUOsWw2xLPV1kyHWVkOsGwyx1hhiWeZxmyGWpVybDLEs66NlOW42xLKsQzsMsSzL0dJWbzfEsrSv7YZYdxpiWdp9s7Y5lnm8yxDrKkOsuw2xLPVlOTaxtK9mHRda2n2zjuU2GmLdYoj1TBjLNavdW45NBvu0bFjNOpZr1rZwuyGWZVtoWY6W+mrW8dfVhljNOv663hDLsm5vN8Sy1JdlP2RZh5pV95btl+W6XLOuDVnal+XYt1nHmM3Yd/hrfqZk0Xd0xWDjddKzWY2npMisPdPFPVodrn9+szzXlfSjc6YXufH5rfYMk/dj4bOtUsyvYHGYcFUIK6PspSTZk57l4nNrzGMc1qiMWB1KWJ4yGZmQL8TvTJBFk5Ntvkie2w2xhhCWVv+qCpbE187f0ewg6fwdKTs8AydD2bUklZ12Rs8wyNPGDauvXL1hy+JVl268fMnayxkbqxKq5xyKJ69Itbj+Jj4qBsvR/3PoXivgodOa0UqMnMLbqBnVtj+Gaq47lXQSr+AWnNSfjBf8iuuf5zzNY5X44vSibc+RtNo2mOfVgMz13ebi/ycd26V1HwW7wsvS6lfwrbqfpGbaO9Zvmmbau2trvfGKNK3e3WGIdash1hZDrE2GWDsNsSzzuNkQa40hlqVNbDTEsrSJmw2xngk2sdUQa5shVrPWbUvdW+rrekMsyzzeYohlWY6Wdn+DIZal3d9oiGVpE3cZYlnaxOD46x+jjbbsazcYYj0T2sK7DbEs25zrDLFuM8SyrEOW+rLs05p1XNisfVqzzq0sdW9Zhyz1ZdlGD/Yd/xh9h+XcyrIt3G6INbimsOfqkKXuLfN4pyFWs86HLHV/kyFWs64XWo5zBtuJPTeeGGwn9pzum7WdSDP+qsA9/lSStodBsEY3wOJPJWH6NJ9dQiz+VJK2pUPSjY3hweM1tE8tedfp+uetVP8t+Amh1hLhicx4D/ErSh7yPCfXPiGE+ePn5NqRzlUljLdwJX06CHk0rFEkA9qpkf5b8up/VD6+RP1r9Ter/uOO+5Jw7/aUzobk40vUGeYvj868W1Tb/asdd8jb4DQZtE8GVZX0AT6ldFTastlTn1LSPhEmaasU5t26Wm88DmtV7rUkYG00xLrJEOsWQ6wthlibDbHWGGLtNMTaZohlmcdNhliWeawZYt1qiHWbIZalfVnWR0v7smwLLeXaaohlaffPBJu40RDL0r52GGJZ5tFS99cbYlna/XZDrMF24h+jnbDM452GWJbjiWbV/V2GWIN1KBvWBkOswTq053RvOXe3nCPLujyvAXnX7VK5svb5u5Lri8ufA+52qVzqdT/Br5AsGfl61pbSfq5P8j5BkaWqhOHnB3Pqu5U/1S3YiIucA6Fvwa+4QuXbo++kTzPsEqz+y58iwLRVJYz1zZ+S6nap3PXaJxBY5/j5ggw6WJJW54Jfcf3zmUfnaT/ZIHmfpMhSpTDv1td643FYq3KvJQFrmyHWTkOsLYZYawyxbjTE2miItcMQy1Jflnm0kktrp5rFVrcbYlnWbUub2GqINdh+DbZfA5lHS91vMsSytPvbDLEs63az1sfthljN2tdaluNmQ6xnQj/0TMijpVyW7Wqz9ttXGmJZymWprzsMsW4yxLIcmzRrnzZYH/dcHpu1334mzNMsbeI6Q6xmtftbDbG2G2JZ2tfthlgD0UZrn0Hm9yy09f4JCTyYnj/FjDyjCvKMSskzpCDPkJQ84wryjEvJM74gz/hnQH46lXSl+m/BZ0DDS4QncuI9xK+4/nm2egak6UXyNykfX2ea9gXlEV1PVsIEa0r9P75PhfEnQR4wPl57V6Z7v66DVAnTO/7072QlP3ivBWT8WT2AbcW7bpfKHcrP4kQWxEUdZCijrrQ2KPgVV8gmSkk61PocyfsURZaqEhZnL8gzReGpKmFc7oNYg1iDWPmwCrR/Ve4XRDbExTZgIPa+CH7FFWpvS0k61foQyftURZaqEib6TaHvls+Nvnhj++svuuyAfYcf/6vxox649diP37Pt2H3ncpsr2IiLnBnyX06rb8GvuELl26PvqcQXZ8OS925FliqFeSfvdJaUsFblXksMltZ35cXy7qLa7t8C9e4wtj2RDXG74f5A1Lvu+nXFFbK7UpJOMX9sB9MUWapKWIZ6x264o7TdStrR890TU7992JY5ex2+9ozrtn/7rIdvHvO6/X5UHf+LjUdf98dvrO0gmZxryCvq7snrMAi8uLb7149hD6lXFNFh2fWGtVJafy06LFP8d0zpTXf4lL7caAdsYy1wP0OZz01rY4JfIVny2lgL8XH+2MZaFVmqFOYdv6PcqvC0Kjwa1jZDrNsMsbYaYm02xFpjiHW7IdZGQ6xbDLFuMsRq1nK0tFXL+mgp1yZDrC2GWDsMsSxt4npDLEub2G6IZakvy/bLUq6dhliW5WgpV7P2HZblaKl7y7ptmce7DLGuMsS62xDrmdBvW9btgehr5Zkbzsdk8tpF6fx1J4WVIQwxMAzlKyfIh+nLMek4HzKfbKfwbpfKlSR9R770PZ/4xLPEWhWZBF/mh20oRMyvYHGYcFUIK2vek2RH+ZKeefNnQzWsIRmxOpSwPGXS7uLzhfidCbJocqItxtk5liHXi44EuTB+l8ItaUVH+I3NDDpqSdIR1gXBL/B5U1HPHIonR4O2uP6mNCQGy9H/OXSvFfDQdRGG1lxxtYsrxmpMeu86E3g6lXSSv6Eg4wwI50+wzlBknJEgI6aXeBpPqSBPSeFhLG1p0bu1td2/ZYr/vvpyoreFeyf0xZypyJdU5WYp8WdCHJFH042k7VS4SzG/wuNcsg2hDNxFzDLkmQVx2olnH0OefSDOcOLZ15BnX4jTCen8/9kQhnYmcuynyCHN6f5wP2uXg3giD95D/ArJkpGvp+ven/g4f9z2zFFkqSph3O7OUXjmKDwalpRHl+tfPvwZ6NkKz+wEni6Fp2BZzmFdoZOwua5/HiTsAAjD8mXXSv9RZt/mVWb24nI8lgd1KrKF1sNsCjsA4stx2xI2D8LksWYeHU3OoCMsC5Fb+hwZ2vwcHmf9hB5n4TBPZNaG8/yJ7OlKmI//4LTd11q94H4/a73A9LNjsMqANRSwpKzKFH9o/ZlqQbu6XLMrbofn5sRO2w4LvmbHIldFCSunkOWB2b8Y9ebL/vy1EqUXWfgej1UOUOJrnyEXXc2D9Bl0dWlPv1nrTS/cElaGsLkU1gZhIoOvk49O7yvfATnlS6M/xK8qYXgUdpayqCphUi+KYmF9s8DqyIk10rnYMYHWJvHW/6xtEqZPGhOMKsgzSuEJ3ReOpjCsAygfu0b93caCY4Iu118P/AqENqbEe0lLOBJP9M1jym6Xys1lnaLTdMpLOdgmoh7YafoWmT3mHRn0jToV2Qr2ZwdoYynmxbzuT2EHQvyzan3DDoKwrGMwyY/X0bsy6AjtYR6F7a+kLai/1PMywa+4Qu1EKakN1uqQZsuStqqEof7YLlqVey0JWPLJmi4Fm9uErPO/IYrMoesCtwkHQhiWL7tG9l4paO+h9TCHwrBN4HmZVZswOWe7OY/iiuxt9f+4tiFzqTLFfc303jRLpvblQps9p9Y3DMtjP+A9o47R5frrlsdEKH+rci9pTCTxNJ5RBXlGpeSZXZBndkqeIQV5hig8Uq+wnmeoVwdpdUCchM13/fMgYQdDWNYxh8icdcyBOhXZQuuB+/GDIT6POQ6BsKztC+roXTnHwfMpbJ6StqD+Uo85BL/i+pdlnjHHgcQXV4e4fDFtVQnjNuEghecghUfD4jEHYnObkHXeN0SRuZnaBCxfdo3svVLQ3kPrgdeCsU3gMYdVmzC5YLvJdleGe9q4gddHX1gfJ/gxw9007sBxt3D7eP9F8WYrcu+p9mh2Pr7E9kirv1nbI95yUqQ9Shqj8BEHWcco4xSe0PVwHIVZjVEq/0BjlGZoj7Q2m+0ubXsk8d9Oz2ty6rrPZ1kdYQ2Oo9K3Wzi/LNpuJa2f85EpWcdR4xWe0PV1PIUNjqOas93S2va0Y5607du5tb7hEv+LMN76fMw4CuXw8UZ36/JLXO8G262BG29JWXS5/jbC462sa9vjFJ5mGm+FardQp3uq3TqAwp5O8z+RPW17JPF/E3C8lbR3Jud+i9TtluBXSJa87ZZWz7VnS9pzHN77gWE83tLaxwMVHg2L54mIzeMt7dlf0l6O8YrMBctynta/idP0yOMtbLOxfNlpdVJkztpuoU5FttB6mEth2N5xuzUfwrK2W6ijyTmfJ3KbgGMefG7GY565CkdBPac+co7bjpzPQBPbDq2u+X3gsge+/vrKias2LN146ZWrLzt11Zb1C69euXTFug2rV1y5cOXKdavWr0ehkWg43MdwdBxHrkcq9xFjXoPMyAsz2uBpHmEd2ABrOWFh+gMJ66AGWGcSFqbHtPi/zfWXUx7otqTA4QqoyXUWyYWNGnf6BzfAWkFYmP5gwjqkAdalhIXpMS3+b3P95WR9JeF4f1gDuS6r9ZXrUEh/GGEd3gBrJWFh+sMJ61kNsFYRFqbHtPi/zfWXk/WVhOP9EQ3ken6tr1zPgvRHENaRDbAuJyxMfyRhPbsB1hWEhekxLf5vc/3lZH0l4Xh/VAO5Vtf6yvVsSC9ptQEWf0Mt6wAL03MHr3WG/Cs8fC9pUy6fNXyUIQ9iyZleooejIT22rZ3KPeGQzv85cD9DZ5z6/D/Br5AsGfl6Ov/nEB/njycOxyiyVJUw7FcxDHmOUXg0rHmGWEdTfnCShGe7Levuyyl5xRcwMS2/8CHx74CNVGfXMbtcf1s5KkUen6PwSfxj6/fblfiIV6b4F3Tv/vWD6LvrFa6qyHRMjCzcn7KdSBzvOoh7oOqI4Fdc//LPU0eOJb44e5O8L1BkqSphOJbCMORZoPBoWPMNsZ5D+YmrI6u7+3LmrSProI5cWcdspjpybffu3yJ1BMdQnco9riM5bTZ1HRH8CsmSt45oZYH54zpyrCJLVQnD8XNcXTxW4dGwDjPESltHat19OSU/aeuIxL8Q6sitdUxtjsF1RJuvHKrwSXwps3YlPuKVKf7t3bt/G9WRw2Jk8dc4bu50/eXnOpLTZlPXEcGvuP72k6eOaPM9zB/XkSMVWapKGM6ZWI+tyr2WBKw0c660WIdSfuLqyD919+XMW0cWQx15RR2zmerIq7t3/6atI5rsAzH30tYX8DsWcTrSbLeqpD+MwuYqPI1s5E3dujxxNiLz9zLFPxhs5K3dffOfVc8drlC7kLodEnyrBd9Ga1jcDh2uyFJ1/ds0/j6C1t5pY4JQWAPYp7Q9XfqUZymyVCnMO9a/tr74LIXn6YLlr/n7Stp4PE25ajxoR6HWyw4jnsMMeRBL2mW2KQsexOIDQuL6hi929+J6L2OYuL5B1lDLFH869A1fqWN2UJyM9fQ5IvtzlEBtTe1wCsM5B9vRAgjjsl8IYWjz7LQHq5JXP04ZPqsXl+NxPrD/PIbCBqD/TL3Z4unQf7L+uD3K0uf5a3kuoI1tJhPPoQrPoQk8kxWZC5Zl5noymcK0epLW3kXmrJstNHsPrQeeY+H6BW+2WABhWTdboI4m59yQwutjqCOMh+22Nq/S5CopOIdSXAlrUdJ216+1udAU4sg6F5qiyDuAY9HU7eLTYSyqtYtFxnxZ5nXIOxDzOsG36pe0dlz7lpeFfcWVw2EJfDnHUD3n7DZ6/i98/qCvdte/DLW9CizXkYAv9+LqfNK+oiL7PnhfUZF9H7yvSNMBr1MdOG33r2+Hp07rG0f2xMyAONPq11qbj2t5B1A83l/jXYfrXz4DUfcEv0Ky5K17Wjlg/tA2h7hkG8EyittvdbCSF7bZ+Q1kYpvVuLQyxf1nXKa4uXIuxJufEO8gJZ6G4f/j/j/BKFPcQ+sYXs/7zOqbR23zZ4nCvNPmjUmbm/mAmAE4mDG1bQu+1eZyba9Q2s3lkpZ15h2v5eTdXD5QWGnGCDn336ReL+QXnIqOERrtac3zgpN3rP+8Lzg1K5a/nla/ZjuXcO1XePhe0bYkL4/WPg/kuqR3vF7I+5C137Q82mFbUjexvxzIOTi/RIBrEVyWCyCM9b8Qwg6isOMgDPfWsdPm7qIH3x/ul2I9r+CLDE2vv6wvEeKLJoP667s/lp2l/nK+zDtfZJ6vBEoYjp9ZfzgXYP0lPSPGMTz2G+w0HeHhz1nW3NHGJE/+RR2Z9/e+qHPqqi3nrLhy9coVG1avvXrZqms3rlq/oUzo3NPMjZFS/ovmEMclSO1dC4XxEYy4Y15znUo64RDLQe0PxMqZ4FdcoZpeShqVaK9ps2Vj2qoSxseOaTPC+QqPhiVlrR2XMZV4sh6XMVWROfTr1lMpDFuIrD3u4HEZfV0jHU0u+Gq+hGE7dEmtbxh+tYyPeJ4OYXjURdLnJeSzQ/w19/+sp+mgeHlHAUlHOuec2T8nbTsXNxNBubRVhjSfeDjkex8b2/r8lW8quf59T9Iqg8TXViXGKvELjsaeLTaJn3jAnt+7MoTNobA2CMOREH/iIefM/tlp9If4VSX+olpvvCxloc0quc9JiyWfUsCjjKXuaF/KTPNJsQ6KO1DjAcGvuEJ1vmc8kPSpNe94PDBbkaWqhPFXF7P204gl7alWNnwMTdavmI5TZC5Ylvtr7ak4rX3jY2iwfmL5stP6OpE563gAdcpHwIfSQ5nCtKdL2pg863gAdZRlPIBlwf1VWUm7p9qEcj6+xDZBq0NZ2wT8pFfRNoHbaywbPuJF+/zkzASe8QpP6LrAR7xgm4Dly86yTdDsPbQeZlJYs7UJWrvJsrcpcWfUr8sU94/TetNMrY/btH5PPt2pfQJ1XwrDcixT2CxFphJx4C4pbBv4U7A9nyaty+11+eXpOmZLDCaWqXc4Fsa6uIsXwjLY4Ee8XI9M7+VBnXnXVusrs9ZOYXyeL2ifZMK2S3RQpfhaG6m1XfgJWHmyrulLZBwIfaEMafSF8Vlf+ynxtba+6vrrqI2w2hQs1GGSvkTGgdAXysD62reBzKyvJHtEHWj95nTC0vSF9XEJySrp25X4iFem+JOgTeA30rBd47KeoWBj21giDMzHMCUfnRSGaT3uIVP64mo7wbQdyxJfO1UF31SUPkI7OUbSdijpBvKpzkC+CaA91cE8s9P6ZtFD2qc6JeIRXNS/d2wTcxQZtbc+DkuJK/G1HVtJNqTJjbvU2IYOV+TWTjmaG8OD/TvmLe7tlWdDXZZPvWvtqXAXbE+7tPYUdcTtqVZnMX7WOstvUuAbtLybGHUsnJp94Vul8sZpmjeItR2diBu3g7k9Jr7glSn+yUp7nWTP2m7cvPaMeShqz6ivK2p98yrxl4a15+EDbc/aSUtJb/jj6SGHUphmzyXXvw3L2r7ibl15Kz/vG/RJ9i95i7N/foNe4j8vwf41/WpvS0n8pNNjGtn/MRSG6ebG8MS152z/Ev/ylPYv3ANh/6gjtv+0pyJJ/AVKfO10Fu1EoiT7P4Z4rOy/1r37Os1JRMcmcHJazFuc/QtemeJvSrD/BYoMSeWxUIm/AOKw/WMeFlIYppsbw4P2j/pi+5f4N6e0/wX1ewNh/6gjtv/jIKxVic/6XqTEx/E3nxS2CML4pD3U8ULi0drBtPaPJ3jJ6V55T+JKsn/tJC6MH3cS1wsT7F+rg9qO77TtUZL9L6CwuLdPMS7aP+qL7V/ivySl/Qv3QNj/AojA9r8QwlqV+KzvpPqCOqm6/nUjyf4XEI+V/fMJkKV6GK5pyHq2d7LfpEzxH6Hn/KiXDOVzWiekcYCB2DmfMZ1WIjzn9Gda/CyQ+bzTnnel2Q8y9+ZNB0zd0nZQidKLLHyP7UtbM9tbiS+6aifZu10qd6pWB4Vb2w9SpjCsRyKDth+kLad8afSH+FUlPr81kbYsRrq+toD23lX/ba8BFvB4N6T+vwwYGF+wyhT/PXByx/ugDdt1T+Hz8T6TEK8U87sLQ7lXrvW9V6n1j99a6x9fuIfW+ssoYcMgDG1nV5z6f9QXYlUgHON/Ep5hedcBaSR9VeHvIP4+civ3sI4yVqtyT+L78vlQXcaK3APurM/PvWun9HiPucU2hrr+tomyY5mKfFJuqFMuU7SPMsi1i7P+H8sUsbCOYPwvUZli3iR9VeFHvTCXxs9lqtl6RYnv9fo46LVCOGn7iTOuX3vNsi997+valyCEqwj+T0++4Z+X/vd99zfC92325TAu4zYxaxvC+x0QS/bnFey7WiQ9fubZpU9f4r20iCHYHflk+3vaMYjgV1yhfrJnX00H8XH+eNxQycf3N//mt7QnWIewLFF3yDOEZBiaUwZt7CKc2thFeDz/82b1lSHnOPZvBW34r9o4GE8De5KeQYrucP6ljU/KFP+3MKZ4ivZ8cJvi3VAIH6KEy3/Rd4sSlz/fjv9FdtYbxhebaY/JazvlVeL/GeaaOyfomKg/lKslBvNvyvxVMMWunEuucxJ/mBIf64DI0+X6151hlA5lr7i+Du9p5VOiuCiDd7iPegjFHRLDw/rQZOhQcLTn9BWSFTnZHrzjuXCrwoN1Cvu8gnPONq0vESdh/NlMDMO8XVDrjceulf6jzB7jf2gegPFYHq0uWfb9cr8N7jMvz//bKS7vvUEZ2wxkrCo87YQ7JEH+EuGUlXSdTq9v2m9aeUuKvElrKnl5EOvC2u7fgn3eRJET7QT7vFkzenHj+jxtzMF93v4zetPNrl836vMkjMd93j231nuP23QeRyGGd7xfQ9rIdsDHOD3rnxT/wHo+sG/T2hDB2nUKDelTsOP6wApxS/wzQJ+Hkj5RX7z/k9txB/+HgiwY1zvpf1gHR4McR86I5xK9dibk0WMcM0OPhzJgPMbI269p4yuuu2nGV1xXMZ3Gwe1xXN8ttjGsQfhQJW9OudeixO+Iya9TuCsNcIcoOFr7XqGwkhLGbQ/mF9stHnNgu4Dt1qyE+lJyffM1lPLVkZCvkpKO6znKPiRBdk1/2H7kXYPoKHVu/PvkFzwyUGscPzjqV3+84djWrQOFf0HLDya+a8qbXp1lDUXKuZ245Br1jfdx7CHPY7hfW1kvj4JrFOpnpbndSJqfofw8n/PuzBj5b4L2+wqqF9r8RKszcf1vW0pZJP5V0J8mPZfENYtdOBCWQedl7bkktmtttV7cuPYW42edW4pOqq5/+5pmnzvqlMc0oqN2p8/ved+2xN8MZcD7trW2WcIw79wutiq82lqk1DEf5wGqVznHt0O0cYS4Thff/rM9YB4ljNfKMEzbb15SZNDmkPjs7iUwHuJ44rT2geurtq6SNF7U6p3gN1u9E9uvuv7lwvaW1objxnMaH5Yv9tViw3Fr+lincc71MpojtAOmtqbF7anEfzu07a+kth3bF7YHrZ1gWZzT26E0c/lOJZ2Ui/YcIcvaD5Yvyon3EL/iCrUvJW5vhY/LiNf6c44TytzHIp9WDiOcrlPteQDPFbX1nqR5UlJ7otU/rpvaOoLWhyTN54Qb18zTjJu0uoVpuZ/8d6hbn0kYN8WNjZzT5wEcP6ntQ1k13Q+lMG3uL9fDEng0uTqV+MMS5MI2GdMyd6M8pO2rjMaIbVpfhWXCfZWmF4zPehyuxO+EOFxHhkPYMApL27cNpTBt7blR3/aZmD4K84HtH89vtTqGfR/2lyWSBTlw/i/7HUvE0e70tUrBK1P8zytjYMaU9sK71bX+mCWFw7n+euF5pcT7Msiwftbu66TnAQX3dg1H2xGn9ZuCb3X2hDav0fZ/FZwHdCbZqTbe0dZhuD9stHbLz0+0tSPveG33+/WyrxKmd7x/Tht3aP2Jl/GbtLY6UM9seC9n3PP0H1Mbgu/las8UeT+zxP859MU/TXi2IDIOdcltCuaX22sp07jn4NymSPxfJbQp2vge5eL3MiX+b5T1kiS70MqPbRnja3sNtDEVr1NpbZ3WR0u8gdhfjvnnPrrRWmyaMZv2TKpK8bX+FOsJr68l2aJ3Sc/Use78uOAa8XdH/u7UnR+tfmOg1nBXrrj9jZ/83AOPZVnDTdIRphcdiS1qOko7nmCsUgJWWwMs/vJKXB3hdMJZsH9P/YUH7t9z7sUqpdULr6lpfXFVCeN5XNZ1CW2tzAKL+z7EjrNtbd6JOnJOH0+gbk+t9eVN2keZc20ltQ3x2krRfZRp11a09VxeK8C2n8dSWr/QofCEwtL6Mi7LnOtIqdfJeE9sTtspZe17tfV3fq6A/TLrX+uztfWMpwsW1v+k9dM05arxJM2BBmqewHuyhhjyIBZ/JYT3NWi/aXkQi78qXFZk8Pk/YWYvLpZx3Pg/7nnpipm96U6e2TeOyH4qxDmnft0B3M5lrssV7ZmNOO3ZGNuttk4oYbj2xfaBa18dFNYFMuBeWXat9B/14PnSnDek6TLnOKmpdJlWX5JXj5nlixJob5InnIsn1QPk5XqwEmx8HdUtbf1cq89yv9Ez+6T9dJK24LsUw7hs0WllyzaBZcs20QVhbBNVCOP6NQLCeN6HTrMXfNcjbf1aF9NGCge3kTw31vb4Yds70HPLtgZYaeaDSVhp56mDc8s9O7csG2KVKD+o2xDvDyblIameJO0BKClyFVzrTz23EfyK66/PPPbYSC9sj9qzgqoSxu1B2jV/y+cHobC0545s93HPE15FfYaki3uewONqif86GE+8tn6d9l0Ftjnm5H16ms1obViSjrW2S6t7/C5bmv2wqDvM21m13b+8L+It0L8m7eE02kvWtqfX/kUn2nw9bq8jcmpr+Wi3r1LGK4PrhaobXC90/fPPZTm4XrjbDa4X6r/Cw/cG1wttePKsF34r43oh980S/48wrvluzHrh9yHOLwbXC83WC38xuF7YNOuFfwEbHzqrNz7yODe4Xoj1RLOJZlov5HK0Wi/8ljL+1uZWces8afd9SvzR9XwUHHur7xPinmiWPwN2uzaeEKetbZQoTHt3UBu/tVKYVq/S2pTk1ct1XQqbSvMORLuSj6T3I0K8A+GdnBdaIkzn9DXHpPVji/1e6z7xuvM7f3j95c3yzu6BVMdyzon22Du7J9Xl97ZzyKy+fKHf2T2izj/4zm665zYD8c7uIiiDPfnO7iVUr56p7+xm6V8G39ntXy5sb2lt2OKdXbHhoXC/vdYbN4POWkRu0U2r65WpXOuNKPhSfh0QJvF61tXyydKjQznTVdp5xERZWyg+X5fp3joYf++St9ZXTryH+BJfO7+3Fe6JjNoZtMNq2bA6CGtIASyRSzvTeEhOuTSsdsLKcjbuSrDpvGO4n//9VTcNfexVf89zdi32g7iutYXmbHnfc38RjIdupPGQ9oxk8D33zHyD77m7/s9WnwnvuT8AdevNCXONNM9NB99z7/t/8D333jhcR5rlPfc3x/RRmA9s/9K+574F6pJ3K1ddtvaqa9auX3XJFauv3lD/KG2fEwedy95q80p9tvS1EzsYMFN611rwaUepw/UvuSyjXtH44lpvepbFO203mqTxNaNnpOh6R2divccDdonCTlB4i+Wpdrykz/nmfcso158fdzL5PI6v/291em8i19ibaHp1yr2SgsO6wXLorv+Onu+emPrtw7bM2evwtWdct/3bZz1885jX7fej6vhfbDz6uj9+Yy3npSVB9qQdlJ1KflA/xVrazT2c0orjTAyd4Jcp/uT6/7wj+d+/9qm3P/jwlx5tNJLft369fsPadasuWX31Jas2r7ps44bVa6++5LIVl12x6pK161ZcduWqSzatW3HNNavWyQdH93CTdYpVk5WzerUXfLiiNlnaQ6RWisdpfHhSs1asae5thvJuGi84AWpN0yEjftGN0MhldfiJJrt2+EnSppskrLQbywVrIMskbvPjrji13rAWCitDWDuFtdX652EIyJvUlGubiU+u9WLMAby59etiG2F2t03565xzo1x8tyX3cDFLW2QSnWmLja0UNhAfk9q//r+ZPyY1Q2R2vUOiQwAvzsa1jdtJL0EUrG8tIov24hLWb8H3E6lJ9etr1q2+bsWGVct9737y1cdL377Id+1MhHUE7a/FxfdPmB8NoxXSa64ZhlryAfSBHmpJ+3L12g2rn7/lklVXX7tx1cZVKy+5ZuOlV66+7JLnb7z6svq468orZbw1sZ5mD4+3TrIabxUdR+Rc2FTHW1pdFbuRKR1eC6fEORHinAhxvEsak3F/5d3xFIb2ewKFYTsgvL7ui/3561H164J92UkD2ZdJmzu2/t+3WzIdqbdbp++qKsfXa8rSXRXlhHo9WRRVE6bjYV+J/rfQf26uygoOO0zX0026Pd+MybdqB7oZkz1/K1evWxUVxHV+1njdqnUbhFf0MBZw8jRVY/KlV/erjYVrweUm1WXgECfl06aE4b5UjNtBv6Xs/KU4ObRuVpqCMXBP9PH/sUSHJu3/BgA=",
      "debug_symbols": "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",
      "verification_key": "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"
    },
    {
      "name": "borrow_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgMEAicCBAQAHwoAAwAEgEQdAIBFgEUGLgiARAABLgiARQACJQAAAFIlAAAAXCgCAAEEgEYnAgIEADsOAAIAASkAgEME/////yYlAAAByh4CAAMAHgIABAAzKgADAAQABScCAwEBJAIABQAAAIUlAAAB8x4CAAMAHgIABAEcCgIFACkCAAIAYzExsicCBwQEJwIJBAMAKgcJCC0IAQYACAEIAScDBgQBACIGAggtDgcIACIIAggtDgcIJwIIBAMAKgYIBy0KBwgtDgIIACIIAggtDgQIACIIAggtDgEIACIIAggtDgUIJwIBBAQAIgYCBS0LBQQnAgcEAgAqBQcCOQOggEOAQwADAAQAAiACAAEhAgACJwIDBAAtCAEFACIFAggtCwgHJwIJBAIAKggJBiI6AAIAAwAGLQoCBycCCQQDACoHCQgACAEIAScDBQQBACIFAgktDgcJACIJAgktDgcJLQoHBAYiBAIEJAIAAQAAAbMjAAABii0LBQEAIgECAS0OAQUAIgUCBi0LBgInAgcEAgAqBgcBPA4CASMAAAGzCioEAwEkAgABAAAByScCAgQAPAYCASYoAIAEBHgADQAAAIAEgAMkAIADAAAB8ioBAAEF96Hzr6Wt1Mo8BAIBJioBAAEFvh4//z6k9vo8BAIBJg==",
      "debug_symbols": "tZfdauMwEIXfxde50Mzob/IqpRQ3dYvBOMFNFpaSd9+Ro1GSBWkh297Yn8fR0RlpJMVf3dvwevp4Gef3/We3ffrqXpdxmsaPl2m/64/jfpboV2fShUO3tZsODHbbkO7yDEYAnAAIoFGIGYgEUiNKkdTKpggnkAiigAsZPCpoJGgk+AwRFDTCGmF3ATRGwSpwBtAI5N4RUSF3igQKuQu0Kmi1C5sEJS90VkEjnhRihqCR1bMX4CQYE0hzMgn4AmRIIWYAVAgZUCNkFbS51YjViNOI04jXLrx2EVQwjfMKyRhygngBm4xdINmQQbCrsRV8BgQFjZCMGEnuNo3hBWIGl2zY83nTaa29HJdhSKV2U3xSkod+GeZjt51P07TpfvXTaf3R56Gf1/uxX+StuB7mN7mL4Ps4DYnOm2trU28K5JLZtTmQ96FIgOE7EWiIGCwaxuKNhL+TwIZE4OhVIzC7IhLoToPqGoRSOVlDGG1No5kKs9oA4Goq7htS8T+diotlVmJ9VmJdIoSoEiHaqgluJELWgCYiS/R/EwGsJ9Io8+CsugjOQ5Fwf5n4jgqF7yjRZi6BSi5cz6VVonyz6tlZU82lXaPBXXNh81AuyCWXgNVcYmsHC6ZsYNHeVId7xIWH6oiiaW6BZTDAyFFWRPy9DWwVOgajUysMsTai/xBxZQtDpmqJYatO5czTAhFm/5ATMlhWDJl6laFrOZEaL0484INOykYGlCqjJhJaTry3VycxPujE842T+sC2NlUbyhZANsKDswPxevJjfUyoIUIOnU6xcISqk+ba8a4sYeO9r60dotb27MvSkWOrSFg5I57lqd+Ny90/+3PSWsb+dRry4/tp3t28Pf4+6Bv9Mjgs+93wdlqGpHT9PAC5PkmBMT2nbwJ5YLth/3xOXf8B"
    },
    {
      "name": "constructor",
      "is_unconstrained": false,
      "custom_attributes": [
        "private",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "verification_key": "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABIAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEJpAAAAAAAAAAAAAAAAAAAAgawGYSn+2eqqIm7LI0oWg3kAAAAAAAAAAAAAAAAAAAAAAAPhPBlEWnM4nJxulbBz7AAAAAAAAAAAAAAAAAAAAJxGeXfUJUm33njjCkZxupG3AAAAAAAAAAAAAAAAAAAAAAAZJ6gB6y2fC/C62Io6ydUAAAAAAAAAAAAAAAAAAACg0P9x33dHHbQoAQgwPXVJagAAAAAAAAAAAAAAAAAAAAAADebSVP9Cidfz7IE0tKWUAAAAAAAAAAAAAAAAAAAAo/fxEQ7jcMT0FY/res+gtiMAAAAAAAAAAAAAAAAAAAAAAA3olV0Zd9XQjqUS9VXl4QAAAAAAAAAAAAAAAAAAAFpO32hkHP1CnBePbEQ5hwX/AAAAAAAAAAAAAAAAAAAAAAAW9q5U/NLQ0avI4y2/XVMAAAAAAAAAAAAAAAAAAAD5z9Ew1nUDq0WZ6JUdpmzWSAAAAAAAAAAAAAAAAAAAAAAAEN9YeEfeoB/6lxS0IGQsAAAAAAAAAAAAAAAAAAAA5CAwzh54sM4veR4GrajP/SYAAAAAAAAAAAAAAAAAAAAAACE1jvXbXJuPtQJ5Y6Fm+AAAAAAAAAAAAAAAAAAAACuyZRljnnmAVr8ziq/yPsS9AAAAAAAAAAAAAAAAAAAAAAAclY9QQIY6gLW3lwtm5WwAAAAAAAAAAAAAAAAAAADQqSYfWqIz/r2aB1hUVMZJbAAAAAAAAAAAAAAAAAAAAAAAGvffT0cHyIsqK4U8FNEPAAAAAAAAAAAAAAAAAAAAbA504c9CH+Yll/pEnCK/lhEAAAAAAAAAAAAAAAAAAAAAABAFa8zQFaV8EW5Hcw5glwAAAAAAAAAAAAAAAAAAABxRMyuD8ZCDk78rLvnojxvcAAAAAAAAAAAAAAAAAAAAAAAOO5wbabjb7uAnBiNetCIAAAAAAAAAAAAAAAAAAABt61xKotL4WPJBpm5pOJRazgAAAAAAAAAAAAAAAAAAAAAAHcgVDHcJ2hrmi8BVhuPiAAAAAAAAAAAAAAAAAAAAmgwq91f09SFJVigyejeFCvQAAAAAAAAAAAAAAAAAAAAAAAixVKJ/wMLrF0uVfVziuwAAAAAAAAAAAAAAAAAAAO0Qp7bTwCDWKpI7W9OWGR0TAAAAAAAAAAAAAAAAAAAAAAAiqKqwFC76lCbUvzIesCEAAAAAAAAAAAAAAAAAAACpYO0E7RgiavfiNMUPto6zLAAAAAAAAAAAAAAAAAAAAAAAH5TAAP1cwiS/0+cpUCw4AAAAAAAAAAAAAAAAAAAAf2bfOy4Wx90Wkg6Cp3acxZEAAAAAAAAAAAAAAAAAAAAAAAhRWG4qQOBJrmhi9vWEmgAAAAAAAAAAAAAAAAAAADnuNoZUxDUBJw+DbGcfW02hAAAAAAAAAAAAAAAAAAAAAAASvZlXDgejSzmbDpIXXSMAAAAAAAAAAAAAAAAAAACVXp7SC6kPQjZmZhkHaNkHWgAAAAAAAAAAAAAAAAAAAAAAH/d5gpsD/YL98UDqUyQFAAAAAAAAAAAAAAAAAAAAlmqk3SXDVv7tUUli+tfTLRsAAAAAAAAAAAAAAAAAAAAAABtTY0gaE0DZYrgFF1VxIgAAAAAAAAAAAAAAAAAAAKHfAHW29PEA3Zjeimk2A5bUAAAAAAAAAAAAAAAAAAAAAAACOFjGSVOuOz/mrQ/rqi8AAAAAAAAAAAAAAAAAAAAKtVZMD3qtsRdC6lcawkW6eQAAAAAAAAAAAAAAAAAAAAAABuELO/3IDDq3zn++UAckAAAAAAAAAAAAAAAAAAAAzWNw5F8oy5V21yemDaDmnLQAAAAAAAAAAAAAAAAAAAAAACDCR7+Ydrmpg8m4ijeHOgAAAAAAAAAAAAAAAAAAAFNJ61jz0xxhwpg1KftCdJdbAAAAAAAAAAAAAAAAAAAAAAASIPNc8XpxuWorl0gUy3wAAAAAAAAAAAAAAAAAAADOKMdiScw64S3c7zr1HjAz+AAAAAAAAAAAAAAAAAAAAAAACz9TYjgwVt49e6gJ/6sFAAAAAAAAAAAAAAAAAAAAu40KrxWtUHMUKc6dUA+L7eAAAAAAAAAAAAAAAAAAAAAAAAPZA6T2tVbVMvVGftb3XQAAAAAAAAAAAAAAAAAAAPxWP3hhvjWZAnc1CUBivFIAAAAAAAAAAAAAAAAAAAAAAAAfgzJHCuZ1H66fvaGxUxUAAAAAAAAAAAAAAAAAAADAym7VVP6/BUktJGdPWsTLNQAAAAAAAAAAAAAAAAAAAAAAHG5WKiSXiok5DFW34XaLAAAAAAAAAAAAAAAAAAAAQ149+NWuiEE4+23XMqbKT4IAAAAAAAAAAAAAAAAAAAAAACXC7iZrHGbSqRWtQyuApQAAAAAAAAAAAAAAAAAAAJFOu28dbJyFULGQWVfPeTWxAAAAAAAAAAAAAAAAAAAAAAAGAHdERCqtdb/uW/2hbBsAAAAAAAAAAAAAAAAAAADyYHb8/r1rtWExpR+VK6W9DQAAAAAAAAAAAAAAAAAAAAAAEW0G7ZwSjyRRfwJO76bFAAAAAAAAAAAAAAAAAAAAVgEPWTMWVwoc4jw+oTFqF3AAAAAAAAAAAAAAAAAAAAAAAAs0QybW3R/zPdsThj1/aQAAAAAAAAAAAAAAAAAAANHeFe/IKeSBRA74rlQ663zxAAAAAAAAAAAAAAAAAAAAAAApsoD+PWB1sZsmkF2BiCEAAAAAAAAAAAAAAAAAAAByVtlX3A1Q13RljHQJdRaJLQAAAAAAAAAAAAAAAAAAAAAAL9H+KUHOI4VCD0jO2tIcAAAAAAAAAAAAAAAAAAAASSVlJrhDmLmQ0GIatq4sFjgAAAAAAAAAAAAAAAAAAAAAAB/dAM7jJf209N+196P7RAAAAAAAAAAAAAAAAAAAADYRK2D9hk8ugLj14ksSf5X8AAAAAAAAAAAAAAAAAAAAAAAtnZyI6S9y3PqNIBDpkeIAAAAAAAAAAAAAAAAAAAArSmiBKnynzDft2fkKlDlW+wAAAAAAAAAAAAAAAAAAAAAAISIjAlLgDELPfotUz9ujAAAAAAAAAAAAAAAAAAAAtacGdm7QrRvAXlVNouqnSSwAAAAAAAAAAAAAAAAAAAAAACVBoCmeOtZs7pwm7LYwBgAAAAAAAAAAAAAAAAAAAHoOdN4UUyAoWtd9y26V/W4oAAAAAAAAAAAAAAAAAAAAAAAQsfNQzq/ZTOOjBGsBsqwAAAAAAAAAAAAAAAAAAAD5piUTvqnXkZ2pmqf0Hu1TIwAAAAAAAAAAAAAAAAAAAAAACiDH7078cqyLa1Yw7AadAAAAAAAAAAAAAAAAAAAAwdjpeyayJo251UWS8S9DngoAAAAAAAAAAAAAAAAAAAAAAB1J1kEHz/u98xU/BL38tAAAAAAAAAAAAAAAAAAAAMXHpmO8CcDSclR+/a/nIuwKAAAAAAAAAAAAAAAAAAAAAAAsQpbtB2iT5SOvY0uhT9wAAAAAAAAAAAAAAAAAAAAkB8YZ3oJnRPuQIZtpCB0RbAAAAAAAAAAAAAAAAAAAAAAAHnV5E3wudO7tV+GnfVwAAAAAAAAAAAAAAAAAAAAAFwacv4MCfdf9JTwSNPzmX9AAAAAAAAAAAAAAAAAAAAAAACbiHyK8IEwTFlxy9Qt0AwAAAAAAAAAAAAAAAAAAAFrl9RgfElPZMbyfjpr4E4IuAAAAAAAAAAAAAAAAAAAAAAAMGJkfaWdbIzcRBlpzeXsAAAAAAAAAAAAAAAAAAAC1lx7+lpvFC4C6ige461go5wAAAAAAAAAAAAAAAAAAAAAAHmdFwt2ujkAgd4LVpdNJAAAAAAAAAAAAAAAAAAAAVGlM6N5u5vqc4mi3YR4aFuEAAAAAAAAAAAAAAAAAAAAAABnRK3YYlk6WUp87RV2zPgAAAAAAAAAAAAAAAAAAAFizPZI63otdBEhBnUg0Xl+BAAAAAAAAAAAAAAAAAAAAAAAorT+MiWPqoo2xOyPO9TIAAAAAAAAAAAAAAAAAAACe1XxR9U4oXDTtSWep/t/5wAAAAAAAAAAAAAAAAAAAAAAAHhXa0jS1bGGnpVJQqKzmAAAAAAAAAAAAAAAAAAAAYx8/ayUS6OK6wi4J3r8TDiwAAAAAAAAAAAAAAAAAAAAAACGqgNoJupA1TkV9PQbJGAAAAAAAAAAAAAAAAAAAAHTR02JqV4LjEinXD7AjqxONAAAAAAAAAAAAAAAAAAAAAAAgveQqOWlou79Of2EQxiYAAAAAAAAAAAAAAAAAAAC/cOMgV5JmbRB4Lfgky4mDBQAAAAAAAAAAAAAAAAAAAAAALT7USRibmwMGX6XBt0h+AAAAAAAAAAAAAAAAAAAA70JLLYunou4TQHZUN+vS/1cAAAAAAAAAAAAAAAAAAAAAACKwd3QIwJ0gm8XBZkrCzQAAAAAAAAAAAAAAAAAAAGBSsDFWpMNlG2T75KQkCAAIAAAAAAAAAAAAAAAAAAAAAAAXpSn4AHnnpj3rkDGPgS8AAAAAAAAAAAAAAAAAAAAUkC2e5eP8MdkMvIKIdhOBegAAAAAAAAAAAAAAAAAAAAAAAZxwvhZxJTvWaKHUbFbrAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAACAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAKUhd1DTWfkfNAASonHiI6pAAAAAAAAAAAAAAAAAAAAAAADp/AZ6FPbUgbXxQYXKjfAAAAAAAAAAAAAAAAAAAAARv7y7Rpm6c/LLXv3pRcNOwAAAAAAAAAAAAAAAAAAAAAAC05xGRq8hdAKyl2/qf5+AAAAAAAAAAAAAAAAAAAAGvMegX/lalrKJQkxfczZw2WAAAAAAAAAAAAAAAAAAAAAAAAxDcm91tv2g3iLODg36sAAAAAAAAAAAAAAAAAAAAdCgnXF47JO614WPluZPC0jQAAAAAAAAAAAAAAAAAAAAAAL5tuC04sAZaN5cMkgqp9AAAAAAAAAAAAAAAAAAAAs8PPbbWlw3xztOqrx8K9tdUAAAAAAAAAAAAAAAAAAAAAAAGaqh23OphDKX3dUwWgOQAAAAAAAAAAAAAAAAAAAPMofO4kQhdTybsV1xRQMcptAAAAAAAAAAAAAAAAAAAAAAAFiSRi70jt/BTMpcaOrm4="
    },
    {
      "name": "deposit_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4456244908619624852": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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ARLQ96I69jg1+yy6OmYbV59FF1iABKzABmSgt8NIJ58Zt9qhY4879thzfiEDvX3FUYEdaImG3jTYDL1p6E1Dbxp609CbnvNzGzznF1qgr/IWWGIbeOb8xApMGyPnGTnPyHlGzjNynpHzXPLY4ULACmxAzm0oAlQgbMh5Rs4zcp6R84ycZ+Q8U/Ybz5yfqMAOzH7jmfMT0ZLIeUbOM3KekfOMnGfkPCPnGTnPDf3W0JINLdnQkg0tOXNeHQXotu7YgZY4c37isDXfBs/5hRXYgAwUoAI7cNiab6R/gnqh57z/gl8peBb6FMLqn4D2KYSBCuxA9JCihxQ9pDjWFcf6rAQTcfQpekjRQ4oeUvRQx9GHqsEdx0PH8dBxPHh9GBMOqk8sDLRErw/N28HrQ/Mt8/qwsAIbkIECVGAHWqDM0YPqWIENyEABKrADLXGOHkwsQNgKbAW2AluBrcBWYCuwEWwEG8FGsBFsBBvBRrARbARbha3CVmHDmKNU2CpsFbYKW4WtwtZga7A12BpsDbYGW4OtwdZga7AxbAwbw8awMWwMG8PGsDFsDJvAJrAJbAKbwCawCWwCm8AmsClsCpvCprApbAqbwqawKWwKW4etw9Zh67B12DpsHbYOW4etw2awGWwGm8FmsBlsBpvBZrBZ2uasyoUFSMAKbEAGClCBHQgbaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopZ01JKOWtJRSzpqiU+7rP7w3KddBgpQgR1oiX6HsrAACViBsBXYCmwFtgJbgY1gI9gINoJt1pLLkYFu644K7EBL9DuUhQVIwGFjj+t3KAsZOGxjJlT1yZiBHei2MW7kkzEDC9D7zX931pKJDchAASqwAy1x1pKJBehP15sjA30vyFGBHWiJfi+ysAAJ6G3mcf0OZSED3caOCuxAt/nx63coCwvQ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",
      "verification_key": "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"
    },
    {
      "name": "deposit_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgUEBCcCBgQAHwoABQAGgEQdAIBEgEQGLgiARAABLgiARQACLgiARgADLgiARwAEJQAAAF4lAAAAaCgCAAEEgEgnAgIEADsOAAIAASkAgEME/////yYlAAADFB4CAAUAHgIABgAzKgAFAAYABycCBQEBJAIABwAAAJElAAADPR4CAAUBHgIABgAcCgEHACkCAAEAjJ5UcicCCQQFJwILBAMAKgkLCi0IAQgACAEKAScDCAQBACIIAgotDgkKACIKAgotDgkKJwIKBAMAKggKCS0KCQotDgEKACIKAgotDgUKACIKAgotDgYKACIKAgotDgcKACIKAgotDgIKJwIBBAUAIggCBi0LBgUnAgkEAgAqBgkCOQOggEOAQwAEAAUAAiACAAEhAgACJwIFBAAtCAEIACIIAgstCwsKJwIMBAIAKgsMCSI6AAIABQAJLQoCCicCDAQDACoKDAsACAELAScDCAQBACIIAgwtDgoMACIMAgwtDgoMLQoKBgYiBgIGJAIAAQAAAcgjAAABny0LCAEAIgECAS0OAQgAIggCCS0LCQInAgoEAgAqCQoBPA4CASMAAAHICioGBQEkAgABAAAB3icCAgQAPAYCAR4CAAEAKQIAAgBf8bSqJwIIBAQnAgoEAwAqCAoJLQgBBgAIAQkBJwMGBAEAIgYCCS0OCAkAIgkCCS0OCAknAgkEAwAqBgkILQoICS0OAgkAIgkCCS0OAwkAIgkCCS0OBwkAIgkCCS0OBAknAgIEBAAiBgIHLQsHBCcCCAQCACoHCAM5A6CAQ4BDAAEABAADIAIAASECAAItCAEEACIEAggtCwgHJwIJBAIAKggJBiI6AAIABQAGLQoCBycCCQQDACoHCQgACAEIAScDBAQBACIEAgktDgcJACIJAgktDgcJLQoHAwYiAwIDJAIAAQAAAv0jAAAC1C0LBAEAIgECAS0OAQQAIgQCBi0LBgInAgcEAgAqBgcBPA4CASMAAAL9CioDBQEkAgABAAADEycCAgQAPAYCASYoAIAEBHgADQAAAIAEgAMkAIADAAADPCoBAAEF96Hzr6Wt1Mo8BAIBJioBAAEFvh4//z6k9vo8BAIBJg==",
      "debug_symbols": "tZjRTiMxDEX/ZZ77kMR2EvMrK4QKDKhSVVBpV1qh/vvaM3FoV0qousMLPeOSGztx7kznc3geH4+vD5vdy9vHcPfrc3jcb7bbzevD9u1pfdi87ST6OTj94x0Pd7gavMfhLumnXHsnEJKAF4BQAJ0BCegg0oiOIo2wQJRICApcIKGBRbJFci7AYFAiwYFBKuCDQSwQvIFFwBmgQZk0oAmiTUEmSDZFNMFogkkFUYEKZItMVUzABbhEYMo5CngVzAoyHGRVITgDNOACAAa5AFqEbHi04dEiySLJItki2abINgWbIKcZUBMLrMAFNLEZNA1ZBJwSmyAVwGBgEZIVA6kddQ1n4ALaADOooHQLZhFEnZ2DQZqBXDCwiK7hDLFAsEiwiO77DGTABRANLEJgYFNEmzSaYLIpkglmm0JXFYMCF2CLaPcqRO3eGSwy5YwKKhgVdLj0RtTlnSEX0OWdIRUgi0Q0sOHJIski2SLZImxTcJkiuWAQC+i+Y1LIBabEJpA0SGpPmtgMsQB5A4toZ5KUnLQzZ8gFdN8pnE6rwYzo4bAfR/WhM2cSv3pf78fdYbjbHbfb1fB7vT1O//Txvt5Nn4f1Xr6V2cbds3yK4MtmOyqdVl+jXXuoB9K2nYZ7iDFVCTHECxHfEXGhajgMZxLxQiJ0JBLnaBqJmapIggsNaGuA2F4uGsIBWxrdUpgtDbkFNEuhBUqJP10K5borub0ruS0hHWsSKWMzCe4UAui8FQKI/1uID+1COm2O4vhFAtH7KkH/JNHrUD47KUzompX0WzTR175yU6RXi9yrai1AzVqWaFG/RI929wXqvgCHZi2552DJVQPLeNYddEsWmLiVRXBdC6wb6x04qCLxMo3Qa3R5zLJEhH1ureg3IlQtLDA0tyX0+hRdbXZhjjdlAi7ULgPXPjGBepkQVwORh6pwYybVyDxoZ7REUi8Teej4yiTnGzOJfJZJe2F7poopQc0k+xt3x+evO39orwl0RIAC2RYLZ9/MpHt2ItUj7GKMrbMD0LO0WI+O3LaqBF5/j6BYfZVy01dhCV+Fn/ZVebi3WiJjs5a8gKMBL+Bo34hc52joF3C0bibXOhrCAo72TSbXORrSAo72TSbXORqmBRytn8mVjoa8gKP1z86Vjkb+Nke7l6v102Z/8SLrpFr7zfpxO5bLl+Pu6ezbw593+8ZehL3v357G5+N+VKXzt2Hy89OLh3jK9/oybLrklY/+/qTT/wU="
    },
    {
      "name": "get_asset",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "asset_id",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "asset::Asset",
            "fields": [
              {
                "name": "interest_accumulator",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "last_updated_ts",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "loan_to_value",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "oracle",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1768177060348318876": {
            "error_kind": "string",
            "string": "Function get_asset can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBJJwAABAMnAgIEAScCAwQAHwoAAgADgEQuCIBEAAElAAAAXSUAAABlLgIAAYBFLgIAAoBGLgIAA4BHLgIABIBIKAIABQSARScCBgQEOw4ABgAFKACAQwQAAyYlAAADsB4CAAMAHgIABAAzKgADAAQABScCAwEBJAIABQAAAI4lAAAD2R4CAAQJJAIABAAAAKAlAAAD6ycCBAAAKwIABQAAAAAAAAAAAgAAAAAAAAAALQgBBicCBwQFAAgBBwEnAwYEAQAiBgIHLQoHCC0OBAgAIggCCC0OBAgAIggCCC0OBAgAIggCCC0OBQgtCAEFAAABAgEtCAEHAAABAgEtCAEIAAABAgEtCAEJAAABAgEnAgoAAy0IAQsnAgwEBAAIAQwBJwMLBAEAIgsCDC0KDA0tDgoNACINAg0tDgENACINAg0tDgQNLQ4LBS0OBgcnAgEEAi0OAQgnAgYBAC0OBgknAgoEACcCCwQBLQoKAiMAAAF9DSIAAoBDAAwkAgAMAAADJCMAAAGSLQsHDC0LDA0AIg0CDS0ODQwtCAENJwIOBAUACAEOAScDDQQBACIMAg4nAg8EBAAiDQIQPw8ADgAQLQsFDC0LCA4tDgwFLQ4NBy0ODggtDgMJACoNCwUtCwUDCioDBAUKKgUGByQCAAcAAAIDJQAAA/0tCAEFJwIGBAUACAEGAScDBQQBACIFAgYtCgYHLQ4EBwAiBwIHLQ4EBwAiBwIHLQ4EBwAiBwIHLQ4EBy0IAQQAAAECAS0OBQQnAgUEBC0KCgIjAAACWQwqAgUGJAIABgAAAtgjAAACay0LBAIAKgILBC0LBAMcCgMGBhwKBgQAHAoEAwYAKgIBBi0LBgQcCgQGBRwKBgEAHAoBBAUBIgACgEMABi0LBgEcCgEHBhwKBwYAHAoGAQYAKgIFBy0LBwYtCgEFLQoDAS0KBQMtCgQCLQoGBCYcCgIGAAAqAwYHLwoABwAGLQsEBy4CAAeAAygAgAQEAAUlAAAEDy4IgAUACAAiCAIJACoJAgotDgYKLQ4IBAAqAgsGLQoGAiMAAAJZLQsIDAwqAgwNJAIADQAAAzojAAADoi0LBw0AIg0CDwAqDwIQLQsQDi0LBQ8AIg8CEQAqEQISLQsSEAAqDhARLQsJDi4CAA2AAygAgAQEAAUlAAAEDy4IgAUAEAAiEAISACoSAhMtDhETLQ4PBS0OEActDgwILQ4OCSMAAAOiACoCCwwtCgwCIwAAAX0oAIAEBHgADQAAAIAEgAMkAIADAAAD2CoBAAEF96Hzr6Wt1Mo8BAIBJioBAAEFvh4//z6k9vo8BAIBJioBAAEFGInTqw4OVJw8BAIBJioBAAEFAtxuJ4B2Ep08BAIBJi4BgAOABgsAgAYAAoAHJACABwAABCojAAAENS4AgAOABSMAAAScLgAAAYAFAQAAAYAEAAEBAIADgASACS4AgAOACi4AgAWACwsAgAqACYAMJACADAAABIguAYAKgAguBIAIgAsBAIAKAAKACgEAgAsAAoALIwAABFcoAYAFBAABAwCABgACgAYjAAAEnCY=",
      "debug_symbols": "tZhRbhs5DIbv4mc/SBQlkblKUQRO4hQGDCdwkwUWQe6+pIbU2AEktG73Jf6GM/qHpChRmY/N0/7h/cf94fT88nNz9+1j83A+HI+HH/fHl8fd2+HlJNaPTdA/MZTNHW43McbNXdVfuY5BAFAgKrBBqgYIAjoI1ZIFcjYoogqgkA2oGLDfYrsFITi4JbologMZQHKoBgkc7BWA0UEFowIbZHQgg5IcqkEFh2JAKogKxaBF0SAvkEJwcEt0S4uiARm0KBpUgxZFA32F5DBhcEAHNsjJgQyah7TdYFAdVigGzY0G2UF0ksSF6sYCZJDcktyCbkG3ZLdk1ZEiQc3hAhqO1A/W6JAd2ID0YVAgAxafU1aoC+RglqzOLyA6iRXYQCtzAbcktyS3NOcbVIMMDsWgRAd/RQ0OLljJgEywBBmFEnJRf1CyUTSZmBTIQOcUs0I1QLeoP+0Z9WcBXYFFQP1ZwC2azPaM5rCButF0NIcN2C1sb6/B/KnNH8l81clFUhBLFuerlhayAi1RVF0gDZobDYqBrosFqgG5hfwZXRcKFHApSAr6LrVAMUhWkJSsIAnd0kq9gY6S2iAttgXcUuSlOSlUg1ZsOkoda0CuQ2zA9i4OwaFb7BmOycF0GEyZF58/P7cb3zzv3877ve6dF7up7LGvu/P+9La5O70fj9vNP7vje3vo5+vu1H7fdme5K7nfn57kVwSfD8e90ud2HR3GQ6OsfrDhMZVSu0QMfCUSJyIBukZAuJAoVxIwkahMxTUqc+4iNV1ppLGG7IOBTEMYcKQxDYXZ3YiRh6HkvxBK+b9DydRnhcazQmOJWsklqqymkRM8CUQaT/RApPf8aSARxoHMyhwoJNcAgjwu80mRSp8mVxFmHgYzq9IUKvaMBK4jkd8IZ7xqZyIBqdd6yJJMF8lfopkUasHsS79In139oHitUSeOZF8ucKGQkK4VZnUqJw2vU6R1G0xwvRHGWaX2QDCuqZB1eL2FTRIKkb3UAQKPNSa1nrl6OmO+zQvosyrDYKyRZjMC3lOiHHZu1Ci9ujLxbbHU2EujpjDWKLPtuKZ1N57ko87qC3p5lZsUWE9TTYEz3aRw1WTLuDbSJJ+IxSsUkVc/Iv96OmXfczcYxumcbhq59iovCYebRpqUV6nJ/ZDKiKtGhGsNnJQXYV+wlC/TEW/cRCGONtE06/apQu8IFw3hqx9pUh4pFPKkSocJNDxA0azByem3NziqcKMI0yoy7pJzEb5otUxjkXlO6kVOII1EcHoyrVD7BlJxXXlynvkNFQqrimR5rDIp2EjcT5by/8WqUdKva5S+cOR7Sh5qzGZHPk8A98SGdNMUy8CIf0FkPV+GgGE4xdPWn3IXyYmGh9TpDt/nl+HGHlF8F+Ca/7TLfFX4Lpe7x8P56nPdp0qdD7uH494un99Pjxd33/599Tv+ue/1/PK4f3o/71Vp/eYnf77JJ7ctQPkun+P0UlrFVr7L6WVsd2ELAb9/qjP/AQ=="
    },
    {
      "name": "get_assets",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "array",
            "length": 2,
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            }
          },
          "visibility": "public"
        },
        "error_types": {
          "11699106313324679151": {
            "error_kind": "string",
            "string": "Function get_assets can only be called statically"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAZyUAAABoACIBAgIoAgADBIBEJwIEBAIuAgACgAMuAgADgAQuAgAEgAUlAAAA4ygCAAIEgEQnAgMEAjsOAAMAAiYlAAABKR4CAAEAHgIAAgAzKgABAAIAAycCAQEBJAIAAwAAAJElAAABUh4CAAIJJAIAAgAAAKMlAAABZCcCAQABLwoAAQACJwIBAAIvCgABAAMtCAEBJwIEBAMACAEEAScDAQQBACIBAgQtCgQFLQ4CBQAiBQIFLQ4DBSYBAIADgAWABy4AgAOACC4AgASACQsAgAiAB4AKJACACgAAASguAYAIgAYuBIAGgAkBAIAIAAKACAEAgAkAAoAJIwAAAPcmKACABAR4AA0AAACABIADJACAAwAAAVEqAQABBfeh86+lrdTKPAQCASYqAQABBb4eP/8+pPb6PAQCASYqAQABBaJbkzUbP0/vPAQCASY=",
      "debug_symbols": "tZbdivMgEIbvxeMcjDMaNbdSSknbdAmEtGSTDz5K7n3HRfOzoLC73ZP6OnYefMdJzFNcm/P0dmr72/1dVIenOA9t17Vvp+5+qcf23nP0KcD/SHCiUoWQUonK+JHnEligYSFZEAahIArNwidpH9Fe2CBKEhX69NIGYRiMfsm4ICyno+dYF4RTUYQIgooiRiRFYYJA9GKeCxF9ncahabytjVG2/6iHph9F1U9dV4h/dTd9/un9Ufef41gPvMqbbforjwy8tV3j1Vys2ZBOlaQJQ7qksjQLguu7g8gMBHBhgMINotwhMIMwzpaRYZzTC8TQjkFpBiGBDQzWqFKMrBXn4ja4o5JW9AuslH9tRdvlVGz6VGwaYYyNCGNVchMuY4QUyGiElPqtEYlpI7k2RwsUGWhRp9s806TowEYKa+eSZnJdSmDUUhFwJgX5hp30U5uDSJCw1BVodaO/uMk1KhlczGy8SCf3DJNhQGlNhIABmyyrzUFgbTQABUlIrls16QWiyaqfnA2/Amkt6+aN+qWsKH9fVsQXlBXpBWVF9dOyHnlWX9phd8fPnja09blrwvQ29ZfN6vj/EVfiN8JjuF+a6zQ0nrR+KPDte+AT0XTka5ojB60K7fxE8qSEosTj7LfxAQ=="
    },
    {
      "name": "get_position",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "view"
      ],
      "abi": {
        "parameters": [
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "position::Position",
            "fields": [
              {
                "name": "collateral",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "static_debt",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "debt",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2493037461250685601": {
            "error_kind": "string",
            "string": "Function get_position can only be called statically"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "init",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "oracle",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "loan_to_value",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "collateral_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "stable_coin",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgUEBCcCBgQAHwoABQAGgEQdAIBFgEUGLgiARAABLgiARQACLgiARgADLgiARwAEJQAAAF4lAAAAZigCAAEEgEgnAgIEADsOAAIAASgAgEMEAAMmJQAABLAtCAEGAAABAgEnAgcBAC0OBwYtCAEGAAABAgEnAggAAC0OCAYtCAEGAAABAgEnAgkAAi0OCQYtCAEGAAABAgEnAgoAAy0OCgYeAgAGAB4CAAsAMyoABgALAAwnAgYBASQCAAwAAADXJQAABNkrAgALAAAAAAAAAAACAAAAAAAAAAAtCAEMJwINBAUACAENAScDDAQBACIMAg0tCg0OLQ4IDgAiDgIOLQ4IDgAiDgIOLQ4IDgAiDgIOLQ4LDi0IAQsAAAECAS0IAQ0AAAECAS0IAQ4AAAECAS0IAQ8AAAECAS0IARAnAhEEBAAIAREBJwMQBAEAIhACES0KERItDgoSACISAhItDggSACISAhItDggSLQsQCgAiCgIKLQ4KEC0OEAstDgwNJwIKBAItDgoOLQ4HDycCDAQAJwIQBAEtCgwFIwAAAbINIgAFgEMAESQCABEAAAQkIwAAAcctCw0RLQsREgAiEgISLQ4SES0IARInAhMEBQAIARMBJwMSBAEAIhECEycCFAQEACISAhU/DwATABUtCwsRLQsOEy0OEQstDhINLQ4TDi0OBg8AKhIQCy0LCwYKKgYICwoqCwcNJAIADQAAAjglAAAE6y0IAQsnAg0EBQAIAQ0BJwMLBAEAIgsCDS0KDQ4tDggOACIOAg4tDggOACIOAg4tDggOACIOAg4tDggOLQgBCAAAAQIBLQ4LCCcCCwQELQoMBSMAAAKODCoFCw0kAgANAAAD2CMAAAKgLQsIDQAqDRAOLQsOCBwKCA8GHAoPDgAcCg4IBgAqDQoPLQsPDhwKDg0FHAoNCgAcCgoNBSgCAAoGJxAMKgoCDgoqDgcKJAIACgAAAvYnAg8EADwGDwEnAgcFAAoqDQcKJAIACgAAAxEnAg4EADwGDgEnAgcGAAoqCAcKJAIACgAAAywnAg0EADwGDQEeAgAHBhwKBwgAHAoCBwApAgACADuaygAtCAEKJwINBAUACAENAScDCgQBACIKAg0tCg0OLQ4CDgAiDgIOLQ4IDgAiDgIOLQ4HDgAiDgIOLQ4BDi0KDAUjAAADiAwqBQsBJAIAAQAAA6wjAAADmicCAQABMAoAAwABMAoABAAJJhwKBQEAACoGAQIAIgoCBwAqBwUILQsIATAKAAEAAgAqBRABLQoBBSMAAAOIHAoFDQAAKgYNDi8KAA4ADS0LCA4uAgAOgAMoAIAEBAAFJQAABP0uCIAFAA8AIg8CEQAqEQUSLQ4NEi0ODwgAKgUQDS0KDQUjAAACji0LDhEMKgUREiQCABIAAAQ6IwAABKItCw0SACISAhQAKhQFFS0LFRMtCwsUACIUAhYAKhYFFy0LFxUAKhMVFi0LDxMuAgASgAMoAIAEBAAFJQAABP0uCIAFABUAIhUCFwAqFwUYLQ4WGC0OFAstDhUNLQ4RDi0OEw8jAAAEogAqBRARLQoRBSMAAAGyKACABAR4AA0AAACABIADJACAAwAABNgqAQABBfeh86+lrdTKPAQCASYqAQABBb4eP/8+pPb6PAQCASYqAQABBQLcbieAdhKdPAQCASYuAYADgAYLAIAGAAKAByQAgAcAAAUYIwAABSMuAIADgAUjAAAFii4AAAGABQEAAAGABAABAQCAA4AEgAkuAIADgAouAIAFgAsLAIAKgAmADCQAgAwAAAV2LgGACoAILgSACIALAQCACgACgAoBAIALAAKACyMAAAVFKAGABQQAAQMAgAYAAoAGIwAABYom",
      "debug_symbols": "tZndbts6DMffJde9kCh+iHuVYRi6LhsKBG2RtQc4GPruh7RFOemBhC7NbuKfaftvkqK+nN+77/tvLz+/3j/8ePy1+/T59+7b8f5wuP/59fB4d/t8//hg1t+75D85ye5TvtnlnNuR1yO0c6B21PVYsB3bOZZ2bDoE7djOuelw05HUjnFuOmTHarrVj67rF9QF4GYHCRrkFODPqkHhBpgC4hKFhcLCYWEMqA2kBEiDCgHxCs0BLlgddIWSMKA2yCVAGgAEcINigpAdqIFHsUJYKCzULdqAS0BtIBAgDWq8osbjGoJqPgM41BXQ87yCNPCaWMAbHayVcHGDHbTB4sYCtcHiRnXgBosbC4RFw6LNQikHhCW7jjhwA3Dn0QEDaoMCAX6zNRNhDjCfi0VBnswVwuLOr2A6xZwnd34FaVDDUsOiYXHnHTilAArQBhkD2isYSkATZK+EFUKQ/CkLmRd/qoNdwmTgyVzB3oXmPHubrtAs4v74PeL+rGD+YDFwf1YIiycTLXXibqzADTAsqA0obiYLB60kxHO4QlgWVx0WVxdwNywuWVxdoFlqKgG1gbc7qoPlh+xd1fsOkYNb/B73cAHvMitQAwoLhYXD4h1/hdrAO/4KoezNvUK8wmvVQb2bk7WFuj9cHKRBMR32S+4Pq4O9XSzz6v5IdqAGHBb3R/xxHxTFGk59FBR0sISLhazeT8UqISdvVOGFcC2KnHxIbCRBAJ1qkPvXqNuw34cc5K55Rzfy9y42z0gjXrt4Tkv/XSls2f1r5M/qQhqUu807Qk1O3hMaSTxbShB2PaQgyp36e7nbuN/HGiRdT/o71jheX292MSF+fT7u9z4fnsyQNm8+3R73D8+7Tw8vh8PN7p/bw8ty06+n24fl+Hx7tKsWwf7hux1N8Mf9Ye/0erM9ncaPWvnn9nQtUrqAJe69ErmQD2GLRi7MMhSBiUiCrmGFcSLBZxJlIiFaOTRElbqIxXWqgWONAjaFNg1jwJHGNBTVcCNnHYbCVwhF/nYoVHur1HGr6FhCpIaEVBw6kScFVmxdEkVqjB+NJMM4klmd19RLtJ60K72JZFKijBQSTOnEi5rPNSYlmikqA04UCtZzBZo0CZYSTYJ1GzQKnA8beVKhpQeCmbuCldy5wqQ+IWs0KkDSsUYda5BKpDPTZV5Ajc5qj8FQA2aFQRAjcCaUCzW4DxpU9bJYJPfSkJLGfkwHUSnbwDPJB87qC3p58UUK6ou2RUGpXqRwNp/wuDZgkk9EjgpF1M2PrO9Pp6berArjdE4HDZJe5VxwOGiUSXmxlPDDKiNvGhnONfKkvCr2DlvpNB35/UMo5T6EnrTKmyG0lNlkINDnApWhF2U2yyeukdKSJNXRhFImoyholZ4PY7hQROsmonqZiNbSRbSOReY5kZOcQBmK6HT0AOnDh+DWwjZv/4FKTZuKZXmognlWa9qXUJq3cOy7xfs1uHcbW9vTUGNW8grbCMB5VPJTBelTVEp0gYItFHp9JIaLFHoyIZ8k840CzmYn2uYFYxoWGNbZota+KPRF7aRKZ7Fk2GLBYYvQbEWqffywpWkZDkKUZ6HkrD0U+7w5CoVmy1pOuXcVtj3zsKvQbJai0hfHRHlY5jTffVEf2k9G1P9pTKOBbSfJ9gV1HM00sbZV2RKbhtsFmu2ebCfbC813tZcUWvEPVW1tKTgsNP14oXG6Qj54llT7BtKr1b6CpKEIzDYNyLFStg/KJ+uQP0gq9l0YIMgoqYxXSCpdI6l8jaTKFZI6L3fs23RjrReK9M3DB0QopS0nSS/05H2JlWtU62xtVlLq879x0QtFMl5BZPuKYl9wxzmZbvtLX8Eb1/GnmNnurq/uFC7cH3L0PRX66A7zrcIXO729uz+e/Vn56lLH+9tvh307/fHycHdy9fnfp7gSf3Y+HR/v9t9fjntX2v7xtJ/PYFMpCH7xD9h+aotQQPbTvFxNN0Dw5dWd+Q8="
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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NsWm2BSbYTNshs2wGTbDZtgMm2EzbA1bw9awNWwNW8PWsDVsDVvD5tgcm2NzbI7NsTk2x+bYyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWpJElGhg2DzSwgb5wZMnABGZQwAJWEJthM2yGrWFr2Bq2hi2ypA8SWazoN1FBAxvoC0eWWGACM9htfdjSYkW/iRUMWzRqZMmNDfSJMTltYgIzGLYWGDYPrKCCBjbQF0aW3JjADAqILWFL2BK2hC1hy9gytowtY8vYMraMLWPL2DI2wSbYBJtgE2yCTbAJNsEm2Aq2gq1gK9gKtoKtYCvYCraCrWKr2Cq2iq1iq9gqtoqtYqvYFJtiU2yKTbEpNsWm2BSbYjNshs2wGTbDZtgMm2EzbIatYWvYGraGrWFr2Bq2hq1ha9gcm2NzbI7NsTk2x+bYHJsvm1wXmMAMCljACipoYAOxkSVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClhSypJAlhSwpZEkhS2JmXutjnxYz8yYa2EBfGFlyY7f1J0sWM/Mmdlsf67NYdnBiBRU0sIG+MLLkxgSGzQIFLGAFFTSwgd3WJytazNebmMAMCljACnZbnz5oMV9vYgPjuIV4ZMnABGZQwAJWUEEDG4itYqvYKraKrWKr2Cq2iq1iq9gUm2JTbIpNsSk2xabYFJtiM2yGzbAZNsNm2AybYTNshq1ha9gatoatYWvYGraGrWFr2BybY3Nsjs2xOTbH5tgcmy9bvS4wgRkUsIAVVNDABmJL2BK2hC1hS9gStoQtYUvYEraMLWPL2DK2jC1jy9gytowtYxNsgk2wCTbBJtgEm2ATbGRJJUsqWVLJkkqWVLKkkiWVLKlkSSVLKllSyZJKllSypJIllSypZEklSypZUsmSSpbEsoOtz0q2mAc4MYMCFrCCChoYqeyBvjCy5MYEZlDAAlbwZfM+I9hiHuDEBvrCniUTE5hBAQtYQWwNW8PWsDk2x+bYHJtjc2yOzbE5Nl+2mEk4MYEZFLCAFVTQwAZiS9gStoQtYUvYEraELWFL2BK2jC1jy9gytowtY8vYMraMLWMTbIJNsAk2wSbYBJtgE2yCrWAr2Aq2gq1gK9gKtoKtYCvYKraKrWKr2Cq2iq1iq9gqtopNsSk2xabYFJtiU2yKTbEpNsNm2AybYTNsho0sUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS5QsUbJEyRIlS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS4wsMbLEyBIjS2xkiQcKWMCwtUAFDey2/tKHxZTMGyNLbuy2/hKFxbKDEwXsthTFIktuVLDb8ijWQF8YWZKjWGTJjRnstj5/3mLO5sQKKmhgA31hZMmNCcwgNsWm2BRbZEmfdm+x7OBEXxhZcmMCMyhgASuoIDbDZtgatoatYWvYGraGrWFr2Bq2hs2xOTbH5tgcm2NzbI7NsUWW9PcILGZ8TkxgBgUsYAUVDFsLbKAvjCy5MYEZFLCAFVQQW8IWWdKXuLBYdnBiAjMoYAErqAvHzUoOjEv3FKiggQ30heO2ZGACMyhgAbEVbAVbwVawVWwVW8VWsVVsFVvFVrFVbBWbYlNsik2xKTbFptgUm2JTbIbNsBk2w2bYDJthM2yGzbA1bA1bw9awNWwNW8PWsDVsDZtjc2yOzbE5Nsfm2BybY/Nl8+sCE5hBAQtYQQUNbCC2hC1hS9gStoQtYUvYEraELWHL2DK2jC1jy9gytowtY8vYMjbBFpcSZWCETQkUsIAVVNDABvrCuJS4MYHYCraCrWCLS4m+2pDFbNOJDfSFcSlxYwLDlgMFLGCbkTlmog4cUTEwgRkUMIpZYAUVjE1vgQ30hXGl0D8TaTETdWIGBSxgBRU0sIG+sGFr2OJKoa8+ZTETdWIBK6iggQ30hXGlcGMC1xyMMRP1xgKGLU7PuFK40cAG+o0tZqJOTGAGY99KYAErqKCBDfSFcaVwYwLjz9ZAXxi/8zfOZz7tWs9Y27WesbZrPWNt13rG2q71jLVd6xlru9Yz1natZ6ztWs9Y2yXYBJtgE2yCTbAJNsEm2Aq2gq1gK9gKtoKtYCvzCVMb80hv9IVx0dCfBLUxj/TGDMYx1sACVlBBAxvoC+Oe4cb5hKmNeaQ3Chi22IZIghsVNLCBvjCS4MYE9vNXQxFJcGMBK6iggQ30hZEEN3abRheJJLhRwAJWUEEDG+gL46KhP1NrYx7pjRkMWw4sYAUVNLCBPjHmkU6MfauBGRSwgBVU0MAG+sI1/tDSGEjwQAMbGLf2/VROYyBhYAJjIzVQwALGRo4/q6CBsZFhi4GEgTGQcGMCMyhgASvYbRaNGr/+NzbQF8av/40JzKCABew2i5aMX/8bDWygL4xf/xsTmEEBY9gibBEKNyoYthLYQF8YoXBjAjMoYAFj3yxQQQMb6AsjFG5MYAYFDFscrOjo/bWpFpM8JyYwgwIWsIIKGhhDSNEDoqMPjJ/8G8OWAjMoYAErqKCBDYx9640akzwnJjCDAhawggoaGDYN9IXR0W9MYNgsUMACVlBBAxvoCyMfbozBuBaYQQHDNrCCChrYQF8Y+XBjArutL8vUYpLnxAJWUEEDG+gLIx9ujLoSGH82DkD07oHRu29MYAYFLGAFFZyDki2maE70hdG7+8pPLaZoTsyggAWsoIIGxr5Fo0bvHhi9+8YEZlDAAlZQwf5O3tXXumsxR3Oxw/Fe5uQUHEch3sucLBuXjevGurFt3DZ22OdYb4v5mhMzOKRxDLxsXDfWjW3jtrEvjmmbi8fO1uC8sWxcNq4b68a2cdvY4TTqW7BsXDauG+vGtvGo34IdzmO/PDhtHN50BcvG4e2fpWkxb3NxeONnL2ZuLg5vX8WpxdzNyfEC69XX+Gkxe3Px8Ma+i2w8vBpcNx7e2EexjYc39lEcLsMb+1jSxuHNsY/xAuvk8ObYx3iBdXJ4o5/HbM7F4c2xj/EC683xAuuVYx/jBdbJ86FBk/WIosl6RNFkPaJosh5RNFmPKFpM6XxVi1aqDuu18TBGC2jeWDYuG9eNdWPbuG3ssF0bb17bvDbqR8uPeJFo7REvY79GvNycNs4by8bb9rdt+9u2/W3b/rZtf9u237ft9237fdt+39rNN69v3pEksY9lJEbsY7nY/nLJxmXjurFuzPaXq23M9sc0zcVp47yxbFw2rhvrxps3bd6RGGMfRzKMfczb9udt+0cy3Nw25rgX2bZftu2Xbftl237Ztl+27Zdt+2Xbftm2X7Z2K5u3bN47AWIfR08f+1i27S/b9tdr47TxdtzrdtzraLccXDeeD7ZaqQY20BeOPt0X92pl9N3734+2j20ffffmtrHDo+/enDbOG8vGZeO68eYdlxIl2mz09ZsdHn395rRx3lg2LhvXjXXjzds2b9u8o69LHOfR12/OG8vGZeO6sW5sG7eNfXG9ro3TxmO/UvDY/hzcNnZ49PWb08Z5Y9m4bFw31o2HV4Lbxg6Pq4ab08Z5Y9m4bFw3no9TW0yrnNjAIe0ncx3BcHPaOG8sG5eN68a68dhZC24bOzyC4ea0cd5YNi4b143DG8PHdQTJzeGt0fgjSGo0Tp3Pj1vMtZyYQQELWEEFDWygL1Rsim0ESww313GxcHPZuG6sG9vGbWOHR+DcnDYe3jgHRuDcXDauG+vGBo+giKHJOoLiZt3YNm4bOzyCIsYf6wiKm8efj2M3Oniwjg5+8/jzGpw3lo1jO/sTtabjx/9m3dg2bhs7PALh5rRx3lg23rwjEGL0TEcg3Gwbt40dHoFwc9o4bywbl403b968efOOi4X+7m/TkQmDRybcnDbOG8vGZeO6sW5sG29e2bwjE2IYUEcm3Jw3lo3LxnVj3dg2bhs7XDdv3bx189bNWzdv3bx189bNWzdv3by6eXXz6ubVzaubVzevbl7dvLp5dfOOfIhRTx35cHPeWDYuG9eNdWPbuG3s8LggiaHQsabl1dddamNNy8mycdm4bqwb28ZtY4d9zuJpY27ljRkc0hZcNq4b68a2cdvYF4/FLifHzsbg6FjscrJsXDauG+vGtnHb2OH1YkezkT19Db021rqcbBu3jR0e2XNz2jhvLBuXjTdv3rx58+bNmzevbF7ZvLJ5ZfPK5pXNO7Knr2fVxlqXVwwcj7UuJzs8sufmtHHeWDYuG9eN57sRLeZXTmzgkPYTcyyMOTltnDeWjcvGdWPdeOxsnHcjeG52eATPzWnjvLFsXDauGw+vB9vGbWOHR/DcnDbOG8vGZeP5RkiLmZcTDQxpPOsdK23ePFLn5rRx3lg2LhvXjWNnYyB8rLQ5uW3s8Li6uTltnDeWjcvGwxtn1AiYm33xWGnzipNqrLQ5edS3YNm4bDzqt2Dd2DZuGzs8roZuThvnjWXjsvHmTZs3bd60edPmzZs3b968efPmzZs3b968efPmzZt3JFKcV2MFzslp47yxbFw2jpkTEthLphjYvxfXvDltnINTsGxcNq4b68a2cdvY4bHg381p4807FtGMMfl7Ec14cn4vonlz29jhsYjmzWnjvPG4849TeOTKzXVj3dg2bhs7fI+wDB6jWNH8Y7HMa/z7urFubBuP/arBDo/FMm9OG+eNZeOy8divOL4jQm62jdvGDt8jKYPTxnlj2VjZd9/2ayyiebMvvhfRvJn9uhfRvFk2LhvXjXVj25j98ov98nRtnDbOG8vGZeO6sW7sa989b/s1Fuq+OW8sG2/7lbf9ytt+5W2/ctuY8+ReQPTmbb9k2y/Z9ku2/ZJtv2TbL7GNt/aUrT3v5yyx72Xbr1I2rhvrxtt+lW2/yrZfdduvup0ndTtP6nae1G2/6rZfdduvuu1X3farbvul23miW3vq1p5j8d14Hudj8d2bbeO2scNj8d2b08Z5Y9m4bLx5bfPa5rXNa5u3bd62edvmbZu3La9fY+HqPrDl11i4+mbdOLahT3j0ayxcfbPDo4/cnDbOG8vGZeO6sW68efPmzZt3LJrbB6T8Govj9kElv8bv4/j34/exxv6O38f+wUu/xu/jzbJx2bhurBvbxmPbPNjhcZ7fHN4+UOXXOM/74JRf4zzXaOex+HT/PKZf43dz7Mv43bx528fxmyhRf/wm3iwbl43rxrqxbdw2dnic2zeHt8S+jHO7xL6Mc/vmsnHdOLwl9nec2ze3jR0e5/bNaeO8sWw8akYbjsXpS5wnYwHpEufDWEC6RBuOBaRvrhvrxr44jd+yPljsafyW3TzqtOCxDb2t0lgwvk+E9jQWjL+5bDyOdQrWjW3jRv2738W/v/vd4LRx3lhWO6TR726uG+vG2/6O36Cxj2MR65u3doi5vWN343517FXcr97YQF8Yc3tv7HNEx8bGqz+RO2MFxxsVNLCBUbcf9rGC440JzKCABaxg2KIt4tWfGxvoC+PVnxsTmEEBQ1EDFTSwgb4w3ve5MYEZFLCA2Bq2eN8n8mMs23ijL4ypuzcmMIOyWt05WM7B8nWwxvqLkbxjpcUIzLHS4o0GNrBvToTlWGnxxgRmUMACVlDBsHlgA31hvKJzYwIzKGBd+zaWak2BvjAm5o8dion5N2ZQwNj0aLOxKOtABfumx2/DWEjxRl8VCraCrWAr2GJi/o0clsJhKRyWwmEp2CqK6KaRvmNxxBsNbGCvEOk8Fke8MYEZ7NsbiTQWR7yxggoa2EBfGN30xgRmEJthM2yGzbAZNsMWfTN+bMaCh5GlY5XDiMyxyuGNvjC63o0JzKCAsZFxAKLr3aiggW1tQ7xqFzhWObwxgRkUsIAV1IXjd6vPV/Mxp23yuGb1YIfve6rBaeP4Xenz2HzMaZtcNq4b68a2cdvY4fF7dnPaePOODy70OXM+5qulPk/Ox3y11OfA+ZivdvO4vrw5bZw3lo3LxnVj3dg23rzj+rLPt/MxX21y2jhvLBuXjevGurFt3DbevLp5dfOOa9A+d9DHrLXJZeO6sW5sG7eNHR7XoDenjTevbd5xrZni/BzXjn3eoY/ZaZNl47Jx3Vg3to3bxg6P686bhyv6wrjuvLlsXDfWjW3jtrEvLmPM5ea08XB5cNTscyV9zE6b3DaOmn3epI/ZaZPTxnlj2bhsXDfWjW3jBufNdY+bxPbf4yaDdWPbmGwpmWwpWx8vWx8vWx8fs9Mml43rxrqxbdw2JltK2byjj/e1wb2MPn7zti9l25fRx/sLRl7uj50Fjz5+c9o4bywbl43rxrqxbbx56+bVzaubd/TlPiHCi25tMvppX9fbi5HtxdLGeWPZuGxcN9aNN5dt7W9b+7et/dt23Nt23Nt23Nt23O++HOfh3Zd75hcn28fss8l5Y9m4bFw31o1t47Yxvyn1ujYmY+uVN5aNy8Z1Y93YNm4bk+1jttrkzZs2b9q8iWwfs9Um68a2cduYbB+z1SanjfPGsvHmzZv3/t3v52cVsr1K2bhurBvbxm1jsr2Wa+O0cd6YbK+lbqwb28ZtY7K91mvjtHHeWDYeLg8m2+vo14NHv76ZbB+TyCbLxmXjurFubBu3jflNGZPIJm8u29pk9HGJbRt9/GaHRx+/eYx/RZ3Rx2+WjcvGdWPd2DZuGzs8cuDmzeub1zevb17fvL55Rw70mcQ+JqkNHhPNUh482lyCdWPbuG3s8P07XoLHMa3BZeO6sW5sG4/6Guzw/ds9OG2cN5aNy8bDa8G6sW3cNnZ4/L7fnDbOGw9XC64b68a2cdvY4dHfb04b541l481bNu/o+/2Zio9JZJPbxg6Pvn9z2jhzXOp2TOt2TOt2TO++EOfDfc7H+XCf84Pbxg7f53zUuc/5wXlj2bhsXDfWjW3jxnk+fvuC7w/73pw2zhvLxmVjXft7f8y3T1L2+6O9N6e1jzZ+126WjcvGY18sWDe2jUcbtmCHRx8ZdfLmzZs3b968eUcfuVk3to3bxhy7+yO/N9+u//qvf/jTX//1X/753//yr3/7p3//+5///Kd//M/1L/7tT//4P/7zT//vn//+57/9+5/+8W//8de//sOf/n///Nf/iD/0b//vn/8W//z3f/7767++0vfPf/vfr3++Cv6fv/z1z53+6x/429fHf/X1E9kvHuOv9w8E+irxutD7oUj6uMjrMeld4nVDTAGzHwrkw1bEG3FjI16PQj4scdqR16OPtmpYsw93pBx2JM/NaEJLWP3h79eP/772jhR/X5WD8RoMf7wBOgu0dn20Afbx37d+hRp/30S/sgHeL9vuQ1k/2gD/+O/X/twh/v7rkuFLG1BngVcH+mgD0ulkXOdza19rgj6J6j6PUvpwE+RwFHydRil/uAmnk7nELLCxEa97b/m4Vx7Oxtf48Dyb8utmgxqvvXpa4zXgNtPlNZaWthrlxxqHkzK+VTs242JP5OetaIdjepX/pl/+UuFwXsZiAeO08i9W0HVErit/XOLUmLXNGq+BuvZhY+ZDVL4ec8ywfT2v2E4M+Slt5XRQ53nxGuuigj4/tV5ji+yJ2Md7cqjxuq+Zp9YLaQ39qYSe+onPtHg9ncwfljglpq242H+7qj2u0Mrcjddzpo8rPN0N+3g3To1pV1rBe/lHJSSd4qLJiouSPiyR320KOZyar0eN6/R+XQqsGiX/WOL4Gzrjprl9vBH1dC2h63e4M5shUp7vSlyK3rtS04e7cji1cpsH9fVI6KMC5z7muk6LJB8e0/dz71RCYuW5O3D84x+Rkk59RPPqI1tj5J+2oxxOz9rmAXndx28Vrt84M5pzZvh2VH8+M8rpCqO0eYr20UFq6E/7cvpxt2t1lNfdC0f28VY8P8vPVR63SPuGFvF3W+TcW+rqLaofJuDph/H1wGJ22dczBP3wVK+H01SudRsi6YcfV31eI1/zXH89t80f1yhv/7rW+u6v66nCs5+Ux7vx8a/rsTVjJtbdmjV93Jr+7jWsXu9ewx4rPMvyY1NU9XXld2gKPd0f2brS6Auif3gNe6zR1hVoX9b64xr17RNc9d0T/FTh2Qn+eDc+PsHPranriDT/2hHpS8etttg24+cadvqVr2UN4th2s/jzvcnxDPV1h/R6ZP9xfJq8fWZYeffMOFV4dmY83o0vRp+va9ByXfpxa7b3W9Pfbk1/uzXbH9ya69x8tWb70k97iWW87hrl4yPSytv33u398Gxvh2d7Ozzb++F5bsz3Lxstz8u1YuYfXjb6ITtfz/bmZrwegX2cv55Pw7/btfz1Yfyehi5zWpvxeu5p+9Dl9RtNajRp+9pReTYi4noaEbnmVuSSyocl7O1e4u3dXnKq8KyXPN6Nj3vJsTHFG42pXypR143Ra0z8w9GMeBX1w9MiFoIfp8XrMecXa0h5UON8aj0abEvX2/F5LPHszIg5cW+O2MW8sfeG7GJq2IfpF0uAzcGdfQThpxY9PTt6NN523IzqLa/NSNdhM+Q7xlRiRtq7gyopvT3OdD5Dng2EpmR/6JGxNdpVzcrhyDwu4l8s0tI8Li/8cpH1YK7uDzp/r0gsi38HWS5fPFtTsTU0+2I5nK3yHcORn5Qxrj8u0/TlMivWXif3dqn+e13QMo+zNR+64OMi/tUiTNIwr18r8rqE247R1U5ljo0bXwO4z5hru7L6zWPU8naMtkve3y2zzT5p8vH5+/wH/cM7qnR6umAMwtiHP6Tny+ZHj3vS6ZnT09vLcxG5Zjq9bkXaochxQH89p85WPt6bcr19/Z1Oj54eXmedSjy8znq8Jx9fgn/SosqPeStfqiHJ1gBw2q7WfrPG9XYN4ZJAtnvV36uxLjxf5T6ucXrs9PSG4lzj0Q3FeV9KmaepFG3v1/jiOSZ5zZ+S0j4+tsdHNtulwGtk5OMOc9wQW4/i5JWsH2+Ivn9wzzW+4eBaYl8OHff0AGosV3j/6Kb61UZdE9OkHc4yTadBUMZAD8dWTxNG65pil153fh9fuJ62o6zBrrKdHr82x/F3bj0NK7I/N/n5d07r28NMSd+fCRVvhL35O6dvz4V6vieHDDq26LOxpnONh4NNlt/v+uez49lI0fvPotL7D6N+Y08+zg6zNy+Rz122FLr9do38S5e1tx/mp/b20/xPdiUx2eR0ld3enxNw3pBY+nyc5+nKhw0p77dpfbtNjyW+oTlqvFR1N0c5NUf7I8/0WtaPU33Fz8eb4dfpR3L9WG8vh+Trp35/ejD1cAjxuBVrTGf/qf51K863+SLc5tfrw+04j1xUxgp8f9j3W0XaxfDHNmb+Oy2yxtyKn46L/aEl+jAZA0Itfbwr9h1Hxr7jyNg3HJljt9PtR7/51wZQNK290WTtq0XWrdhrm8oXi5R126D1+uruyBrw09fI1IdFYtbiez8Q+fQo4tkPxLnEN/xAaF3boZoOzZGOc6W4unxxbR+crDkdrlBV14QruzQftuQQaCVzHZL945kH+Ti2HB+FH78SV/pw3CAfX0t5dGeZk54OTVl9Rq/rw7HgnM45so1Me5YPx8nPZVJhOlwqaocy5xPlqpwo263/b/Rgk/VmoEk5nLI5vT2im08vQD195yfLu/dDxxIP3/p5vCeH137OLfpoRPdY4+GI7mc1rrdrPBuNzXI9vOOu+Yvb8Whk+ZPteDRw+HxfDjWO+1LWE155xfTH21H/6O14NDr9vMYX+8vD0el8GgN9Ojp93pBno9P59FTp6Ul2rvENB/fZ6HQ+v0f0bHT6kw15NDqdi759DVHs/dHp43Y8G53+9ApRtyvE8tEVYr2+4TKzHkcR1oDsK4XswyvV0wlia4LXCz8+Uev70/pzfXss9Vji4bVDfX9m/ydX3Ot3Lrl/HEG1vR8fx0tubrpfmA6X3KfJkExbsP324beKKNO71Jp8sUhbNzLaTL58B7FPAXT98h3EWhGk303UQ5lju6xnIWolf7Vxueltlx6K1PdT8XDa5/ji07hkTlf7UtfJaU3hy+nwi2fX2z8059elHv7Q2PV+kx4P7RpKfB3l/MVTfnyNeQ6+lS/fNMdnIOaVhH2558SqfOuC5NBzrtOUrrwG8RnDl98akfStUa76pWHN1190iuSPhjXz6TmR8Kj7dYNkXynx7Crgs7Hzh+0h39Ee5f2x4mORhy1ynNjJK2X+w6/nb80O9fVQ9FXkME/1tIDIb8wOPZXR+DrD/P38cBz/WIIBL/VsXyuxXvlWrx8fmaf37/LVed6+3gyrXj5+oeD4dq/LiqF9X34Zn/X3Z6lk/4b1evz9BXv8/RV7/P1ZKucWfTZL5Vzj2SwVufLbwwif1Hh2H+Dvz3SR6+0FJ44lnp4d7890kevd5//nXr+GZM39414vp/h5eNctx2GIZ71eTs+pHh7X9P7iVI/3xA57cr191y3p/Smln2zHo+dtclqX79ktjJyW1Xt6y33cjme3MMfmeHhXeK7x7K5QjmvzPWvSXN6/Kzxux7MmPa8HYvPKpaV2WKnwuCLTo/fAz8vaPbpukezvJ9jpac7DBDuVeJhgj/fEvtagzy5bjiUeXrWcn0o9u2r5hidb8v4PUz2O0T18f/K8Mt3T9x4/qfLwtcfyDW89Pq/hX6zx7J3H8i2vPJ7b9ekbj8dteXymfLJi38P3Hc9VvmWPHp+1n1R5eta2bzhr2zecte0bztr2HWftJ2fKwxdsn68r+/GVVX132v/5vaU1be/1kHhb2Sb9vBXnV9uYoJI+epp6LvFoFFXOry09GTM8Noaua11p2xDqL41xvLx7NBtT9JTPj2Zjnks8m41Z3r+pOy0sq3nNbt0nyf+0sOyxwrq00+2d618qHJ8FXSuP6zbLPv9WU2SaYpu1+HMNOT6U8ryOa+pfuPzCGVqu9cpA+XH6c3leI63lT15d5uM1teT02tPDGYti76+UJvb2Wj/HEg/vHh7vyeHu4dyij2YsHms8nLH4WY3r7RrPZixKe7qYVM1f3I5HMxY/2Y5n91OP9+VQ47gvz2YsSmt/9HY8mrH4vMYX+8vDGYtyWtbv6YzF84Y8m7EoXt4/yc41vuHgPpuxKJ+8+/RoxuInG/JoxqK4vztkWK7rG4YM3d8dMjxeBdV1HbW/5vdb11G+KpSPK7T3n6efazx7nC61fs/IQ333cfq5xKPH6Z+UePI4/ZNPLzy9Ga1/9ODH43PkG6ZcSPmec6S8f46U98+R8vY5cnxYuT4ellre72t/+vhX8ndvr48l0usabN0BvdJ5G27IP3+tJL073FA+eaXmwXBDOT8I+o72sHWWvn4l8qE9jktRrgdKL2wf7szxBubpV2ROL/g++ozMscTTAQN7e8Tg2BpPhwzOTfpszKCcnqI8HTM4n2bbqnMv3r+a9/NpJse5vcaCtm0/OvJTkfc/z3PcjngNeZTIW4b8uh2nInWdJrnWQ5Fzw5Z1n/vifSzll4Z9e/i0yNvDp6WkPzbPfmiPHz6t+HN7nMuwUsCL26FZTxcSWdeHT7PK3gHbV4vYNxQp+atF1mr6+XXbeihymphy6RrcuXTvwz+fKafj02xdKrYmHxc5vfnU1vTNVtIXS6yLzVbtiyXWS+1te4HrqyX00BbHo5LXJa/kVg/bcfzC1voJL3I6KsdvhVUuJTTVL54fntYvnx8P7ml3fG1J8da+VuQ1DDl/yEWbv70l9br8i4c4rQiQ/aWJX4qcVvcTWVvyGs48HeKnOWKHMDo9Xnr03PG8GcbXb9t1SOfjV6bqSqLXLc42/v9zDTuOEfPTuU8H/Wl4Rk8rufu2DPu+ztfPNU69Jl2FSQzXlvC/9SvR1lVnbj9c1/xWkfX08IX6cZHzrzgnyYtPF0enTzX5eqKRrm1N+GTldzalrXM+/ZAmv27K6T6cKySVfLhZs+Pry6wAnVL7YhFdnaf8MG79W0WMNTpfP2JfK1LTyvqaTjf0xy0paw2Vsk9F/L0tickBY0t++LzObx1iWd1HSzoUOT7t0fVzXvfx2t8rYrp+dUzbV4s4RfyrRXSF2w9zTX+vyLYS4v7hjt+7MajX+hXt9+j65TK8ofbi9tUyeXvqK3roQadVAB+OmnzyhasnoybHEg/nWRzbw/gBq+0UkH6c9tkqE+iafbTqXTl+deDZMMMn27G9x+hX+rDI6YFHWvMTPH18X34skdeueM7tS/fltfm2VIV+td/oxWCU7t80+rlMvfK7wx3nEo+GO+r19humv9Me6Y1mrZQ59ZtzmbRuqV98+EGvV3v/6LS3j066/uCj80N7VPv60Slbma/+WGhh0ERr+fiqoJ7eR372Y3Es8ezH4lziG34sXree9B3zfGiP9u6jj2OJV0Kvz3C9+MNVVj8pYpWZJPbhKqufFeEX58Vfy/rXg0rOV5fri+erXdsOXYcx2Hp85ep7yuS8pmFkufaxvvLFIil/sYgwbCFeD0Xau1cn5+0oaT2/KOX64s7UdaOSq6avFXkdj/VZ6euHccfy9Pn064/yfuAPq+D+9HVrOQ0UPPyG+6nG64drjRea7Cfr9bxIudIauUylfbFIWiOXr35aDkXs7d/yY4lnv+Xy9sSBc2vkFdEl/3AL+lNrHB9w+frwbfGshyKn9/lZr3n7iuVP42KfbIayGT+MU/zWvnBjf+X25SLrJdKrfrlV13pc9fVw6Ytnu6x5Ia/HGIcipyH2bynydCJErdfbV2mnEg+v0o4lHl2lnVvj4USIT5r02USIepz093AixPFXZo1j/TBv4OdfmVMJ5RVf++EbgD/9UNXjZd6qsT33+OV3qr79mZWqb39m5dQWVteltx+as56eaOWL6/ck+8y0n34djm9c1TUhpO0n2K9Fytu/lVre/q1Uffu38twauj0Wt0NrvD0KcB2fiK1HlT/8QP18dtj1dk85vXT1sKecPlb1fk8hibM2+1LwsGBtdtOvlJBL1tmZJX+pRF43c/LDA7BfDqq9f0Te/lrFucTDu4XjifG0xmm9rMTIbP7hk0g/Pjqu7TQcytPnbVaA2W9sRma69KvDf7wZxyK+psLkq12HffmGH/pzkbp9fqe27Usi8vPF4LlM25Z4btsyT79dhsuofZbQ75Zp26rV2+3HL2VOH0hiyvEeJK/frucl+iKk68z/YW2C3zpGnrbdyV9uXJbzevH+wsBvldGLQ63Xdtv+a+P+8WV+WDBJTkfpVCQL17v1+mIRWY+h8/4m5y9FTsHwGnlb410lfZwuenoVK29TbCjx87pvx5e5Ht7bnYs8vCX6ZEue3RLpVb4hKY+HpnCmVb8Oh+Y09aKwFucPn8KSn4ucXht8tqKeXsdbzUdvlOt1uLd69kb5scSzN8qf74kd9uTUos9W1NP0/pvLn2zHoxX19P0vWOl3LKev37Gcvn7Hcvr6Hcvp63d81UvzcX3jp1/1+qzMw6X9z2UefxzsszIPvxCg3/GFAP2OLwTo+18IOHbkh2tBnms8WwtS5e0vBKh8wxcCjtvxsEm/4wsBn5yrT78Q8EmZp18I+KzMwy8EfHZFfjF/44es/elSWuXtkaxziUfjejHI8weWeDg0+Mm9Eh8J0H1p/l/uTvT9L2MfRymtrqw3Tfq1gV/TlYtmtX1x9DjxAo/k8sXx0ofHt/2xQ7+6fmya1o+/RanH95m+o8jjW62a332Mdizx7DHaucSjx2jn1nh6z1i/456x2jfcMx4f2tT1ID2rnM4Qf/92T6/3b/dOqwY+vN07lXh4u/d4Tw63e8cWfXi7p+8v/PvJdjy73Tu+lPXsCu8UyY9v905FHt/uHbfk6e3escjT271jkae3eybfcrv3SZmnt3vHMs9v9z4p8/R273yoH97unYs8vN079aCH9yanjvz0du9Y4+Ht3vHx1rMwOL1+9Ph277QdD5v0fGgf3u6dz9XHt3vnMo9v9z4p8/B273yZ9WiJs0+u1J6scXY9fGJymIeqxzUFH01aUH97CWH1t5cQPpd4dpt3bM+2rgT0h1urn9vzdMnKZxV61G9F2k9FjqMA60tfkvcFcH6riKy7iR9u8n6viK3FvMR/WGP6N4qUaxUpV/UPi9j772F9sh3rNHuF42k7ypsP9o4Vnt5tnos8vEn7ZEue3aTZ8dnPw5u0c7cp24sX6eOT1Y7fQvqOIq9QXasJ1B8mTf5OEWW9adWvFqnrRya/Ls8ORcq74Wynofhn4Xwu8SycP2lTJsTadWrT4xThZ59Bt9PbRttq4nL9MLHspy3JpwHSvFawfPXC/OFTaDsOXj+7ebX89vWqnRYXfHqjZrl8x43auczjO6zPTpSLOVme6ocnyidn2zZpqH70q2X5O07Z/PZw7flcezYEZvL+NwTt/U81HUs8GwJ7vicfD4F90nsfDYHFt3XeHAI7d9+HY0/HIk/Hns5b8nDs6Vzk4djTZ2n0cLznszR6OFDzSbs8G6j5pMizgZrjr8WzUYXjaf9woOZc49lAjZW3P3tpx7XjHg7UWGnvN6m8P1Dzybn6dKDmkzJPB2o+K/P0ufzxtbJHAzWfvJn2ZKDmk1eXG/MWf1jZ73fef1beCFeXLxZpa/247Ff9WpHXVe/2usxhd04/wk/fxD4Webbk+bnEoyXPPynxZMnz83Gx9Tue7ctvyP9QpHy1SKaIfHxc7P03suz9SQpm1x9a4uE8h3OD6n+76sdvHpXt7te/miD7lny5SFujLC/8chFuXI9Fjgu7PMv289owjz40cl7xav1+v25gv7ho1hrJf+GHq6YfV0R79s2V86Jqzz66clzBb7VFNfnqCn4tryLttFzkuciajvP6wf3qMoCc6rXZV5dG5FR/1fvygoRrtOiFX24TFj/wLy/mWVkQoqp/QxH74hKaRdcQeNkXQvq1yOn9CTrOKxw/fvPOTs+eCrcB5cfbgN/bkry2pH28JZ8UYaKiST7szukzrWXdB7xuXK5DkdPPd+XTj9tENLl+4wA3Pv14WgawnV5eenqA25XeP8CfbcmjA/xJkWcHuJ2e+zw9wO2qf+gBrtfFaiyHlQTbaYp+zWv0quZtnOanwfh2nSfCcP+8P7Vtv7Mz67FevezjYGynhxxPdyalP3hnmGb8wi+mfJW16tfr9km+WCSzJbl+S5GvLh7N/IAfj83vFVkLK77w6w2rNGz+apFMkXL4+Tx/3Wa9W533o/Pzh2na+1/Iau9/IaudxtC+ocTDdUCPDSoscid2HRr0dGifLPt13ozC7WbxdtiM9n6YZX8/zM5fT8p8uj7XD3fmkyLru6m5ajsUOS2l+PQ7TtLeHfM6l3g05vVJiSdjXudvnz38Tqi9e896HR9G8Jmw68OPg7TTkoFtfUaq+ccPElo5Lk+1PhyR96VUf36QcBqpYnm8lL7SFFuB/KUCz96AeXsZubcXkXv7ccH1B56QhUXbiqWPP0p6fIFnWwN6n24jz7/Bqax2ovvEod8o0Srf3apf2wpfiwPn60pfKZEvsv+HR1q/sRXbl2F+fLj2GyWYFfrD+j6/USI1nqr517ZCeFpZ9rvY3yixfTKvbpNifi7RTrPsS2H0Z7+4eL60VxI+uiD2tcYoFxN1c3q7Pb9YwnhWarbPr60/tqceh/WfLNB87Ge8u+w/zHmsz3dk3Rwl338Ff9mRtxdba/r2YmvnEu/PJE9rK35au/OnxjitBZjUrjXF6DVy9dFjgc+KrC/ZpD675sMicrpqvVh4u5bD7pye5zPp6hXrH6801U4fPHo8mHfcnVa26Zty2J3j14PX3WL1LUtfp8zzIkoGaZGvFuGDAKr7k46fi7S3L1s+246L7ZDDdpxfRyGKbL+7+XkqSzu+QNWcKelpn8giv7FDRsOaHY7OaREDudZDCrm26V/lp7ePY7G8DxOJGTWethmtvxY5TbFX3ip5cb0OTXvclu1x53ZB9eu2fMNTl3PTshjla3TxsCWeztfK2+xaO5XJf3Awvca+1udu83X42fDjOIXy6sHpKYP/0TnbD8ranT2Yftmd4wI8mfvz7csCv+5O+47dOT4VW/PKre6PYH+KA7+OM1LWnKctDFL+qUI6ju2tT9P98CGa4j8VOc69Wnkv1zbK+HORc4Mk53nW/rHLXxrk+MmVtH1EZp/P/XObnNYBWBlb94HsX0ro+zntp0dRT3Paj+9TPc7p8w49TEdP13eko5+eSD3tf8eD3NZF6A9TMX4+yEnez0ZP5Y/emcaStPsSo7/sjb4fjZ7sO/amHE9Z56LttDt+7IG6eqAfiuTrG45w/o7T9bg7iY/z5P3zdr/sjnzDIc7lj/7103W/Y5YPYX96LiW+HkyVa7vA+SVM8vFVUd6oKNsNrf9c4/QcRtYsih+W+M1efypyeg2QT3Hnsr88X37aktOifE/fvflkS8oabyj7cNgvW3K+hH00PcVPn8apdU3qrnUv8hvHpjA1VPdPrf98bOQbLmDPW6JMp9ZtTOvXLTkNFLD6eL32Cxx93m8Kn60ueZuN8Uu/kW+45zo9m7CLZxP7B8eejxMWXbMOipWPxwn99FmrZ+OEXuTdccJziWfjhJ+Nz7E4vX78JUYv+v4g37HIs7kLxxu+p8f2PE7oLGzg+evjhM+m2p2LPJtq56dVXp5OtfN6upN+NNXu+Pv9GpHeHkHpfs7/3ujPdoezvdr1u6M/z45O8+84Ou07jo6/fXTOo1A/vm3uXx6Fetaw5yIPG/a41unThj1+oepRwz6/Iz+cr58UeTbk6fodN1qfFHl2jXYu8vAAn96LenyAT79+Dw/weYTiac/5bITiWcOeizxt2PodDavv95zTmJqyrkD7+O7Vjp+4XG/wFtnX5v15qPI4ZqM8fNTDstqfjdk8PLzlGw5v+47rgSZ/6OH1taCAb69W/3J4T89fairMONvnLvxyeI+fuXgyjfCzIayHB/c7QvF4TfL04J4+V/U0FE/jAX7xknc99N7TdUC51peqStrXPP/58B7H45723vwd4Zy/I5xdv+MA2x96gIXlL2R/0PDrAT5Nw2prXlvxfQWMXw6wvN1/83eEc/6GcE7xnOfd4/uq8v5163GQk5cz0v4awE+DnOk6PQIqZfuC+DbwZL9Ro65zZF/l6DdrGK/i6hdr6FrE/YdXGr5co361xmoP/XJ76GoP/XJ72NoX+3J77DW+2h7MjbUvt4et9rAvt0db+9K+3B57ja+2R1tTW5t9eTvWNy9b++p2xCyE+773+oYaX96ONS3UDxl0fETydGWx83OWh0sUpus0EG9pHRrL++Dkr1VOi52vVTjKDxO562/szsMFwT4p8my1tXORh6utffLYaD37rTXrR4+NjiV4eaTuqzf/Von1zenXY+T8YYlvGDxLl3zDGMCrytuDAK8ax+lXrDmVt29l/jdVji8CrnaV66s13P6bH+/f3Jt9xfSt1/xmFVt5lO2wP+dnizUxp3p7iPW7TzkfPrKt33HKlm85Zcv741bnh7aVx8fbS6c/N+xrQ06rV6Q1DVnSPlPv5+vv8vSjQdtTufTzD+h59bl1f7W//f5bJda7vLq9WvibJa71E/zhVnzyHJxVfa4fLvN+3ozzQitrJfn9Db83ivjHT+QfTg2wKx3OsuP3rQqT3cu+XNIvu3N6EfdaC+Jq2uel/lLkdKqmXNcNZ5LLv6VMyh837vkbCjTLaYbP6d73Wr/l5aofz+dM1/ETdevapm1jGz9Pq3nVKI/ufj19eLX3qlHfvWL8ZDtYnmSfSfZrDfuOlNe3lwZ61fDvuDCx6/0Lk2ONhxcmx73JTCWTK3+1yuMLk2PHaQz7Xn7oOKenWLLutsq2O7+MXh2fYa2bk7K/Qqe/N+Xp4fXRN0w0eO2Nf0fPaW8/G3j+9lv5+O2314ac3tNqrEnftmU5fl424fimysNnA5+9qfJwysO3XAI3/ZZD/PbTgeM7M8/G5D97Y+Zhs7bvaNbT3JjnzXp6mvUNPUeECeo/PM7+ZXrbaY7cxaD8pfnQ/U4n7PdUebaQzCc1Hq0k81mNJ+frJzflsqYNZtlndP/mAMGz3+FPhpF4Lr5/kvi3RqJYeHR/IVd+Z3Dv2ZLwnxR59smA88tmr9/s2W9y+/iNtZSODwlWHm3vVf3YHqeLNJZEqT9chj8u8OiIXO8OLh4XFeCbUql+fHV3LrHuWtP+nvfvlHh43Z1Ok3oeXnefazy67n76/cTDaOD5m1QXg03ypRIPL9qPO6JrK7J9rcTD+Lzez87TZL5r+wKUfumg9sGLNQCxXZj+Vgm+z5fa17ZiG8EQ/9pWVD5/UbfJ9L9VQvlGUfOv7QhrkEj+2o4Ir5BK/dqO6DrBX08Ov7YVZizi5F87O5lVlTx/qYSt8SQr+pUCvm7e9nldvwbn8RM+by+/xHJBnr+2G6uHudU32+FrBV4DletgZt0Xm3u+alJe692lfX2DL5fQL5WQtfjTC9vXSihpZfKlEnWtT/9Kq6+1hfBFtfLD+oFfLPG1g1rWY4rXkHz6WgnSqqh+sQQ78sMqsL9RYt3xvn4Hv3ZQi/Py//WlrSjr2URpX2oJzqsfP1D7071hOr0+lTK/QHm/W26Pt2IV+OGn+Dd2Yy1kqOVLDVnXeyz1hwWanhdg8WqXrxW4/pvnB18q8MNrvb/TiGuRqq8FnaZ1Syz+5hZ89TA+mehyLPDkBevjfeiTeTLXu8Mbx9VuXyOg+8cV68evvb+uxU8r9ZW1JqbX6+MvxL2qHB+bvLl84uu22rgz//Cj4K+Hs6cvGj75rvhnrcqP8NXk47lY5zKvXxzuf4p9tczFYg+vkZ1UvlpGlVNl/5b2b5YxvsR77e9Z/24Z5w61Xe2rJ66tARC37RfpvzlxH1fxL1dxLsa9frFKnwXKcbrax3U+O4e3IYAm+asN7JV5py19tWm22wxvp8N0fFb2uGnOdR4O159rPBuu/6TGh8P1//P1f/75X/7y93/667/+yz//+1/+9W//9vp7/9VL/f0v//y//vrn+//+n//4279s//Xf////b/6X//X3v/z1r3/5v//0//7+r//y5//9H3//c6/U/9ufrvt//kfrL6X5q03/5z/8Kb3+v+vr0sjV+v+X1/9/3WLX3P9b/8OvVC3/8Pof7/8i/vT1und9/Y//z//qm/v/AQ=="
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "1602191554767750373": {
            "error_kind": "string",
            "string": "Function _borrow can only be called internally"
          },
          "1768177060348318876": {
            "error_kind": "string",
            "string": "Function get_asset can only be called statically"
          },
          "2493037461250685601": {
            "error_kind": "string",
            "string": "Function get_position can only be called statically"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "10435052277855889085": {
            "error_kind": "string",
            "string": "Function _withdraw can only be called internally"
          },
          "10492081608786484886": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "11699106313324679151": {
            "error_kind": "string",
            "string": "Function get_assets can only be called statically"
          },
          "13135008234568508716": {
            "error_kind": "string",
            "string": "Function _repay can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "16022896159229267359": {
            "error_kind": "string",
            "string": "Function _deposit can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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ExItChITLQ4PEwAiEwITLQ4QEwAiEwITLQ4JEwAiEwITLQ4LEy0LEQsAIgsCCy0OCxEnAhAEEi0IABItCggTLQoKFC0KDRUtCg4WLQoGFy0KAxguCIBNABktChEaLgiARQAbLgiARgAcLgiARQAdLgiARgAeAAgAEAAlAAA1rC0CAAAtChMLLQoUDwsiAAuARgAQJAIAEAAACzAnAhEEADwGEQEeAgALACcCEQQDJwITBAMAKhETEi0IARAACAESAScDEAQBACIQAhItDhESACISAhItDhESJwISBAMAKhASES0KERItDgwSACISAhItDgkSACISAhItDgYSLQsQBgAiBgIGLQ4GECkCAAYEX/G0qicCEQQSLQgAEi0KCBMtCgoULQoNFS0KDhYtCgsXLQoGGC4IgEQAGS0KEBouCIBFABsuCIBGABwuCIBFAB0uCIBGAB4ACAARACUAADWsLQIAAC0KEwktChQMCyIACYBGAAYkAgAGAAAMECcCCAQAPAYIAQAiAgIJLQsJCCcCCgQCACoJCgY7DgAIAAYjAAAMLikCAAYAX/G0qgoqAQYILQsCBgAiBgIGLQ4GAicCCQQAJwILBAMAKgkLCi0IAQYACAEKAScDBgQBACIGAgotDgkKACIKAgotDgkKJwIKBAMAKgYKCScCCgQAJwIMBAMAKgoMCy0IAQkACAELAScDCQQBACIJAgstDgoLACILAgstDgoLJwILBAMAKgkLCikCAAoEBbTXqycCCwAEJAIACAAADNYjAAAP3C0IAQgnAgwEBAAIAQwBJwMIBAEAIggCDB8wgESASgAMLQgBDAAAAQIBLQ4IDC0IAQgAAAECAS4MgEYACCcCDgQPLQgADy0KDBAtCggRAAgADgAlAAA23C0CAAAtChANASIADYBKAA8tCw8OJwIPBBAtCAAQLQoMES0KCBIACAAPACUAADbcLQIAAC0KEQ0BIgANgEoAEC0LEA8cCg8QBhwKEA0AHAoNDwYnAhAEES0IABEtCgwSLQoIEwAIABAAJQAANtwtAgAALQoSDQEiAA2ASgAMLQsMCC0IAQwAAAECAS4MgEUADC0IAQ0AAAECAS4MgEgADS0IARAAAAECAScCEQDvLQ4REC0IAREAAAECAScCEgDwLQ4SEScCEgQTLQgAEy0KDBQtCg0VLQoQFi0KERcACAASACUA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",
      "debug_symbols": "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"
    },
    {
      "name": "repay_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "from",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "on_behalf_of",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "stable_coin",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4456244908619624852": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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ARLQ96I69jg1+yy6OmYbV59FF1iABKzABmSgt8NIJ58Zt9qhY4879thzfiEDvX3FUYEdaImG3jTYDL1p6E1Dbxp609CbnvNzGzznF1qgr/IWWGIbeOb8xApMGyPnGTnPyHlGzjNynpHzXPLY4ULACmxAzm0oAlQgbMh5Rs4zcp6R84ycZ+Q8U/Ybz5yfqMAOzH7jmfMT0ZLIeUbOM3KekfOMnGfkPCPnGTnPDf3W0JINLdnQkg0tOXNeHQXotu7YgZY4c37isDXfBs/5hRXYgAwUoAI7cNiab6R/gnqh57z/gl8peBb6FMLqn4D2KYSBCuxA9JCihxQ9pDjWFcf6rAQTcfQpekjRQ4oeUvRQx9GHqsEdx0PH8dBxPHh9GBMOqk8sDLRErw/N28HrQ/Mt8/qwsAIbkIECVGAHWqDM0YPqWIENyEABKrADLXGOHkwsQNgKbAW2AluBrcBWYCuwEWwEG8FGsBFsBBvBRrARbARbha3CVmHDmKNU2CpsFbYKW4WtwtZga7A12BpsDbYGW4OtwdZga7AxbAwbw8awMWwMG8PGsDFsDJvAJrAJbAKbwCawCWwCm8AmsClsCpvCprApbAqbwqawKWwKW4etw9Zh67B12DpsHbYOW4etw2awGWwGm8FmsBlsBpvBZrBZ2uasyoUFSMAKbEAGClCBHQgbaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopYoaomilihqiaKWKGqJopZ01JKOWtJRSzpqiU+7rP7w3KddBgpQgR1oiX6HsrAACViBsBXYCmwFtgJbgY1gI9gINoJt1pLLkYFu644K7EBL9DuUhQVIwGFjj+t3KAsZOGxjJlT1yZiBHei2MW7kkzEDC9D7zX931pKJDchAASqwAy1x1pKJBehP15sjA30vyFGBHWiJfi+ysAAJ6G3mcf0OZSED3caOCuxAt/nx63coCwvQ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",
      "verification_key": "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"
    },
    {
      "name": "repay_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "owner",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "stable_coin",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgUEBCcCBgQAHwoABQAGgEQdAIBEgEQGLgiARAABLgiARQACLgiARgADLgiARwAEJQAAAF4lAAAAaCgCAAEEgEgnAgIEADsOAAIAASkAgEME/////yYlAAADAR4CAAUAHgIABgAzKgAFAAYABycCBQEBJAIABwAAAJElAAADKh4CAAUBHAoBBgApAgABAMYRsMUnAggEBCcCCgQDACoICgktCAEHAAgBCQEnAwcEAQAiBwIJLQ4ICQAiCQIJLQ4ICScCCQQDACoHCQgtCggJLQ4BCQAiCQIJLQ4FCQAiCQIJLQ4GCQAiCQIJLQ4CCScCAQQEACIHAggtCwgFJwIJBAIAKggJAjkDoIBDgEMABAAFAAIgAgACIQIABScCBwQALQgBCQAiCQIMLQsMCycCDQQCACoMDQoiOgAFAAcACi0KBQsnAg0EAwAqCw0MAAgBDAEnAwkEAQAiCQINLQ4LDQAiDQINLQ4LDS0KCwgGIggCCCQCAAIAAAG6IwAAAZEtCwkCACICAgItDgIJACIJAgotCwoFJwILBAIAKgoLAjwOBQIjAAABugoqCAcCJAIAAgAAAdAnAgUEADwGBQEeAgACACkCAAUAlEiUnCcCCQQEJwILBAMAKgkLCi0IAQgACAEKAScDCAQBACIIAgotDgkKACIKAgotDgkKJwIKBAMAKggKCS0KCQotDgUKACIKAgotDgMKACIKAgotDgYKACIKAgotDgQKACIIAgUtCwUEJwIGBAIAKgUGAzkDoIBDgEMAAgAEAAMgAgABIQIAAi0IAQQAIgQCCC0LCAYnAgkEAgAqCAkFIjoAAgAHAAUtCgIGJwIJBAMAKgYJCAAIAQgBJwMEBAEAIgQCCS0OBgkAIgkCCS0OBgktCgYDBiIDAgMkAgABAAAC6iMAAALBLQsEAQAiAQIBLQ4BBAAiBAIFLQsFAicCBgQCACoFBgE8DgIBIwAAAuoKKgMHASQCAAEAAAMAJwICBAA8BgIBJigAgAQEeAANAAAAgASAAyQAgAMAAAMpKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEm",
      "debug_symbols": "tZjRbtswDEX/xc95kERSlPorQ1GkrTsECNIiSwYMRf59pCMqTgGpQea9NMdMdUVK1LXjz+F1fD7+fNrs3t5/DQ8/Pofn/Wa73fx82r6/rA+b951EPwenf7zLwwOuBu9xeGD9lGvvBAILeAEIBdAZkIAOIo1EBY1kgYgGuQBbhC2SwCAVyBbJJRJcMOAC3hvEAsEigQzKFAHQwAQRDEyQbAoSwSB1hegNLMLOgAoki2jOARREMNBqAKfDWSEW8M6ADHKBgAYWQRuONpwsQhaJFokWYZuCbQo2QV1nBZwSiwpUYEpsAk0jK+QCAQxSAbAIyoqBV+ACuu8TRGcggoAKIgg6O6cCms8ZLJItomuoQLrvZ7CIt4ju+wS672egAuAMaqTMTggGZVIiEySbIppgtCl0VSErkEEukNCgRKLmjF5BhqO0RNTlRVJAg1xAl/cMqQBYRI/VBGTDySLRItEibBG2KdimSCaY+Ays+46okAtMiU2gaUjJPCU2ARfQg38Gi2hnopTM2plnyAV03zGfTqvBTObpsB9H9ZiZ64gXfaz34+4wPOyO2+1q+L3eHqd/+vWx3k2fh/VevhUHGnev8imCb5vtqHRaXUa79lAPBKEM93JQuEqI2V2J+I6IC1XDYZhJxCuJ0JHgnKJpcM5URRiuNKCtAQFcKhrCAVsa3VJytjTE3pul0AKlxP9dCqW6K6m9K6ktwZxMghM2k8idQkAM1QoBxH8txId2IZ02z7F2aI54OSf0JYleh+bZSck0E/laSb9FmS77mpsivVqIsdYSfLOWXovKnbAe+oSzFaW7sphJfM2Cu7ZRF8M7cFBF4nUavtOi8ujlwESCOHRzW/oiVI+9PKw0uzR0VkQ6vTaIcI53ZQIuVPMA1+6yEHqZUK6HDqMPd2ZSD78H7YxWJtjLJEa8ZJLSnZnEPMukubCh56jIDDWT5O/cHZ8ud8vQWZOOCMijmG2xcPLNTLpnRx586tmJMbbODvRu/hzr0RGrrxJ4u69ysB7JjKnlArDInX+JW3+3Fh9rLbnpq0ALOBrEBRztG5HbHA3SAo7WzeRWR0O3gKN9k8ltjoZhAUf7JpPbHA1xAUfrZ3Kjo2FcwNH6Z+dGR8N0n6M9ytX6ZbO/erFzUq39Zv28Hcvl23H3Mvv28OfDvrEXQx/795fx9bgfVWn+dkh+snn5fecJH/XlkF4SySU/nnT6vw=="
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZxc11UnfKu7utUltbq0WpIlSyVLsmRb3pfstmXJi7xJlrwkJomRbWE7si3bkmzJsuOyNjteyOIMQ1gGCIQESMgwBCb5PoaBBGY+CB4ywBASkskCfIGZQBySECYTJpMn1en617/+79ZbTrfKcd/fT+pX757zP+eee+6563uvEo6lOa2/u/bdd/ut9z9490Pbdm+/ddfu7/+f3K20cquhYKr0FPNrq47ljLQoBoBz8Pv/GiGboBGSmI+/+c4RBszFHwZHWjzF5B8rf8JTsPxhuPX3nc02P+piuNO+/28GXN9C8svYr4z+cyI6W92sb7bpGyFTGveLDU3B+81dn/7FTz7367/3gd3vf9+Pzf7szPfMWDv98cOHv7b4H5b8xIuHf954L2u2daqGfHWapMubhfjHdb+iWYh/wPivbLZvNuzion8/eMtdv/adnTOuOPjhhz/7mev2zFyy7ePLnnrfLb//zmV/d+sR492oeP/22Z98vP7hd/1s4/QXvjV8xdu/eus3Ng698rMvPLroEwe++3cvPm+8VyneP7nlu5//SP35R/Y+97H9r1wzd9sHn//01//Hf/7kr9a/8aUPPfDpC4z36ma7zEXiwDXNQvyzjP/aZujW/Ylf+MDn1z33wtl/9d3pT1+77dDe857505v//pGF71/1N2/50JIPzjbe6xTvl3evf+fuBfde+Pcjf/zcOT+3+KQvfPP9H/nKP+3b/sqvfuVvf3P5N4x3k+LtkYx3c7Obd+G5q191/49/at7n1pz8l5f8zgfPfPeib6587ec+euXPvfidP/hn4L1e8KakCsvd0mxn5LD1uH9ubRbirxr/Dc1C/IPGf2OzzV8J+X3tpmYh/nH5NzcL8Y/b7/XNNn+O8teN/w3N9s1GyJSGjPeWpuStHDx517+uPVe59uMHzvjI6PSP/926n7l0/QufPPT0svoHf8Z4f0jwnvba2ovve/qth8MX3/8/f/SfTvutS86YvXTd7DP/7Cf/fPF9D/7QoheN940t3pxlXmL8b2q2+Un3aDL+NzcLyR/nv7XZ5s8hf9znfrjZvtkImdK4v2xrtmXn0H28zm9rFuIfNv7bm4X4pxn/Hc1C/CPGv71ZiL9m/D/SLMQ/3fjvbBbin2H8dzUL8Y8a/93NQvwzjf8tzUL8Y8a/o9nmzxHvGsZ/T7MQ/xnGf2+zEP/Zxn9fsxD/Oca/s9nmz2G/S4z//mYh+euM/4FmIf7LjP/BZiH+y41/V7MQ/3XGv7tZiP9W49/TLMS/zfgfahbiv834H24W4r/d+Pc2C/HfYfz7moX4txv/I81C/D9i/PubhfjvNP5Hm4X47zL+x5qF+O82/rc2C/HvMP7Hm4X47zH+ZrMQ/73G/0SzEP99xn+gWYh/p/EfbBbiv9/4DzUL8T9o/Iebhfh3Gf+RZiH+3cb/ZLMQ/x7jf6pZiP8h439bsxD/XuN/ulmIf5/xP9MsxL/f+J9tFuJ/zPifa7ZvNkKm9G7j/dFmbt5/Zbxvb+bm/f+M9x3N3Lx/MD0cW+PbsejYjWTdb2Urc8/uu++5e/e+dbt2bX9w9/qd996/bffdt92zfdOD226/Z/tN2x/cdffO+xiwQr9tPY7vJ3Lmd8q5YvvuS+/ZefuO6/bce9v2BysEWhECbHAUBPjcLvAb7r53+/fXk++9nyEGUqCrKdCLuqDX77xv9/etsnvdHXc8uH3XrjQdKyGeEvDZXeAtS6dpVwx0/V3b7r5v4x0MOpQR1JZyh4E+RzPbPNqin0byERuX63MMgU9SnsI1gPg10iWnvEqF8Ewel8/czMpeE7rURR7buCbk1IScusjjYV0ZrEOOWI84Yh1wxDrkiNV0xHrMEesJR6z9jlg7HLE8be/Zhg73KdYeRyxPn/C0vad/7XXE8mzbnj7xsCOWZ4x+yhGrX/tHm06NhO7xQZEjBDOK8Q9aWabjTaGT4dtYB8dGlZS/hsV5JqtGWDl1r8R0R/24HqaDPCxjGtb0nFgjIq9IndQi5WL8NHo1XjX60Qg+0o+Fbh8zXivrTMjLsx0cs/soYBp+okO9dd2a/GzYftueO6/ZeSdjo+uheZYQne3qDYRus85IwQr0ewndGwQ8TAneCZ3qX7599+133bDtzju33/H9Quwihi6EDU19nychSFPSIQeKNuyCQa2SJSgdVaz1N7GqnTZrWfWandvuWL/t/l177tk+gNChc1rIVkFUvMf1jnmDdG+Q6DY0O3/bKRemCwLHam6U7jdCpjTTvGKmyLS8McCeRnl1yKtR3izAstU1y5sNebZ6xvZLEtsAy5ro8sCiNi7TcTmwHscoD0NXHWSzP0wXcqzcA4J+BmGldS2DGeSpbpeXMGLLLFlaqZUjSXUhg+t4AqLJvH6PJiWHVHMrxI/yENP0MVuPijzDsvY7FHT3OAPKgPTc9qt07zOtv3XCTJKdSosNF/DeAOj4p1Q2tD37URk7I57phfcQvxZK+W0lVq9qiFgyds/JYnfUh2M92xbjIvoR0o9CGZAer5NUpXtfaf2th26fYz+aKcqD99CPvkRlQ9uzHxW087qsfmT4tVDKbyuxesXysR8VHGJfksXuqI8aF6BtsQ9FP0L6mVAGpMfrJFXp3rdaf+uh2+fYj8ZEefAe+tHXWtcjKeVphEzpYTWeYj9EO+Q5pZjVDw2/Fkr5RSVmR9Ue1ZjQeOsij7c56kJOXcipi7xDTT+sA45YDzti7XPEOtynWI85Yj3hiLXfEWuHI9bjjlieft+P9or1U3mxkuTpq0ccsR51xPL0Vc8y7nHE6te2/Ywj1r2OWHbSiseBhp+kkdDd9vLObRDP9MR7iF8jXYqOdZRd1JjRyjermLzZFeJHeYhp+vC6Gds2+WcrnDjmRvpZUAakx+skVenexS2D1wkzSTzmni3Kg/dwzP2qFu6YKA+vb+T1V+RnGyIf+2uZ+kQ80xPvIX4tlGoflZj/KLtY+WYXkzcrS/2iPmbrOSLPsOzAHvor0s+GMiA9XiepSvc2k7+ib7O/zhHlwXvor1dVOsuGtmc/Kmjny7L6keHXQim/rcTqFcvHfjSnmLwNWeyO+pit54o8w5rX+o1+hPRzoAxIj9dJqtK9N5Mfoc+xH80V5cF76Eevb+GOpJSnEbIlbmOGgdhoh+z1VPl6Vj80/Foo5ReVmB1Ve7TyzSskr/Ii+w7KQ0zTx2w9X+QZlu3boh8i/TwoA9LjdZKqdO9e8kPEZN+ZL8qD99AP76R4hrZnPypm53BpVj8y/Foo47dtP1L1qtqjlW9+MXnrstgd9TFbnyDyDGtB6zf6EdLPhzIgPV4nqUr39pMfoc9xPDtBlAfvoR/taeGOifLw/kKsvSFuXfAbnfLJHHHzBlXnOfgf4Do0DNQN6ySHP52Ttb0Yfi10+0eR9rKA5KXVt5V9odClLvK4jhYKOQuFnLrI43WNMlj7HLF2OGI97Ij1uCPWHkesxxyxmo5Ynj6x1xFrtyPWYScsFT/L6HWo6Yd1xBHLs20/44jlGQs92+MTjlie9fisI5anT3ja3qttB+cyevrEAUesfo0Tnnq9HMZMU33a8bO9Z3t8xBHLs4xv61O9PMcTnmXk/UGcW1Zaf0dCd9vLMW+9qEJ4pifeQ/wa6ZJTXiVmFywfz5MXCV3qIo/nyYuEnEVCTl3kccwvg7XPEWuHI5ZnGR9zxHrCEeuII5an7Z9xxJqqx3xYzzpiefrEXkesA45YnvHrsCOWp+09fdXT9v0avzx91dO/mo5YnvXo6V+ebcjTvw45Yu1xxPIsY7+O5TzL6Dme6Nd67Nex3Nscsfp1nOM5xpwaT/xgtCHPOOGpl5d/Jde8LlpGryebflietj/kiGV9LZ8bM/wklVwDW14hPNMT7yF+LXTXpdcamDpjZuVbVExeI0s9oD5m6xNFnmEtbv3Gs1VIvwjKgPR4naQq3XuwVei6wOQzeieK8uC9AdDxntaPMVGesnsVyM82RD7214L1OZjVXw2/Fkq1j0rMf5RdlP8Yr6pXtn/Weo1hjQX/2DtflGdU8HE9o3457J75WQjDr4VSflWJ2V/Zxcq3uJi8WRxLUB5imj5m6yUiz7BOav3GuIT0i6EMSI/XSarSvbdTXEJMjktLRHnwHsalt1FcUm2maLtAfrYh8rG/FqzPoaz+avi1UKp9VGL+o+yi/Md4Vb2y/bPW60sRy/xvcUROrJ0qOchvdKOCj/0P9cvuD5UvZvU/w6+FUv5eidlf2cXKd1IheZUvcIxDeYhp+pitl4o8w1rW+o3xEulPgjIgPV4nqUr3/i3FS8TkeLlUlAfvYbz85YHOsvH7AJNUzs6hntWPDL8Wyvht249Uvap2bOVbWkzeWBa7oz5m62Uiz7Aard/oR0i/FMqA9HidpCrd+23yI/Q5ftZimSgP3kM/+mjrx0iP8vRIX1J1kYP/Z0dCt61y8J86ErrtmYP/o8a/vBj/bxr/ycX4nzD+FcX4X2/8K4vxv8n4VxXjX2P8pxTjP8/4Vxfj/1vjX1OM/0rjP7UY/8eM/7Ri/ONfNj69GP96419bjP9bxn9GMf7njf/MYvwvGv/ZwJ9nbcf4zy3GP/4K5HPwptDJ8K0vOAvoKyl/DYvzTFaNsIr2m0p31I/HpeeAPCxjGtY5ObFGRF6ROjk7pJcL8UcjurCeSeJ3mBQtc5L2OmLtcsQ65ISVXPPYoIxe9znqtdRJr+R6mSNWwxFr2AkrSfxlzjJ6LXfSK7k+uU+xVjhirXTEWuWIdYoj1mpHrDVOWEniLwqW0etUR70OOup1mpNeyfXpjlhefUdyvdYR6wxHrDMdsWb3IVaSbmwe+1tyvWBjyfWCV5dcL7i25HrB1pLrBVeUXC/YUHK+f42NlVfBzUrrr5rL5xi3X1chvBD0/Mfwa6RLTnnj859TSB6Xj/c/Vgtd6iKPfXy1kLNayKmLPD4LVQbrKUesPY5YjztiPeaItdcRa4cjVtMRa58j1uE+xfL01f2OWF62V/1iv/iqZ3s84ojVr+3xSUcszzbUr7Z/1BHLM0549rWeMdrT9p726lf/8hybeNajp+1fDnHiGSes5JrnkGX0esBRr4aTXp5YSbq/6afXcke9vGyfpN2OWJ4+sSL4YQ07YSXJyyeStMsJK7k+OfhgJcmzHj318vLVfo6F8xz18oxfnvXoqVc/2itJnr7Ka5/90nd4xa8kPeuI5Tn+esQRy3NNwXNM7jlX8Fx7PNzCsnXsFZBXaf0tuYY/ViE80xPvIX6NdMkpL7qGj+Xjs7+ri8mbmaUeUB+z9RqRZ1i2J4xnf5F+NZQB6fE6SVW696mW4euEmSQ++7tGlAfv4dnfPxzsLBvanv2ooJ0zf2PS8GuhlN9WYvWK5eO9IFVPdZHHY+as9lZ1d6jph3XAEethR6x9jliH+xTrMUesJxyx9jti7XDEOuiIdcgRy7Men3LE2uOIdcQRy7Nte/qXZxvyjKsvB9s3HbE8Y7TFQnu+E8czI6FTTt6xOfIbnRo3Jf8aIVPaUvJ5lptKPs+yycZFp8HNSuuvetYkxxjtiQrhhaDHhIZfI11yyhsfE64leVw+HhOeIXSpizw+H3SGkHOGkFMXeRy7ymA95Yi1xxHrcUesxxyx9jpi7XDEOuiIdcgRy9P2/eqrRxyx9jliefqXZ8w54Ij1crB90xHLs4yH+xTLs23vd8Tysn1yzWf/+sVX+3UM4Ik11W9P9dsvlb5jqt+e6ren+u0fTNv3q68+6YjlaS/PmONp+0cdsTzbkGe/3a8xul/HE55l9Bz7etajp+1fDnHiGSes5JrPKJTBWu2I5bVOnlyvccJKEp9vLKPXPEe9HnDSK0m7HbF2OWEl17w/NWX7eBn5fHYZrIYj1nInrCR52ut0J708fTVJnm2oX/2+X8v4gx4LPfVK0lTf8dLvO5L0oBNWcu155sHLXsn1Sie9kuuTHbEaTlhJ8uwfveyVpH7sO5L0rCOW55zvEUcszz0dz3UAz/UJz/M5h1tYdtYLz4ZVWn/VO5ETOY2QKa2tEJ7pifcQv0a65JRXidkFy2d2sbKfKXSpizyOh2cKOWcKOXWRx/5aBuuwI9bDjlgHHLGecsTa54h1yBHLU6+9jlg7HLGeccS61xHrWUcsT3s94Yjl2R6POGJ5+r1nLPSsx0ccsQ45Ynn6RNMRy9P2e/pUr4OOWIccsTzHJp79tmc99mv88vQvz/bYrzHaE8vTv/Y7YvG3j3F+U2n9Vd+fyTF3WlkhPNMT7yF+jXTJKa8Ss4uaw1rZzxa61EUe7wGrb6icLeTURd6hph/WAUeshx2x9jliHe5TrMccsZ5wxNrviLXDEeugI9YeR6xDjlhHHLE8/cvTXo87Ynn6l2cb8oyrnj7hGVf7tW0fcsTybENPOWJ5tseXg381HbE8xwD8HgQcL/N7EPKO2ZHf6EYFX6X1t+Q3H99ZITzTE+8hfi10l7nImF3ZX9klz/cIk2vP7+tx31IG6ylHrD2OWI87Yj3miOX5LcgdjlgHHbEOOWJ52r5fffWII9Y+RyxP//KMOQccsV4Otm86YnmW8XCfYnm27f2OWF62T669voubJE9f7dcxgCdWv/bbnrY/5IjlGaM9xxP96qtT/fbx69OmxuT5sKbG5MfPv6bGhcfPv/pxXJgkT3v1q68+6YjlaS/PmONp+0cdsTzbkGff0a8xul/7NM8yeo59PevR0/YvhzjxjBNWcs1nlMrodb+jXqud9Equ5zliee4PedprpaNeu530StIuJ6zkmp817gefSBI/c9kPtvds297t0asNJddrnLCS5NkeXw7+xe9BKYPVcMRa7oSVJE97ne6kl2csTJJnjO5Xv+/XMv6g97WeeiVpamzy0u87kvSgE5bneCJJXvZKrr3G5Mn1yY5YDSesJHn2j55zmH7sO5L0rCOW55rCI45YnvtWnutMnutfnucLD7ew+Pkyw0/SSOhuL4mcRsiURiuEZ3riPcSvkS455VVidlHnpK185xaTN6NC/CgPMU0fs/V5Is+wzm/9xm8JI/25UAakx+skVeneP7Ym5nXCTBJ/S/g8UR68NwA6fnW4s2xoe/ajgnY+KasfGX4tlPLbSqxeVftS9Wq8dZHHayRZ7a3q7lDTD+uAI9bDjlj7HLEO9ynWY45YTzhi7XfE2uGIddAR65Ajlmc9PuWItccR64gjlmfb9vQvT70869FTL8844ekTnvXYdMTyjPf8PB6Ojfh5vNj4UslBfqMbFXyV1t+R0D1GyTFeOlwhPNMT7yF+LXSXucj4TNlf2cXKfr7QpS7yeG3nfCHnfCGnLvK4jZXBesoRa48j1uOOWI85Yu11xNrhiHXQEeuQI5an7fvVV484Yu1zxPL0L0+9POvRUy/PuOrpE5712HTE8rT94T7F8owT+x2xvGyfXPOzff3iq/06nvDEmhoDTI0BJjKuTo0BpsYAU2OAqTFALyxPe/Wrrz7piOVpr36NE486Ynm2oX7tO/p17Nuv/uU5jvasR0/bvxzixDNOWMk1n2Mog7XaEctr/T65XuOElaT7m356zXPU6wEnvZK02xHLSy/vevS01y4nLG+f8KrH5HqZk17JdcMRa7kTVpI87XW6k17J9alOWEnqV1+dao/Hr4z96F9JmuqHpvye8x50wkquPc+IePrXSie9kuuTHbEaTlhJ8uxrveyVpH5sj0l61hHLcy76iCOW576V5/qE57qJ53mmwy0sOxs3DHmV1l87FzgP7idyGiFTqlYIz/TEe4hfI11yyhs/FziP5HH5zC5W9pOELnXKSxI/J3OSkHOSkDNZWKq+MPb2SDeyPQwDsfH8QY66WZjVFwy/FrrrpogvLCV5aXa1si8TutRFHtt4mZCzTMipizzexyyD9VZHLE+9DjhhJdejwQfLu4w7HLGajliHHbH2O2J52uuII9bTjlgHHbH2OWJ52v4xR6y9jlieZXzGEeteRywb29tzJNgvrQidctS4aF5EDvIb3ajgcxojzCw6Rig4Po2OEZRdrHzLiskbzVLfqI/ZuiHyDGt56zc+L470y6AMSI/XSarSvbe3HiKqE2aSeOzaEOXBewOg49tauGOiPOyvql6WClzlr0Y3IvgadvHNXZ/+xU8+9+u/94Hd73/fj83+7Mz3zFg7/fHDh7+2+B+W/MSLh3+hZH3fbPyNYvxzjX+50j2eho13ZTHZc4x/dTH+2ca/phj/BuM/FW427OKifz94y12/9p2dM644+OGHP/uZ6/bMXLLt48ueet8tv//OZX9365Mln2dbZ/znF+KvjPvcBUr3eBq324XjaLl0X2b8ryjEX3nR+F8J/AOZ+cOI8b+qGP+Fxv/qYvyvMP7XAH8O+zWM/7WF+CtfMP7XIWjr78o//3+mffuX3179d3/x4s6Hv3Xa8394xXO//SuvfdcLZ1zU3PpXP/YP1xrvRYK3h9xxn7tY8f7tsz/5eP3D7/rZxukvfGv4ird/9dZvbBx65WdfeHTRJw589+9efLfxXqJ44+k1xrtuXJNc9p5n/Jcq2X9yy3c//5H684/sfe5j+1+5Zu62Dz7/6a//j//8yV+tf+NLH3rg0xcm/cmvUH9SAT2mwbX5UZKsr0zSm5udNEmqEv3sWW2+D7fkjRJPCN3joAG4n8Mmi7AMltQ4yPBrobvsRcZBAySPy8drJVWhS53yksRj56qQUxVyFNazjlg7HLEOOmLtc8R6whFrryPWY45YnmXc74jVr/61xxHrkCPWEUcsT//ytNfjjlie/uXZhg44Ynn6hGdcPdzCGhV5PA4Ygvs5+uWBrOMAw6+F7n65yDhgiOSl2WXG9//NaV3v2X33PXfv3nfNzm13rN92/64992zH0QSOEFhKhVDxXiV0lh7zBuneINFd2ez8fXWzmy8I7CTfam4a3W+ETOlS84pLRablrQdsHlltgLwq5V0GWM81O/Muh7wfbbYxOLENsKzJ3wcWtXGZjsuB9bie8nAndwPIZn8YEnKs3AOCfpiwhgSf1VkveSVbaaWkrwyaj+MOtSqX4cciTtaIYbK8IobSPRZJ0S+wjGlYwzmxRkRekTqJRULEH43oovTkWJh15mX3p0X0QvoxIdt4zUb4tqi8vVOajbAtGH7SW9Rb163eYsP22/bcec3OOxkbXRbNs5DoLKQPhG5XGk7BCvR7Id0bBDxMsQl/lmZneiapLrBsIWJqQHEsTQ0oIE0NKMJLZ0ChOgpeCuQlwiQ17OKJX/jA59c998LZf/Xd6U9fu+3Q3vOe+dOb//6Rhe9f9Tdv+dCSD85JZK2pHSMdC7oTxWsr21CP8lWJ/v31Nt/alrykhS5o5bda6KV77tmxZfvuB+/e/tD278fyXYFSr2Z1bbPz93XNbj6VzCVUMzfzFgxcmQOl4deCruZGyJTGA6WakWL5igVKdgi0Sgj+gdJq0FKRQFlw5JY7UFYoDwMlB9GJCpRW1ryBEuuRAyU2cA6UyoNRjpV7QNAPEVYsyPWSNzXUOZamhjqQpoY64aUz1GG+odDd4o23SrQ/1BpSlGzpYTbwsY5TY4RjaWqMAGlqjBBeOmMEFYEqhDGRSzMoOzpp+/Lu9e/cveDeC/9+5I+fO+fnFp/0hW++/yNf+ad921/51a/87W8u/2bJaHNTySh5Y8K3lyaN/P4WvLYeLe2sjPFWif6ttTbfozBpXNXKb0Wim7bdc/cd23Zvv+y+B/Zs37P9jut27t6+a919d1z20Pb7dueeQm5sdv6+qtnNp9L00C7wbMLHQibJApTRW2gdBjlIwwYy+gMtoyQGe7rVkJXTmT6jxB9Cdxc2l3RvhEwpcxdm+DXSpWgXNpfkcfmKdWHszmgVRMV7HDYwbzK6sBPofiNkSrm7MN6owC5sDuVNVBdmZc3bhWE9chc2H/K4C0N/mCvkWLkHBP18wpor+LgLS5M3KPh46FKh+7hWN1vI5rW6n4Ko8tyidDvMDul2sN9qssD2tvwklfTlm7NGIcOvhe66LxKFTiB5XL5iUQg9BaXcRKhGg7SYbgLNkJ5/c+1VBR8nHjidQHlJslpdQDyNkCnNyVqrhl8LpbxovFYXkDwuHw/mFhaTN7tC/CgPMU0fs/UikWdYJ7Z+Y+tH+oVQBqTH6yRV6d6/a0WHOmEmiR/mWSTKg/fwEPUHaUCJ5ZlBZVP1skDg1gW/0Sk5J5SUc0JGORNRHqsnixl/BIPn/0C2nRsps+pt5mYs89yQLmdGSTkzhBxrB3iE4U3NzryRSF4NME8gzOnAx/vpMyFvE+WNAeYMwqxHMGcJzKTuHprexkv+qQfZsKexkaPVAb70AHnx9xDRJml9C6dKtJ8Bv/qvtc4yYP2xrVU7szyMe2wXFV8sD2MW23pxBHOJwEzKc+/0Tjq2V5JKPsh3U9a+zPBrpEvRvkw9KKoegCz5oOGNFeJHeYhp+pitV4k8wzql9Rv7MqRvQBmQHq+TVKV7X6G+bBXQcl+2SpQH72Ff9iVqF2j7Sspfw+V7HAdjD/di+zWfP/ph5VpnWbDdD4buOGELQ9z23w27+F+jPgX5uW5VOypa/qWijDE7l31wNmt7bbSua6FUfKjE2o96kN/Kt6qYvDlZ/Bv1MVufIvIMa03rN/oX0q+CMiA9Xiepyvmt+FwP3W2b2+spojx4D9vr/6b22gC6sv7aABpuF9hvY3sdpj5/GejKfX5yvbJ1XSX6x6C91lqYY6HbPxukVwP08iw/9/snOMpBLH4QU/kClt/sZ7ZBvz+F+NBXuc0pX18jZCt8w+jlGwum67Kl+YbJ4r7vNvCNEzP4xlhIr88x+o1xOhZfkH5l0OUaTqFPK9fyVlmSOcE7FnViGn/aOIL7PaNfCZjPL9J6YrnUS8E4NiK9io3KpvzCVyUb7cz7DMY/HOK+yHH3dGFT7o+Rf1ToYm13JGi/b4RM6dIs8QHxa6FU/1jJamvujwu+rGJdzE8Qk219msgzrLWt3+j3SL8GyoD0eJ2kKt17NfXHpwEt98enifLgPeyPz6d5GNq+bD+h2lqvmHsxxdxVoKuKufaykCrRXw0x91KKuaodTnT5ec68xlEOYnF/vJawuPxmP7MN+upa4jsD8pAO+2P05zOEbIWftT/ePF2XLc03TBa3pbPBN7aSbyC/1Z/ymzWUh3XN/XGvfug8oje9h0N8nFMl+lsi/bEau2CM4/7Y6N8U6Y9VnIn1x8oXVWxUNl1LWOrFq2hn7o+VTbH8J1H5jf6OjP2x8av1uVubnXm4PsfzFNyDaFAe7inw+B7X5+ZT3mLI4zi8BPLQR3h9blqkPPgoGq8X47ov76lMh7yFlDcT8hZRHq77nkh5dchbTHmzIG8JlNXWfflQzL7W/ZLnNeRRx9i6eiXlbwjZ+gM+woty5jrKQSw7ehzbcS4qB2Py8tApZyLmtUrOAkc5vDeLchYJOeZ/JxJfI2RKmc8LGX4tdMebIuP4E0kel6/YTj1GSLYKouK9SugsPebFduqT5HFeaAndb4RMKfd5IY6ieF6Io+hlgOV5XsjKmve8ENYjnxfCHozPC6E/nCjkWLkHBP1iwjpR8Fmd9ZI3KPj4lEKF7qedFzKMKtH/HIxGfoxGY0oWtjYeEZnuaSchWQejfx/o8PQijVlNKdfCFMyPTm/b4wPTNWYQmKpci6lcrMOJpIPRf1CM9AZDt/8pHzuRfuPIF3n5t/KZ2US/pEd5uJ6M/t9F6mmR0AF3cdmmrAPTLE7R4TeFDiLar995/75WtA+U+CEzjtZseT5XtUjgpCXDT7zQPHKQcNGLQ8o99gDjTUpuLygef5XCPdt3b08p+4DQTckcCDqNpuiWJOuZCvbxmccUhl8LOko1QqZUYc81eVw+frBDRfS6yMP6ZT+KyUnq1MbBrTrdunvng2lVmnWwURFqhZA+6KiEzqpAnpezG+QbWrIToFUQFe/FLN+rtj2e1+TupBEypdxDSz5ujkNLHnZO1NDSypp3aIn1yENLDAI8tER/WCTk8MFOpD+RsGLDwl7y1NCTj7NzxEgbWvIQzOg/D131c4s6y8mdKn49crh1PYET2NlZo8xLewI7i1CNBmkxzQLNkJ5/zyG+a5rdfJw4yjTofiNkSpM2gX17szMPo8w7mm0MTirKNFrXSUt4T44ogy0yS5RRk9vLKA8XDi6nPDwGdgXl4dL0lZSHRw42tq45Gnyblj4L9tdy6dOwxkK33XC5mH13UNzjpTXknxORM1ZSzpiQU9JWlZJtbZBHLUdvCp0arWv2W8tXfw2L83hcV/YRQ6V7rB7SetU0rEU5sUqOj8frZGGkXCq2KV2UnryYYVsxB1v7zckoYOaMTmx8PJZ76IJv/7gwq78Yvtc3I9UbFWPfjBwRutQpL0n8zeERIWdEyFFYBxyxnnTEesIRa68j1g5HLM8yetajZxkfdsTyLGPTEeugI9bjjlj7HLGOOGI95ojl6ROe7dGzDXn6hKe99jtiHXbE8rT9I45YnrY/5IjlaS/PWLjHEeuQI1a/xkJPe3nGnJfDmMnTJzz7bS/bJ9ejwQcrSZ5+72n7Rx2xPP3es4yeccJzDOBpr2ccsZ4lrKzzeqOfLujVupGtBeI6ofGOtH7j0dO8e6FpdsCjroZf4ssKZp4LiI6/rIChpZaCFej3BXRvEPAw4avpsmz+NAizETKlcyuEx2UIhO+1+dMgeVw+XlpST/DWRd7pcI15KEc97VQXedy9lsFqOmIddMR63BFrnyPWEUesxxyxPH3iCUesHY5Ynj7haa/9jlie9nrEEcvTXk86Ynn66l5HrJdDPR5yxPK0l2c/tMcR65AjVr/2Q5728oz3nv7lGXM826OnT3iOmbxsn1zzUkm/+L2n7R91xPL0e88yesaJfh1/PeOIZUsl6i0xfIC5IeQ0InKQv5EBS82HjX6NoI8tyagn3G3tgN820AiZ0kDM3msA0/BLLMk0Wr/PITpeksEQdkoKVqDf59C9tCUZPgX0T62TP2bGgqez5Ck+Pl2HS00nkf55VwaRfyQip1ZSTi2jnHkl5cwTckYFXyXlr8nhe7GdhHkkp+gpPyUHsewFHWY3XHZjP8h7Ig/5F6VgDYW2znc12zT8Eo5G63dVYCbJXqJaJfrR1jgjWXL9g9Zxu9jLVBN9xkbjuiIv6lol+jn1Nt/sFqays9W78gN+6GmOkKswuW3lrbua0CGGhfU1negbrd/DKfT8CKTRL4a64xei8Is5k4T+syhFB/QffEFmmv8sK+A/y0fjurL/TA+dso3+m2NtvpXkP2jjmP9Mpzx1alXFTD5hnTdmjgn9lJz5lIf68Uvz8EUS/NLwE0SZK5SHup8Q0X260MH64IKnw3M/STFGefgkRZ3yLoO8WZR3OeRx33UF5PHzYVdCHr+QZiPk8UtaroK8JZR3NeRNp7xrII+f28M0SL+xTpI2+kfQRpkukEz0mfWUhy/5QNujHfExeXzBiMUCHs+dAO15w2invLrQ1XwOX3yTw+fOqxBeCHrrzfBrpEtOeeNbb7NIHpePt97mCF1UvDoZrjEP5cSeNsA8XjIog3XYEethR6wDjlhPOWLtc8Q65IjlqddeR6wdjljPOGLd64j1rCOWp72ecMTybI9HHLE8/d4zFnrW4yOOWJ71eMgRy9NeBx2x9jhiHXLE8mxDnuMJT3s97og1FVePX1z1sn1yzVtv/eL3nrZ/1BHL0+89y+gZJ/Y7YvXrePU+RywbrxofztFxLaDkutGA8Rf8qNX4E+z4Ia/YGrbHWwVMltdbBZTusXrCt27wWwUU1pKcWCMir0id9HqrAK+fKV2UnuiLZct8ImFlXdvJW3djQp7xlmwDAzF7Y1kNv8Q2spnnXKLb0mzpErrd8sQUrEC/z6V7advIZkpcxuOtvDqVIa0a1VZePSJnekk50zPKqZWUU8soZ6yknLGMclaUlLNCyBkUcnDrTm1h4zbWn9M2lvk2bmPhVg5/X9XoT5zZ5vsMbWMhvz0VM0a/k2t+3zo+MGT+7/EAEOKFoLs3w6+Fbp8t0r3NJHlcPqvrfK8p4xaCVkFUvFcJ3dGkAprhPT74MI347ODMYEhPZjGruYIbD7k312qUhxs8vDF1GWB5vgzRypr3ZYhYj7xphdGGX4aI/jBTyLFyDwj6McKaKfisznrJGxR8NcKo0H2MOLOF7CrRfxM27fk920oWtjbzW243ae9OZh2M/p9BB35/80zgUeWqgT5of/uNbY2/PmzYMyHqfndUyw9CPpcPfTXtHdZYHqS3DPVO7rrgDyn32Ld5s7QeocVXVPFv5Yv8/m7rxdLKzvVv9NOg7Fz/04UO+Hgs2591YJrhFB1mCB3Kvb+boz7XEtfEdIGTlswaicea97J1uHWoe2keUPb93SMpMgeCTvwNHeMLod3jFRw7ZB6rGH4t6OjXCJlShT3X5HH5eGtf9RR1kZfWSnvJKfn+7rRBjAoWzB+ItyLuJSlx5730CWic5fPULO+qFPIbnZIzvaSc6RnlvJTfAcpYaqqTpJ3NY3/5vaunQsDlz63NAT0U5g3NTnp1ylKdWjP6Xh8zYVuqJYiYbLQld1BLcuq6VNDjSgyfTET9lubUdcsk6zpH6DoqZHNXUGZ1C/FMT7yH+DVRhiJdQcwuRxVr/c03beVzu2gVRMV7ldBZeszjiD+f6DY2O38XmbauovuNkCnlnrbyW2Zx2sprxRM1bbWy5p22Yj3ytLUBeTxtRX9YKuRYuQcEfYOwlgo+q7Ne8mIt3zAUX/L7YsETe+VKlhadJB5sNRyxVgks8/eCH6SenzVSHa8PUlvZ1whd6iIPz6NjHspZI+QorMWOWAudsJLEH6eewprCmsKawnqpYVke9tmriK8BfDYbU7MlnkmrfeWFEf3Uh5OVnBUl5awQcmJfE+O/JofvsRyls/roOtst72P0yL+KyoPnEnAT87mZWibO7JHXniGsEv00eHbnHTPTy4h2PlquZrfOI62/VcjLMa4ZS8beHz25LQfHKUd1bLZx09oP0t/doldjCVvQVXVtGL3q4CeoDtTnU2cJffjzqS/ClsZPUx3gmZdG0PJCD3nsI8OCHvHYR94rtjuUfjzHVT6Jdl6XIu8XxWqT8juTXdLv5iu/w/bKfpd13J3FT9Emyk+znFNCP+AVLP6cLteB4fGnb39N1HkWP1f1avQfyVivTvFE1ivaiutVrTSqfijmB1hf/Mwf1nnayixiYV1nqddZAp/r9T9G6lUdhEE9uV6N/uMZ6xXPGR7Fgbyy9Yq2ylKvSM/1qvpv9VHWeujuJ2cSVuwsZJKy1CvWQdqnql+I1Kta9Y/FYaP/VB/EYbRVlnpVOyNZ65XjMNbrMspTOxBFY7RhZY3RRv85Uec85ue4kKafslvJTcj59HtpihrzBH8g3grdm5eCZTjJPVy0Z5NbcYeDXgJlkxv9X0VOfswR/ElSIcrKU/YYfYXwTB+8h/i10O0SRZYeew09eekx64fj8naLE+CqSbLdk4pQi/kDYVXEPcxTrjoC98xV1bfhsIf+czpyqr6lGIt8auRv9DYCTRtdGF6V6L8V6YV6zdY4Wp8m6HFkbPqo8p9Geci3KEUO9o4Y+ddRWY3+uxl7R5M9Eb0j2oh7x7WQNyjo2d5nCPq1QMOrSmdAXqxJn0ZyeoUO9n/lp2r2rUbj6rhxFn9U/oU+sYby1GxO+YLRTcRKCZaHfSHWlpLEton5DtqmHnr7CbbLNSQnFpeSFPMFXF2w1bARwEY5jZAprTY5ajfesLF7zVFnt6NOllRXbfdqpEvRrnqQ5HH5uKuuCl3qlJek+5ttOs4bFPcGIlg7HLEOOmLtccQ65Ih1xBHrMUcsT3s97ojl6V9POGIdcMTy9Il9TljG76XX4aYflqdPPOyI5ekTTUcsz7jq2ba9fDVJ/RpXPX3CM355tiFPn/C0135HLE977XXE8vRVT72m+u3jZ69DjlieMdpzDPCkI5Zn/OpXn/CME/3aD3nOYTzL+LQj1lRc/cGIX571+JAjlqe9+jXm9Ou48BFHLM/26NnXetZjv45X73HE8tTLM64+6ojlGSf6NUZ76uVp+36NE55j8pfDvNaz336qT/U65IjlWY+e7dFzDuO57uuJ5ekT3IYqrftIY19SStKtzXY+0tuXjUruFd/Be7GGgdhDBbErhBdCp56B8EeFPNOrlpLXCPH0zdt/Z+xXn775gxXiN134Hp9PUK9RUXvaZit8/0kOW92mznCYbMurQt4Q5Q1BnumQ/P0vJ3fqN1xQvyz2Q/y6oOen0rLWxezQ6Qvo73YuBo98jlBeA/L42J86F4L0fF7NztUMp9DzeTWj/06rvaonW/BMTy1FHuqnzrLVBf8pKVhpp7NXp+hujzCpd7Kos03qNUNG3+usHT/Nh2Xg811rRHmwPvlJtPGzhqI8qv2ZT5U8QzXzeJ+h4nNSeIaKn87HM6BrKA/bToN0UG96UCfR+ekY5MUv/8W+8thP7Xoh+FKsXZ+UIg/1i7Vr5M/TrpN0Z1PrvjRnuz5J6NdP7XplxnZtPjXVrnu3a/VuqKztGr/6yl+EXQt5hotvAzmvdV0l+vMiPqvOFceeljxT0ONZY/6yJtr3TMpDvlMo70zI43OpZ4VuO6Be/J40o38N2OEz4INHy9JsyzC9Svr6OuXrZwEB+/rZkDco6LkuzhH0ZwON2aRO9Fwvae0GbXo16Wo2Ghb0iFcl+stF7Df9ML6dRbqvyan7fKH7aOhuM9imNrcOpKsz5fx41JqITObFGDScQm94VaLfLOzF/TW2A7TTEGEa/dZIPFDxNtaH9Yq3fBYf7bKW8tQbkCbwmY1Lj/czG1b/9dAdD7mfivX9atyW1f/Rhy6e3omrxkjIu7J1zWOk7TnHSMvgXt4xEvc3yk7KvxqUhzY9gXRQ/S7S8xzQ6O/N2N84+fMc5c/os+zPMf9MUt6+32xSD939Qdr4G7Gwrrm/Uc+8nSbweXy7N9LfNIB/Lel+Qk7ds7Y3bFMLqL9ZBnTc38TaOPOinLT+Jm1udiDS3ywD3XmsqPoboz8ciQfKlrH+ptdzYaaPsmmsL2q0rifwjRdzvd+gUzRW1kN3++En6BuQx/6/TMjJ6v/oQ8PU3/B6CGKhX1RIR/RHbDe29lkl+h+P+GOvvpRtHnvbDOqj1l94zoO6m50mcI3tpuP9Zh2rTzXGb1AetmMeW6t1NIwh7I/oR7iO9tVaJx1+8KLS+mt7Arg2kMPmmV8JYPg10iWnvPHnDEdIHpfP6i7fe5OH4Zqtgqh4rxI6S495g3RvkOiubHb+tppluiBwrOYKfvwg93uThylvA+RNo7zLAMvzvclW1rzvTcZ6XE95uFuyAWSzP4wIOVbuAUFfI6wRwWd11kveoOBTn2DB+9iLDAnZVaL/HehFnluUbgfcnWNM+32q0JPrwvJDaPtywQ9rzM4ahQy/FkpFvfEoVCN5XD6fKGRSZhGq0SAtplmgGdLzb/7o2DXNbj5OHIVm0/1GyJRco9AI5WEUenuzMw+j0DuabQxOKgpZWRO7vSdHFMLWmyUKWR5G+MsoD98Adjnl4bc5rqC8OuRdSXn43oONresqleEvWwAlzxR0+E0Iuo6nxi39Nm65ttn5u8i4peD3jF+S4xYrq+e4BVuO57hlNmFN9LhF8VVC5+yL63CYaEMo3RMNZo0Ihl8LpSLfeESYTfK4fGYHfkch8qpdXNQd81BOlu+0c++Ev3vpXPJFafx7JEWNAcEfiJebapZDfhiYeQHXdBkOcTevsu6t3lW900/xJymL2092R1jW7VWYiLl9TeiiDryhDbkOJ8lVk2Q9ZEWoFUI+V61QnnJVnJVdnSJ7OOgZIbuq0deFq9ZDp47In2CuqXXKvhLoBkN3+VjXjaSrokFdjX4+6Po06Yq257HuRtCFm9RVpHsjZEqZm5Th10iXok3qKpLH5Ss2tmTvQ6sgahC0QeT1ajkbmp2/i4wtr6H7jZApXWteca3ItLzrALtCeZsgbyPlbQYsHlteD3l5x5ZW1rxjS6zH6yjvasjbBLLZH64ScqzcA4L+asK6SvBZnfWSNyj4KoRRofu4JnalkM1PWJwFUYXXxFDWlaEzqcjCO6BJYnuH0B2FCvry67NGIcOvhe66LxKFriF5XL5iUQg9BaXcTKhGg7SYbgbNkJ5/c+0tE3ycDKdKOl/Z8qLE+17Vuh4L3d7LX3ZBHWLxvC74jU7JmVFSzgwhR73L0p5hUu96nE58OH55M/Gth7xNlLdBlEvN5hnz8gjmFSIv0e+FWZ10GI0qKX+TNCjusU2vErpa3WEE4JmYam3XROQgv9GNCr6y5VE6qzEXfuFm66w2D/bCGLXRjxut6yrR37CozXcTtbdrgd90VHbmtpjXztOFnIm2M7ep6xzlIJbVmdlmM2GxnRuta7MzjpI2E9/1kId0OCLYDPevF7IVvmH08sE7Z+mypfmgyaoS/avAB99S0AevozwceXJ/aHqgHZC+EXS5hlPo08r1QGROeJXgV7rzFyKui+ieJPZF5OeR60T4PMrs5T+PkP+YHdL8Z03rukr0J4P/PEb+gyO0iSh/rF3jSM5mZrF2reIH82EbnZtBh81C57rgNzo1AyvrG0rnXr7xDPmGxa403+DnX4x+BvjGj5JvYPw0HZWdeQyY184zhJyJtjOP77Y4ykEs7t9uICy2s9WT2Xkr5N1AfDdCHtJh/3YD3L9RyFb4Wfu3n5mly5bmgyarSvQvLmzzvTcyp4n54BbKQ5vyKssWYQdVBxXSeziFfguVy+h/SfRvsfa6BTA5lhv9BwGTz2eaXCyXmi3HfHGrKJey6Q2ht2y0M6+7Gv9w0OVP85Vfj9jU+IdSysM2NfrfjNhU2ShmU9XGbhDlGhNlvpGwrhZYaOcsNsXyX03lN/r/EBmHXSf41diBx5BqHIb0/NyiamNqbMJt7BMZx5A8tsG1BXsnilpbuJb4cK+D52LrIW8T5eHaAq9zXAZ53P9dDnnXU94VkIe+b2sLVSrrp1r3S+5JyHM2V5FuaWto+DeEbP3pAOmJciZi3SS5Xk5yrnaUc3VEzkTN59lu1zrKQawNzWN/1VyNvzCZd66G/LH5bLWknKqQw1jWxyQJx3j8nI/R/y3Eqc+d3Imp5tv4/iSe46i5tbVpXqNohEypYvxbivEPWlnUGooap/Eul+Wrv4bFeSarRlh5yx7THfVjP1HzoxjW9TmxRkRekTrZHCmX6leULkrPtLaBcmbCPR4rbYnohfRq/Gm8ZiOe/zRCpjQQs5EajybzRjvv2tpp2rD9tj13XrPzTsZGl0XzLCY6a94DoduVrk/BCvR7Md0bBDxMkxUulZyxknLGhJyJXqobIzlpU+Ha7DYPunHaVHh165qX6v47TIVHW5hqKpzW9Coh2zEek5d2NGYoRb/ZLZ3waEyFeLDMqyM647Iwy02SbfmxDie0dCjZ5clhLC8x4HCfwxGGs6soD4eSsWkTHzhQUz413awL/qtTsNKGKjylMvplUMdZhirYJnioog5/qCVetoOSE+uKN2aUUy8ppy7klB3KKDlKZ56eJglj0FqKQWq7CXnt0RzelvkjiEFnRWIQ6si/VTznGMTbRkzD/mn050dikBqeX9NM13kzyGC5SeIYNL4lRzGo4BBNxiDDUn0ov5Yubx+K/JPVh84hOROxpJ8kPuqAdcLxJe/wHPl5uJzWHq+YrWWq9sj9IdK/G9rjVdQe0Z9jY6/Y0nlamwgh2/ZN2ha5ikFJivVBRr8l0gfFpjNJik2X0/TDw3pIPxvKnIYVxD2jx/6Pl5CuJ9rNEdq06WVyfUHruuQUfqv581aRaXk3CJ0sD5e+NzfbdJz42BvqnNT3F+h1QEjH+qgtCcZUbX59s5PWyjwgcHlrENsx22tTU+vAdZykN7Roub0/MLuNfyf1MwWnuTdw/WHi+mPbcVL1Z3ol9Te2oo3LdCwT7Xwj5alXmPM8jOtj/3GyF7ZPTsfDXryl0ctelmflHRB8fLDZ5P00+OtbCa8Kstj/+fXdNwI+8yeJx2JGfwD6ijesiMvH+LUlpTw/QT6E9ZzDh9aZ7W8KnToh9s0FsbOMlxB/VMgzvWoiL8ur8D/xkde/Yc83f/KBCvGbLnyPl/9eL+gXCHqz1RuAP4etXmftCl8TZLItrwp5N1PeEOSZDupV+K8vqF8W+yF+XdD/cLNNl6cu6kIOj5XLYG0uiGWv6L8J+DneYX/O/YPqk5MY8NEe8UmNbzg+/AbFh4LjrfPVuInjw00FsbPGB8MfDen2rom8LPFh5tc3r7jiyP0bKqE7Dg6KexwflK+cIOhLtr+zVXzgGFCFvJsoD+OD6aDiQ8FYf3YW+yF+XdBzfMhaF3Uhh+NDGazNBbEsPqgxq4oPPB7aKsqD8YHH5P8vtfmCj1fK9R5+PAgfW00SzqV4nrI5goP3cEyFPDz/NvpPwJjud2Zr/awMm4R+6igN2vn3Z6fTbRV0ybabtf3WttsV23dvvWvbg9vv2Lr99ge37x6k0vNqFq868c6aSlZC/pjRFfSbZ+tVwsGRa69kMsdCt2XwZZEsR63wcsubL3RUchaWlLNQyFGzlErKX5PD92I7jwtJTuwxyDKHHBBP6Yn4Xo9Bqo1ytSukopvx1kUe78ipQ5xbhRyFxSuM6uBgJXS3zSyr1rGHFNJ2ZD8/W8tUO7JJ2tLi5YM7g7D6+kVafUW9Yu0JPzpTpD0tyijnxJJyThRyJrrdnkjlQb9hu+X1G+TP6jdfc/Kbjy1o8/1jBr+JlTH2oEzssFqvh262EFbWHYNqBjmxHYNqRjlZyhOTczzLY1hqpwnr4IZmul7XE1avfmArYalVbOWDrHPeUwhq50LJub6knOszypms8mwqKWdTRjmLSspZJORM9MHmRSQnLd4unNPmQT9Ni7d8asHo3w/xdnELUz1k8YNu562OchCLX3qQVp+rqT5jD4UlievT6N8O9XlahvpUtkkb+6LcWF1jvOXVKTVWvj5Crx4kUn3KBK4KZn61Me8MFNwBGZ+/qJU8LB++xmVe67o1y1+3fdc5575yw/en+Pvu3522QjgLhYL+TB/oN/MluvFY4GohI0nsP1uJjuvd7jN+Fp160fbKV7Euy8NmsViH/HlPHlr98MnD17baedZTH+hDsZOH/GKIzSm6D4oyTA+6vd7R1Pphma+OlNno10fKfH2PMvP4Pe3kOP5mukFRhpHQ7QOIoWy8OHTqntefkH+y+s7FJCetT9tEfVqvh+1f27rmVeRHoU/bQn2aGgtOdPnTTnBiuV4LNGlzG3WKLUm8Y2/0P9Qqe8n1OLmazrsA6gHypHxvojrtdWKf69To74M6/eEMdRprH+rkcSwWXBehV3NFtfYTGzda/fCLARohS6p8MYuPIn6NdMnpD+PjjdiLDpJUdLxhuF+AAqH+vcYbzBcbbzBtWtvjMcAWut9rvKF0SqPNO95QuzqV0O2LWdYmkd/ozD8Lrq83TJfxtV7QBX2e2+4m0JHboqKvkn6Mn7aOUA3aNtY38fhpN4wl3rji2LWqiyUp+oWQrS6Qf7LWiZeQnInoE5PEp8ixXtmH865Hx/Zeevnga1rXvcYqB3P2a7wDbPRLoV87Qv2aenpQ+VlsrYXLn3e8GGtvWdsP20jpnqS0J9HeS+OYgk+ibVYnFsxfS46RNmdpE4g/KuTxg9aYl+Uk0Hv/9MJPXLLzje/kPsp04XtZ1lpWCfpy45Vjr2w+KqPZ5scTDUmqQt4WyhuCPNNBnQQqOL65Nov9EL8u6NeDjnnqQmFdXRDLTu/EXjA22bEiba3CYgL3tR+IzNvVU4XqSbjYngLPCbiMHHOS1Ag6fY+S4Zn9pwlZfPrRaD8M5b51Raeuaesq1ZTyxJ6gqYR027AMdRrqdaFTt+sz6KbWTxAjbY8pwVB7buy3eZ86u07oo+SsKClnhZAT65P4r8nhe7H9uxUkJ20887s594fubvHy/tAojGd+j8Yz6ukIk6eerFcvZ2Hbpz3VyvHE6P8A2hU/1VqlMmM5Y36W9UkKo/8vk7Auw2Wqhu7YmqTLmkGWqdeThLExQ+xJddV/Mlba2i6Poa1sO+a3+f4b+fFAiJf/8mYnptFvm9fG/IucmFekYH5jThvzL6lt4FiMPzKNL/kaFPe4/SM/j9l4jtwImdL4i4vWF+Mff0kOvnliUOhk+GVfcIayaqHbxkXWu5TusXrAt1rw+pDCGsqJNSLyitRJNVIuxB+N6KL05DGGkoMfyeb5yIaIXkhvbQh903jNRpdBXg4bDcTqawNgGn6y1llvXed8cZGZZwHRWQgcCN0mXp+CFej3Aro3GPSLixLsL7XCqVpqOCdFZ9OB77EbI39sSWOkpJwRISeGdY7AMvrLBb36YrCVA13NeD2+T5XWJPDdlYbv4IZLiM5GAQMh3ft7ueESupfmhqqF8XtPVO+B5hkTGPxMzYaITCtrktT7KYzOenkbvSyae+zviJCfo8qf5NeWGgZiX14QO2sPyp8nRnmmV03kZVmt+lr9jD99w6rL/ijWzPAeN0v1YalzBX3J3YtDarUKX8OapCrkXU55Q5BnOqjVqoKh4VAW+yF+XdDzalXWulBYVxfEstUqDJ/WdiarLcew1MpShXRO+zQHxwqjb7RihfqyqLJDEPcGQnecuL557K/qkvjD05eJsuI9thvyG90ExqqhvLGqFrrLXGS0r/xW2YVfkYy89dAdq/h9DCqOXSXkvFSw0Df5tdyWr/6aHL7HcrCt8kemL3eUo/q6mJ8XlYNYfPp3oj5XZitTJfvGTeqdfJb4PWTKL3AVkMcauFLE9seVI34lOu5KXQLXnAbpN/fPt61o4zKdpcl616RaDcHV22vnapm4eovjJ15JM/qNsOq1eW56GdM+ZZV3Z/dGGisX3NmNvmP0B8nHi/jxewr6MY+9NolyqBOxVg4Vr/kpAoyxmyhPfa5BxTJ750AldMdT3g1LEq9Iq3msGjdxu847btoo5JQcG+X2Tf4kBu464ZiWk/Ix0znxsU9l8DHuO1k3ZQeMVawjlifru02N/iEYd/MuEL4/wTDvanaX2+ivAhmBMJLEsc/o91PsKxifZOzjfkONI0rKzfzJdMOvhe5YVmRcrvpTNS5NlsBamywZPlac1mtXCBXvVUJ3a6mAZnhviOiuanb+Nq/llsbYSb7VHK+INUKmtJkjAybVa3HUwF6LR1+4H8ifTMdns/J+Mt3KmveT6eq5Cn4TL5aJ9zDZ4+yelVu9we86wkobOQ1mkDco+PitOIov+X2p4FHnACopf0OIzyzYjh5YmwRWydHh3KyRyvC9PnTS6w26XPasHwTBDSDMQzmxcyiIVXXCShKvIExhTWFNYU1hTQaWmmXxjBL7KX6mE+MgzlAwD/WLbT4jf2yTe0VJOSuEnIl+PmQFlQf7SLabOp+7KSIH+TdRedJWvv54rpapVr6SZDM5Xol6Nax8/cncTp3Vhn6Sxuge18NRjGY3rx0eqEJejvHFWDIG/ujJbTls16FmGzfLOMTOONaJHsuufCFrHX2e6ojPWTIvny01+hVQR1+k1Um1uhlrV0pehco8HPTqKZ8tNfq/Ebt5Sr+0laS0L1asTJH3dyDveZoTod/hTvhRHMjLM45WfocrXux3WXfQYvFCta166I49vIOrzkzGzhMb/3DQdYBnPpH+m6LOs/i5qlej/3bGesVVxKM4kFe2XtFWXK9qd1z1UzE/wPqK7bytJ6z1AgvrOku9Dgh8rteBVqxR9Wr8WK+oJ9frOD1gxuoVz3cexYG8svWKtspSr+q8JcctpMd6NZuo/v0KysOYyHJU/EY/yFLnWD8cv41+tqhzHjtyXMjSv+CKZKtp24rk1t07H9zeWpIMlGJLiMnvtMef5wj+QLwVuscfvFLhExdZ2eQmezjoJSsOn0a/UJg8Fn6TFDsaXvKYeuZFbcP3OlreK6zxUlGsmWFeH7hqkmy1uyLUYv5AWBVxL4TeR5V5FKiilRrVca+V1nMYXpXo10R6DtUTqhmR0auRO/aOfPQYy8BPeiLfxhQ52KNhtOYezejPytijOc18ZI+GNuIeTa0sqLfBGb16shZXS3k2xE9oY556I07WZmjhlUMd8qqZlfKX2Ig7Zh/lXzji5icl1ZtelS/guYwkVSGv7CwYy8O+EKvbJLFt1JNtWN88asXzGrzyhO2Sn3xUs56svoCrHX9MM2Ksq4n47iufHboOYgE/qR07j5QknvEb/fUivsTKsFGUIdY20Ebs6+op5MneeeWzROh/fJYI/Y/PEuGZON6xTXvDICfuo9EOWc/LsT8Ybh6fR1+6lnwe29kZJDPv6iry99OjSmcILKNXY5zYo0rq7FPJM0njjyqpIa1aSXV4VGkF0fGjSjgb2JCCFej3Cro3CHiYlEtsTNHT5PZyCeRPcwk8nmSbGUl+2kPSR1qhtOQM6fnYke6SD1s+XyG8EPTsK+04NuqlHgPI8ljSn/zjE0/90O1/85lYk4oNqdQQ/0xBX/Kxn3fEhtnqsaTLKG8I8kwH9VhSwTDwjiz2Q/y6oOfHkvIeucS8LQWxZofuUGltZ7LavrVlGxo8I4Zak62LDTfeERn2qS5AfdRD6c42Xh8pl5KzPmO5YnLOLinnbCFnVPBVUv6aHL7HcpTOvTblfnpemwf9O22IfmeLlxdNXw8v3/jZFqYaXqQt5FdAntqg5/aKR31j/Z7Rvw/8k4/68sYbllPpfDnICKE7ZvBRX6P/Zep7J+KzdrFHoErKzbwqavjqkeAiq6IbSR6Xr9hRXz6mwB/aU+vKldBZeszrtfh5ZbPzd5GjvgUPaef+2DyPrHByyBNO/GAkH/XFTxHkPeqLD6/kOeqL9XgD5eEo60aQzf6wUcixcg8I+qsIa6PgszrrJU8t8PJIWvElv08VPJ4PK3o+kMhHs5HO/J1fB9YImVLmT28YvtenA3t9TozLrj6/pY7f8Owv7yezEGuLI9YmJ6wk8XHAKawprCms44+ljm3wA5zYH/An9jB28fGsvDNRtaet5MwrKWeekDPRR2rnUXnUQ7gVysPyxB4mR/6sD5N/Z56WmXVmOP4wOcwM/2Vep85qZpgkNQuPbSYaXcnNxJlqMxHtOtRs42bp7+2YsTo+ZGVXvpC1jkbmd+oTO2qI+vCq8LlQRzPoMAWubPID/702sPGBWaynrEdqjX5WS6deR2p5Tmf86khtkvhzeEY/D+RNwpHa2crvsD2w3+Gqe2wFKhYvVCyth+7Yw0f00Ma8MjJZx20bwh+4L2LfSNNP2c35iN7GFDVmCf5AvBW6NysFy3CSe7H3cKkjeuosEYeI1cLksSpL0tQRvZfcET1bpaoItZg/EFZF3Auh9xE97lViJlamUlEky+HuVwiXjkVYNcKKjQSwemNH9K6jPLUdz3LUofMkcY9m9Bdl7NFM9kT0aGgj7tHUMZ7YB9d6HePhpqZWU1SPlvehoaxH9HikFvMXVd6YfZR/qQ85xD4opHzB6CZiVF3mQbWixxf5wVG0U+zBtkrobv95fQFnT99J2XNLw03bA8MYgBh8jM7o3yhigGGq8wqxY3TqtYA4jDB91CuUrqI81UVOYGwaVf6I5Wd/jJU1SVlG22pUqkbbfLQYh0f8yqFefhPzR9zn/Wnar0V9TslQttjKA/LHPlA2UlLOiJATwzpFYBm9+qBl7Pgc7pwZb8mPhw/EYiHuxhl+ieNzZp7FRMfH5zCk3pCCFej3Yro3GOLH5yZ60Wuy3tTIx2Pe1Qq9JTdyD6qTw2bLkt9jO1ghvBD0jIo3VVEevzsH87Icu/vsx17z23Of+LOxCvGbLnwvS9M9TdCXbJ5N1T2ZbHXs7gbKwy7GdFDH7m4sqF8W+yF+XdDzsbusdaGwri6IZcfu1LfOJrst27DxX8Mwio/dTbQuJd+BlfsgCB8rwvaFdcqJlwlQ57xvikSbom5sIzVtZL8zHbK+KdLofxHqnI+P8ZQ8SbjwnfaUnVoCSBIfHzP6X6E+5HoqeyNkS+r4GD/FFfuGo5q6xr7Di/w4pSxRhtx+vIHyMK7yQRnsE/iw082Qxyt9r4c8frrmDZA3RHm3QB5/F/aHIG8T5b0R8njD6E2QxwfbMKl2it+p/KMT27hMF0gm+gyPETBeme3VBs5auMY805Xvsa8h/0AKH+qTpJKPK1RKHuEf//5W7D0pyqfUoxf817A4j7+SsKGY7tGvJKjlLPVuD17iLPrVEcQq+djCeJ30erdFli/jKD2zbEythXtZll+UvdVT38Zb8inGgZiNsC0YfokpqhXndKKzrludybw8BSvQ79PpXq8pqlrVKxqukD8WrnAlTp1D6XjNFq00qxP9OPTgTw8b/ckntPm+COcDvhQ5H3BN6MxDOdeS/utDO5mtS34sK/OmID8dVnATssI2NnlcvmIn1Ifgmq2CqHiPvRzzeO+P+avEV+SEesGAu5FPb2NSp7d5EIUtaT3lXQNYfEL9WsjLe0IdX32f54Q61iN36uqUnXkU+sMGIcfKPSDoLyOstGdyBjPIGxR8Q4RRofsYfa4UsqtE/12YcP0YTbiULGxtvU6ZME3a/nA4oa3D0yn7w9WUcvERED59j23NFlpY/nyIwNUTtPwg5HP50FeHU/TF8iD9CNiAj32o/Z6Qco99m59PujxCy7ENfytfvJLor+hRdq7/8RNPkfpfL3QwvZLE9mcdFI3SYa7QQfQi63fevy/lxAefV+Woz7XENbFe4KQls0bisea9bB1uHepemgckJbdzsuNDyHu270477cJlTethB4JOo0HrlqTjdYBpqJi86AEmLF/RA0xprbSXnJIHmNIGMSpYMH8g3oq4F1pq/8pIJ53ahMcmsrN57C9vwq+CBv18yoOoAymYdrTe6NVjY7FDM2rWqL5HFJs1xmRjJ8fBLe8BH3WoQ73LaEzod31OXbdMsq6XCV3VwRgONQVXSzOHGsP3+vJFzC5HFWv9LfeNHrQKouK9Skhv3RxRuHPa2Oz8XWRaVHBP9ka172JJrVfzfg2uV/P68esBi6dFb4C8vNMiK2veaRHW402Uh2+1uhlksz9cL+RYuQcE/VbCul7wWZ31khdr+Yah+JLfFwseNSWupPwNobtFJ4k7862OWDcIrJL71vOzRirDV+cMikQqdW5A7UerNsd76JjHSzg3CTk3CTkKa4sj1uVOWEnihw6nsKawprCmsF5qWOrczQ3Eh/0nP+iMMXVF6NQv754m8qftMVq++mty+F5s73QFycGFIdxgOnhCmwdtlHYcnR86Nfp/geXNI61rdaSWX2eHZ+6MbiLeIoxjgqFmGzfN35Cev6WDfW+sDvAMYawO3kF1YBhZHwkw+v8f6uB5qgNc3MHxd5o/K3nsI8MhRPfR2Ud+XCw/K/14Tqh8Eu28LkXeT4nVmQl8FGG+8jscd7LfZR2nZvFTtInyU17xUVsOsSdNjT/tSVPecjD694s6z+Lnql7HX72WsV6d4sn8iX7ERPkB1he/XECdd6vQb8TCus5Sr+qRRa7X34jUqzqkgHpyvRr9RzPWq9OXB2S9oq2y1GvsMT91Lhrrlc8UYT+5nrBi58mSlKVe1ZYd1+snIvWqVsljcdjo/1MfxGG0VZZ6Va+NzVqvHIexXmPfSOK2nDdGG1bWGG30fyLqnMfIHBfS9FN2c34Bw/UpaswT/IF4K3RvXgqW4ST3cJGbTc5vMEV6ZXKj/0xkJ/4ywZ+k2FFRjxe8I57pg/cQf7KPmvLyqWpmsabUq1ucAFdNku02VIRazB8IqyLuYZ5yVdxf5AdGcS8Ve+jP0xFAdCGeKajIp0b+Rm8j0LTRheFVif5/RnqhXrM1jtY3C3ocGfPDzViGmylP7c6wHOwdMfKvo7Ia/T9m7B1N9kT0jmgj7h1xZ2lQ0LO93yDo8WkKXoXBpyliTfpmktMrdLD/Kz9Vs281Go+9LKTXrIz9C33iJspLezXvUexmOw8fTE5SFfLKrpRgedgXYm0pSWybmO+gbeqht59gu7yJ5MTiUpJivoCrC7wapr4vtVHgGv1WwBoUGG9p0fMTxbMWHPurzpGossXOL8RWFVCfsdAd4/lpHuTDsw1HsZvtvH5ducvbF1jd1kO3r26lPByG8kofxi2zd+ITvzunk049+c1/TVe+xyuP6nWfvBvvIQex3kRycKiMK5ynLGjjsk3UsPk1resq0V+6oM13aus69h27KuWthXY2bWU6P39nUb1waCx0+wE/QqLKifbjeGD054Ken4H2kKQJ+O5eXbU7jFvc7lSMQfq8faTZRK1cbiIsdZ4LbdrrKWGuM8PjJ3RfB3XAs2IcS28h3a/OqbvqT1QcMd6j/VQrjoyRDhzP0/owVVdqxr8lBWtA6I/tlut9UMhW9OYTeBBfxecq0V8FdTV9pcYMKTpsStF5OIX+RtLB6K8T/hKLA+j/PA8y+usBkz/E0wvztSmYN0TGGqqd4i5p3v6UxxNoR55boe7cL94E8pn2IpKPeejnLDdE9OU+tZe+3N9Y3g7or25tXY8QXs5YPRirq7OEvlnralOkfIxlfNXQ7Y+xNoL2+JEFGnMoJ+bdok9XY5Vbm238HSnjkSTFlv14nMPt8BQak6ixAY9JHhDtUfX1hlWur698Me8L/HrZhmNCr2/s8hgb+5vZlDcZfemb5nTiXh/BTa5Xkx6xMV5y/YrWNcfhZiQOKxvGbK7miGhXfiMI1scNlKd8drL9EcvP/hgra5LyzofZH1X/ofyRx1kxv0lSzB+NN/GhTTS2Q135bUk3RvTpNeZOW78cTqHnmG/0/yoy7lHrP7F5Qq+1Q372AvulNwQtG9sl2oRfrmv0P5kxHjuteciX66Ld2P9jNkoS2/QWQY+2MpvUiR7tq/z/9ZSn1pFibTZr28D1udUUqz3X51SsNvpfybk+F4vVE7U+F4vVE+mr/bo+h76adX1uYYaxQGwvQPnj9UJ/ta7E9Y58i0Jvva4XetUFPz+jNhFrgyhTjTm4PHnXKJCf37K1xbE8Smf1AnRc6/xDmluomIO83A8Z/V/DXOkFmlfg27l4bJfVp/jZ2tjaTpLsucqJGwuGoeM9FuTxHvZj/DJ59eY89D3s047SNNv8puNE2AvbM9srFp+SlGVegW2CP3Oo3h6r1kz5CI+yZdbxAb6x8Wuze+uvPpmW1T/44w59tHd23Ptm9oW8e2ccL1GOipdcxxhfsV54L8novxkZ0yk/iPlNr7mW6ZPlDIBaf5/AGNLXfsNnANR6YFa/4RiC8Rz7aOu/Y+O3SujsJ7HP5ef6FQ5/0KJC96fDfeR7JZWZYzdjv4rozX7DKfS8jm30MxYe+xvb20jT4dWkw9YeOmwhHcZjh9BBjXl4DzbvZzORf3MKH9s+NpYeCd3teiKOZhp+LWg/bIRMqRJrT2qswE+6qHivxgUl7XKDesImkE5qj0Y99Y11zmmQfqPOiS/OXNnGZTrWR705d7LtsJnyMJ7bU5DqXKCd9Shio+U5bKTGBseznW8ROqo55vFq51uKyYu2czX3fqm0c14PmGrn/dnO1VhO2ShJjZAtxc7VlXx7z/Ks7dPwa6HbF4q0z6xz2JJva2nMCsfGnRyDz4dr9bURrC+v+ouNoya7/sqOo1T9qXGUZ/1h28pTf2qtdj5cYx6WJ7ZWi/yTtVY7n+SkrdXeurDNg3bIu1a7c2Gb77bWtVqr5fVYda50As95Dk70emGZsx+8DjAZ64Wfn631rwDuawQvt22k3yr0MHprc2kvjjVePke2G+a+T6ecFUl77ojXv4z+YcCc6PUvPmOCdo49AxNb/3J6Bmb58X4Ghv0ezzvwmQ5uX0nC9VD2T6Xr9SV05XrEuno9YRVdl32b8MsJfB5ued63diibxt7a0cumPIdCO/J5VHVuKxZ7i6x/3kr9F9bZxgwy1f6bep6PY5355Xug/vnMM56TMnn4zCv3z0b/U5FYp8oQ+1hur7N2sedDbojwYbscEbIadvG9eDI8851pQhafNzfaXwA73bpC61JhfXqk2Nsqy455K4QXgh7T8xsmC87Bo2+YVH5f8suUy7LMydQZPawvNdbGMfCv0hhYtTGMOxe2rrmNfQTGwL+WghmCbrexZ9VRnysy7O967P+rthvb3+V9YbUOYzrgOXc1VuIzaEb/W9A2Y8+E+ewnV75+vMdF3Pdhv8jzAeVfaV+3RBulnXXlfTCj/89iD8r0w/6Uz1Ruzql72jkSbovYNrgdq/Vw1eZi7R71tnPv3O4/Felbe53PzDt/5Ocy0ZaxNQw7j6nai9FNxD76ZJ5dsrpVZ5f4+Up8lsJkqthr9k58Yi3F3qzPX1QE1qDQo7V03PUc5pcj/tWrX8l7PpOfgcp6ls7a/gSejZuT9xndrPs6WfwR6zbLWS+15tXrOZxaSt+O/oK857WuOUZ/I+e6Rmw+nPUZirzv9uA4huM2fuZWvVcG9eJvkxj9/844XnBaR1l3vN8rw30uPuPAc2Xl62jTXut2XGdp86nhlv+p8YJ6tjTLPN/rWYqfmXXsOhbPsvTjzItxYziFPu2MzyxhL471afOSNYRp9HMBM8vcP3a+v1eMjPURvHamxjUTOD65tJ+fs+PxCbaNiXrO7hnyfxyL8NtyN0dkMi/KSfN//kyr0a+O+D/2lWp8vowwjf60iP97P9/C/Zp6TlqNrWLjJ6e9r8v6ee9rE+Wp5zvYD1BOkeeeH5nViavG58jbaF3z+Py1Of0LP9I6Wc9PXUN56hkGrse0fobnKUa/AewQG285zQfm9vOzMrzmpeKnWuOIxU/VX3L83BQZb10D/Lzncl1O3bO2N2xTd1J/cy3QcX8T299mXmzXaf2N4XHf8IZIf3Mt6M77Saq/Mfo3RuKBil2x/kbZfpMol7Ip90Wou/mCap9GV7J9zsv7no1YWZPEtlGxFX2X+xuMh9dSHrYNHstcK+Rk9X/0oa0t/y9n171H6Y/q0mxjDwpKw68S/f0tn6yBnva3mkGPb//cNz78vg/92R/OJv4kWR0lezZJ/e9Y1NahArQPL2rrvhv2uCuh8x3C/H69Ycizd/wl9E8uat83e1qelcuSfR3Q9BmBPKvfAbhn9WvtaBrIGa9LknsAyvco6TYQ0c2+Tlgl2mYLY4Tk5GyTgesMsczGmDcNdD20qBgd1qe9g4jrE/GwPo0O2/5wRF+TlfhfUf9ec+Rd//aKz/3L+l7+XRT/kzuu+61tl58/c6LwL3v/Hz6waN1fz58o/N/f8Xu3jM0KAxOFf8Z/n7fgx//62n+VJ76YL+C5a+OzNjMT7udoM6Oov6VBuof4NdIlp7zxPfaZJI/Lx3vsY8XkzagQP8pDTNPHbF0XeYbV6uo6xk5IPwZlQHq8TlKV7n2AxrR1oOWvqNVFefAexuH3pvRTvwFx/JfpmTuse6xrzEPZyo/rKfwhFO8PLW9aJG8kklcT5bK86cD3ZuKbITAT3X/pxPb9hM7ater/3t5s0yX/5kJelr55DsiZGzqx5vXA2kJYyD+PsOb3wOKv6SG/8ZqvmT0ua9kpsctv05ghZrN3NDXex2nMgOfQy44Z+Hw56lNJ+RtCd9xMErcFxOLndGYLOSXLNzNrfDf8GulSNL4rH8LycXw/oZi80QrxozzE5DpdIPIMq7W11hHfkf4EKAPS43WSqnTvTym+LwBaju8LRHnwHsb3F2icgLYv669oG6s/NR7BM2d/QesC2L5VX39Xi5fb+JkQM/6S+if0T65bVX4PP0O8EHQ7MvxaKNVuKzG/xvJxO1pQTN6MLH6H+pitF4o8w7Iwj/WO9AugDEiP10mq0r3/Qe0I2xy3o4WiPHgP29FfUztC25dtR7FYNBHtNUnWJmO2wJhs7dDaGNb7QuLDumKfU3W9SMhW+IbRK8Z8e5Eum4oxKItj8lyIMd+hGIP8Vn+x+DMWuts8v4erV3u2OuD2OCzoEa9K9JVWudTar/GjrVAvPmc/PqYDTF77VXEDx4y8vql8UcUZZdOFhDUgsLA8vP+gbIrt0/DYpjOETdXzbPxMPbblOZSHbXou5eG8cx7l4dyV5zE4F+U+G+ei6Ac/d2L7fq/2lCTus43+hIiPqBigxoRGf6KgXyTKPRa6/eJEykM+9q0TIY/Hgotbv9EOqNedzWN/q0S/FOwQ2y80vUruR4yq/YjFQDDUbOMm/5ZA3qCg57o4SdAvARqzSZ3oVXtVbR9tyu3VbDQs6BGPxwmnRtortvfFpPv8nLqPCt25/+I29e3IeDZLn4G4s4lexTfVl3F8Oy/SZ6gxfKzPMPoLj2OfgXZZSHlp47Gj2M1uzJLtc6Zqn1h+bp+xsiaJbaNiK/qulU29Y3U25aH/LyA5s4WcrP6PPvQXNNZWax/812TyPR4DI5atscTaEvrc1ha9Gnfw/KaX/24jLORnuy7sgXUbYaWNndN8AbFuJyw1To/1wYh1B2Eh/4mEtbgH1nbCQv7FhLWkB9aPEBbyLyGsk3pg3UlYyH8SYS3tgcVzLORfSljLemDdTVjIv4ywGj2w3kJYyN8grOU9sF5PWMhvvKMCy9q0rWWcDPcnYs3T8GukS05542s1J5M8Lh/PC1YIXeoij8ekK4ScFUKOwjrBEWuBI9ZCR6xFjlgnOmItdsRa4oh1kiPWUkesZY5Yjdb1RK+R81x81FGOWgtT4+AGXON6nBp/pGHwOrnaC8P1uKdo/cD41bscUFaV6H8N1uOeaV2PCf7YmhuvC8TmSrG5VZKyrMdlmVu9KzK3muh5kJqDVoQc9pMkea2dvScyF58t+Cdr7axKebh2xuv0uHZmNsW1s6JnwvhMA5aNzzRg2dSZhjHKmw55dcqbAXl4puWXqDyx82lYnumUh+11hPKw7qZF7DCD8tAfhihvCPLMJtNDvN0sh3t559T8LhhsB/x9FOTj2KXWNE0HG39gHEW9eP3R6D+Wcf3R9JqI9UecOw4127jJPzUXRHqui9h6JdqkTvRcLxzflE055pmNhgW9ivlG/3uRmIf9Fa+djubUPeu7VrBPtv666DnG/3BP7ZzPvn/aXX1yjvF3UX9Las73Ej3H+DsV4kd56hyjyasXkzfI63JcN9gfY2xCej4HiefX5oCwKt37EvU/2O/yWiWep+S9f8wbFPcGjhOWWkNFu1mdJXb9c7IF+lsl5a/h8j3WEetzsuctqj0k/xohUzqXx2uGgdjoNzl8/+asscTwa6FUW6vEfEyd6VVt03jVGvj9zTZdL/9DOQrrSJ9i7XPEajpiHXTE8rTXY45YTzhi7XfE2uGI5VnGA45Ynno97Ijl2R4963GvI5ZnGzrsiOVZj56++pQjlqd/HXLEetoRy9Pv+zXmeJbxGUesex2xnnXE8rSX59jE07/6dVzo6ff9Opbb44j1uCPWy2Es169+7zk2merT8mH161iuX2PhIUcsz1joWY+e9urX8dd9jlj9Ov56xBHLs20fcsTytJdnP+TZhvrV9p7xy3Ndrl/Xhjz9y3Ps269jzH7sO5Jr3lPy6DvGUrDxOrY3q+RUhM5qTxfPaI2E7vLm2dc1/rkF+U1v3L9Ve5h8Hgv3tiopfw2L80xWjbBy6l6J6R7by8V9ayxjGtacnFgjIq9IncyOlAvxRyO6KD3Z58uUedgRaxphqfZXF1hGr96/o/wg9v4dqzt8B06OuhuI1Z16R88MKNOe3Xffc/fufRu237bnzmt23snY2JTQPDcRnT0iNRC6XXxOClag3zfRvUHAw6TCaC1FT5PbK4yq44+TFa5HBZ/RlTyCk/mT8YZfC91lLhIe6yQvzS7qeI7xqmMwP9wEYaHzmEvyO/baLtV9lOwKb89qX8P36n5iYTpJbN8sYTpJDzTbdGVCa5Le5oh10BFrnyPWw45YRxyxPMu41xFrhyOWp0/sccTy9Im3OmK9HHziCUesA45Y/dq2PW3vaa9HHLE8y/i4I5ZnPXr6/X5HLE+/f9QRy9MnnnHE8vSJqfHXD0aM9uxrdztivRxi4bOOWJ4x5yFHrCcdsTzbkKe9PPu0fh0X9muf1q9zK0/be7YhT3t5xuipvuMHo+/wnFt5xsJDjlhTawrHrw152t6zjE87YvXrfMjT9o85YvXreqHnOGcqThy/8cRUnDh+tu/XOJFl/FWDe1e36NWrf+eETqy5PbD4U0nIn+WzS4jFn0pSRzqMb36KHHy9hvrUUpJGQ3fZKq2/JT8hNFghPNMZ7yF+TZShyD65+oQQlo/3ydUrnesij49wxT4dhHIU1hzSAf3Uyf4DRe0/p5i8qP1V+81r/7TXfVl+ko6XzaYVkxe1GZaviM2StL557K963SEfg1M6qE8G1QX/JHxK6TVZ6+Z4fUpJfSLMeOuUl6QHm206zhsU9wYiWHscsR5zxHrcEWufI9ZeR6wdjlhHHLEOOGJ5lvFhRyzPMjYdsQ46Yj3piOXpX57t0dO/PGOhp15POGJ5+v3LwScedcTy9K/DjlieZfS0/SOOWJ5+f8gRaypO/GDECc8yPu2I5Tme6FfbP+OINdWG8mHtdsSaakPHz/aec3fPObKty/MaUJIaIVOqqs/fVUInLn8OuBEypczrfoZfI11yyhtfW8r6uT4r+yKhS13k4ecHC9p7kD/VbdiIizInwt6GXwul6nfc3rFPMxxVrPWXP0WAvHWRx/bmT0k1Qqb0iPoEAtscP1+QwwbXZLW54ddCdzmL2DzrJxus7EuELnXKS9KuZpuO8wbFvYEI1gFHrCOOWPscsXY4Yj3qiLXHEeuwI5anvTzL6KWXilP94quHHLE827anTzzhiDUVv6bi10SW0dP2Dztiefr9k45Ynm27X9vjIUesfu1rPetxryPWy6EfejmU0VMvz7jar/32PY5Ynnp52uttjliPOWJ5jk36tU+bao/Hr4z92m+/HOZpnj7xkCNWv/r9QUesQ45Ynv71lCPWRMRo9Rlkfs5CrfcvishBfv4UM8qZU1LOnIxyppWUMy2jnAUl5SzIKGdhSTkLXwblGRV8ldbfkntAMyuEZ3riPcSvhe4ye+0BKbtY+ZYUkzeaJb6gPmbrk0SeYS1t/cbnqZB+CZQB6fE6SVW6908tkDphJok//XuSKA/eGwAdX2xlsK8kqREypfN5L850QVy0QY46Gsvqg4ZfC6V8ohKzoepzrOxLhS51kZfmLyhnqZBTF3lc71NYU1hTWMWwSsS/OvcLphviYgyYiLMvhl8LpeJtJWZT1YdY2ZcJXeoiz+ybwd4Dfzz3zXuGf+FNt5+xeuZlX184590HL/695w5cvHotx1zDRlyUmaP81az2NvxaKFW/4/ZeRvLSfNjK3hC61CkvSfZMZ0XkDYp7AylYqu8qipWkNzWP/S3R7i5g3zPdELcB9yei3TVa17VQyu8qMZti+dgPlgtd6iIvR7vjNDMQb0Pwzj0nfHrZFy7Yd/oJF+7c9NChL9zwobfO+/lTv1Jf+A97XvvQ//rczhHSKYSecs3c42WdAZlvbh77m4xhX9FqKGbDamjnDRJvcm02rBL9byxt8716aads9AP2sQG4n6PO12b1McOvkS5FfWyA5HH52McGhS51yksSP6M8KOQMCjkK64Aj1pOOWE84Yu11xNrhiPWUI9YeR6zHHbEec8Tq13r09FXP9uip18OOWPscsQ47Ynn6xCOOWJ4+ccgRy9NenvHLU68jjlie9eipV7/2HZ716Gl7z7btWcZnHLHudcR61hHr5dBve7btiehrbc8N52M2eR0jvuR6lPKqkIcYmIf6VSP6IX81hY/LYfPJYcpvhEypYvwjxfjHP/GJ7xIbFDoZvs0Ph1CJlL+GxXkmq0ZYecse0x31i+1582dDFda0nFgjIq9InQyH9HIh/mhEF6Un+mKan2MdcrsYieiF9GNCtvGajfAbmzlsNBCzEbYFwy/xeVMzz+lEd3WzpUvodqVpKViBfp9O9wYBD9MYYahwxc0urRrrKfxJGo3IGRV8Vr7poOMKyOdPsK4QOq6I6Ij8RqfkVErKqQg5jKWWFpO0s3nsb5Xof7u1nJj4wvOLOjFXCv1iTW6VoF8JNKaPso3xjgrZlZS/JieEuA+hDtxFrHKUswpohknOKY5yTgGamSRntaOc1UAzCnzJ7zWQh35mepwq9LBwehrcz9vlIJ7pg/cQv0a65JQ33nWfRvK4fBx7The61EUex93ThZzThRyFZfUxFrrrhz8DvUbIWRORMybklKzL09lWmCxvbegug+WdAXlYv5wG6TfqnMS8mSvbuEzH+qBNTbfJtsMayjsD6O1125Z3JuTZtmYRGy3PYSOsC9Pb+hwb2nwdtrP+nrazqkJnNZznT2SfLPIS+l9afuxatQvu9/O2C+Rfk4JVBazpgGV1VSX6sdaeakm/ulP5FcfhtQWxs8Zhw1d+bHrVRF41gy7vXvMPc3759v/9mQrxmy58j8cqZwh69Rlys9WZwJ/DVreN95vNNr/Jtrwq5K2lvCHIMx2SNvlfTu7U74yC+mWxH+LXRR6+CjtPXdRFnrWLsljY3jywRgpizQ4hdUygYhIf/c8bk5A/NiaYU1LOHCFnsvvCuZSHbQD149Srv9tXckwwFrrtwI9AqDEl3ost4Rid2ZvHlI2QKa1lm2JSNuWlHIyJaAdOyt6mc4L5XA57o01Nt5L92RlqLMVysaynUd5ZQL+12Zl3NuTlHYNZeRIbfSyHjdAfzqS80wRvSftlnpcZfi2UihOVWAxWbUj5svHWRR7aj/1iUNwbiGDZJ2vGBDbHhLzzv2lC58luCxwTzoI8rF9Ovfx9Zkl/n2w7nE55GBN4XuYVE5YXjJtnEq3pPtT6jWsbNpeqEu0vnNzm2bysUxb67E3Nzjysj1NB7tYWxljoti2PiVD/QXEvNiYyOiVnTkk5czLKWVNSzpqMcqaVlDNNyLF2he08R7s6W7UBS5Z3Tugug+WdC3l5xxymc94xB9rUdJtsO3A/fi7Q85jjPMjLG1/QRh8rOA4+h/LOFLwl7Zd5zGH4tdBdl0XGHGeRvLQ2xPWLvHWRxzHhbCHnbCFHYfGYA7E5JuSd900TOvdTTMD65dTL32eW9PfJtgOvBWNM4DGHV0xYXjJust9V4Z4aN/D66Lta44RkzPAOGnfguNtkJ3R/QnRrhN7HKx6tKSYvGo9U+80bj/jISZl4FBuj8CsO8o5RFgg5k90OF1Ce1xhl5g/QGKUf4pGK2ex3WeOR0f867dcUtHXHZ1kDYU2No7LHLZxflo1bsfVzfmVK3nHUQiFnstvrQsqbGkf1Z9xSsT3rmCdrfLu52Zlv9J+G8dZ/SxlHoR4J3YKG1t9okzQVtyZuvGV1MRa6fYTHW3nXthcIOf003pqsuIU2PV5x6wzKeynN/0z3rPHI6P95EsdbsbMzBc9bZI5bhl8jXYrGLdXO1d6S2sfhsx+Yx+MtFR/PEnIUFs8TEZvHW2rvL3aWY6HQuWRdnqn6N0vKjjzewpiN9ctJtUnTOW/cQpuabpNth7WUh/GO49Y5kJc3bqGNlhfcT+SYgGMe3DfjMc9aIaOknTO/co5jR8E90GjsUG0tOQduZ+Bbj69csX335j233XP37Vdv37dr3X13bN724O67t92z7o47Hty+axcqjYJmwn3Mx8Q0dj1b3EeMM3sUxh6YUYOnMwnrrB5YWwgL+c8irLN7YN1AWMiPvPh7KHTraRu6AxlwuAEqvbaSXhjUuNM/twfWNsJC/nMJ67weWLcRFvIjL/4eCt16sr1iOMm/C3rodXuzU6/zgf8CwrqwB9YdhIX8FxLWK3pgbScs5Ede/D0UuvVke8Vwkn+v7KHXjzQ79XoF8L+SsF7VA+tOwkL+VxHWq3tg3UVYyI+8+HsodOvJ9orhJP9e00Ovu5uder0a+I1XDbD4G2p5B1jIzx286gz5r8nhe7FDufyu4dc4ykEse6eX2eG1wI+xdVTcMxnW+b8O7ufojDO//8/wa6RLTnnjnf/rSB6XjycOFwld6iIP+1XMQzkXCTkK60xHrNdSeXCShO92u6nRKdPKig9gIi8/8GH0z8FBqje0MMdCt6+8JkMZXyfkGf3FrfvDgh7xqkT/5saxv8kg+h2tBlcXOl2Uogv3p+wnRpOkEZI9UW3E8Guhu/6LtJGLSV6av1nZLxG61EUejqUwD+VcIuQorHMcsV5H5UlrI/c2OmUWbSMPQRu5v4XZT21kT+PY3zJtBMdQo+Iet5GCPpu5jRh+jXQp2kZUXWD5uI1cLHSpizwcP6e1xYuFHIV1gSNW1jZyqNEp08qTtY0Y/a3QRp5sYao5BrcRNV85X8gzequzYUGPeFWif7Zx7G+vNnJBii7JNY6bR0O3/txGCvps5jZi+LXQ7T9F2oia72H5uI28SuhSF3k4Z2I7Dop7AxGsLHOurFjnU3nS2shPNjplFm0jV0Ib+TctzH5qIz/fOPY3axtRuk/E3EutL+B3LNJspHy3LvgvoLy1Qk4vH/lQQ+uT5iM2f68S/YXgI/+20Vn+vHYeCaXiQuY4ZPheC7691rA4Dl0odKmH7pjG30dQ8U6NCSYLawL7lKGXSp/yCqFLnfKSxPZX64uvEHJeKljJNX9fSY3Hs9SrkoN+NFnrZReQnAsc5SCWxWX2KQ85iMUvCEnrGz7daOMm/2wMk9Y32BpqlehPgb7hsy3MEaLJ2U5fZ7q/TmSqNbULKQ/nHOxHl0Ae1/06yEOf56Q2Vq2syThl9qo2LtNxObD/vIjyJqD/zHzY4qXQf7L9OB7l6fOSa9sXUGObk0jO+ULO+RE5JwmdS9Zl7nZyEuWpdpLV303nvIctlL9Pth14joXrF3zY4hLIy3vYAm20vOCBFF4fQxshHcZtNa9SelUEzvlEa3kDgrfRulZzoaUkI+9caKnQdwLHopnj4kthLKriYpkxX555HcqdiHmd4Xv1SyqOq295efhXWj1cEJFXcAw1/p7dXvv/Ji950ddw6K5DdVaB9XoV4Nu9tDYfO1dU5twHnysqc+6DzxUpG/A61XnLj/1N4vCK5Z00diZmNdCsal2rmI9reecQHZ+vSdJI6K6fiWh7hl8jXYq2PVUPWD70zWkh7iNYR2nnrc4VZWGfPaeHTuyzSpaqUzx/xnWKhyvXAt0FEbqzBZ3CSH7j+T/DqBLtK1sYiZ1PW9VZRnX4s0J5SVLzxtjhZn5BzAS8mDGzbxu+1+FydVYo6+Fy42WbJYnXcooeLp8orCxjhILnbzKvF/IDTmXHCL3OtBZ5wClJbP+iDzj1K1Zyvbx1zX5u+eqvyeF7ZWNJUTkqPk/kumSSeL2QzyGrv1nlqJdtWdvE/nIi5+D8EAGuRXBdXgJ5bP91kHc25V0KeXi2jpOau5sdkv7wjAzreSUfZOh7++V9iBAfNJmyX+f5WE6e9iv4MO85pvM5ItPycPzM9sO5ANsvtkeMY3jsNzgpG+HLn/OsuaOPWZmSB3Vs3t9+UOfq7ftu2nbP3Xds2333zvu2bH9gz/Zdu6uEzj3N2hQt7bdZDnFCROskDVAev4IRT8yrNCr4TIZ5Dlp/IlbODL8WSrX0SmxUoh7TZs9G3rrI49eOqRnhOUKOwrK6Vq/LWEZy8r4uY5nQebIft15GeRgh8va4U6/L6Ey9bLS85KP5lodx6NZmZx5+tYxf8Xwy5OGrLmKfl7DPDvHX3P9ji2eE6IqOAmKvdC44s39d1jiXNhNBvdQqQ5ZPPJz35U/MH/yRO36pErr7ntgqg9GrVYn5gr7kaOzV5pP4iQfs+ZNUhbzTKW8I8nAkxJ94KDizf3UW+yF+XdCvb7bp8tSFmlVyn5MVyz6lgK8ytrajvpSZ5ZNiI0Q7UeMBw6+FUm1+fDwQ+9Rakng8sEboUhd5/NXFvP00Ylk8VXXDr6HJ+xXTBULnknV5moqnllR849fQYPvE+uWk+jrTOe94AG3Kr4CfLDtUKU/tLqkxed7xANooz3gA64L7q6rgPV4xoVpMXjQmqDaUNybgJ73KxgSO11g3/IoX9fnJlRE5C4WcyW4L/IoXjAlYv5w8Y4Ly98m2w0rK67eYoOIm6z4kaFe0rqtE+y/L2zwrWuM21e/ZpzvVJ1BXUx7WY5XyVgmdKiQDT0lhbNjZ7CyD0Vdbeie2/MzJGnMgBRPrNEk4Fsa2eFQO5OXwwd9N9ProyW05aLMkDTU7dVZxCul5vqA+yYSxy2xQJ3oVI1Xswk/A2s66spfpOBH2Qh2y2Avp2V6nCnoV6+uh20ZDhDUksNCGMXuZjhNhL9SB7bW6h85sr5g/og1Uv3kyYSl7YXu8mnQ1/mFBj3hVom9ATOAn0jCucV2vENgYGyuEgeWYIcoxSnnIm+C+YmknrjoJpk4sG716qwo+qWh9hHpzjPGOCL6J3NWZyCcB1K4OlpmT6pvNDll3dSokx3DR/klinzhd6Kie+rggI67RqxNbMR9SeuMpNfahC4Xe6i1Ha1PkYP+OZUt7euUiaMv2qXcVT012yXg6puIp2ojjqWqzSJ+3zfKTFPgELZ8mRhubTOVf+FTphxqtgoZO32BZKA91Rdy0E8zDKfSGVyX6a0W8jvmzOo1b1J+xDGX9Ge11V7OzrEZ/w+T688yJ9mf1pqXYE/749pDzKU/5cyV0x7C88RVP69pT+UWfoI/5v5Utzf/5CXqjvyPi/8q+6mkpo4+9PaaX/19Eeci3NkVOWjxn/zf6HRn932RPhP+jjdj/s74VyegvEfTq7SzqjUQx/7+I5Hj5v725JcubiC6OyGReLFua/xtelej3R/z/EqFDrD7WCfpLgIb9H8uwjvKQb22KHPR/tBf7v9EfyOj/l7TuTYT/o43Y/y+FvEFBz/ZeL+hx/M1vClsPefymPbTxOpKj4mBW/8c3eN3bOHZd9E1cMf9Xb+JC+rQ3cb0r4v+qDaoT31njUcz/L6G8tKdPkRb9H+3F/m/078no/yZ7Ivz/EiBg/18HeYOCnu0day9ok3robhsx/7+E5Hj5P78BstLKwzUNW89Okp03qRL9R2mfH+2So36uHQWeABiIXXCP6doK4YWg97R4L5DlJUntd2U5D7L2rQ+fsWzf0NkV4jdd+B77l1ozO1HQm62GSfdGyJSuVm3QZKvzIFXKw3ZkOqjzIEMF9ctiP8SvC3p+aiJrXcwOnb6A/j7W+jvcBCyQk6Rprd9VwEB6w6oS/W/Bmzt+G2LY0XtCXkL3QoSukvL3KIa4V2123qs1u+kHm930Jnt6s1tHy5sBeeg7R2lav9FeiFWDfKT/Q9jDStII8Bh/XcgfIfkdeot72EYZa1DcM/qkfj7R0rFm90B23v3zJA0TP95j2eYb00O3b6LuWKemn9Ub2pTrFP2jCnodldn6jXWKWNhGkP4vqE6xbMZfF/LRLixLyec6Vb5eE/SJXf8r2LVGOFn7iU2P7Lx/y599+bPqSxAmqwz+/9y4/6c2f+qdz/fCT2L2DhiXcUzMG0P4vANi2fm8kn3XgPHjZ55Ddv4Kn6VFDMMeKabb97KOQQy/Fkr1k+PnakZIHpePxw21YvL+T/Lkt8UTbENYl2g7lDONdJheUAc1djGZauxichL5d6zq1KHgOPb/lPThf1HjYHwb2DdpD9Jsh/MvNT6pEv3/gjHFt+nMB8eUJE2H/Gki336bvQcELX++HX+b7mw3pDefGU4p6zCV1ei/B3PNpxdpTLQf6jWQgjmwoo35PGGaX4UQb3NGP0PQYxswfcZCd9uZQXyoey10pg79g64TpEUdkoTnqKcR7bQUOWwPpcOIwFH79DXSFWWyPySJ58KDQg62KezzSs45h1RfYsny+LOZmIdlu6XZpuM0SL9R5wTjCzQPQDrWR7Ulz77f7g/BfZbL8/9houWzN6jjkIOOdSFnmHCnRfSvEE5V8I0G3d7U36z6VoS+sTWVonIQ64eax/6W7PMWm57oJ9jnnbqijZvW56kxB/d5Z65o861tXffq8yyPx31JemOzfY9jOo+jECNJfF7DYuQw4CPN+Pon0Z8H/dDTNF6fJuQdfQsN2dOw0/rAGsk2+q1gz1eSPdFefP6T43iA39NBF6RNkvU/bINLQI/XrUiXZXYdjZQxwbh0haZDHZCOMYr2a2p8xW03y/iK2yryKRkcj9P6bvONGT3yp4uyBXFvQNCPpJQ3CNm1HrjTBI6K7zXKq4g8jj1YXoxbPObAuIBx69RIe6mEznJNp3KNRMpVEXzczlH3aRHdlf0wfhRdgxipjO753klv+chErXH89Wu+/r/2Xzz4xETh3zLw14t/Y+kv/UyeNRSr52GSZddob7yPYw/bj+F+7a5WfZRco5Cflea4EZufof48n0vSDSn6PwHx+x5qF2p+otpMWv87lFEXo39AzOvUugKuWRzFgbwcNq+qfUmMa0PNNm5avEX6vHNLs0k9dMfXLOfc0aY8pjEbDQc9v+dz20b/KNQBn9tWsdnysOwcFweFXLUWaW0soflxalcFx7fT1DjC0mhIj//sD1hGy+O1MsxT580rQgc1h8S9u/fAeIjpLKn4wO1VravExouq3Rl+v7U78/166K4X9resPpw2nlPysH6xrzYfTlvTxzaNc66fojnCMGCqNS2Op0b/6xDbf4ZiO8YX9gcVJ1iXEHQcyjKXHxV8Vi9qHyHP2g/WL+qJ9xC/FkrFlwrHW5PHdcRr/QXHCVXuY1GeqodZQdtU7QfwXFGt98TmSbF4otoft021jqD6kNh8zmTjmnmWcZNqW8jL/eS/h7b1QmTclDY2CkHPA5g+FvtQV2X76ZSn5v52PSMiR+k1KuhnRPTCmIy8LLtXGbL2VU5jxCHVV2GdcF+l7IL0bMeZgn4UaLiNzIS8GZSXtW+bTnlq7blX3/ZCSh+F5cD4x/Nb1caw78P+skK6oAyc/9t5xwrJGA56rdLwqkT/38QYmDEtXiTp7mY3ZkXICKHbLjyvNLrPgA4Przp2HdsPKHm2ayb6jiXVbxq+17sn1LxGnf8qOQ8YjfmpGu+odRjuD3ut3fL+iVo7ShKv7X6lVfd1wkwSn59T4w7VnyQ6fonWVidqz4bPcqbtp3+VYgg+l6v2FPk8s9F/Hfrir0X2FkzH6SEeU7C8HK+tTtP2wTmmGP23IjFFje9RL34u0+j/WayXxPxC1R/7MtKrswZqTMXrVCrWqT7a6CbifDmWn/voXmuxWcZsak+qTvSqP8V2wutrMV9MUmxPHdvOV0uuEX9p9j9dfeTj9c9N1BruHdue+sB/+uN3fzLPGm7MRshvNjJfVDbKOp5grEoEa6gHFn95Ja2NMJ/JLNm/Z/7CA/fvBc9iVbLahdfUVF9cF3k8j8u7LqHWyjywuO9D7DTfVvNOtFEIejyBtr2+2Sk3do6y4NpKZh/itZWy5yizrq2o9VxeK8DYz2Mp1S+MCDmThaX6Mq7LgutImdfJ+ExsQd+p5O171fo77ytgv8z2V322Ws94qWBh+4+tn2apVyUnNgeaqHkCn8ma5igHsfgrIXyuQf3NKgex+KvCVaFDUv6rVrZxsY7Txv9p+6XbV7b5rl3ZSWO6bwKaW1rXIyA7hNxtuab2bCypvTH2W7VOaHm49sX+gWtfI5Q3BjrgWVlOg/Qb7ZDIy/K+IWXLguOkvrJlVntZWRPMPF+UQH+zMuFcPNYOUC63g7vAxx+itqXWz1V7tvu99uxj5+mMt+SzFDO4bjGpumWfwLplnxiDPPaJOuRx+5oFeTzvw6T8BZ/1yNq+HkqJkSaDYyTPjdUZP4y9Ez23HOqBlWU+GMPKOk+dmlse37ll1RGrQuVB207G84OxMsTaSewMQEXoVXKtP/PcxvBrodueRfyxl13YH9VeQV3kcTzIuubvuX8wWVhq35H9Pm0/4b3UZxhf2n4Cj6uN/v0wnnhf6zrrswrscyyTz+kpn1ExLGZjFbtU2+Nn2bKch0XbYdm2No/95XMRH4b+NXaG0+ks2dDxXvs3m6j5etpZR5Sp1vLRb98rxitT64UyTa0Xhu7yc11OrRceS1PrhfqvyeF7U+uFPnKKrBd+Oed6IffNRv8vMK75m5T1wq8AzT9OrRe6rRf+49R6Yd+sF9oHDBK+sVVtepQTwtR6IbYT5RP9tF7I9ei1XvhlMf5Wc6u0dZ6s5z6NfkGrHCXH3vJ5QjwTzfrnwB5W4wlLam2jQnnq2UE1fhukPNWusvqUlTXR65EMPpXlGYhhUY7Y8xGT8QxEkux9oRXCDEGvOcbWjz3Oez34+z//htG/eeTOfnlm9zxqYwXnRMftmd1roP96xapOeZP9zO5rW/KnntnNtm8zEc/sXgF1cDyf2b2d2tXL9ZndPP3L1DO73fXC/pbVhz2e2TUfng73h5tt2hw2GzC9zTaDoa1TtdkmNHyrvxHIM7rxdbViuozb0N7panEeMVHXAaLn6yrdewjG30f1bXbqifcQ3+hnQJ7RD8I901G9g3ZGMx/WCGFNK4Fleql3Gk8rqJfCGiasPO/GvQt8uugY7u+/928em/7Jf/O9Iu+uxX4Q17Ueozlb0efc3w3joSaNh9QeydRz7rnlTT3nHrr3Vl8Oz7n/OLStX43MNbLsm0495975e+o59zYNt5F+ec79V1P6KCwHxr+sz7lb3/d/Afexq6vTjwUA",
      "debug_symbols": "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XcbHoJH+TNvkH7jtyT9w25Pfvu3ZTeIZzMVbd58/XgggLwWosdeIftiI63YAXtvph1247geI1RPWEeHvBLi1Pu7bS/RutyK88xHOdsW6WKMz6foNTr4fQmPwKOn6edU3QvRYPjqtG758J4R9XzDvA44jvRJCDhbC/rD13zeOglkt6eOd8zdCLB/epJdOJKXO7oPjtaPI7OpY1k08vhGixD3v48asPg2R0u790Q8sUJkjTR/3iq+1BusupXUH81cb9MUQUuOredG15H0jRFTdtC6x8nIIfSlEjpv+B/bXQijrfbb8UojKDXstr7VFZgfk8uFX7MUQr3VqiRekj5eB6bUQrPdZVF8MwYl82JjhGyHijjGV/lqnlsH6I8dLR1HirWjpL7UE11WV5yfxKNLbLGMdFVlH6frto4gAHxaz/cZpxA+qlpcassa3dPXD3c39AGwlM/JrAY7/4c3lSwE+rCzwnUaMO7zXCp2mGIrL480j+NyN//vxf//4r3/++z//5W//+sd//Plvf/2Px9/77zPU3//8x3/5y5+u//t///Ov/7r813/8///u/+Vf/v7nv/zlz//2z//+97/965/+z3/+/U9npPO//XZc//O/+vmZcX+M9f/vf/otPf7/OBd8GHUcj/+fz/8+0vH473L+/3T+Ba1H+6fH2Kec/yLZn5B0/on8v//7POT/Bw=="
    },
    {
      "name": "update_accumulator",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "asset::Asset",
            "fields": [
              {
                "name": "interest_accumulator",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "last_updated_ts",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "loan_to_value",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 128
                }
              },
              {
                "name": "oracle",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "public"
        },
        "error_types": {
          "206160798890201757": {
            "error_kind": "string",
            "string": "Storage slot 0 not allowed. Storage slots must start from 1."
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgEEACcCAgQAHwoAAQACgEQlAAAAVyUAAABfLgIAAYBELgIAAoBFLgIAA4BGLgIABIBHKAIABQSARCcCBgQEOw4ABgAFKACAQwQAAyYlAAAGAR4CAAIAHgIAAwAzKgACAAMABCcCAgEBJAIABAAAAIglAAAGKicCAwAAKwIABAAAAAAAAAAAAgAAAAAAAAAALQgBBScCBgQFAAgBBgEnAwUEAQAiBQIGLQoGBy0OAwcAIgcCBy0OAwcAIgcCBy0OAwcAIgcCBy0OBActCAEEAAABAgEtCAEGAAABAgEtCAEHAAABAgEtCAEIAAABAgEnAgkAAy0IAQonAgsEBAAIAQsBJwMKBAEAIgoCCy0KCwwtDgkMACIMAgwtDgMMACIMAgwtDgMMLQsKCQAiCQIJLQ4JCi0OCgQtDgUGJwIFBAItDgUHJwIJAQAtDgkIJwIKBAAnAgsEAS0KCgEjAAABcg0iAAGAQwAMJAIADAAABXUjAAABhy0LBgwtCwwNACINAg0tDg0MLQgBDScCDgQFAAgBDgEnAw0EAQAiDAIOJwIPBAQAIg0CED8PAA4AEC0LBAwtCwcOLQ4MBC0ODQYtDg4HLQ4CCAAqDQsELQsEAgoqAgMECioECQYkAgAGAAAB+CUAAAY8LQgBBCcCBgQFAAgBBgEnAwQEAQAiBAIGLQoGBy0OAwcAIgcCBy0OAwcAIgcCBy0OAwcAIgcCBy0OAwctCAEDAAABAgEtDgQDJwIEBAQtCgoBIwAAAk4MKgEEBiQCAAYAAAUpIwAAAmAtCwMBACoBCwYtCwYDHAoDBwYcCgcGABwKBgMGACoBBQctCwcGHAoGBwUcCgcFABwKBQYFASIAAYBDAActCwcFHAoFCAYcCggHABwKBwUGACoBBAktCwkILQgBAQAAAQIBLQ4DAS0IAQkAAAECAS0OBgktCAEMAAABAgEtDgUMLQgBDQAAAQIBLQ4IDR4CAA4GAioOBg8OKgYOECQCABAAAAMIJQAABk4nAgYFAAoqDwYQJAIAEAAABQwjAAADHy0IAREAAAECASkCABIGO5rKAC0OEhEkAgAQAAAENCMAAANCJwITBQECKg8TFA4qEw8VJAIAFQAAA14lAAAGThwKFBMGJwIUBQIMKhQPFSQCABUAAAODIwAAA3otCgYQIwAAA6MCKg8UBg4qFA8VJAIAFQAAA5olAAAGTi0KBhAjAAADoxwKEAYGHAoPEAYEKhATDycCEwYCBioPExQEKg8GEycCFgYACioWBhUkAgAVAAAD6gYqEwYYCioYDxckAgAXAAAD6iUAAAZgKQIABgZLmh7/BCoQBg8AKg8UBg4qDwYQJAIAEAAABA8lAAAGcgYqBhIPACoSDwYOKhIGECQCABAAAAQrJQAABnItDgYRIwAABDQtCxEPBCoDDxAnAhMGAAoqEw8RJAIAEQAABGYGKhAPFQoqFQMUJAIAFAAABGYlAAAGYAYqEBIDLQ4DAS0ODgktDgUMLQ4IDRwKAwUAHAoOAwAtCAEOJwIPBAUACAEPAScDDgQBACIOAg8tCg8QLQ4FEAAiEAIQLQ4DEAAiEAIQLQ4HEAAiEAIQLQ4IEC0KCgYjAAAEyQwqBgQDJAIAAwAABOAjAAAE2yMAAAUMHAoGAwAAKgIDBQAiDgIHACoHBggtCwgDMAoAAwAFACoGCwMtCgMGIwAABMktCwECLQsJAS0LDAMtCw0ELQoBBS0KAgEtCgUCJhwKAQYAACoCBgcvCgAHAAYtCwMHLgIAB4ADKACABAQABSUAAAaELgiABQAIACIIAgkAKgkBDC0OBgwtDggDACoBCwYtCgYBIwAAAk4tCwcMDCoBDA0kAgANAAAFiyMAAAXzLQsGDQAiDQIPACoPARAtCxAOLQsEDwAiDwIRACoRARItCxIQACoOEBEtCwgOLgIADYADKACABAQABSUAAAaELgiABQAQACIQAhIAKhIBEy0OERMtDg8ELQ4QBi0ODActDg4IIwAABfMAKgELDC0KDAEjAAABcigAgAQEeAANAAAAgASAAyQAgAMAAAYpKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKgEAAQUC3G4ngHYSnTwEAgEmKgEAAQUohpKwR9z9QzwEAgEmKgEAAQVkYYioxs+UyzwEAgEmKgEAAQVFp8pxGUHkFTwEAgEmLgGAA4AGCwCABgACgAckAIAHAAAGnyMAAAaqLgCAA4AFIwAABxEuAAABgAUBAAABgAQAAQEAgAOABIAJLgCAA4AKLgCABYALCwCACoAJgAwkAIAMAAAG/S4BgAqACC4EgAiACwEAgAoAAoAKAQCACwACgAsjAAAGzCgBgAUEAAEDAIAGAAKABiMAAAcRJg==",
      "debug_symbols": "vZrdbhs5DIXfxde50D/JvsqiKNLULQwYTuAmCyyKvPvyaETNOICEdLLdm/gz7TlDURSpkfPr8O349eXHl9Pl++PPw6e/fh2+Xk/n8+nHl/Pjw/3z6fGi1l8Hhz/e6Uu609d8+ET66vW9dwBW8AohNojeoCiwQvINSjCwj8g+IrOwWdgs4gySgSwQXDTgBj4YUIMAQQLkBtEZJANpkKIBN8jBQAWDDjlgFAuUBhjFAmZhs7BZMIoFkoEsEDGKBbiBDwbt8hi8gY4ieIA0iNGAG6RgQA0Id9cJjAKdDMgGskByyQA6OuRU3ahADYJZglmiWaJZklkQw1AUEMMFMJyoUJxBMuAGhC8zgBogmNEDSgMxC5wHZDgfM4Ab+GhglmCWYBY4v0BpgFxdIDfIzsBukaVBMcFCDcgEMd1Rh1yqPxqNgmBGAVADzGnygNIgmqX6g+9UfyqoPykowJ8FzIJg1u8ghhXgRtVBDCuwWdjuLuaP4F6qQ1jkC2QDaVCDWYEbIBMWsMvh/AJ2ebTLUzLQy5PGh7IKpgLgBsUsWE0LICwaOkICVMB0J/WZsWQW4AaIagUs6uwA0iCZJZkFa7kC1nL2AFjUQ0boKuBeWRNSkFoLmAX3qoAh5wRQV7OOSzBfmQCwqD+SvYFait5LijcwC5mFpAEnA7MILaC1WF0sEeR9J0hlELKqUbchJo0ghwruEJUilcQodxsC0wj3RdV1mI+FWDOFXKVsJN0mZvOYpkZs5LsNnjZSZcLYavdolDuJEcpzI/WKCgjFhWpPwqwS/POIcKNiRN1G3cbdVsexkBihUjfiRrXjNLK71Z6zEIozY0S1f3Dti8h0DpVgw2wF5HqjbkPica4EG7ptwBqlei0WaaWIVdooGSGSXCrp9xjRiIgkSyX1lOFfrNWkfor4LVTL2kJiVLIRGkej1da/x9EI2YkG45PTe4irbV+MUHnRWpTYKHZb7RyV4J/4SsUodxsKnmC8tX00SnZtbXELdT1UvUb9vtLvK2bLLnQqRt51snvkZRyvr3cH2yN9eb4ej9gibTZNupV6ur8eL8+HT5eX8/nu8Pf9+aV+6efT/aW+Pt9f9VONzfHyTV9V8PvpfAS93q1Xu/GlOlsoqPVyna9CXULX342In4i40DVcChuJciMRJhIkSLxFQ+tz7iIUbzTiWCPqjoybhnJII43pUETMDV2vw6Hk/2Ao5U8PJXOfFR7PCo8liNgkSNvfyAmZDCTqQraBxJQ+OhCtjcOBTNI85GwZGnJZpzW/cWKSobpzMgndO228YH+rMclQny0xwkYhJr5VSJMZ0XpnM5J4XfAx3C55P0nQ2AeSfOkKmnG3CpP0DF5sUkNwMtagsUYWsnD6vM+LwLZW9bIw1pDZjASrnj4n2qlRes3ILPvGQr6nBkU31AjTGkpxrTvjeIQ4y6/Q06vsUhDsy6uCZN6lcNNOyjg3wiSe2vgtQ5M26HW1yvvDqRt1c0PCJL1mRSNTz/IS07BohEl6FYrmh2aGXzV8uO2Ms/rHqS9Yzttw+HeX0OJsYkPxwxIaw6wZUOi9QGjoRZw1eVfYQhodOR5uFCZVNAhTj4dy2CkivIqI7BMRjl1EeCwyjwltYhLiUISn1SNQLx+U1nWnffs3VNitKhrloUqa7UpZ+g5K/DqcWOL7NUpfNl7POIYa05RPfYLLphC9SfkUZxuPtaIq5+HUpDTbDVJfe8rj+Z2OhdcGM16+MwWiHg3ivENBnzRLT9OxQprkV4m9nm72kjm8W4B6b6HA+wR8r8a0S6AXQQ3oLgHuArxPoFgQ2bs9Ahxsaenp2B4Bfcxat/RuOJF5tmNKaz/Sg+V1fcv7vfCp1ypPeejFRCKm/myiZyFulxfB922b/sow8qK4PxuLWNzmHGDoRfj/vKCxF/OOahPi/Ud9SG6Y3qX82axI67lMSsNVWviDkZiVay9hPYPwewr++pyoZxhpj4LubfqWMQx9oNmuU/qGUc8i4nDXSdOjJe97MPWgdrhNozTbkTjf601xJQ33RjQ/XrJV5nmz/X27r5lq5NjLb85+rDEdTVgztITsxqOZBtbxmmTbVvA2sLNDJpw091TfVq/fEkn9sCv67TPj74n0Z/APiGTnukh2stOTvC7/vOnzb0R4tvHMqdfCqL9g+j2POPpLQ98uKEfZKYJjsQ+LrIeRzqVxTGYdP8fcRXQdDTN2ekjSH5Ik7DxmKbZshPJHD2reKnzWt/cPp+vNv3C8Qup6uv96Pra3318uD5tPn/95sk/sX0Cero8Px28v1yOU1v8D0T9/6YPMnZ58fsYvfXirdV7bFN56vPV8p7Xh8yuc+Rc="
    },
    {
      "name": "withdraw_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "secret",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "verification_key": "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"
    },
    {
      "name": "withdraw_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBGJwAABAMnAgMEAicCBAQAHwoAAwAEgEQdAIBFgEUGLgiARAABLgiARQACJQAAAFIlAAAAXCgCAAEEgEYnAgIEADsOAAIAASkAgEME/////yYlAAAByh4CAAMAHgIABAAzKgADAAQABScCAwEBJAIABQAAAIUlAAAB8x4CAAMAHgIABAEcCgIFACkCAAIA+qLFKicCBwQEJwIJBAMAKgcJCC0IAQYACAEIAScDBgQBACIGAggtDgcIACIIAggtDgcIJwIIBAMAKgYIBy0KBwgtDgIIACIIAggtDgQIACIIAggtDgEIACIIAggtDgUIJwIBBAQAIgYCBS0LBQQnAgcEAgAqBQcCOQOggEOAQwADAAQAAiACAAEhAgACJwIDBAAtCAEFACIFAggtCwgHJwIJBAIAKggJBiI6AAIAAwAGLQoCBycCCQQDACoHCQgACAEIAScDBQQBACIFAgktDgcJACIJAgktDgcJLQoHBAYiBAIEJAIAAQAAAbMjAAABii0LBQEAIgECAS0OAQUAIgUCBi0LBgInAgcEAgAqBgcBPA4CASMAAAGzCioEAwEkAgABAAAByScCAgQAPAYCASYoAIAEBHgADQAAAIAEgAMkAIADAAAB8ioBAAEF96Hzr6Wt1Mo8BAIBJioBAAEFvh4//z6k9vo8BAIBJg==",
      "debug_symbols": "tZdNbuMwDIXv4nUWIvXLXKUoijR1CwOGE7jJAIMidx/SERWngDRAprOJP9PV06NE0fVX99a/nj9ehun98Nltn76613kYx+HjZTzsd6fhMHH0qzPyQ7Hbuk0HBrttlCvfg2EAzwAMaBRSBmsZZJCViIxyEiEBjiAy+JghoIJGokZiyJBAQSOkEfJXQGMUnAJlAI1Anh0RFfKkaEEhT4FOBZ1O4USQ80LvFDQSrELKEDWyeA4MJIJJgIdbI0BXsMYqpAyACjEDasQ6BR3uNOI04jXiNRJ0iqBTRBWUdV5AjCEJpCs4MXYFscGL4BZjC4QMCAoasbxilnN3soZXSBm82HCXy6bTWns5zX0vpbYqPi7J427up1O3nc7juOl+7cbz8kefx920XE+7mZ+y63564ysLvg9jL3TZ3Eab+lCwXswuw8GGEIsEGLoTgYaIwaJhHK4kwp0ENiQipaAakcgXkWjvNGxdwyJXTtZgRlfTaKZCpDYAqJqK/4FUwv9OxaeyK6m+K6kuEWNSiZhc1QQ1ErHOgCbCR/RfEwGsJ9Iocx9Qt8QHF4qE/2biJyoUfqJEm7lEW3IhqObSKlFanXryzlRzaddo9LdcyDyUi7wicy4Rq7mkVgeLpjSw5FbV4R9xEVd78s0FmmYLLIsBhl9lRSTc28BWoWM0urXMkGor+hcRX1oYkq2WGLbqlN95WiDMFB5yYk05dcz1KkPfcuKpNBAXAB90UhoZWKmMmkhsOQnB3Zyk9KCTQCsn9YVtNVUXSwuwLsGDuwPp9ubH+prYhoj16HWLmRNUnTTPTvDlCJsQQu3sWNtqz6EcHX5tFQlu9pdnvtvth/nuP/uLaM3D7nXs8+37edqvnp5+H/WJfhkc58O+fzvPvSjdPg+Af5+4wMg+yzcB35DbUHi+yNR/AA=="
    }
  ],
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "PriceFeed"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Lending"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "collateral_asset",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "stable_coin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "assets",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "collateral",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "static_debt",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_borrow_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_borrow_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_deposit_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_deposit_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "stable_coin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_repay_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_repay_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::_withdraw_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::_withdraw_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::borrow_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::borrow_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::borrow_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::borrow_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Lending::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::deposit_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::deposit_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::deposit_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::deposit_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "asset_id",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::get_asset_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "interest_accumulator",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "last_updated_ts",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "loan_to_value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "oracle",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "asset::Asset"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::get_asset_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Lending::get_assets_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "array",
                "length": 2,
                "type": {
                  "fields": [
                    {
                      "name": "inner",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ],
                  "kind": "struct",
                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                }
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::get_assets_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::get_position_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "collateral",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "static_debt",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "debt",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "position::Position"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::get_position_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "oracle",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "loan_to_value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "collateral_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "stable_coin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::init_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::init_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "from",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "on_behalf_of",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "stable_coin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::repay_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::repay_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "owner",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "stable_coin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::repay_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::repay_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Lending::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::sync_private_state_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Lending::update_accumulator_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "interest_accumulator",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "last_updated_ts",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 64
                    }
                  },
                  {
                    "name": "loan_to_value",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "oracle",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "asset::Asset"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::update_accumulator_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "secret",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::withdraw_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::withdraw_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Lending::withdraw_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Lending::withdraw_public_abi"
        }
      ]
    }
  },
  "file_map": {
    "100": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "101": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "105": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n\n    if is_fn_private(f) {\n        if is_static_call {\n            create_private_static_stub(f)\n        } else {\n            create_private_stub(f)\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            create_public_static_stub(f)\n        } else {\n            create_public_stub(f)\n        }\n    } else {\n        create_utility_stub(f)\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "109": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY, call_interface_stubs::stub_fn, stub_registry,\n    },\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_authorize_once, fn_has_noinitcheck, get_fn_visibility,\n        is_fn_contract_library_method, is_fn_initializer, is_fn_internal, is_fn_private,\n        is_fn_public, is_fn_test, is_fn_utility, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\npub(crate) comptime fn create_authorize_once_check(f: FunctionDefinition) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[private] or #[public] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_fn_private(f) {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "111": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "112": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/storage.nr",
      "source": "use poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault};\n\nuse super::utils::AsStrQuote;\nuse super::utils::get_storage_size;\n\n/// Stores a map from a module to the name of the struct that describes its storage layout.\n/// This is then used when generating a `storage_layout()` getter on the contract struct.\npub comptime mut global STORAGE_LAYOUT_NAME: UHashMap<Module, Quoted, BuildHasherDefault<Poseidon2Hasher>> =\n    UHashMap::default();\n\n/// Marks a struct as the one describing the storage layout of a contract.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract should have this macro (or `storage_no_init`) applied to it, and the\n/// struct has to be called 'Storage'.\npub comptime fn storage(s: TypeDefinition) -> Quoted {\n    let struct_name = s.name();\n    if struct_name != quote { Storage } {\n        panic(\n            f\"The #[storage] macro can only be applied to a struct with name 'Storage', got '{struct_name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage_no_init\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n\n    // This macro performs three things:\n    //  - it marks the contract as having storage, so that `macros::utils::module_has_storage` will return true and\n    //    functions will have the storage variable injected and initialized via the `init` function.\n    //  - it implements said `init` function by allocating appropriate storage slots to each state variable.\n    //  - it exposes the storage layout by creating a `StorageLayout` struct that is exposed via the `abi(storage)`\n    //    macro.\n    let mut slot: u32 = 1;\n    let mut storage_vars_constructors = &[];\n    let mut storage_layout_fields = &[];\n    let mut storage_layout_constructors = &[];\n\n    // TODO(#8658): uncomment the code below to inject the Context type parameter.\n    //let mut new_storage_fields = &[];\n    //let context_generic = s.add_generic(\"Context\");\n    for field in s.fields_as_written() {\n        // FIXME: This doesn't handle field types with generics\n        let (name, typ, _) = field;\n        let (storage_field_constructor, storage_size) =\n            generate_storage_field_constructor(typ, quote { $slot });\n        storage_vars_constructors =\n            storage_vars_constructors.push_back(quote { $name: $storage_field_constructor });\n        // We have `Storable` in a separate `.nr` file instead of defining it in the last quote of this function\n        // because that way a dev gets a more reasonable error if he defines a struct with the same name in\n        // a contract.\n        storage_layout_fields = storage_layout_fields.push_back(\n            quote { pub $name: dep::aztec::state_vars::storage::Storable },\n        );\n        storage_layout_constructors = storage_layout_constructors.push_back(\n            quote { $name: dep::aztec::state_vars::storage::Storable { slot: $slot } },\n        );\n        //let with_context_generic = add_context_generic(typ, context_generic);\n        //println(with_context_generic);\n        //new_storage_fields = new_storage_fields.push_back((name,  with_context_generic ));\n        slot += storage_size;\n    }\n\n    //s.set_fields(new_storage_fields);\n    let storage_vars_constructors = storage_vars_constructors.join(quote {,});\n    let storage_impl = quote {\n        impl<Context> Storage<Context> {\n            fn init(context: Context) -> Self {\n                Self {\n                    $storage_vars_constructors\n                }\n            }\n        }\n    };\n\n    let storage_layout_fields = storage_layout_fields.join(quote {,});\n    let storage_layout_constructors = storage_layout_constructors.join(quote {,});\n\n    let module = s.module();\n    let module_name = module.name();\n    let storage_layout_name = f\"STORAGE_LAYOUT_{module_name}\".quoted_contents();\n    let (module_name_str, module_name_len) = module_name.as_str_quote();\n    STORAGE_LAYOUT_NAME.insert(module, storage_layout_name);\n\n    quote {\n        $storage_impl\n\n        pub struct StorageLayoutFields {\n            $storage_layout_fields\n        }\n\n        pub struct StorageLayout<let N: u32> {\n            pub contract_name: str<N>,\n            pub fields: StorageLayoutFields\n        }\n\n        #[abi(storage)]\n        pub global $storage_layout_name: StorageLayout<$module_name_len> = StorageLayout {\n            contract_name: $module_name_str,\n            fields: StorageLayoutFields { $storage_layout_constructors }\n        };\n    }\n}\n\n/// Same as `storage`, except the user is in charge of providing an implementation of the `init` constructor function\n/// with signature `fn init<Context>(context: Context) -> Self`, which allows for manual control of storage slot\n/// allocation. Similarly, no `StorageLayout` struct will be created.\n///\n/// The contract's storage is accessed via the `storage` variable, which will will automatically be made available in\n/// all functions as an instance of the struct this macro was applied to.\n///\n/// Only a single struct in the entire contract can have this macro (or storage_no_init) applied to it, and the struct\n/// has to be called 'Storage'.\npub comptime fn storage_no_init(s: TypeDefinition) {\n    // All `storage` does is provide the `init` implementation, so we don't need to do anything here. Applying this\n    // macro however will cause for `macros::utils::module_has_storage` to return true, resulting in the injection of\n    // the `storage` variable.\n\n    // We do need to make sure that the type is called Storage, since we'll do `Storage::init` later on.\n\n    if s.name() != quote { Storage } {\n        let name = s.name();\n        panic(\n            f\"The #[storage_no_init] macro can only be applied to a struct with name 'Storage', got '{name}' instead.\",\n        )\n    }\n\n    assert(\n        !s.has_named_attribute(\"storage\"),\n        f\"Only one of #[storage] and #[storage_no_init] can be applied to the Storage struct.\",\n    );\n}\n\n/// Returns the expression required to initialize a state variable with a given slot, along with its serialization size,\n/// i.e. how many contiguous storage slots the variable requires.\ncomptime fn generate_storage_field_constructor(typ: Type, slot: Quoted) -> (Quoted, u32) {\n    assert(\n        typ.as_data_type().is_some(),\n        \"Storage containers must be generic structs of the form `Container<_, Context>`, or Map<Key, _, Context>\",\n    );\n    let (container_struct, generics) = typ.as_data_type().unwrap();\n    let struct_name = container_struct.name();\n\n    let constructor = if is_storage_map(typ) {\n        // Map state variables recursively initialize their contents - this includes nested maps.\n        let (value_constructor, _) =\n            generate_storage_field_constructor(generics[1], quote { slot });\n\n        quote { $struct_name::new(context, $slot, | context, slot | { $value_constructor }) }\n    } else {\n        // We assume below that all state variables implement `fn new<Context>(context: Context, slot: Field) -> Self`.\n        quote { $struct_name::new(context, $slot)}\n    };\n\n    (constructor, get_storage_size(typ))\n}\n\n/// Returns true if `typ` is `state_vars::map::Map`.\ncomptime fn is_storage_map(typ: Type) -> bool {\n    if typ.as_data_type().is_some() {\n        let (def, generics) = typ.as_data_type().unwrap();\n        let maybe_map = if (def.name() == quote { Map }) & (generics.len() == 3) {\n            let maybe_key = generics[0];\n            let maybe_value = generics[1];\n            let maybe_context = generics[2];\n            quote { crate::state_vars::map::Map<$maybe_key, $maybe_value, $maybe_context> }.as_type()\n        } else {\n            quote {()}.as_type()\n        };\n        typ == maybe_map\n    } else {\n        false\n    }\n}\n\ncomptime fn add_context_generic(typ: Type, context_generic: Type) -> Type {\n    let (def, mut generics) = typ.as_data_type().expect(\n        f\"Storage containers must be generic structs of the form `Container<..., Context>`\",\n    );\n    let name = def.name();\n\n    if is_storage_map(typ) {\n        generics[generics.len() - 2] = add_context_generic(generics[1], context_generic);\n        generics[generics.len() - 1] = context_generic;\n    } else {\n        generics[generics.len() - 1] = context_generic;\n    }\n\n    let generics = generics.map(|typ: Type| quote {$typ}).join(quote {,});\n    quote { $name<$generics> }.as_type()\n}\n"
    },
    "114": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "115": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "116": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "117": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "118": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "119": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "121": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PlaintextLen * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let env = TestEnvironment::new();\n\n        // Log decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"utilityGetIndexedTaggingSecretAsSender\").returns(\n                IndexedTaggingSecret::deserialize([69420, 1337]),\n            );\n            let _ = OracleMock::mock(\"privateIncrementAppTaggingSecretIndexAsSender\").returns(());\n\n            // Encrypt the log\n            let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the log\n            let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec =\n                BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "137": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "149": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "152": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "156": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "157": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "158": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "159": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(utilityGetContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(utilityGetBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(utilityGetTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(utilityGetChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(utilityGetVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "160": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "161": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "166": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "167": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "169": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "171": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(utilityGetIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(privateIncrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "174": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "177": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 1;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. PXE is using version '1', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "181": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/map.nr",
      "source": "use crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::{storage::map::derive_storage_slot_in_map, traits::ToField};\n\n/// Map\n///\n/// A key-value storage container that maps keys to state variables, similar\n/// to Solidity mappings.\n///\n/// `Map` enables you to associate keys (like addresses or other identifiers)\n/// with state variables in your Aztec smart contract. This is conceptually\n/// similar to Solidity's `mapping(K => V)` syntax, where you can store and\n/// retrieve values by their associated keys.\n///\n/// You can declare a state variable contained within a Map in your contract's\n/// #[storage] struct.\n///\n/// For example, you might use\n/// `Map<AztecAddress, PrivateMutable<ValueNote, Context>, Context>` to track\n/// token balances for different users, similar to how you'd use\n/// `mapping(address => uint256)` in Solidity.\n///\n/// > Aside: the verbose `Context` in the declaration is a consequence of\n/// > leveraging Noir's regular syntax for generics to ensure that certain\n/// > state variable methods can only be called in some contexts (private,\n/// > public, utility).\n///\n/// The methods of Map are:\n/// - `at` (access state variable for a given key)\n/// (see the method's own doc comments for more info).\n///\n/// ## Generic Parameters\n/// - `K`: The key type (must implement `ToField` trait for hashing)\n/// - `V`: The value type:\n///   - any Aztec state variable:\n///     - `PublicMutable`\n///     - `PublicImmutable`\n///     - `PrivateMutable`\n///     - `PrivateImmutable`\n///     - `PrivateSet`\n///     - `DelayedPublicMutable`\n///     - `Map`\n/// - `Context`: The execution context (handles private/public function\n///   contexts)\n///\n/// ## Usage\n/// Maps are typically declared in your contract's #[storage] struct and\n/// accessed\n/// using the `at(key)` method to get the state variable for a specific key.\n/// The resulting state variable can then be read from or written to using its\n/// own methods.\n///\n/// ## Advanced\n/// Internally, `Map` uses a single base storage slot to represent the\n/// mapping\n/// itself, similar to Solidity's approach. Individual key-value pairs are\n/// stored at derived storage slots computed by hashing the base storage\n/// slot\n/// with the key using Poseidon2. This ensures:\n/// - No storage slot collisions between different keys\n/// - Uniform distribution of storage slots across the storage space\n/// - Compatibility with Aztec's storage tree structure\n/// - Gas-efficient storage access patterns similar to Solidity mappings\n///\n/// The storage slot derivation uses `derive_storage_slot_in_map(base_slot,\n/// key)` which computes `poseidon2_hash([base_slot, key.to_field()])`,\n/// ensuring cryptographically secure slot separation.\n///\n/// docs:start:map\npub struct Map<K, V, Context> {\n    context: Context,\n    storage_slot: Field,\n    state_var_constructor: fn(Context, Field) -> V,\n}\n// docs:end:map\n\n// Map reserves a single storage slot regardless of what it stores because\n// nothing is stored at said slot: it is only used to derive the storage slots\n// of nested state variables, which is expected to never result in collisions\n// or slots being close to one another due to these being hashes. This mirrors\n// the strategy adopted by Solidity mappings.\nimpl<K, T, Context> HasStorageSlot<1> for Map<K, T, Context> {\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<K, V, Context> Map<K, V, Context> {\n    /// Initializes a new Map state variable.\n    ///\n    /// This function is usually automatically called within the #[storage]\n    /// macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PrivateContext`/`PublicContext`/`UtilityContext`.\n    ///               The Context determines which methods of this struct will\n    ///               be made available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this Map within the contract.\n    ///                    Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart\n    ///                    contract dev shouldn't have to worry about this, as\n    ///                    it's managed behind the scenes.\n    /// * `state_var_constructor` - A function that creates the value type (V)\n    ///                             given a context and storage slot. This is\n    ///                             typically the constructor of the state\n    ///                             variable type being stored in the Map.\n    ///\n    // docs:start:new\n    pub fn new(\n        context: Context,\n        storage_slot: Field,\n        state_var_constructor: fn(Context, Field) -> V,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        Map { context, storage_slot, state_var_constructor }\n    }\n    // docs:end:new\n\n    /// Returns the state variable associated with the given key.\n    ///\n    /// This is equivalent to accessing `mapping[key]` in Solidity. It returns\n    /// the state variable instance for the specified key, which can then be\n    /// used to read or write the value at that key.\n    ///\n    /// Unlike Solidity mappings which return the value directly, this returns\n    /// the state variable wrapper (like PrivateMutable, PublicMutable, etc.)\n    /// that you then call methods on to interact with the actual value.\n    ///\n    /// # Arguments\n    ///\n    /// * `key` - The key to look up in the map. Must implement the ToField\n    ///           trait (which most basic Noir & Aztec types do).\n    ///\n    /// # Returns\n    ///\n    /// * `V` - The state variable instance for this key. You can then call\n    ///         methods like `.read()`, `.write()`, `.get_note()`, etc. on this\n    ///         depending on the specific state variable type.\n    ///\n    /// # Example\n    ///\n    /// ```noir\n    /// // Get a user's balance (assuming PrivateMutable<ValueNote>)\n    /// let user_balance = storage.balances.at(user_address);\n    /// let current_note = user_balance.get_note();\n    ///\n    /// // Update the balance\n    /// user_balance.replace(new_note);\n    /// ```\n    ///\n    // docs:start:at\n    pub fn at(self, key: K) -> V\n    where\n        K: ToField,\n    {\n        // TODO(#1204): use a generator index for the storage slot\n        let derived_storage_slot = derive_storage_slot_in_map(self.storage_slot, key);\n\n        let state_var_constructor = self.state_var_constructor;\n        state_var_constructor(self.context, derived_storage_slot)\n    }\n    // docs:end:at\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "191": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_mutable.nr",
      "source": "use crate::context::{PublicContext, UtilityContext};\nuse crate::state_vars::storage::HasStorageSlot;\nuse dep::protocol_types::traits::Packable;\n\n/// # PublicMutable\n///\n/// PublicMutable is a public state variable type for values that can be read\n/// and written within #[public] functions of your smart contract.\n///\n/// You can declare a state variable of type PublicMutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicMutable<T, Context>`\n/// or:\n/// `your_mapping: Map<Field, PublicMutable<T, Context>>`\n///\n/// The methods of PublicMutable are:\n/// - `read`\n/// - `write`\n/// (see the methods' own doc comments for more info).\n///\n/// ## Example.\n///\n/// A voting contract's proposal count can be represented as a PublicMutable<u64>.\n/// The count can be read by anyone to see how many proposals exist, and incremented\n/// when new proposals are submitted.\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext or UtilityContext).\n///\n/// # Advanced\n///\n/// Unlike private state variables which use notes, PublicMutable stores values\n/// directly in Aztec's public data tree. This enables direct read and write\n/// access to the current state during public function execution.\n///\n/// docs:start:public_mutable_struct\npub struct PublicMutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_mutable_struct\n\nimpl<T, Context, let M: u32> HasStorageSlot<M> for PublicMutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicMutable<T, Context> {\n    /// Initializes a new PublicMutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`UtilityContext`. The Context determines\n    ///               which methods of this struct will be made available to the calling\n    ///               smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_mutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicMutable { context, storage_slot }\n    }\n    // docs:end:public_mutable_struct_new\n}\n\nimpl<T> PublicMutable<T, &mut PublicContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    /// docs:start:public_mutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n    // docs:end:public_mutable_struct_read\n\n    /// Writes a new value to this PublicMutable state variable.\n    ///\n    /// # Arguments\n    ///\n    /// * `value` - The new value to store in this PublicMutable.\n    ///\n    /// # Advanced\n    ///\n    /// This function updates the value stored in Aztec's public data tree.\n    /// The new value becomes immediately available to subsequent reads within\n    /// the same transaction.\n    ///\n    /// docs:start:public_mutable_struct_write\n    pub fn write(self, value: T)\n    where\n        T: Packable,\n    {\n        self.context.storage_write(self.storage_slot, value);\n    }\n    // docs:end:public_mutable_struct_write\n}\n\nimpl<T> PublicMutable<T, UtilityContext> {\n    /// Reads the current value stored in this PublicMutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The current value stored in this PublicMutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable,\n    {\n        self.context.storage_read(self.storage_slot)\n    }\n}\n"
    },
    "207": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "210": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "211": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "213": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "214": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "216": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "218": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "230": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "249": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "295": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n"
    },
    "298": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/partial_address.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, salted_initialization_hash::SaltedInitializationHash},\n    constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Empty, Serialize, ToField},\n};\nuse std::meta::derive;\n\n// Partial address\n#[derive(Deserialize, Eq, Serialize)]\npub struct PartialAddress {\n    pub inner: Field,\n}\n\nimpl ToField for PartialAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl Empty for PartialAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl PartialAddress {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(\n        contract_class_id: ContractClassId,\n        salt: Field,\n        initialization_hash: Field,\n        deployer: AztecAddress,\n    ) -> Self {\n        PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            SaltedInitializationHash::compute(salt, initialization_hash, deployer),\n        )\n    }\n\n    pub fn compute_from_salted_initialization_hash(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n    ) -> Self {\n        PartialAddress::from_field(poseidon2_hash_with_separator(\n            [contract_class_id.to_field(), salted_initialization_hash.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn to_field(self) -> Field {\n        self.inner\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.to_field() == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\nmod test {\n    use crate::{address::partial_address::PartialAddress, traits::{Deserialize, Serialize}};\n\n    #[test]\n    fn serialization_of_partial_address() {\n        let item = PartialAddress::from_field(1);\n        let serialized: [Field; 1] = item.serialize();\n        let deserialized = PartialAddress::deserialize(serialized);\n        assert_eq(item, deserialized);\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "300": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/salted_initialization_hash.nr",
      "source": "use crate::{\n    address::aztec_address::AztecAddress, constants::GENERATOR_INDEX__PARTIAL_ADDRESS,\n    hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\n// Salted initialization hash. Used in the computation of a partial address.\n#[derive(Eq)]\npub struct SaltedInitializationHash {\n    pub inner: Field,\n}\n\nimpl ToField for SaltedInitializationHash {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl SaltedInitializationHash {\n    pub fn from_field(field: Field) -> Self {\n        Self { inner: field }\n    }\n\n    pub fn compute(salt: Field, initialization_hash: Field, deployer: AztecAddress) -> Self {\n        SaltedInitializationHash::from_field(poseidon2_hash_with_separator(\n            [salt, initialization_hash, deployer.to_field()],\n            GENERATOR_INDEX__PARTIAL_ADDRESS,\n        ))\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n"
    },
    "304": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/contract_instance.nr",
      "source": "use crate::{\n    address::{aztec_address::AztecAddress, partial_address::PartialAddress},\n    contract_class_id::ContractClassId,\n    public_keys::PublicKeys,\n    traits::{Deserialize, Hash, Serialize, ToField},\n};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct ContractInstance {\n    pub salt: Field,\n    pub deployer: AztecAddress,\n    pub contract_class_id: ContractClassId,\n    pub initialization_hash: Field,\n    pub public_keys: PublicKeys,\n}\n\nimpl Hash for ContractInstance {\n    fn hash(self) -> Field {\n        self.to_address().to_field()\n    }\n}\n\nimpl ContractInstance {\n    pub fn to_address(self) -> AztecAddress {\n        AztecAddress::compute(\n            self.public_keys,\n            PartialAddress::compute(\n                self.contract_class_id,\n                self.salt,\n                self.initialization_hash,\n                self.deployer,\n            ),\n        )\n    }\n}\n\nmod test {\n    use crate::{\n        address::AztecAddress,\n        constants::CONTRACT_INSTANCE_LENGTH,\n        contract_class_id::ContractClassId,\n        contract_instance::ContractInstance,\n        public_keys::PublicKeys,\n        traits::{Deserialize, FromField, Serialize},\n    };\n\n    #[test]\n    fn serde() {\n        let instance = ContractInstance {\n            salt: 6,\n            deployer: AztecAddress::from_field(12),\n            contract_class_id: ContractClassId::from_field(13),\n            initialization_hash: 156,\n            public_keys: PublicKeys::default(),\n        };\n\n        // We use the CONTRACT_INSTANCE_LENGTH constant to ensure that there is a match between the derived trait\n        // implementation and the constant.\n        let serialized: [Field; CONTRACT_INSTANCE_LENGTH] = instance.serialize();\n\n        let deserialized = ContractInstance::deserialize(serialized);\n\n        assert(instance.eq(deserialized));\n    }\n\n}\n"
    },
    "311": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "320": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        // Q: I don't understand this comment. We could still compute a siloed nullifier from a zero contract address.\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "334": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut result = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         result\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Serialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the serialized member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize(self.$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    result[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; _];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Serialize::serialize(self.$param_name)\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "335": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "336": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "346": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "348": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/storage/map.nr",
      "source": "use crate::{hash::poseidon2_hash, traits::ToField};\n\npub fn derive_storage_slot_in_map<K>(storage_slot: Field, key: K) -> Field\nwhere\n    K: ToField,\n{\n    poseidon2_hash([storage_slot, key.to_field()])\n}\n\nmod test {\n    use crate::{address::AztecAddress, storage::map::derive_storage_slot_in_map, traits::FromField};\n\n    #[test]\n    fn test_derive_storage_slot_in_map_matches_typescript() {\n        let map_slot = 0x132258fb6962c4387ba659d9556521102d227549a386d39f0b22d1890d59c2b5;\n        let key = AztecAddress::from_field(\n            0x302dbc2f9b50a73283d5fb2f35bc01eae8935615817a0b4219a057b2ba8a5a3f,\n        );\n\n        let slot = derive_storage_slot_in_map(map_slot, key);\n\n        // The following value was generated by `map_slot.test.ts`\n        let slot_from_typescript =\n            0x15b9fe39449affd8b377461263e9d2b610b9ad40580553500b4e41d9cbd887ac;\n\n        assert_eq(slot, slot_from_typescript);\n    }\n}\n"
    },
    "361": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "363": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "364": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "384": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "39": {
      "path": "std/ops/arith.nr",
      "source": "use crate::convert::AsPrimitive;\n\n// docs:start:add-trait\npub trait Add {\n    fn add(self, other: Self) -> Self;\n}\n// docs:end:add-trait\n\nimpl Add for Field {\n    fn add(self, other: Field) -> Field {\n        self + other\n    }\n}\n\nimpl Add for u128 {\n    fn add(self, other: u128) -> u128 {\n        self + other\n    }\n}\nimpl Add for u64 {\n    fn add(self, other: u64) -> u64 {\n        self + other\n    }\n}\nimpl Add for u32 {\n    fn add(self, other: u32) -> u32 {\n        self + other\n    }\n}\nimpl Add for u16 {\n    fn add(self, other: u16) -> u16 {\n        self + other\n    }\n}\nimpl Add for u8 {\n    fn add(self, other: u8) -> u8 {\n        self + other\n    }\n}\nimpl Add for u1 {\n    fn add(self, other: u1) -> u1 {\n        self + other\n    }\n}\n\nimpl Add for i8 {\n    fn add(self, other: i8) -> i8 {\n        self + other\n    }\n}\nimpl Add for i16 {\n    fn add(self, other: i16) -> i16 {\n        self + other\n    }\n}\nimpl Add for i32 {\n    fn add(self, other: i32) -> i32 {\n        self + other\n    }\n}\nimpl Add for i64 {\n    fn add(self, other: i64) -> i64 {\n        self + other\n    }\n}\n\n// docs:start:sub-trait\npub trait Sub {\n    fn sub(self, other: Self) -> Self;\n}\n// docs:end:sub-trait\n\nimpl Sub for Field {\n    fn sub(self, other: Field) -> Field {\n        self - other\n    }\n}\n\nimpl Sub for u128 {\n    fn sub(self, other: u128) -> u128 {\n        self - other\n    }\n}\nimpl Sub for u64 {\n    fn sub(self, other: u64) -> u64 {\n        self - other\n    }\n}\nimpl Sub for u32 {\n    fn sub(self, other: u32) -> u32 {\n        self - other\n    }\n}\nimpl Sub for u16 {\n    fn sub(self, other: u16) -> u16 {\n        self - other\n    }\n}\nimpl Sub for u8 {\n    fn sub(self, other: u8) -> u8 {\n        self - other\n    }\n}\nimpl Sub for u1 {\n    fn sub(self, other: u1) -> u1 {\n        self - other\n    }\n}\n\nimpl Sub for i8 {\n    fn sub(self, other: i8) -> i8 {\n        self - other\n    }\n}\nimpl Sub for i16 {\n    fn sub(self, other: i16) -> i16 {\n        self - other\n    }\n}\nimpl Sub for i32 {\n    fn sub(self, other: i32) -> i32 {\n        self - other\n    }\n}\nimpl Sub for i64 {\n    fn sub(self, other: i64) -> i64 {\n        self - other\n    }\n}\n\n// docs:start:mul-trait\npub trait Mul {\n    fn mul(self, other: Self) -> Self;\n}\n// docs:end:mul-trait\n\nimpl Mul for Field {\n    fn mul(self, other: Field) -> Field {\n        self * other\n    }\n}\n\nimpl Mul for u128 {\n    fn mul(self, other: u128) -> u128 {\n        self * other\n    }\n}\nimpl Mul for u64 {\n    fn mul(self, other: u64) -> u64 {\n        self * other\n    }\n}\nimpl Mul for u32 {\n    fn mul(self, other: u32) -> u32 {\n        self * other\n    }\n}\nimpl Mul for u16 {\n    fn mul(self, other: u16) -> u16 {\n        self * other\n    }\n}\nimpl Mul for u8 {\n    fn mul(self, other: u8) -> u8 {\n        self * other\n    }\n}\nimpl Mul for u1 {\n    fn mul(self, other: u1) -> u1 {\n        self * other\n    }\n}\n\nimpl Mul for i8 {\n    fn mul(self, other: i8) -> i8 {\n        self * other\n    }\n}\nimpl Mul for i16 {\n    fn mul(self, other: i16) -> i16 {\n        self * other\n    }\n}\nimpl Mul for i32 {\n    fn mul(self, other: i32) -> i32 {\n        self * other\n    }\n}\nimpl Mul for i64 {\n    fn mul(self, other: i64) -> i64 {\n        self * other\n    }\n}\n\n// docs:start:div-trait\npub trait Div {\n    fn div(self, other: Self) -> Self;\n}\n// docs:end:div-trait\n\nimpl Div for Field {\n    fn div(self, other: Field) -> Field {\n        self / other\n    }\n}\n\nimpl Div for u128 {\n    fn div(self, other: u128) -> u128 {\n        self / other\n    }\n}\nimpl Div for u64 {\n    fn div(self, other: u64) -> u64 {\n        self / other\n    }\n}\nimpl Div for u32 {\n    fn div(self, other: u32) -> u32 {\n        self / other\n    }\n}\nimpl Div for u16 {\n    fn div(self, other: u16) -> u16 {\n        self / other\n    }\n}\nimpl Div for u8 {\n    fn div(self, other: u8) -> u8 {\n        self / other\n    }\n}\nimpl Div for u1 {\n    fn div(self, other: u1) -> u1 {\n        self / other\n    }\n}\n\nimpl Div for i8 {\n    fn div(self, other: i8) -> i8 {\n        self / other\n    }\n}\nimpl Div for i16 {\n    fn div(self, other: i16) -> i16 {\n        self / other\n    }\n}\nimpl Div for i32 {\n    fn div(self, other: i32) -> i32 {\n        self / other\n    }\n}\nimpl Div for i64 {\n    fn div(self, other: i64) -> i64 {\n        self / other\n    }\n}\n\n// docs:start:rem-trait\npub trait Rem {\n    fn rem(self, other: Self) -> Self;\n}\n// docs:end:rem-trait\n\nimpl Rem for u128 {\n    fn rem(self, other: u128) -> u128 {\n        self % other\n    }\n}\nimpl Rem for u64 {\n    fn rem(self, other: u64) -> u64 {\n        self % other\n    }\n}\nimpl Rem for u32 {\n    fn rem(self, other: u32) -> u32 {\n        self % other\n    }\n}\nimpl Rem for u16 {\n    fn rem(self, other: u16) -> u16 {\n        self % other\n    }\n}\nimpl Rem for u8 {\n    fn rem(self, other: u8) -> u8 {\n        self % other\n    }\n}\nimpl Rem for u1 {\n    fn rem(self, other: u1) -> u1 {\n        self % other\n    }\n}\n\nimpl Rem for i8 {\n    fn rem(self, other: i8) -> i8 {\n        self % other\n    }\n}\nimpl Rem for i16 {\n    fn rem(self, other: i16) -> i16 {\n        self % other\n    }\n}\nimpl Rem for i32 {\n    fn rem(self, other: i32) -> i32 {\n        self % other\n    }\n}\nimpl Rem for i64 {\n    fn rem(self, other: i64) -> i64 {\n        self % other\n    }\n}\n\n// docs:start:neg-trait\npub trait Neg {\n    fn neg(self) -> Self;\n}\n// docs:end:neg-trait\n\n// docs:start:neg-trait-impls\nimpl Neg for Field {\n    fn neg(self) -> Field {\n        -self\n    }\n}\n\nimpl Neg for i8 {\n    fn neg(self) -> i8 {\n        -self\n    }\n}\nimpl Neg for i16 {\n    fn neg(self) -> i16 {\n        -self\n    }\n}\nimpl Neg for i32 {\n    fn neg(self) -> i32 {\n        -self\n    }\n}\nimpl Neg for i64 {\n    fn neg(self) -> i64 {\n        -self\n    }\n}\n// docs:end:neg-trait-impls\n\n// docs:start:wrapping-add-trait\npub trait WrappingAdd {\n    fn wrapping_add(self, y: Self) -> Self;\n}\n// docs:end:wrapping-add-trait\n\nimpl WrappingAdd for u1 {\n    fn wrapping_add(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingAdd for u8 {\n    fn wrapping_add(self: u8, y: u8) -> u8 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u16 {\n    fn wrapping_add(self: u16, y: u16) -> u16 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u32 {\n    fn wrapping_add(self: u32, y: u32) -> u32 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u64 {\n    fn wrapping_add(self: u64, y: u64) -> u64 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for u128 {\n    fn wrapping_add(self: u128, y: u128) -> u128 {\n        wrapping_add_hlp(self, y)\n    }\n}\n\nimpl WrappingAdd for i8 {\n    fn wrapping_add(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_add(y as u8) as i8\n    }\n}\n\nimpl WrappingAdd for i16 {\n    fn wrapping_add(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_add(y as u16) as i16\n    }\n}\n\nimpl WrappingAdd for i32 {\n    fn wrapping_add(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_add(y as u32) as i32\n    }\n}\n\nimpl WrappingAdd for i64 {\n    fn wrapping_add(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_add(y as u64) as i64\n    }\n}\nimpl WrappingAdd for Field {\n    fn wrapping_add(self: Field, y: Field) -> Field {\n        self + y\n    }\n}\n\n// docs:start:wrapping-sub-trait\npub trait WrappingSub {\n    fn wrapping_sub(self, y: Self) -> Self;\n}\n// docs:start:wrapping-sub-trait\n\nimpl WrappingSub for u1 {\n    fn wrapping_sub(self: u1, y: u1) -> u1 {\n        self ^ y\n    }\n}\n\nimpl WrappingSub for u8 {\n    fn wrapping_sub(self: u8, y: u8) -> u8 {\n        wrapping_sub_hlp(self, y) as u8\n    }\n}\n\nimpl WrappingSub for u16 {\n    fn wrapping_sub(self: u16, y: u16) -> u16 {\n        wrapping_sub_hlp(self, y) as u16\n    }\n}\n\nimpl WrappingSub for u32 {\n    fn wrapping_sub(self: u32, y: u32) -> u32 {\n        wrapping_sub_hlp(self, y) as u32\n    }\n}\nimpl WrappingSub for u64 {\n    fn wrapping_sub(self: u64, y: u64) -> u64 {\n        wrapping_sub_hlp(self, y) as u64\n    }\n}\nimpl WrappingSub for u128 {\n    fn wrapping_sub(self: u128, y: u128) -> u128 {\n        wrapping_sub_hlp(self, y) as u128\n    }\n}\n\nimpl WrappingSub for i8 {\n    fn wrapping_sub(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_sub(y as u8) as i8\n    }\n}\n\nimpl WrappingSub for i16 {\n    fn wrapping_sub(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_sub(y as u16) as i16\n    }\n}\n\nimpl WrappingSub for i32 {\n    fn wrapping_sub(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_sub(y as u32) as i32\n    }\n}\nimpl WrappingSub for i64 {\n    fn wrapping_sub(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_sub(y as u64) as i64\n    }\n}\nimpl WrappingSub for Field {\n    fn wrapping_sub(self: Field, y: Field) -> Field {\n        self - y\n    }\n}\n\n// docs:start:wrapping-mul-trait\npub trait WrappingMul {\n    fn wrapping_mul(self, y: Self) -> Self;\n}\n// docs:start:wrapping-mul-trait\n\nimpl WrappingMul for u1 {\n    fn wrapping_mul(self: u1, y: u1) -> u1 {\n        self & y\n    }\n}\n\nimpl WrappingMul for u8 {\n    fn wrapping_mul(self: u8, y: u8) -> u8 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u16 {\n    fn wrapping_mul(self: u16, y: u16) -> u16 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for u32 {\n    fn wrapping_mul(self: u32, y: u32) -> u32 {\n        wrapping_mul_hlp(self, y)\n    }\n}\nimpl WrappingMul for u64 {\n    fn wrapping_mul(self: u64, y: u64) -> u64 {\n        wrapping_mul_hlp(self, y)\n    }\n}\n\nimpl WrappingMul for i8 {\n    fn wrapping_mul(self: i8, y: i8) -> i8 {\n        let x = self as u8;\n        x.wrapping_mul(y as u8) as i8\n    }\n}\n\nimpl WrappingMul for i16 {\n    fn wrapping_mul(self: i16, y: i16) -> i16 {\n        let x = self as u16;\n        x.wrapping_mul(y as u16) as i16\n    }\n}\n\nimpl WrappingMul for i32 {\n    fn wrapping_mul(self: i32, y: i32) -> i32 {\n        let x = self as u32;\n        x.wrapping_mul(y as u32) as i32\n    }\n}\n\nimpl WrappingMul for i64 {\n    fn wrapping_mul(self: i64, y: i64) -> i64 {\n        let x = self as u64;\n        x.wrapping_mul(y as u64) as i64\n    }\n}\n\nimpl WrappingMul for u128 {\n    fn wrapping_mul(self: u128, y: u128) -> u128 {\n        wrapping_mul128_hlp(self, y)\n    }\n}\nimpl WrappingMul for Field {\n    fn wrapping_mul(self: Field, y: Field) -> Field {\n        self * y\n    }\n}\n\nfn wrapping_add_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() + y.as_())\n}\n\nfn wrapping_sub_hlp<T>(x: T, y: T) -> Field\nwhere\n    T: AsPrimitive<Field>,\n{\n    //340282366920938463463374607431768211456 is 2^128, it is used to avoid underflow\n    x.as_() + 340282366920938463463374607431768211456 - y.as_()\n}\n\nfn wrapping_mul_hlp<T>(x: T, y: T) -> T\nwhere\n    T: AsPrimitive<Field>,\n    Field: AsPrimitive<T>,\n{\n    AsPrimitive::as_(x.as_() * y.as_())\n}\n\nglobal two_pow_64: u128 = 0x10000000000000000;\n/// Splits a 128 bits number into two 64 bits limbs\nunconstrained fn split64(x: u128) -> (u64, u64) {\n    let lo = x as u64;\n    let hi = (x / two_pow_64) as u64;\n    (lo, hi)\n}\n\n/// Split a 128 bits number into two 64 bits limbs\n/// It will fail if the number is more than 128 bits\nfn split_into_64_bit_limbs(x: u128) -> (u64, u64) {\n    // Safety: the limbs are constrained below\n    let (x_lo, x_hi) = unsafe { split64(x) };\n    assert(x as Field == x_lo as Field + x_hi as Field * two_pow_64 as Field);\n    (x_lo, x_hi)\n}\n\n#[field(bn254)]\nfn wrapping_mul128_hlp(x: u128, y: u128) -> u128 {\n    let (x_lo, x_hi) = split_into_64_bit_limbs(x);\n    let (y_lo, y_hi) = split_into_64_bit_limbs(y);\n    // Multiplication using the limbs:(x_lo + 2**64*x_hi)*(y_lo + 2**64*y_hi)=x_lo*y_lo+...\n    // and skipping the terms over 2**128\n    // Working with u64 limbs ensures that we cannot overflow the field modulus.\n    let low = x_lo as Field * y_lo as Field;\n    let lo = low as u64 as Field;\n    let carry = (low - lo) / two_pow_64 as Field;\n    let high = x_lo as Field * y_hi as Field + x_hi as Field * y_lo as Field + carry;\n    let hi = high as u64 as Field;\n    (lo + two_pow_64 as Field * hi) as u128\n}\n"
    },
    "416": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/lending_contract/src/helpers.nr",
      "source": "use dep::aztec::hash::pedersen_hash;\nuse std::ops::{Add, Sub};\n\n// Utility used to easily get a \"id\" for a private user that sits in the same\n// \"space\" as the public users.\n// It help us to have a single mapping for collateral that have both public and private users.\npub fn compute_identifier(secret: Field, on_behalf_of: Field, this: Field) -> Field {\n    // EITHER secret OR on_behalf_of MUST be set. But not both\n    assert(!((secret == 0) as bool & (on_behalf_of == 0) as bool));\n    if (secret != 0) {\n        pedersen_hash([this, secret], 0)\n    } else {\n        on_behalf_of\n    }\n}\n\npub fn covered_by_collateral(\n    price: u128,\n    loan_to_value: u128,\n    collateral: u128,\n    increase: u128,\n    decrease: u128,\n) -> u128 {\n    let price_precision = 1000000000 as u128;\n    let ltv_precision = 10000 as u128;\n\n    let collateral = (collateral + increase) - decrease;\n\n    let collateral_value = (collateral * price) / price_precision;\n    let debt_covered = (collateral_value * loan_to_value) / ltv_precision;\n\n    debt_covered\n}\n\npub struct DebtReturn {\n    pub debt_value: u128,\n    pub static_debt: u128,\n}\n\nfn div_up(a: u128, b: u128) -> u128 {\n    let div = a / b;\n    if div * b < a {\n        div + (1 as u128)\n    } else {\n        div\n    }\n}\n\npub fn debt_updates(\n    interest_accumulator: u128,\n    static_debt: u128,\n    increase: u128,\n    decrease: u128,\n) -> DebtReturn {\n    assert(interest_accumulator > (0 as u128));\n    let accumulator_precision = 1000000000 as u128;\n\n    let current_debt_value = (static_debt * interest_accumulator) / accumulator_precision;\n    let new_debt_value = current_debt_value.add(increase).sub(decrease);\n\n    // static_debt_increase = amount / accumulator\n    // rounding up new debt.\n    let static_debt_increase = div_up(increase * accumulator_precision, interest_accumulator);\n    // rounding down repayment.\n    let static_debt_decrease = (decrease * accumulator_precision) / interest_accumulator;\n\n    // We need to allow repaying of the entire debt as well etc. This is very prone to failing\n    // if you try to repay exact due to time diff between sim and execution.\n    let new_static_debt = static_debt.add(static_debt_increase).sub(static_debt_decrease);\n\n    DebtReturn { debt_value: new_debt_value, static_debt: new_static_debt }\n}\n\npub fn debt_value(static_debt: u128, interest_accumulator: u128) -> u128 {\n    let accumulator_precision = 1000000000 as u128;\n    div_up(static_debt * interest_accumulator, accumulator_precision)\n}\n"
    },
    "52": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/lending_contract/src/interest_math.nr",
      "source": "use std::ops::{Add, Div, Mul};\n\n// Binomial approximation of exponential\n// using lower than desired precisions for everything due to u128 limit\n// (1+x)^n = 1+n*x+[n/2*(n-1)]*x^2+[n/6*(n-1)*(n-2)*x^3]...\n// we are losing around almost 8 digits of precision from yearly -> daily interest\n// dividing with 31536000 (seconds per year).\n// rate must be measured with higher precision than 10^9.\n// we use e18, and rates >= 4% yearly. Otherwise need more precision\npub fn compute_multiplier(rate_per_second: u128, dt: u64) -> u128 {\n    let base = 1000000000 as u128; // 1e9\n    let WAD = 1000000000000000000 as u128; // 1e18\n    let diff = WAD.div(base);\n    let mut res = base;\n    if dt != 0 {\n        let exp_minus_one = (dt - 1) as u128;\n        let exp_minus_two = (if (dt > 2) { dt - 2 } else { 0 }) as u128;\n        let dt = dt as u128;\n\n        // if rate_per_second < sqrt(WAD), then base_power_two and base_power_three = 0\n        let rate = rate_per_second;\n        let base_power_two = (rate * rate) / WAD;\n        let base_power_three = (base_power_two * rate) / WAD;\n\n        let temp = dt.mul(exp_minus_one);\n        let second_term = temp.mul(base_power_two).div(2 as u128);\n        let third_term = temp.mul(exp_minus_two).mul(base_power_three).div(6 as u128);\n\n        // throwing away precision to keep us under u128 :sob:\n        let offset = dt.mul(rate).add(second_term).add(third_term).div(diff);\n\n        res = base.add(offset);\n    }\n    res\n}\n"
    },
    "53": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/lending_contract/src/main.nr",
      "source": "mod asset;\nmod position;\nmod interest_math;\nmod helpers;\n\n// Single asset CDP contract.\n// Shoving re-entries up the ass.\n// TODO's:\n// - Use asset address instead of 0. We only use 0, as there is only one collateral asset :shrug:.\n// - Update accumulator should be for specific asset, just abusing only 1 asset atm.\n// - A way to repay all debt at once\n// - Liquidations\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Lending {\n    use dep::aztec::{protocol_types::address::AztecAddress, state_vars::{Map, PublicMutable}};\n\n    use crate::asset::Asset;\n    use crate::helpers::{compute_identifier, covered_by_collateral, debt_updates, debt_value};\n    use crate::interest_math::compute_multiplier;\n    use crate::position::Position;\n    use dep::price_feed::PriceFeed;\n    use dep::token::Token;\n\n    use dep::aztec::macros::{\n        functions::{initializer, internal, private, public, view},\n        storage::storage,\n    };\n\n    use dep::aztec::protocol_types::traits::{FromField, ToField};\n\n    // Storage structure, containing all storage, and specifying what slots they use.\n    #[storage]\n    struct Storage<Context> {\n        collateral_asset: PublicMutable<AztecAddress, Context>,\n        stable_coin: PublicMutable<AztecAddress, Context>,\n        assets: Map<Field, PublicMutable<Asset, Context>, Context>,\n        collateral: Map<AztecAddress, PublicMutable<u128, Context>, Context>,\n        static_debt: Map<AztecAddress, PublicMutable<u128, Context>, Context>, // abusing keys very heavily\n    }\n\n    // Constructs the contract.\n    #[private]\n    #[initializer]\n    fn constructor() {}\n\n    #[public]\n    fn init(\n        oracle: AztecAddress,\n        loan_to_value: u128,\n        collateral_asset: AztecAddress,\n        stable_coin: AztecAddress,\n    ) {\n        let asset_loc = storage.assets.at(0);\n        let asset: Asset = asset_loc.read();\n\n        let loan_to_value = loan_to_value;\n\n        assert(loan_to_value <= (10000 as u128));\n        assert(asset.last_updated_ts == 0);\n        assert(asset.interest_accumulator == 0 as u128);\n\n        let last_updated_ts = context.timestamp();\n\n        asset_loc.write(\n            Asset {\n                interest_accumulator: 1000000000 as u128,\n                last_updated_ts,\n                loan_to_value,\n                oracle,\n            },\n        );\n\n        storage.collateral_asset.write(collateral_asset);\n        storage.stable_coin.write(stable_coin);\n    }\n\n    // Create a position.\n    #[public]\n    fn update_accumulator() -> Asset {\n        let asset_loc = storage.assets.at(0);\n        let mut asset: Asset = asset_loc.read();\n\n        let timestamp = context.timestamp();\n        let dt = timestamp - asset.last_updated_ts;\n\n        // Only update if time has passed.\n        if !(dt == 0) {\n            let precision = 1000000000 as u128;\n            let rate_per_second = 1268391679 as u128; // 4% yearly rate / (60 * 60 * 24 * 365)\n            // if rate_per_second < sqrt(WAD) our approx is eq precision + rate * dt\n            let multiplier = compute_multiplier(rate_per_second, dt);\n\n            // accumulator *= multiplier, and multiplier >= 1\n            asset.interest_accumulator = (asset.interest_accumulator * multiplier) / precision;\n            asset.last_updated_ts = timestamp;\n\n            asset_loc.write(asset);\n        }\n\n        asset\n    }\n\n    #[private]\n    fn deposit_private(\n        from: AztecAddress,\n        amount: u128,\n        authwit_nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        let _res = Token::at(collateral_asset)\n            .transfer_to_public(from, context.this_address(), amount, authwit_nonce)\n            .call(&mut context);\n        // docs:start:enqueue_public\n        Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, collateral_asset)\n            .enqueue(&mut context);\n        // docs:end:enqueue_public\n    }\n\n    #[public]\n    fn deposit_public(\n        amount: u128,\n        authwit_nonce: Field,\n        on_behalf_of: Field,\n        collateral_asset: AztecAddress,\n    ) {\n        // docs:start:public_to_public_call\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.msg_sender(), context.this_address(), amount, authwit_nonce)\n            .call(&mut context);\n        // docs:end:public_to_public_call\n        let _ = Lending::at(context.this_address())\n            ._deposit(AztecAddress::from_field(on_behalf_of), amount, collateral_asset)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _deposit(owner: AztecAddress, amount: u128, collateral_asset: AztecAddress) {\n        let _asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n\n        let coll_asset = storage.collateral_asset.read();\n        assert(coll_asset.eq(collateral_asset));\n\n        let coll_loc = storage.collateral.at(owner);\n        let collateral = coll_loc.read();\n        coll_loc.write(collateral + amount);\n    }\n\n    #[private]\n    fn withdraw_private(secret: Field, to: AztecAddress, amount: u128) {\n        let on_behalf_of = compute_identifier(secret, 0, context.msg_sender().to_field());\n        Lending::at(context.this_address())\n            ._withdraw(AztecAddress::from_field(on_behalf_of), to, amount)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn withdraw_public(to: AztecAddress, amount: u128) {\n        let _ = Lending::at(context.this_address())\n            ._withdraw(context.msg_sender(), to, amount)\n            .call(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _withdraw(owner: AztecAddress, recipient: AztecAddress, amount: u128) {\n        let asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n        let price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n\n        let coll_loc = storage.collateral.at(owner);\n        let collateral = coll_loc.read();\n\n        let debt_loc = storage.static_debt.at(owner);\n        let static_debt = debt_loc.read();\n\n        // debt_covered will revert if decrease would leave insufficient collateral to cover debt.\n        // or trying to remove more collateral than available\n        let debt_covered =\n            covered_by_collateral(price, asset.loan_to_value, collateral, 0 as u128, amount);\n        let debt_returns = debt_updates(\n            asset.interest_accumulator,\n            static_debt,\n            0 as u128,\n            0 as u128,\n        );\n\n        assert(debt_returns.debt_value < debt_covered);\n\n        coll_loc.write(collateral - amount);\n\n        // @todo @LHerskind Support both shielding and transfers (for now just transfer)\n        let collateral_asset = storage.collateral_asset.read();\n        let _ = Token::at(collateral_asset)\n            .transfer_in_public(context.this_address(), recipient, amount, 0)\n            .call(&mut context);\n    }\n\n    #[private]\n    fn borrow_private(secret: Field, to: AztecAddress, amount: u128) {\n        let on_behalf_of = compute_identifier(secret, 0, context.msg_sender().to_field());\n        let _ = Lending::at(context.this_address())\n            ._borrow(AztecAddress::from_field(on_behalf_of), to, amount)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn borrow_public(to: AztecAddress, amount: u128) {\n        let _ = Lending::at(context.this_address())._borrow(context.msg_sender(), to, amount).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _borrow(owner: AztecAddress, to: AztecAddress, amount: u128) {\n        let asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n        let price = PriceFeed::at(asset.oracle).get_price(0).view(&mut context).price;\n\n        // Fetch collateral and static_debt, compute health of current position\n        let collateral = storage.collateral.at(owner).read();\n        let static_debt = storage.static_debt.at(owner).read();\n\n        let debt_covered =\n            covered_by_collateral(price, asset.loan_to_value, collateral, 0 as u128, 0 as u128);\n        let debt_returns = debt_updates(asset.interest_accumulator, static_debt, amount, 0 as u128);\n\n        assert(debt_returns.debt_value < debt_covered);\n\n        storage.static_debt.at(owner).write(debt_returns.static_debt);\n\n        // @todo @LHerskind Need to support both private and public minting.\n        let stable_coin = storage.stable_coin.read();\n        let _ = Token::at(stable_coin).mint_to_public(to, amount).call(&mut context);\n    }\n\n    #[private]\n    fn repay_private(\n        from: AztecAddress,\n        amount: u128,\n        authwit_nonce: Field,\n        secret: Field,\n        on_behalf_of: Field,\n        stable_coin: AztecAddress,\n    ) {\n        let on_behalf_of =\n            compute_identifier(secret, on_behalf_of, context.msg_sender().to_field());\n        // docs:start:private_call\n        let _ = Token::at(stable_coin).burn_private(from, amount, authwit_nonce).call(&mut context);\n        // docs:end:private_call\n        let _ = Lending::at(context.this_address())\n            ._repay(AztecAddress::from_field(on_behalf_of), amount, stable_coin)\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    fn repay_public(\n        amount: u128,\n        authwit_nonce: Field,\n        owner: AztecAddress,\n        stable_coin: AztecAddress,\n    ) {\n        let _ = Token::at(stable_coin)\n            .burn_public(context.msg_sender(), amount, authwit_nonce)\n            .call(&mut context);\n        let _ = Lending::at(context.this_address())._repay(owner, amount, stable_coin).call(\n            &mut context,\n        );\n    }\n\n    #[public]\n    #[internal]\n    fn _repay(owner: AztecAddress, amount: u128, stable_coin: AztecAddress) {\n        let asset = Lending::at(context.this_address()).update_accumulator().call(&mut context);\n\n        // To ensure that private is using the correct token.\n        assert(stable_coin.eq(storage.stable_coin.read()));\n\n        let static_debt = storage.static_debt.at(owner).read();\n        let debt_returns = debt_updates(asset.interest_accumulator, static_debt, 0 as u128, amount);\n\n        storage.static_debt.at(owner).write(debt_returns.static_debt);\n    }\n\n    #[public]\n    #[view]\n    fn get_asset(asset_id: Field) -> Asset {\n        storage.assets.at(asset_id).read()\n    }\n\n    #[public]\n    #[view]\n    fn get_position(owner: AztecAddress) -> pub Position {\n        let collateral = storage.collateral.at(owner).read();\n        let static_debt = storage.static_debt.at(owner).read();\n        let asset: Asset = storage.assets.at(0).read();\n        let debt = debt_value(static_debt, asset.interest_accumulator);\n        Position { collateral, static_debt, debt }\n    }\n\n    #[public]\n    #[view]\n    fn get_assets() -> pub [AztecAddress; 2] {\n        [storage.collateral_asset.read(), storage.stable_coin.read()]\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "64": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "65": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "72": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between a #[private] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[private] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[private] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[private] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[private] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp =\n            inputs.historical_header.global_variables.timestamp + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// TODO(https://github.com/AztecProtocol/aztec-packages/issues/14025) - we\n    /// are considering making msg_sender: Option<AztecAddress>, since\n    /// a returned value of `Option:none` will be clearer to developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `-1` for the first function call of the tx.\n    ///\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[private] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[private]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some historical block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[private] macro.\n    ///\n    /// # Arguments\n    /// * `returns_hasher` - A hasher containing the return values to hash\n    ///\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[private] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a heft function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "73": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between a #[public] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[public] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[public] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[public]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases, and is enforced by the protocol's kernel circuits.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the account or contract that called\n    ///   this function\n    ///\n    /// # Examples\n    /// ```rust\n    /// #[aztec(public)]\n    /// fn transfer(context: &mut PublicContext, to: AztecAddress, amount: u64) {\n    ///     let sender = context.msg_sender();\n    ///     // Only the sender can transfer their own tokens\n    ///     assert(sender == get_token_owner(), \"Unauthorized\");\n    /// }\n    /// ```\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    /// * Globally visible unlike private execution where it's contract-local\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[public] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "74": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "75": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "77": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "79": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "96": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    }
  }
}
