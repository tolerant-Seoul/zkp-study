{
  "transpiled": true,
  "noir_version": "1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec",
  "name": "Claim",
  "functions": [
    {
      "name": "claim",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "proof_retrieved_note",
            "type": {
              "kind": "struct",
              "path": "aztec::note::retrieved_note::RetrievedNote",
              "fields": [
                {
                  "name": "note",
                  "type": {
                    "kind": "struct",
                    "path": "uint_note::uint_note::UintNote",
                    "fields": [
                      {
                        "name": "owner",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "randomness",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "value",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 128
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "contract_address",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "metadata",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::note::note_metadata::NoteMetadata",
                    "fields": [
                      {
                        "name": "stage",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 8
                        }
                      },
                      {
                        "name": "maybe_note_nonce",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "855401245733623969": {
            "error_kind": "string",
            "string": "Obtained invalid key validation request"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4174732183419875782": {
            "error_kind": "string",
            "string": "Proving note inclusion failed"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6886668913653275628": {
            "error_kind": "string",
            "string": "Note does not belong to the sender"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16665315179574742866": {
            "error_kind": "string",
            "string": "Note does not correspond to the target contract"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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8vXx3xGeYnakJz6jPPEZ7YnPGE98xnriM84Tn/Ge+EzwxGeiJz6TPPGZ7InPFE98pnriM80Tn5088dnZE59dPPHZ1ROf3Tzx2d0Tnz088dnTE5/pnvjs5YnPDE989vbEZ6YnPvt44jPLE599PfHZzxOf/T3xOcATnwM98TnIE5+DPfGZ7YnPHE98DvHE51BPfOZ64jPPE5/5nvgc5onP4Z74HOGJzwJPfI70xOcoT3yO9sTnGE98jvXEZ6EnPllPfBZ54rPYE58lnvgc54nPUk98lnnis9wTnxWe+Kz0xGeVJz7He+Jzgic+qz3xOdETn5M88TnZE581nvic4onPqZ74nOaJz+mITz6fNTnDkz5neuJzlic+Z3vic44nPud64nOeJz7ne+JzgSc+F3ric5EnPhd74nOJJz6XeuJzmSc+l3vic4UnPld64nOVJz5/8cTnak98rvHE51pPfK7zxOd6T3xu8MTnRk98bvLE52ZPfG7xxOdWT3xu88Tndk98/uqJzx2e+Nzpic/fPPH5uyc+d3ni8w9PfO72xOefnvjc44nPvZ743OeJz/2e+Dzgic+Dnvg85InPvzzx+bcnPg974vOIJz6PeuLzmCc+j3vi84QnPk964vOUJz5Pe+LzjCc+z3ri85wnPs974vOCJz4veuLzkic+L3vi84onPq964vOaJz6ve+LzH0983vDE501PfN7yxOdtT3ze8cTnXU983vPE531PfD7wxOdDT3w+8sTnv574fOyJzyee+Hzqic9nnvh87onPWk98vvDE50tPfL7yxOdrT3y+8cTnW098vvPE53tPfH7wxOd/nvj86InPT574/OyJzy+e+PzqiY98aVVMXFLRjE/giU+BJz4pT3zSnvgUeuJT5IlPsSc+JZ74lHriU88Tn/qe+JR54tPAE59yT3wynvg09MSnkSc+jT3xaeKJT1NPfJp54tPcE58Wnvi09MSnlSc+rT3xaeOJT1tPfNp54tPeE58OnvhUeOLT0ROfTp74dPbEp4snPl098dnIE59unvh098Snhyc+PT3x6eWJT29PfPp44rOxJz6beOLT1xOffp74bOqJz2ae+Gzuic8Wnvhs6YnPVp74bO2Jzzae+Gzric92nvhs74nPDp747OiJT39PfCo98Rngic9AT3wGeeJT5YnPYE98hnjiM9QTn2Ge+Az3xGeEJz4j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",
      "debug_symbols": "tL3RknQtbqZ7L33sg4VAEvKt7Njh8Hg8E47osCdszz5x+N53IkAvVdVJUpnrO+l6/q+r9LIAabFAwH/95X/+8//4v//7H/7lX//Xv/3HX/7+//mvv/yPf/+Xv/71X/73P/z13/7pH//zX/7tXx//+l9/udr/pPKXv0+U8n//3V9S+2+Tx3//3V9M+4/af5j/SNc1fqbxk8bPPH6W8ZPHTxk/dfys4+ewl4a9NOylYS8Ne2nYS8NeGvbSsJeGvTTs0bBHwx4NezTs0bBHwx4NezTs0bBHw14e9vKwl4e9POzlYS8Pe3nYy8NeHvbysFeGvTLslWGvDHtl2CvDXhn2yrBXhr0y7PGwx8MeD3s87PGwx8MeD3s87PHDHref1n/KNX6m8ZPGzzx+lvGTx08ZP3X8HPZk2NOHPWk/0/hJ42ceP8v4yePnw561n618uUGdYAPqNSFNoAntqUuDMoEnyASdUCfYALsmpAk0YVq2admmZfeX9qzuMQ51QrP8qGZyt3FIEx6WySFPKBN4gkzQCXWCDWgO1CFNmJbTtJym5TQtNzei3EAn1Ak2oLlShzSBJuQJZQJPmJZpWqZpmablPC3naTlPy3laztNynpbztJyn5Twt52m5TMtlWi7TcpmWm4sRN+AJMkEn1Ak2oDlahzSBJuQJ0zJPyzwt87TM0zJPyzIty7Qs07JMyzIty7Qs07JMyzIty7Ss07JOyzot67Ss07JOyzot67Ss07JOy3VartNynZbrtFyn5Tot12m5Tst1Wq7Tsk3LNi3btGzTsk3LNi3btGzTsk3LNizn65qQJtCEZrk2KBN4gkzQCXWCDXAfdEgTaMK0nKblNC2nabn5YE4N6gQb0HwwS4M0gSbkCWUCT5AJOqFOsAF5Ws7Tcp6W87ScR9zImSfIBJ1QJ4yIlMs1IU2gCXnCtFym5TItl2m5+WC2Bjag+WCHNIEm5AllAk+QCTphWuZpWaZlmZZlWm4+WK4GZQJPkAk6oU6wAc0HO6QJNGFa1mlZp2WdlpsPltygTrABzQeLNkgTaEKeUCbwBJmgE+oEG2DTsk3LNi3btGzTsk3LNi3btGzTsg3L5bompAk0IU8oE3iCTNAJdcK0nKblNC2naTlNy2laTtNympbTtJym5TQt07RM0zJNyzQt07RM0zJNyzQt07RM03KelvO0nKflPC3naTlPy3laztNynpbztFym5TItl2m5TMtlWi7TcpmWy7RcpuUyLfO0zNMyT8s8LfO0zNMyT8s8LfO0zNOyTMsyLcu0LNOyTMsyLcu0LNOyTMsyLeu0rNOyTss6Leu0rNOyTss6Leu0rNPy9MEyfbBMHyzug9agTOAJMkEn1Ak2wH3QIU2gCdOyTcs2Ldu0bNOyTcs2LPN1TUgTaEKeUCbwBJmgE+qEaTlNy2laTtNympbTtJym5TQtp2k5TctpWqZpmaZlmpZpWqZpmaZlmpZpWqZpmablPC3naTlPy3laztNynpbztJyn5Twt52m5TMtlWi7TcpmWy7RcpuUyLZdpuUzLZVrmaZmnZZ6WeVrmaZmnZZ6WeVrmaZmnZZmWZVqWaVmmZZmWZVqWaVmmZZmWZVrWaVmnZZ2WdVrWaVmnZZ2WdVrWaVmn5Tot12m5TsvTB3n6IE8f5OmDPH2Qpw/y9EGePsjTB3n6IE8f5OmDPH2Qpw/y9EGePsjTB2X6oEwflOmDMn1Qpg/K9EGZPijTB2X6oEwflOaDTA3SBJqQJ5QJPEEm6IQ6wQbQtEzTMk3LNC3TtEzTMk3LNC3TtEzTcp6W87Scp+U8LedpOU/LzQc5N9AJdUKz/BjYS/PBDmkCTcgTygSeIBN0Qp0wLfO0zNMyT8s8LfO0zNMyT8s8LfO0zNOyTMsyLcu0LNOyTMsyLcu0LNOyTMs+F/P40JDmgx3ShDYdczXIE8oEniATdEKdYAOaD3ZIE6blOi3XablOy80HpbVX88EOdYINaD7YIU2gCXlCmcATpmWblm1atmFZmw9KaZAm0IQ8oUzgCTJBJ9QJNiBNy2laTtNympbTtJym5TQtp2k5TctpWqZpmaZlmpZpWqZpmaZlmpZpWqZpmablPC3naTlPy3laztNynpbztJyn5Twt52m5TMtlWi7TcpmWy7RcpuUyLZdpuUzLZVrmaZmnZZ6WeVrmaZmnZZ6WeVrmaZmnZZmWZVqWaVmmZZmWZVqWaVmmZZmWZVrWaVmnZZ2WdVrWaVmnZZ2WdVrWaVmn5Tot12m5Tst1Wq7Tcp2W67Rcp+U6Lddp2aZlm5ZtWnYflAZlAk+QCTqhTrAO1X3QIU2gCXlCmcATZIJOqBOm5TQtp2k5TctpWk7TcpqW07ScpuU0LadpmaZlmpZpWqZpmaZlmpZpWqZpmaZlmpbztJyn5Twt52k5T8t5Ws7Tcp6W87Scp+UyLZdpuUzLZVou03KZlsu0XKblMi2XaZmnZZ6WeVrmaZmnZZ6WeVrmaZmnZZ6WZVqWaVmmZZmWZVqWaVmmZZmWZVqWaVmnZZ2WdVrWaVmnZZ2WdVrWaVmnZZ2W67Rcp+U6LddpuU7LdVqu03Kdluu0XKdlm5ZtWrZpefpgnT5Ypw/W6YN1+mCdPlinD9r0QZs+aNMHbfqgTR+06YM2fdCmD9r0QZs+aNMHbfqgTR+06YM2fdCmD9r0QZs+aNMHbfqgTR+06YM2fdCmD9r0QZs+aNMHbfqgTR+06YM2fdCmD9r0QZs+aNMHbfqgTR+06YM2fdCmD9r0QZs+aNMHbfqgTR+06YM2fdCmD9r0QZs+aNMHbfqgTR+06YM2fdCmD9r0QZs+aNMHzX3w8TVh7oMOaQJNyBPKBJ4gE3RCnTAt67Ss07JOy80H9WpQJvAEmaAT6gQb0HywQ5pAE6blOi3XablOy3VartNynZZtWrZp2aZlm5ZtWrZp2aZlm5ZtWrZh+bGsfgWlIArKQSWIgyRIg2pQaKTQSKGRQiOFRgqNFBopNFJopNBIoUGhQaFBoUGhQaFBoUGhQaFBoUGhkUMjh0ZzUi1OOagENQ11kiANqkE2qTnroBREQTmoBIVGCY0SGiU0SmhwaHBocGhwaHBocGhwaHBocGhwaEhoSGhIaEhoSGhIaEhoSGhIaEhoaGhoaGhoaGhoaGhoaGhoaGhoaGjU0KihUUOjhkYNjRoaNTRqaNTQqKFhoWGhYaFhoWGhYaFhoWGhYaFhU8PzZwalIArKQSWIgyRIg2pQaKTQSKGRQiOFRgqNFBopNFJopNBIoUGhQaFBoUGhQaFBoUGhQaFBoUGhkUMjh0YOjRwaOTTCz1P4eQo/T+HnKfw8hZ+n8PMUfp7Cz1P4eQo/T+HnKfw8hZ+n8PMUfp7Cz1P4eQo/T+HnKfw8hZ+n8PMUfp7Cz1P4eQo/T+HnKfw8hZ+n8PMUfp7Cz1P4eQo/T+HnKfw8hZ+n8PMUfp7Cz1P4eQo/T+HnKfw8hZ+n8PMUfp7Cz1P4eQo/T+HnKfw8hZ+n8PMUfp7Cz1P4eQo/T+HnKfw8hZ+n8PMUfp7Czyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfycws8p/JzCzyn8nMLPKfzcc4r08amSPKloUAqioBxUgjhIgjSoBoVGCo0UGik0Umik0EihkUIjhUYKjRQaFBoUGhQaFBoUGhQaFBoUGhQaFBo5NHJo5NDIoZFDI4dGDo0cGjk0cmiU0CihUUKjhEYJjRIaJTRKaJTQKKHBocGhwaHBocGhwaHBocGhwaHBoSGhIaEhoSGhIaEhoSGhIaEhoSGhoaGhoaGhoaGhoaGhoaGhoaGhoaFRQ6OGRg2NGho1NGpo1NCooVFDo4ZG8/N6OaUgCspBJYiDJEiDapAN8sSlQSmIgnJQCeIgCdKgGhQaKTRSaKTQSKGRQiOFRgqNFBopNFJoUGhQaFBoUGhQaFBoUGhQaFBoUGjk0MihkUMjh0YOjRwaOTRyaOTQyKFRQqOERgmNEholNEpolNAooVFCo4QGhwaHBocGhwaHBocGhwaHBocGh4aEhoSGhIaEhoRG8/NanCRIg5qGOtmk5ueDUhAF5aASxEESpEGhoaFRQ6OGRg2NGho1NGpo1NCooVFDo4aGhYaFhoWGhYaFhoWGhYaFhoWGTQ1PjhqUgigoB5UgDpIgDapBoZFCI4VGCo0UGik0Umik0EihkUIjhQaFBoUGhQaFBoUGhQaFBoUGhQaFRg6NHBo5NHJo5NDIoZFDI4dGDo0cGiU0SmiU0CihUUKjhEYJjRIaJTRKaHBocGhwaHBocGhwaHBocGhwaHBoSGhIaEhoSGhIaEhoSGhIaISfc/g5h59z+DmHn3P4OYefc/g5h59z+DmHn3P4OYefc/g5h59z+DmHn3P4OYefc/g5h59z+DmHn3P4OYefc/g5h59z+DmHn3P4OYefc/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYSfS/i5hJ9L+LmEn0v4uYafa/i5hp9r+LmGn2v4uYafa/i5hp9r+LmGn2v4uYafa/i5hp9r+LmGn2v4uYafa/i5hp9r+LmGn2v4uYafa/i5hp9r+LmGn2v4uYafa/i5hp9r+LmGn2v4uYafa/i5hp9r+LmGn2v4uYafa/i5hp9r+LmGn2v4uYafa/i5hp9r+LmGn2v4uYafa/i5hp9r+LmGn2v4uYafe4aYXU4UlINKEAdJkAbVIJvU/HxQaGhoaGhoaDQ/t+QkQRpUg2xS8/NBKYiCclAJCo0aGjU0amjU0LDQsNCw0LDQsNCw0LDQsNCw0LCp4Ylkg1IQBeWgEsRBEqRBNSg0Umik0EihkUIjhUYKjRQaKTRSaKTQoNCg0KDQoNCg0KDQoNCg0KDQoNDIoZFDI4dGDo0cGjk0mp8bO2lQDWoazSs84WxQCqKgHFSCOEiCNKgGhQaHBocGhwaHBocGhwaHBocGhwaHhoSGhIaEhoSGhIaEhoSGhIaEhoSGhoaGhoaGhoaGhoaGhoaGhoaGhkYNjRoaNTRqaNTQqKFRQ6OGRg2NGhoWGhYaFhoWGhYaFhoWGhYaFho2NTxZbVAKoqAcVII4SII0qAaFRgqNFBopNFJopNBIoZFCI4VGCo0UGhQaFBoUGhQaFBoUGhQaFBoUGhQaOTRyaOTQyKGRQyOHRg6NHBo5NMLPLfzcws8t/NzCzy383MLPLfzcws8t/NzCzy383MLPLfzcws8t/NzCzy383MLPLfzcws8t/NzCzy383MLPLfzcws8t/NzCzy383MLPLfzcws8t/NzCzy383MLPLfzcws8t/NzCzy383MLPLfzcws8t/NzCzy383MLPLfzcws8t/NzCzy383MLPLfzcws8t/NzCzy383Kaf0zX9nK7p53RNP6dr+jld08/pmn5O1/Rzuqaf0zX9nK4rNFJopNBIoZFCI4VGCo0UGik0Umik0KDQoNCg0KDQoNCg0KDQoNCg0KDQyKGRQyOHRg6NHBo5NHJo5NDIoZFDo4RGCY0SGiU0SmiU0CihUUKjhEYJDQ4NDg0ODQ4NDg0ODQ4NDg0ODQ4NCQ0JDQkNCQ0JDQkNCQ0JDQkNCQ0NDQ0NDQ0NDQ0NDQ0NDQ0NDQ0NjRoaNTRqaNTQqKFRQ6OGRg2NGho1NCw0LDQsNCw0LDQsNCw0LDQsNMLPU/h5Cj9P4ecp/DyFn6fw8xR+nsLP+/lS1+VogX7K1MAEJGAGFiADBahAqLnLSyN3+U4piIJyUAniIAnSoBoUGjk0cmjk0MihkUMjh0YOjRwaOTRyaJTQKKFRQqOERgmNEholNEpolNAoocGhwaHBocGhwaHBocGhwaHBocGhIaEhoSGhIaEhoSGhIaEhoSGhIaGhoaHev6ojATOw9a/Uz15ioAAVWIEW6AdgDUxAAmYg1CrUKtQq1PxArGSOFuiHYjl6+pgfXuXpY4+O7th+laihH742MAEJmIEFyEABKrACoZahlqGWoZahlqGWoZahlqGWoZahVqBWoFagVqBWoFagVqBWoFagVqDGUGOoMdQYagw1hhpDjaHGUGOoCdQEagI1gZpATaAmUBOoCdQEago1hZo7ix/Y5BlmEwuQgQJUoKuJowW6swxMQAJmYAEyUIAKhFqFmkHNz5AjdSRgU8vuOH6S3EAGClCBFWgTPflsYgISMAMLkIECdLXkWIEW6C/RgQlIQFfr57oVIANdTRwVWIEW6LFkYAK6mjpmYAEyUIAKrEAL9FgyMAGhlqGWoeaxJFdHAWqgR41cHN2uOTYLxevM40PpvyBABVagBXp8GNjsFnYkYAYWIAMFqMAKtECPDwOhJlATqHl8KN5YHh8Gupo/vMeHgRVogR4fBiZgU2PvqR4fBhYgAwWowAq0QI8PAxMQahVqFWoeH9ib0OPDQFcjxwq0QI8PA13Na8fjw8AMLEAGCtDVvCP2Eyc72kRPWpuYgATMwAJkoAAVWIFQ8/jQTpUgz1+bSEBXK44FyIHu8wPdgjm23xVybMWRfqyjAivQAt2lBzZj4oV0lx6YgQXIQAG6mj+FDw8GWqA7+sAEJGAGFiADBQi1ArUCNXd/8dpx9x9IwKbWdsaRZ6dNZGBTU69Ud3/1inL31342pgW6+w9MQAJmYFOrLuHuP1CACqxAC3T3H5iABMxAqCnUFGoKNYWaQq1Czd2/eu9z9x+YgQXIQAG63eabnqs2MQEJmIFloqeVpbauSJ5XNtElWst71tdjdO5YgRboPjQwAQmYgQXIQAFCjaBGUMtQy1DLUMtQc3dq65Tk+V2pLSiRJ3g9Jq0dE5CAzYJlxwJkoAAVWIEW6I4zMAEJCDWGGkONocZQY6gx1NxFrDi6hX4krNdv/wUFVqAFdmfomIBu1zuMO8NAL693GHeGgQL0knk38g5u3izewQd6f/Ba9zNbfWbD07YmKrACraG3pp/eOjABqaHb9TNcBxYg1AxqBjWDmp/n6uhJXL2qPYtrIgEzsAAZKEAFVmC0pqdzTYRaglqCWoJaglqCmnusdw1P1+pdQ7pv+i903+zIQAEqsAJt9gdP25qYZifwxK2JGSiza0j3zdYfpPtmxzS7hqdljQbw81wHFiADZXYCz82aWIE2O4GnZ01MQKgx1BhqDDWOvuO5T4+5ZUcGCtCL47XjxxsPtEA/4nhgAhIwAwuQgQKEWoVahZpBzaDmjpP8gdxxBhYgAwWowKbmczaeFNXRs6ImJiABM7AAGShABVYg1BLU+iHl5EjADHS17MhAAbpacaxAC/Rjywe6Wj/32u2KIwMFqEC3Wx3dbvMAz44in/Ly9KiJBMzApuYHrXuK1EQBKrCp+cHknhxF41Rul/DiuL+RF6efYe5/5v42kIECVGAFWqD7W/Zad38b2NT8Y9szpSYWIAMFqEBXU0cL9FPOByYgATOwABkoQAVCTaCmUPOzz/1r3JOnJmagq3kbe6gYKMCm5p/rnkJFxRvLQ0VHDxUDE5CAGdjU/MvdM6kmClCBFWiBHioGJiABMxBqBjWDmkHNoGah5olV5B/xnlk1kYBek9mxABkoQAVWoKu1qvYUq4kJSMAMLEAGClCBFQg1ghpBjaDmocI/+D25aqICK9ACPVQMTEACZmABQi1DLUMtQy1DrUCtQK1ArUCtQK1ArUCtQK1ArUCNocZQY6gx1BhqDDWGGkONocZQE6gJ1ARqAjWBmkBNoCZQE6gJ1BRqCjWFmkJNoaZQU6gp1BRqCrUKtQq1CrUKtQq1CrUKtQq1CrUKNYOaQc2gZlAzqBnUDGoGNYOahZpdFzABCZiBBchAASqwAqGWoJaglqCWoJaglqCWoJaglqCWoEZQI6gR1AhqBDXEEkMsMcQSQywxxBJDLDHEEkMsMcQSQywxxBLrsSQ5KrACLbDHko4J6EFXHQuQgQJUYAVaoAeQgQlIQKgx1BhqDDWGGkONoSZQE6gJ1ARqAjWBmkBNoCZQE6gp1BRqCjWFmkJNoaZQU6gp1BRqFWoVahVqFWoVahVqFWoVahVqFWoGNYOaQc2gZlAzqBnUDGoGNZtq+bouYAISMAMLkIECVGAFQi1BLUEtQS1BLUEtQS1BLUEtQS1BjaBGUCOoEdQIagQ1ghpBjaBGUMtQy1DLUMtQy1DLUMtQy1DLUMtQK1ArUCtQK1ArUCtQ64OR4qjACvRw5df29MFIxwQkYAYWoAdHV+uDkY4KdDVxtMA+GOmYgATMwKbWDrnOnkA2UYCuZo4VaIF9MNIxAQnY1Nq6SPZMsokMdLXsqMAKtECPGuL16/FBvKI8PgxUoFvwivL40NHjw8BWXulXJBEwAwvQ1fyBPD4MVGCd6Cli1NYvsueDPT77HRkoQK/ffjtTBVpgHzR0TEACZmABMtDVyFGBFWiB7vMDE5CAGViADIQaQY2gRlDLUMtQy1Bzn29rPtnTwagdk5g9H2xiBVqge/fABCRgBhYgA6FWoFagVqDGUGOoMdQYagw1hhpDjaHGUGOoCdQEagI1gZpATaAmUBOoCdQEago1hZpCTaGmUFOoKdQUago1hVqFWoVahVqFWoVahVqFWoVahVqFmkHNoGZQM6gZ1AxqBjWDmkHNQs1PWpuYgATMwAJkoAAVWIFQS1BLUEtQS1BLUEtQS1BLUEtQS1AjqBHUCGoENYIaQY2gRlAjqBHUMtQy1DLUMtQy1DLUEEsIsYQQSwixhBBL+mWNbf049+satTpmYAEyUIAKrEAL7LGkYwJCjaHGUGOoMdQYaj2WmKMF9ljSMQEJmIGuJo4MFKACK9ACeyzpmIAEzECoKdQ8lrS15twvfRxYgU2t+hN71KhedI8PbfE896sdBzYLbZUr9+sdB1qgx4eBCUjAVl7zruHxYSADBajACrSJ/drHgQlIwAwsQAa6GjsqsAJdrdVkvwpyYAK6mjpmYAEy0NWq40Mtt/Ws3C+CvPyeRb8KciABM7A0JEdumB2loZfXr4W8vGR+MeRAC/TLIQe6mpfML4gcmIEF6Grm2CSSF6e5f05enOb+OXmlNvd/PKBjAhIwAwuQgQJ0Na8zvzWyo/u891RPkptIwAwsQAYKUIEVaIECNYGaXyNJ3oTN5ycWYHugcbemABVYgRbYfH5iAhIwAwsQago1dTVvFq1AC6wXMAEJ6GreuWoBMlCACqxAC7QLmIAEhJpBzaBmrub91xRYga7WeoknyT36vmMCNrWWGJs9SW5iU/OLWT1JbqIAFViBFtjiw8QEJGAGQi1BLUEtQS1BLUGNoEZQI6gR1AhqBDWCGkGNoEZQy1DLUMtQy1DLUMtQy1DLUMtQy1ArUCtQK1ArUCtQK1ArUCtQK1ArUPOrZ9sKafaMu4kEzMAy35ulx5KOAlRgBVpgjyUdE5CA/hTZsc5Xs2fR5ZZtnD2LbmICEjADC5CBXg/NnTwzbtRDxRNXPLH7/EAGev2KowIr0AINrWlQM7SmoTUNrWloTUNrus/3MrjPD7SJfsrbxDTLwN3nO2ZgqDF8nuHzDJ9n+DzD5xk+zyn6DicCZmABcpQhCVCBUIPPM3ye4fMMn2f4PMPnmaLduPt8RwVWYLQbd5/viJqEzzN8nuHzDJ9n+DzD5xk+z/B5Lmi3gposqMmCmiyoye7z6ihAV6uOFWiB3ec7NrXiZXCfH5iBBchAASqwApta8UL6FdQD3ef9F3yk4F7oKYTZb372FMKJCqxAtJCihRQtpOjrir7eI0FH9D5FCylaSNFCihaq6H2IGlzRHyr6Q0V/8PjQEg6yJxZOtECPD8XrweND8ZJ5fBiYgQXIQAEqsAJtovTZg+yYgQXIQAEqsAItsM8edExAqCWoJaglqCWoJaglqCWoEdQIagQ1ghpBjaBGUCOoEdQIahlqGWoZaphzlAy1DLUMtQy1DLUMtQK1ArUCtQK1ArUCtQK1ArUCtQI1hhpDjaHGUGOoMdQYagw1hhpDTaAmUBOoCdQEagI1gZpATaAmUFOoKdQUago1hZpCTaGmUFOoKdQq1CrUKtQq1CrUKtQq1CrUKtQq1AxqBjWDmkHNoGZQM6gZ1AxqFmo9q3JgAhIwAwuQgQJUYAVCDbFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLFLFEEUsUsUQRSxSxRBFLKmJJRSypiCUVscTTLrMvnnva5UQBKrACLdC/UAYmIAEzEGoJaglqCWoJaglqBDWCGkGNoNZjyeXIQFerjgqsQAv0L5SBCUjApsZu179QBjKwqbVMqOzJmBMr0NXavJEnY05MQG83/90eSzoWIAMFqMAKtMAeSzomoK+uF0cG+lOQowIr0AL9W2RgAhLQ68zt+hfKQAa6GjsqsAJdzfuvf6EMTEDPHPDf7ZkOHQuQgQJUYAVaoEeNgQnoTyGODBSgP4X3Sf9CGWiB/oXiiQGeYDnR68w7gX+hDCzApuYpIZ5gOVGBFWgTPcFyYgI2NUmOGViADBSgAuvY8pOtb3Iqjr7rxX/BRxUDC5CBAlRgBc4tP7mnUg5MQALmsTcqeyrlRAYKUIEVaIF9Q1THBIyWt8xAAUbLW67AaHlPmuzN7UmTE6PlPX9yYgFGy3v+5EQFViBantHyjJZntDyj5Rktz2h5RsszWp7R8oKWF7S8oOUFLS9oeUHLC1pe0PKClle0vKLlFS2vaHlFyytaXtHyipZXtLyi5StavqLl3ec9VcpzIicKUIHeFtnRAt3nByYgjd2t2XMiJxYgAwWowAq0geXq2x07ehurYwEyUIAKrEB/itrQ3/4DE5CAGViADBSgAisQagQ1gpq//VuWV/Hsx4kF2NTa27949uNEBTa1lt1UPPsxt7FR8ezH3FILimc/TiRgBhYgA11NHBVYgRbokWBgAhIwAwuQgVArUCtQK1BjqDHUPBKoV6pHgoEF2NSqV5RHgoEKrEAL9DHBwKZWvX59TDAwAwuQgQJUYAVaoI8JBkJNoaZQ81nLtgO/ePbjRAG6mteOz1pW71E+a9nRZy0HJiABM7AAGSjApmbeJz1qDGxq3Xk9agxMQAI2NfOi+0hhIAMFqMAKtIl+wt5EV2NHArqaOBYgAwWoQJdoscRTKScmIAEz8CFRWk5D8VTKiQJUYAVaYAsgpb1QiqdSTiRgBhYgAwWowAq0wAy1DLUMtexq5FiADHS17KjACnQ1b4vial6/xdW8zgoBM7AAGSjA9rp1hb7V0ykFUVAOKpPEjVdHBgqwveG9AvwF38km+eu9UwqiILdojq0akrer+6P//+6OnVKQJ5845aASxEESpEEu0s1YYHPDkryJmhtOJGArZvLqMLfgTmQ2sacempMbYEcCZmABMlBGlfTEw041aFZnzzrslILKrETPI+yV6HmEpW1jLp5HONBdpqXKFM8jnOglrY7erZxKEAdJkAbVSe4WyQviDkD9X9tfZycJ0qD21+Rkk7zvd0pBFJSDXMTrwPv9wKZC/RcUWAPZjbo6uwVvQmZgs+C2WKNiuAItUC6gm/XWFAJmYIkKd08aKECoCdQEago1hZpCTaGmUFOoKdQUago1hVqFWk1Aml29olNXdOqKTl0FqIHmjeJFcGcaaBN7nh47pSAKykEliIMkSINqkE1KoZFCI4VGCo0UGik0Umik0EihkUKDQsNdzSvNE/UmZmCrPw9vnqg30f2lOCqwAi3Q304DE5CAGViADIRahlqGWoaae2j2Z3MXHUjADCxABrqaOCqwAj0JplHP3nNKQRSUg0qQW/TO5A6a/V/dQbPXtzvowAwswFZSjwGejDdRgRVogf628+L7264TBTUpD12eiTeRgS7lNezeObACXcqNuXcObA9W/HGbd07MQP96cuIgCdKgGmST/DVYvAL9NVi8ftq4s7RJ0eJ5dRMr0CZ6Xl1ps4XF8+omEjADC9DHnU4SpEE+fHeyST767JSCKCgHuUh2ZKAALdD9tc1kFk+Rm+gfUU4cJEFeI+JYgRbozspeFnfWgS7lT+fOOrAVVrwi3VnbHE3x/LgiXk/urG3usnh+3EQLdGcdmIAEzMACdDUvrzurzxZ4flzxL3XPjyv+Te6ZcMW/vj0TbmIGFiADBaiB7qfqj+l+OjADC5CBAtRAf0/6ZIBntxWfDPDstokCVGB7Nn80dzkn97hOKYiCclAJ4iAJ0qDQqKFhoWGhYaFhoWGhYaFhoWGhYaFhU8Nz3galIK8QJwnSoBpkk5qzDUpBFJSDSlBopNBIoZFCI4UGhQaFBoUGhQaFBoUGhQaFBoWG+5pP63he2sQCbIbaNobieWnFp1Q8L620fKziGWjFZ0E8q6z4BINnlXH/Rw2qQTapvdMGpSAKykElyEW8bO42AxVYgRbo77+BCUjADGyP77MjnmI2UYBu1yvQB50t2bR42hi7geZhgzhIgjSoBtmk5l2DUpCLeAd19xpYgN7RvZW653jTdNfxWuu+0zEDC5CBAlRgBdpE6T7UMQEJmIGulh0ZKEAFVqAFuq8NTEACZiDUEtQS1BLUEtQS1NzrfEbIs8UmEjADC5CBbrd1Gc8AKz7h4xlg/qbzBLBBJaj1mP57EqRBNcgmNQ8c5AUyx/bHPj3kyVwTK7D9vU/YeDLXxAQkYAYWIAMFqMAKhJpATVzNK1sImIGu5nUpDHQ1r1ZxNX94cTV/eLFAvYBNzWc6PJlrYlPz6Q1P5mKf3vBkLh9seC7XIA2qQTap+e0gt1gcW0n9c89Ts9i/OD01a6IFNsdl/7b01KyJBMzAAnS77QE93Yp9ssHTrdjnATzdamIGFiADBajACrTA5GrkmIAEdLXsWIAMFKCrFccKtMDmjOK/2nxxEAU9pHwU6KlWgzhIgjSoBrlIayPPspqYgARkoBdTHC3QfdE/3z1zaiIBW0n7r5YgDpIgDapBNql57KAUREGhwaHBocGhwaHBocGhIaEhoSGhIaEhoSGh4R7q36CeIjWxAluV+Vykp0hNTMBWZdkbyD10YOtH/uHsKVITBajACnQ1L5m/Xge6mrdKdTUvmXuvf1t5itREBjY1n+jzFKmJFdiq0H+1ufSgFERBOagEucXmX57wxP497AlP7POEnvA0MQMLsJW05YUXT3iaqMAKtMDmzf7Z4flO7KNDz3diHxh7vtNEH914Gf2KXv+reU1nqfM+n1LnfT6lzvt8iicqsX88eqLSxAq0QHfHgQlIwAwsQAZCLUMtQy1DzV3Xx1ueqDSRgBlYgAzUWQd+s08nm+Q3+/jv+c0+nSjIjXsV+St2IAMFqMAK9EdpfdizlSb6o3hr+it2YAaWflNUiXs6S9zTWeKezhL3dJa4p7PEPZ0l7ukscU9niXs6S9zTWeKezhL3dJa4p7PEPZ0l7ukscU9niXs6S9zTWeKezhL3dBZPV2KfNPB0pYkKbJXm72pPVxro79+BCdgqzecaPF2J/Z3h6Up+zVXxdKWJAmxq/m7ydKWJNtHTlSYmIAEzsAAZKEAFViDU/GI/c0pBFJSDShAHSZAG1SCbRKFBoUH+PMUxAwuQgQJUYAVaoEeGgQnoauyYgQWoge7tPpXjKUrsUzmeojQxAwvQy+vP5iPsgQqsQAv0EfbABCRgBhYg1BhqDDWGGkNNoObu73HdE5cmNjWfDPLEpYkM9E8P7zr+/h5YgRbo7++BCUjADHQ1byx/fw8UoAJdTRwt0N/fAxOQgK7mD+/v74EMFKACK7Cp+VvN05kmJiABM7AAGShABVbgVGNPZ5qYgK6WHDOwAF0tO7pacVSgq7GjBfr4vc1nsCc5TSRgBhYgAwWowAq0QIIaQY2gRlAjqBHUCGoENYIaQS1DLUMtQy1DLUMtQy1DLUMtQy1DrUCtQK1ArUCtQK1ArUCtQK1ArUCNocZQ81jSpqTYk5wmFiAD23uqfTKyJzlNrEAL9KtOBiYgATOwAP0pakOPD9X/1ePDwFZe8w7u8WFgATJQgAqsgR4JzJ2hon4rnth9fqACK7DVb5umYk9GmpiABERrGtQMrWloTUNrGlrTojVT93l1TEACZmCZZfBkpIkCVNitQKjB5xN8PsHnE3w+peg7KTFQgAqsUYYUNel5SROhBp9P8PkEn0/w+QSfT/D5BJ9P3ee9DBk1mVGTGTWZUZPu822Wjz0vaaLXZHFUYAVaoPu8uTH3+YEEzMACZKAAFehq1dECOTq4ZylxG12xpylNLEAGomv4oGEgGovRWILGkgQkIBpL0FiCxhI0lqCxBI0l6IiKjqjoGs39pQ2gOfUJuI4C9Ck4r4c+B+cl65Nwjn0WrmMCEjADC5CBAvQhVXtZpv5x0DEB3a73B/+YH+h2/YGMgQL0p/Dmtgq0iZ5GJS2rjD2PaiIBM7AAGShABVagBSaoNff3UYcnUw3ioIdRH1F4ftWgGuQWW7/z7KqJCUjADCzAVv7kUj5lN1CBTcxrqPl9p+b2g1IQBeWgEsRBEqRBoZFDo4RGCY0SGiU0SmiU0CihUUKjhEYJDZ/Sa1PS7IlZEwnoMzD9dwvQp3vEUYAK9BmCbsECfXKvTXWz52tNdDVvTZ/fG1iA7avQm8KnCDppUA2yST5F0MktsqO3rhfPPTr5o7hHD7RA9+iBXlLvKu7RAzOwABno07/kqMAKtECfsRuYgE2NvIrczwcWIAMFqMAKtIme4TUxAQmYgQXoasVRgAp0NXF0tVZ9nus10dWqIwFdzRwLkIECVGAFWqDHgIEJSECoEdQIagQ1ghpBjaCWoZahlqGWoZahlqGWoZahlqGWoVagVqBWoFagVqBWoFagVqBWoFagxlDzyNAmyNkzvyZmYAG2iSn363616UAFVqAF9gF/xwQkYAa2p2g5euzJX9Im6dmTvyZ6ef13lYAZWIAMFKAGeiTI3sEr6rfiid3nBwpQga1+25IAe2LXQPf5gQmI1jSoGVrT0JqG1jS0pqE1LVrTs8B6cTwLbCIBM7AA/dnEUYD+bOpYgRboPj+wqRU35j4/MAMLkIECVGAFNrW2ZMF+utpEmo3l+WLSFjLY88UmMlCAOhvAU8YmRmN5ytjEBCRgBkZjFTh6gaMXOHqBoxc4eoGjFzh6gaN7cpi0hRf25LCJCvSK8npwly5eMnfpgQlIwAwsQAYKUAP9te7vfc8em0jADHS73jV84W6gABXor+b+Zxbojj4wAQmYgQXIQAFaX4Bizy8blIIeRtVrsbn+oBLk5a+OAlRgBVqgO/7ApuQdt/n9oBzkVeUN7l4/UIAPKfWaak4/yAZ5otmgFERBOagEcZAEaVANCo0UGik0Umik0EihkUIjhUYKDXfwlrfKnoc20B18YGvxlpLFnoo2sbV4W09jT0abyMBWaW25jD0fbWIFWqD7+sAEJGAGupo4MlCACnS16miB7usDE5CArmaOBcjAVo+dNKgG2aTm/YNSEAXloBLEQaHBocGhwaEhoSGhIaEhoSGhIaHhMUC8lT0GtDUk9sPUJlqgx4CBCUjADCxABgoQago1hVqFmn8MiPcp/xgYmIEFyEABulpyrEAL9PjgX/qeNCfivaefn+pUg9ofeaTyjLiJCUjADCzAVkSPNp4RN1GBFWiB/n4fmIAEzMAChFqCWoKau39bC2LPiBvo7j/Q1bIjATPQ1YojAwWoQFdjR1drIcjz5KTt0GVPlJtYgAx0u+bY7PqEhWfLSfXyuqP7Ionny01MQAI2NZ/U8JPSJjJQgK4mji7hxfH3u090e0ad+NSdZ9SJTx96Rt3EAmSgABVYgZ5l4nXmb/2BLuHV56/6gQXoEl5Id/OBCqxAC3Q3H5iABMzAAoSaQq25ufosnmfSTbTAPgLomIAEbPHLJ+n8TLSJDBSgAivQAu0CJiABoWZQM6iZq3nf8ZHAwAp0tdZCnqSnPg/oSXoTXU0dM9DVqiMDBajACrTAntbTMQEJmIFQS1BLUEtQS1BLUCOoEdQIagQ1ghpBjaBGUCOoEdQy1DLUMtQy1DLUMtQy1DLUMtQy1ArUCtQK1ArUCtQK1ArUCtQK1ArUfIjgs6Ke4ZfGvxIwAwuQgQJsdn0GdSTweUf0MYBPLXoK30QGClCBFWiB6qNmcsQTq8RTdJ/vWIEW6D7v0wqemDeRgBmI+q1Qq6jfivqtqN+K+jW0Zvd5L0P3+Y4ZWIAcZXCfH6hAqFmo1esCJiABM7AAeQrXS4AKrECbZeipfAMTEGrw+Qqfr/D5Cp+v8PkKn68p2q3SBUxAAka7eULgRAZCDT5f4fMVPl/h8xU+X+HzFT5fc7RbzajJjJrMqMmMmnSf9+luTwmc6DXJjgTMwAL0Z/MyuM8PVGAFWqD7/MAEJKCreSH902Cg+zw51umFng2oLRecPRtwYgISEC0kaCFBC4kAFViB6H2KFlK0kKKFFC2k6H2IGlXRHxT9QdEfPD60JHT2TMCJGdjs+tS9JwOqT5t7MuBEBVagBXp8GJiABMxAt+u9xCPBwAq0iZ72py2BnD3tbyIBM9BXeciRgQJUYAVaYLqACei1I44MFKACK9AC3bt9JcET+NSXDzyBT31azBP4JlZgs+DTmZ7AN7HVg08iewLfxAxs5fXvLD+PbKIAFViBFuh+PNDVsiMBM7AAGShAT2j3enCP7fXgHjsQteMe67OgntY3kYECVKA/hXcC9+OO7scDE9CfwtXcjwcWoKt5A7gfD1RgU/O5XE/rG+h+PNDV/Indj32G19P6tPco92Of7/S0vokCdLv+bP6eH5iABHS7/mzdY71zdY/tWIEW2N20o++O8WfzrJyBAvQm9GfzrJyBNlCu2EkjPRNvIAEzsAAZ6JUqjhbor+aBCegPr44ZWIAMnDuKpOfcDaxAC/T8m4EJSMAMLEAdu8jk6hvYOvpT1IbuvAMTkID+FP5n7rwDGShABVZge4rLa9IzbQYmIAEzsAAZKEAF1kB3Xu5IwAwswPYUbRFdPI9uogIr0MamP/E8uokJSMAMLEAGCrC1RZtwFc+um5iA/hTZMQMLkIECVGAdm0vFjwUb6Fu/ByYgATPQ7RZHL693Ln+xDkxAGptW5erbUzsWIAMFqMAKtImpb0/tmIAEzMACZKAAFViBUHM/blPM4nl0EwuQgV476qjACrRAH2IPTEACZqCrVUcGClCBrmaOFujePTABaTaW59FNLEAGClCBFRj9wfPoJja7bdpZPGNuIgObXfGq9sF024shnjE30QL91TwwjZ3d4slzEzOwABkoQAW6WnF0teYtnjw3MQEJmIEFyEB/NpfwV/PACrRA9/mBCUjADHQ1b273+YECVGAFWqC/sAcmIAHz2BgvqW9J78hAX1/ydvPXuHpr+mt8oAV6fBiYgATMQF/L8jb2D/OBAlRgBdpE6itzHRPQ1dgxAwuQgQJUYAVaYF+j6+hq1ZGAGViADBSgAiuwqbVtAeJJeBMTkIAZWIAMFGB7b2anGmSTPPW2UwqiILfoNesxoPZ/tcB+hISX3w9mGUjADCxABgpQgTXQ3/Btxl48pU7dmT2lbmIBMlCACqxAf4rWyz2lbmICEtDV1LEAGShABVagBXoM6M/mMcDfuX4E2sQMLEAGClCjLRQtpGghjwEDE5CAGViADGxt0fuDn/LS0Q+rGOjLlN7Z3NsH+kJl/4UCZKCvh3rDurcPrEBfEm0N4Ol2ExOQgBnoaubIQAEqsAIt0L19YAJ6Xu3l2HqqD5A8Wa62pQ3xZLmJBPTEXHIsQE/NzY4CVGBLNL26hAV6yuzABCRgBhagq7GjABVYgRboybMDUzyxp8peXtWeKztQgAp0u+pogXwBE7BFDf+G8LS4iQXIQAEqsAItULx2qmMGFiAD/Sn6nymwAi3QjzLM/md+RNNAAmZgATJQgBrYPLYm72fNYycSsD1F8s7VPHYiA9tTJO9n7a09sT1F8s7V/HigXUBX8zY2AmZgATJQgAp0Ne87ZhM9hW5iAhIwA1udtbk38WQ5P5ZTPFnOz4cUT5Yb6MfLDExAAmZgAba2aBnK0s9OG6jACnS11gCeLDcxAQmYgQXIQAFqYD+f1x/TvbulV4lnyE3MwAJkoAAV6G3hT+He3dG9e2ACtqfwftYPVRtYgAwUoAIr0AKbz0/0p6iOBchAfwqvB1ZgBban6HXW3t0T21O0aWTxvLmJGdjU2uSyeN7cRAEqsAItUC+gq2VHAmZgATJQgF5n3sErWr6i5StavqLlK1q+ouUrWr6i5StavqLlDS1vaHlDyxta3tDyhpY3tLyh5Q0tb9Hy/bC2jskTm9skpHjq2oOzs4Lpwu9QWpgWzmDuvy/OaWFaOC9cFuaFZWFduC5sYFl0ZdGVRVcWXen2q7MuXMGqeC7t/27OBq7XwmlhWjgvLLBZF/u1Lmxgc/s+Y+bHkAW7fe6/4/Z9wspPIgvmhWVhXbgubMGefRWcFqaF88JlYV5YFtaF68KLbur2s3O3U5zRHyTpwnVh9Aeha+G0MC2cFy4L88KLLi26tOjSopu7LjunhWnhvHBZmBfu9dZZF+711rUMXK6Fe7uoc7dTnXXhXn6v22LRl6T77+C0MC3c7ZtzWZgXlujzMvy3c1140ZVFVxZdWXS7/3ZW/x2fzvLsqeC8sJdN+u/zwrKwl83nt6T7+GAvm08pSffxwWnhrut12H18cFmYF5aFdeG6cNf1tu6+PzgtTAvnhcvCjLYePu5lHj7e6l+Hj3dOC9PCeeGyMC+MttZLF64LI2Z6LtXwa0+mCqaF88JlYV5YFtaFK5gQM7X7/mD0JR2+72Ubvt95eS5anouW56LlufK1cFqYFs4LL7p50c2Lbl5086KbF92y6JZFtyy6ZdEti25ZdMuiWxbdstTniBXOvLQjL+3ISzvy0o68tCMv7chLO/LSjrzo8qIri64surLoyqIri64surLoyqIri64surro6qKri64uurro6qKri+4YY7BzXdjA9Vo4LUwL54j/2uPPYF64P1d7L+gYS1RnWrj3Ey/bGEu4j4x40lkW1oWX/mnon/W6FkZsrxctnBcuC0O3dl/zuF27rw1OC1PE8Np9bXCJuF27rw2WhRGTa64LG7j72uC0MC2cF0ZMrt3XBsvCunBdGO+COnytOrcvCutYgRboX2EDE5CAGViADBQg1ARqAjWFmkJNoaZQU6gp1BRq6mrqWIEW6PMxAxOQgBlYgAwUINQq1CrUDGoGNYOaQc2gZlAzqBnUDGoWap7UNDEBCZiBBchAASqwAqGWoJaglqCWoJaglqCWoJaglqCWoEZQI6gR1AhqBDWCGkGNoEZQI6hlqGWoZahlqGWoZahlqGWoZahlqBWoFagVqBWoFagVqBWoFagVqBWoMdQYagw1hhpDjaHGUGOoMdQYagI1gZpATaAmUBOoCdQEagI1gZpCTaGmUFOoKdQUago1xBJDLDHEEkMsMcQSQywxxBJDLDHEEkMsMcQSQywxxBJDLDHEEkMsMcQSQywxxBJDLDHEEkMssYglekUs0StiiV4RS/SKWKJXxBK9IpboFbFEr4glekUs0euCWoJaglqCWoJaglqCWoJaglqCWoIaQY2gRlAjqBHUCGoENYIaQY2glqGWoZahlqGWoZahlqGWoZahlqFWoFagVqBWoFagVqBWoFagVqBWoMZQY6gx1BhqDDWGGkONocZQY6gJ1ARqAjWBWo8l5sjt6BNyFKACK9AC+4kpHROQgBlYgFBTqCnUFGoKtQq1CrUKNT9hta0mqp+tNpGBAlRgBbra1dAuYAK6GjtmYAG6mleqCVCBFWgTPftrYgI2tbbEpZ79ZW1dSz37ayIDBajACrRAP2N1YAISEGoJaglqCWoJaglqCWoENYIaQY2gRlAjqBHUCGoENYJahlqGWoZahlqGWoZahlqGWoZahlqBWoFagVqBWoFagVqBWoFagVqBGkONocZQY6gx1BhqDDWGGkONoSZQE6gJ1ARqAjWBmkBNoCZQE6gp1BRqCjWFmkJNoaZQU6gp1BRqFWoVahVqFWoVahVqFWoVahVqFWoGNYOaQc2gZlAzqBnUDGoGNQs1zxSbmIAEzMACZKAAFViBUEMsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEkoxYkhFLMmJJRizJPZYURwYKUIEVaIE9lqhjAja1ltCgfuzbxAJkoAAVWIEW6LFkYFNrSRXqmWwTM7AAGShABbpadrRAjyUDE5CAGViAriaOAlSg16QL91ji2GNJxwQkYAYWIAMFqECoFagx1BhqDDWGGkONocZQY6gx1BhqAjWBmkBNoCZQE6gJ1ARqAjWBmkJNoaZQU6gp1BRqCjWFmkJNoVahVqFWoVahVqFWoVahVqFWoVahZlAzqBnUDGoGNYOaQc2gZlCzUCvXBUxAAmZgATJQgAqsQKglqCWoJaglqCWoJaglqCWoJaglqBHUCGoENYIaQY2gRlAjqBHUCGoZahlqGWoZahlqGWoZahlqiCUFsaQglhTEkoJYUhBLCmJJQSwpiCUFsaQglhTEkoJYUhBLCmJJQSwpiCUFsaQglhTEkoJY4tl01vb5qmfTTUxAAmZgATJQgE2t7d1Vz6abaIEeSwYmIAEzsACbWtvUqp5NN1GBFWiBHksGJiABM7AAoVahVqFWoVahZlAzqBnUDGoGNYOaQc2gZlCzUPMcu4kJSMAMLEAGClCBFQi1BLUEtQS1BLUEtQS1BLUEtQS1BDWCGkGNoEZQI6gR1AhqBDWCGkEtQy1DLUMtQy1DLUMtQy1DLUMtQ61ArUCtQK1ArUCtQK1ArUCtQK1AjaHGUGOoMdQYagw1hhpDjaHGUBOoCdQEagI1gZpATaAmUBOoCdQUago1hZpCTaGGWMKIJYxYwogljFjCiCWMWMKIJYxYwogljFjCiCWMWMKIJYxYwogljFjCiCWMWMKIJYxYwogljFjCiCWMWCKIJYJYIoglglgiiCWCWCKIJYJYIoglglgiiCWCWCKIJYJYIoglglgiiCWCWCKIJYJYIoglglgiiCWCWCKIJYJYIoglglgiiCWCWCKIJZ6Zae3IBfXEzIkZ2NRaBq56VuZEATa1lnqjnpI50QI9lrQ8YvXD8SYSsKmxG/NYMpCBTY27MQVWYFNjN9bvxOuYgE2t5aGo52xOLEAGClCBFWiBHksGJiDUBGoCNYGax5J2a5j6kXkTK9ACPZYMTEACZmABMhBqCjWFmkKtQq1CrUKtQq1CrUKtQq1CrUKtQs2gZlAzqBnUDGoGNYOaQc1jSbu5TD3js6MnfE5MQAJmYAEysKm1HcjqmZ4TK9ACPZYMTEACZmABMhBqCWoeS9rZmOpH5g30WDIwAQmYgQXIgR4UfJ3MMzOtbdZTT8ycKEAFVqAFuvsPTEACZiDUCtQK1ArUCtQK1BhqDDWGGkONocZQY6gx1BhqDDWBmkBNoCZQE6gJ1ARqAjWBmkBNoaZQU6gp1BRqCjWFmkJNoaZQq1CrUKtQq1CrUKtQq1CrUKtQq1AzqBnUDGoGNYOaQc2gZlAzqFmo1esCJiABM7AAGShABVYg1BLUEtQS1BLUEtQS1BLUEtQS1BLUCGoENYIaQY2gRlAjqBHUCGoENR9KaEcPNupIwAwsQAYKUIEVaIEeSwZCrUCtQK1AzWNJO81APdt0ogIr0AI9lgx0NXYkYAbqDJm1h4qOFthDRccEJGAz1g4Z1n6B7kAGtqK3sxO036E7sAKbWjsVQfs1ugMTkIAZWIAMFKACKxBqFWoeKtr+fO1X6g7MwAJkoAAVWIEW6KFiYORg1B4qOmagq3n39FAxUIAKrECb6JmoExPQn00dM7AAGShABVagBXqoGOi/Wx0r0AKxxmpYYzWssRrWWA1rrIY1VsMaq2GN1bDGalhjNayxGtZYDWushjVWwxqrYY3VsMZqWGM1rLEa1lgNa6yGNVbDGqthjdWwxmpYY/U80r5q5HmkEyvQZxebZ3ke6cQE9DY2xwwsQAYKUIEVaIESK0wmCUjApmZeBo8EAxkoQAVWoAV6JBjY1MwlPBIMzMACZKAAFViBFuiRwNxFPBIMJGAGFiADBajACvR2ax+vnkc6MQFdjR0zsAAZKEAFVqANrJ5Hai03v3oe6UQCZmABMlCACqzA+Y1ePSHUP8GrJ4ROVKB/bCdHC/SgMNALaY4EzMC2I+O6+i/zwrKwOrui7/aabGDfgTI5LUwL54XLwl3XKzjLwrpwXdjA5Vo4LUwL54W7rldv4YVlYV24LmxgvhZOC9PCPoPish4xBjKwi6qzLlwXNrBcC6eFaeG8sD9sW0ipnjYaLAvrwnVhA/tWr8lpYVrYdZM3qHY72dnA9Vo4LUwL54XLwrywLOze4J7jAWKgBVoXLc5pYVo4L1wW5oVlYV24P6xXuFmwp4kGp4Vp4bxwWZgXloW7rjnXhQ2croVdt73KqqeMBueFy8K8sCysC9eFDexRp83V1Z46OpCAXbRzWZgXloV14bqwgXvYGdwftjjTwnnhsjAvLAvrwnVhA/fw0t41NfVwQd5APVwMNnAPF4PTwrRwXrgszAvPWdDac0IHVmAXbT0/9XAxOC1MC+eFy8K8sCzsD5u9wnu4GGzgHi4Gp4Vp4bxwWZgXdt12PHL1LNHgurCBe3jJ3kA9vAymhfPCZWFeWBbWhevCc7a59ozRgQnYRb1RengZXBbmhWVhXbgubMHUw0s7lalSDy+DaeG8cFmYF5aFdeEK7mGkndpcqYeRwXnhsjAvLAu7fR+ZUA8jg/25fEjjWaPBXTc708JdtziXhbuu10+PJIO7rjjXhbtu8yzqkWRw1/Vn75FkcNc157Kw67I/Y48kg13Xox/1SDLYddmfsQ9gBrsu+zP2CDPYddmfsQ9gBnddf8Y+gBncdf0Ze0Qa3HX9GXtEGjyXLSrFIkmlWCSpFIsklWKRpFIsklTqoxfv+dRHL4MN3MOReA30cDSYFs4Ll4V5YVlYF64LG1gXXV10e9gRr/keXsRru4eX/lw9vHTu4WVwWpgWXspfl/LXpfx1KX9dyl+X8tel/LaU35by21JvtujaotsjiT9j7hHDnzFfKH++aOG8cFmYF0b586UL14VR/pyuhdPCtHBeuCzMCy+6adHtEaM/Y48M/RlpKT8t5e+RYbAuXBdeyp+X8uel/Hkpf17Kn5fy56X8eSl/Xsqfl3rLi25ZdHsE6M/YPb0/Y1nKX5byF/TbzNfCS7vz0u597NE219fcxx6D59Ja7WmfAxVYA4dPi3O30f/d60C97N13B+vCdWEDd98dnBamhfPCZeFFtw8l1Ous+/rgurCBu68PTgvTwnnhsjAvvOjWRbcuut3X1du5+/rgtDAtnBcuC/PCsrAuXBeGbrmuhbv94tztsLMuXBc2cPf1wWlhWjgvXBbmhbuuOOvCdWED9xgwOC1MC+eFy8JzQbf2xM6BCuyi6mzgHhgGp4Vp4bxwWZgX9odtE/y19MAwuC5s4B4YBqeFaeG8cFnYdas3bg8kg7uuV34PJNUrp8wV7NqzPQcmIAEzsAAZKEAFViDUBGo9sLQJ71r6YGFwXrgszAvLwrpwXdjAPeAM7rreB3rAGZwXLgvzwgLugaJNjtbSA8VgXlgW1oXrwl5O8/bqgWJw/31vu+7ggy2Yu4P7nB/3l/9gWriVM7U1vcr91JnBvLAsrAvXhQ3cT7canBamhRfdfrqVz9WNExkHy8K6cF3YwP3Eu8FpYVo4L7zo0qJLi24/9artPq7cT70abOB+Es/gtDAtnBcuC/PCsvCimxfdfhKPzzVyP4lncFqYFs4Ll4V5YVlYF64LL7q86PKiy4suL7q86PKiy4suL7q86PKiK4uuLLqy6MqiK4uuLLqy6MqiK4tuP/XKp1S5n3o1OC1MC+eFy8K8sCysC9eFXdenV8fJmu0g6DpO1hxMC+eFy8K8sCysC9eFZx5R7dmdAxPQRdtm9zqO2xxcFuaFZWFduC5sweO4TZ9eHcdtDqaF88JlYV5YFtaFKzi2llTpsacdTlvHaZuDZWFduC5s4B57BqeFaeG88KJLiy4turTo0qJLi25edPOimxfdvOjmRbfHnna4dR2nbfqM8zhtc3Bd2MA99gxOC9PCeeGy8NydUXuG50AFdtHqbOAeeAanhWnhvHBZmBf2h/UZ5HE05+C6sIF74BmcFqaF88JlYddtRzRX6YFnsC5cFzZwDzyD08K0cF547kmpPfdzoAC7aHauCxu4R53BaWFaOC9cFu4P672rR53BunBd2MD9rM/BaWFaOC/cdb1H9QAzuC7c7bdONc76HOz226WBdZz1OTgv7PZ9Vnqc9TlYFtaF68IG7qOhwWlhWjgvvOimRTctumnRTYtuWnRp0aVFlxZdWnRp0aVFlxZdWnR7RPJ+Nc4A7dwj0uC0MC2cF/YENHHsJrOzgXuwGdxNFmdaOC9cFuaFZWFduC5s4B5vBi+6Pa74nPw4xtPX7scxnoN14bqwgXtcGZwW7rM06pwXLgvzwrKwLlwXNnD/sPGZpXFcZ+7/XhbmhWXh/lzVuS5s4B5CBqeFaeG8cH8ub98xa9pZFtaF68IGtmvhtDAtzHh2W56rh5DBdWELHsd4epnHMZ6DaeG8cFmYF5aF8Vz1qgvjuWq6Fk4L08J54bIwL1zj2WtanmuEis5pYVp4eS5anouW56LluUgXrgujn9S8PFdenisvz5WX58rLc+XlubIsvNRnXuqzT5r0Zy/Lc5W8cFmYF16eqyzPVZbnKstz8dJPeOknvPQTXp6Ll+fi5bl4eS5enouX5+Kln8hSn7LUZx+P+Hpc7eORwbKwLlwXNnAfjwxOC9PCeeFFVxddXXR10dVFVxfduujWRbcuuhW6nvWYyBOZPO0xWBZW5+xcFzaw98/JaWFaOC9cFuaFZeFFNy+6edEt3U5x7r/PzoZ/5142ce5lU2daOC9cFuaFZWFduJetOhtYroW7rjm7rn9UeSLjg72eve+R5wh5KuN8FpGFl2fs/con46z3q8F54bIwLywL68J1YQP3fjW46/qz9H5l/iy9Xw0uC/PCrmv+vH2oO7gubOA+1B2cFqaF88Ld5qMO7ervoDY5aFd/77QJQbv6e6dN/NnV3zuDeWFZ2MB9KNpuK7OrD0UHdzvq3MtQG/f3QptAtKu/FwaXhXtbX86ysC5cYX/4nf/78LvOaWFaOKMe+kftYF5YFl6et48n+zP28eTgpR76uE79b/u4Tr2e+7hucF3YwH1cN9jtq+v2OKxuv8fhwbKwLlwX7va9rnocHpwWpoXzwmVhXrjrept2fxlcFzZw95fBaWFaOC/ctbw/dB8ZrAvXhQ3cfWRwWpgWzguXhRddW3S7H1XvP32MN9iCewrf5LQwLZyjXXoK32ReGG3a0/BS26xhPd0utU0T1tPtJuvCdeFettaXUh+nDU4L08J54bIwLywLd93sXBc2cP+kG5wWpoXzwozn7T7YFpmsZ9MN7j7Yn7H74GBaOC/cn8Xrs4/NBsvC/VnUuS5ssMOLLi+6vOjyotu/9QYvbcdL2/HSdry0HS+6smh13xcvc/f9wbpwXdjtiD9L9/3BaWFa2MvfrtS1NK6A6cwLy8K6cF3YwOMKmM5pYVp40a2Lbl1066JbF9266NZFd1z1Ys7dv9wHuy+r97Huy4MtuOfLTU4L08J54e7L5MwLy8K6cI3yUH+fdu5TPoPTwrRwXrgszAsL2M9rFi+mn9c8sDb0wvh5zR39vOaBCUgNs2MGFiADBajACrRAP695YAJCzY9jbjkn5llqtaWZmCepVe+vnqM20I9jHpiABMzAAmSgABUINT+O2TuXp6dNTEACZmABMlCACqxAqCnUFGp+tLv7uR97OLEAGShABVagBfrR7gMTEGoVan6Iu/uYZ5vV3uX8YPaBGViADBSgAivQJnpS2kSXSI4ZWIAMFKACK9AC/TT2gQnoEuToxrKjAivQjbVO26/UHZiABMzAAmSgABVYAzMkukN6ebtDdhSgAsP9+zW5HeGQGQ6Z4ZCeWTaxABkoQAVWYLh/vzx3YDNmHRmIojOK3s9H9yfu56M79vPROyYgATOwABkoQAVCTaCmUFOo9VsV2BEP3y9NaN7SL8TtVV0TkIAZWIAMFCAkKuq3on4N9WtoTUNrGlrT0Jrueh50+323HnT7fbceBvt9twMJmIEFyEABKrACI5h7ZtjECHieFzYxAwuQgQJUYAVGePV8sIlQI6gR1CjCq6eCTRSgAiswwmvJFzABCZiBUMtQ687bgq5nbvWI6IlbExkoQAVWYIRXz9mamIAEjPDaL7kdKEAFVmCE137J7cAEJGAGugQ5Rnjtd9h2dC8cGOG132E7MAMLkIECVGAFRjD3U/cmQqLi4d0h/Tum31Y70ALdIQe28vp3lJ+kNzEDC5CBAlRgBdpET+KamIAEzMACZKAAXY0da6C7nnb0ShVHASqwAi2wvyHV0RurOhYgAwWoQLdrjhbYX4sdE5CAGViA/vCXowAVWIEW6O/NgQlIQK/f5MhAASqwAi3QfXNgAhIwA6HGUHM39c9Iz5maWIEW6G46MAEpal3QWILGEjRW78rexr3Tehv3TtuxAm2i9E5rjglIwAwsQAYKUIGuVh0t0F8zAxOQgBlYgDKfTfp9O62Npd+s0zHFA/lbZGAGFqCPQJKjABXoIxBytEDv4N1ChlqGWoZahlrv4B0FqMAKRLMUqPVerf/9d395wH/9xX25bRjyx3dIE2hCnlAmtGK0G1D9kdke1nKz1t+Yjzrs78sH9LdlgzSBJvh78nr8bfGSuKn8+E+O/2w7tLyJHJrxtjfLy9w2Y3mZS1MXWLjGLzA9/l29VF7aMkvbQCfUCTbAC8zl8be1/a2Xtu2G9NI6lAk8QSbohGa2ZZx4GzTwFmj5JR5gHJrlllHhYwCHZrnlRniMcWiWW/qDxxeHZrklI3hsaeCRxcEtP6K5RxWHPMEtPxrO44mDW37UqscShzrBLT+ewqOIQ5rgltttlnlCmdAst1U4H4c7eMOldtHfBBvgb34/bjBNoAnNctv55298B57glh9P6u96B7fs5zYM8Ld84UfzWXRvar29xYrHf3vjSfvv1P7ba5p41LSDTqgT3EYzmeAyVP778Q9//bd/+sf//Jd/+9d/+M9//+d/bv/f/If/+Mvf/z//9Zf/84///s//+p9/+ft//b9//evf/eX/+8e//l//pf/4P//4r/7zP//x3x//76Oq/vlf/+fj58Pg//qXv/5zo//+O/z19fxPHxMoPP76MYGiYSA9+NDE46tyFuDx0ZhgIn0tBT034ZP+vRBXDgP5WxnycwO1rWy6gUdXemqgPDdgLZq7AbP3DMgsQTun4qmFXT1ynSYeX7D1aT3qpjWp7QztFZkzavIxxf7FRN215uwP2RgGhI8fQwiPkfXpY6SNjcfoYnapB6Iq5JuJtOlSpS0m9gZhpqcmNr1SVaJTFTwH52MLHsW6BUnPLZw+hj5/jF1laktb6JWplz01Ibso0T5aRpQo6akJ/bgqNj3zMU8enfuxRhY2Cn01YZtCyIwzj9X8p4WgTWW2HYscji6CYjwm4s4fxbODxqNwevYotOlaVGej5uupgb2PmUS3SPlZm9LnMW9n4hFk4uVhtnl5yM5HhMJHlsqg7+XYdE+us0EenxKLBflFz6iGnmFLq37vGbTpoW3mYL6IeCnJY/7z67tw907XKxxFaYkZx61SrrDwmDx7/irK23c6R+Tqg59p4+urJG9e649lX406fUzu0WLlW32Uz/tHe/N91j+2z/KY97viWTLn58+ye8P7+uGIHNWWkthXG/Xj/mF3RMG9lVOPKelzjyn0aY3sW1dyBMPHbKU9bd2y6amP5cEZkx/Lg0s/S+WrjU1PzYlmfeTHyGex8fXdUGQ7pJ/d/bE6lJ/b2JWDSowkqW7KsempxaIcj9lMe2pj3zI1KvUxmqr1acvwJqaK56/1AJDpeRziTU99LGpcEVVTfcsGpzSjKie63nuWTNOGlPQ8DnHZjR6idVlkE8t2LcNaEJjrrlZ3b/9UeQ5OW9bO9cR7Wf+o/0vROSB7fCyVTa3aH33LqB/q08vRbj1+Wg7Z9DLK+CBfPwPp2/tfPo6p21KUNP2FSrmelmI3CnlEzniSpOnpKER2kUxsdrCsea1RObbxePnPIFSyXM9t6OfjGKkf97BtjcaXB9GXCMTnNijDxqZVNH06Z6T06aSR5k9njfY1UcNLHhMnz2uCt6PkGi+4sr5Xvo4adPvGp+jjuepzG7tylCX0pI2N3dg0p4KZBnlqY1unEnMNJF+e5Rc9VKJOSb+U46uN+nEPrR/30Ppne6hyzFXYxt8r76ZuFPMdef0W/DqOq5se2u6GGTba3Rpv2Wgb7GMWitNzG/XzKFztj0ZhP/N5tIrKe33cohj5ovrUhn08c28fT91b+ZN9PF/Z4lsl0/Oa2I1DCZ/EOa99K5/bsBJ+ctXruY1d/+Qa9ZHYEqzkb2MN281DxbzL2rseb4nzSC4YJ+j1PJKnaxdC2fBZzba4vXwzso1gWNO4vnxlfC/JppsW35TWB3CPOPh0acUPJtq0b7ztr+UN+WM2fzcajVnwcj2fw/azaJ5+AHJ0M5Hrej6Ffe1Go4/peMLsDeWnMy/bNwPH4gRJfh6R02WfV+tuOvywWndrNcfVulsyOq9W2y7YpIjLbM8DiZ9q8/QtVShmX3iZffnR5RPf0DbyedvoHW1T72ib/cJLzEc9pk6eLqZdu49JjlhUqjxfYqW0e+fFWCinL+u09AsjvuX3b704vxvJNyzVls/XasvHK5THT7JZrd1WaSqxfk6bMapP8342qErblaijUdXexNn64L46WGJothuyp7xdyY/163bz3PNItjVSI7FBe87YMyPl876+W4s67Os7E4d9/fhJNn19X6US7VLtzXapyVAfuhmZld3qLcc84WPadJm9/Zb4su+rFuk3j4XLTUjdrUWd9pCSP+4hOxOHPeT4Sd6NhhZfEY9FadlUqd5QpfXzKq2fV6n+6SplDKeu+t6Lv1wp5rOvsmkXzruR0FmaF98QUPnzgMqfB1S+IaDua/TjsaXGoL+o2vOxpexWGClmp6TkTUjeLf9YWpIDrucReV8fivqob9bpaf7cbmG/xPLP49OsPLfBn/d0kY97+s7EYU8/fpJNT9/WKBY9HjUq79ng+AQizk9T4NJuGYotFj3YxN60EZNcWxv7HnaYovn5R5R+/hG1W4o6zfPUXbbpUaJn2s1fit82NCfpl7yiHzW6+QI6y9LcFYMtFgjlWidzvxdjuxJ1nGmVdstRp6lWabcidZYXsO8hZ+mzaTvx+HnLaEz4s2rZdJBjI/amkRqzfQ9820hs42grCG8a8UuURySj8mZvfQyBY5rtwXnTW7ed/jxVe2tGYzDT7gBJb5sxzB3WZdz9OxfUyN16LMzQxgWPjdi7RuJ5HsjvGWl3n6KNrrozs61cP2p+9JhrGWD9so3qMr9bl4Hrb83EWlEzs+m/52/0p19HtFu1Usyv6PM36X4EfbZNYLdkdfqxuDeC9OnHJ0XdGNGjpUDSsnma+vE4nHYrVmcjra2Js5HW+ZPo5km2NSp4ndfylo3sY6ixFGH6ro3rYxsZg4K8fHL+zkYMPR/mntvYLVYdflO8sHH0TbF/llJmN81F6uc23uxjmSxWmUp93ra7/VJpGQwo7TZ/7QqisfCWVZ6Hj90y02nj7m3c0Lia8Cwbx6VtDkCk/7TbQN6tVIsFr7rpZbuVprMVYsrbFQBDAvf1fOi6LUeJOauyJsX/qI7tey4WvEpe10S+v+d2aeCH8010w1IVfb5URZ8vVdENS1X7Gj2bb9rbOJtvot1C1anr73vH0VwRlY83R29NnLbs8ZM8jx27jUpHY+S9y5YCt/+yoeabkd3SztmSPe0WmM6W7F88CtLcym6UvS3H4b7gbUEsx5xGup5nlviJBx/WKX+cQL03cUN1sF9dNKqj7KpD/mRP5xIvJ36En00xdrv6Urysad3B+s3vdxulDrewbksRszrrq/pHKWS7oS/eCYXW3LZzEz4/gLkCvt4zYowJB1vX/X5lpF6YQ1km3n9TqTFxV2zTtLv1pRtMtLk2zCrV9PRR9kZOW0buaBm5oWW2nivLuOHLtsBfuL+keBr5ei7Ar4zE19yjTOVNIyW+PORLbuqvjOSYNRTW57lltFuMOHzH7FarDt8xWxM3vGOEoxwiaVMddf8ZdZSxT7sZVJHIxtJLNm+73dzyacY+7VarDtOXqZaPP07rtmnO0pep7uPIYfry3kzbZIjlGdGNmX1HuRgdZZk9+EVU05xiSJPLpsva9fmksH1+3BTZ559U9vkn1fGTbD6W9zV6Nim8s3E6KfzCxvWxjcMJ3d1uqi8f7UxvluNscnpfjrO5x+Nn2dnYPUuJZeL8CNPPbOSr/OlynE1wH9t4018OJ7jzdjHndIJ7W5CzCe683d9y1sle2Lihcc8muP0N8vEE974gRxPcOX286y/vdlGdTnBvy3E4wf1qhLhsUOXy5MWfdyf5nQ4zt0YOv9+340ONLLEHPu/s9HnGf6aPM/63Js7GDudPsomF+xF3vOeS2fMQRDcsfm6H3PjofuDmNL+dEUXmg66fD78yIsgRE635TSM1PmSkan77C2LNI1wmAH/7BRGnfLSvCd6Y2dZLLKeIFnq3cvHRW6/NQXa7L7zTqLhbybgsDi1JV33LdShh12/avPHyxyupudywkrotx2mVbps2phIfrUxvdvl05SW1rLz90Zx4GUno256T6FoGJBvP2SZ6U6wDYBngVxOsZkulXPzWtObjDw1G6Nm0Zi72+dzo1sgt8/inNZJuqBHON9TIzshZjezzQ7HNzL68P3+VZGqxsvowskl3tW0fOU4y3ZkRv91hvkGfzeTvTWDKS4z0PROxPVyMn5rYJ2kvo6P8brq44XAIK5t9Cdv9v5YjEq0P832KNt+wtyrfsLcqf763Kn++tyrfsLcq37C3Kt+wtyrfsLcq37C3Kt+wtyp/vrcqf763Kt+QU553S01nOeV7t49pWTXbuP1ua9Xpl/d2KuLQ7XdrVYcNuzNx2LDHT7Jx+22NHn5578bcp+6mnx/nlKt+/BmzO+jv9LN7W46zz5htdRx+Ge5tHH4Z7taWDqvU8g1fhrtynFXpiyND4jzKmurze3L2xzidbS2Xz0cu9vlulGwf70bZmjgMYfb5bpRthZ5uCv943FKuz1P8yw3LW7stIKebjLYTdYc7Mfc3o5zuoHxh5XAD5fZIqsP9k+c27E0bZ7sn6Zbv2n29nu6d3JblvKfsbwQ53Dm5t3LLE533Wruj127vODnstec27E0bZ722pFt67b6nnG7VPb7X7OnQqtDHSdW79DCN3L3HGG49q/N7Keo2gwBZKunZkureBDYefTkC/puJ3R6qw4nUXWVIDHYf3zv8vDLyx2n/JX+c9r83cZiSKZ82yW4lVOJYf/mSa/8LCzGyk2Xr9g8L28SDK8IxL8n69IuaSIUwOKT81EbZLkwZ4Whso6Vhzy9YOeviLy41i2H/gzeX+JTdAX2HHr81cebxhT+ujt2UlOJuANWneRz8aR/fWjjq49sthod9fL9N8bCP7y6IOu7j22tkr/iMWq94+XHJ3M4G4xIO5o2N7XG6RZabTWxzqRrzx56yNXHmKax/NHB8qY4vtzX/6o65uB+OJK93u5U3bejnNpbsjV/ddXdJjBYueX4/XJFdtVbc3FXr5rK73cR6jdWwuiwQ/M5ErJdW1jdNxC6BumTEvWtCNnWx31gXE4V5W5/brdJ4K0jiN1vW4rK8x5xyeu9pcAXhl8sDf2MjS3xm5PVqyB82Tq+G1I27bBehTr5Vyv5lHU5br03w2O2YUg6HU15POKjfbOyPakFAXpeQvgXC7Q0ltpwBt24x/m5jO+9x4Q7DdC13dn5/ml2t1njx07rR8FfhtMbnxgPlqY39CwYd5MG79+32zqnYuPGYfFls6NdPuO1VmRL9rHxJZv/NdZuKgzQeUe09GyX2F5V1hv5XV3ZmifNjs7553abGBoEH1vds4EKeLwsWv7Kx7Mq3L6fx/+bazyve/G3YLO9aQZrTg+ubVmhZdMiyGVLtbqA6u89ra+LsI2Zv4ugr5sVdqkvumF3PkpzKbh3HUqw7WHo+Vt6aoNjeb0T1nbEyV1v2B8ibnUwufExJup5b4d0FVGcfIHsTRx8gfJU/+gHytTrS+5XKsLK59ndvJcWQ+8G7+H7Vz5vm43lTTtefbZov1cH6dtOUxcrmRWOfhrKthbP5mO2TKKGrqu1u7JZPJ6e2Jh7RME4rfvDTcyReGNHlblV9eo7EKyOI7g9+K65KVfQQy88nL7eJzvfcUk2RTUL5Wj+Zr/dsJHrPBkeSMrGkt2w8yh9Xx1xfPpq/2djMhhwuOMj+pNb42k1frhL+xVXXKb52H3GtPLXB2wP9zuLy1sRZXM4fH/CzrQwK538svtHzytiuOVjcQFGMZGNk+wkRUXk5Rv7bV+qLYgiK8eVD5lfPgi+Zr5fO/s5I5F5d/Hatxl42vt68kv34WvddnuHR63Jr4eh1ub1a/nD5Yn89/dnyBZftDalnyxfbW545li/qWpDvh4JwkY8DUPl49Za3s49HAWhfGbJMKz+/k+yxRvNpZWxvWKZ44edMz29Y5s+P8+PPj/PjG47z295YfWhi+6mO71v6ciBg/vYou1lUTIAu+d76i8umD911f2H1clob1+XgqR8XVu+vvV4OBFjvZ/ytFQTCdQXkN5dnt22i0b5fEsfoFyWxtJySQO8+D7ZaJP6yg+43VuRC3cq1jAu/W+Hths97zHzJZc/PLyffG6Ec437i600jWeLrcD0a6Ec7bwuC245Ken5tPOvnZza9sBEvisdoID1/fW+NHI4jXpTkcCCh/Hlk2l9efbbHiPXzyydZP758cmviLEH//Ek2Cfr768CP9hjxblPwaWr89j7ww9M9tkZOT/fYl+Rwm9HeyOHpHq+uNz883WNv5vh8wFdmDg8JeVG9Z4eEvDBydkjI9hb7w31LO+853Aq2t3G2FYzt49Oo2G44jWpbjtMq3Tbt2SEhL/rq6SEhL8ycHhLyyszhISEvBn0XVhS+hLfvkxvXx2mqexNH39Fy8R81cfYp/mIwjjNCZD2Z43uN1s8/P+s2ASfi/GMp4fkp7tt5hYREsUzlzXmFs2ZJ9PEMyW5kJPGGqMLPz5CtHy951Y+XvGr9fOy9tXE49JZ0w6RAuj7f3i/0+fZ+oY+3929NnA29z59kM/S+Pt/eL/T59v6U0h1D73TH0DvdMfROdwy96Z6hN90z9KZ7ht7pjqF3umPofX08Trw+P4Vhb+Ns6C25fjr0lmyfD7235Tgdeqc7ht50z9Cb7hl60x1D7+1YgGM08eVqmt+MJiwslKcW9PNhpm6X0OJ0r8fyz7oOV85taBx3lu3LftBzG+UKG+Vie2pDdlm8Z98x+2JEJHs4z64Y+eOBwAsbZzO9eyOnK8b7khwON3eLWKfDTd2Oe5d8pKTPu9luO4HgGgn5knD6Cxscrk+i5Xkf2eUSnS2TitCny6R7E2cBJO2uBv3FeObarkocXjWyzZ6t8Z2ZvuyM+OZ58vn10yKfH/gj8vGBP1sThx81x0+yiWXy+fXTWxuHN428snF9bOPsphHZvWQObxp5UY6jm0ZelOPoCKTzZ9nY2D7L2U0jUtOfLsfRTSPnNt70l8ObRmR3xt/pTSP7gpzdNCL183vSX9i4oXHPbhoR2x9vdXTTyIuCHN00Ip8f8yd3HPMnNxzz9+K9f3TTiLxYqDq6aWRr5PA87d32ndMJ0W1i0tnYQa/r07HD1sTh2OH4SXYTouXjCVG945i+S26YEN0ZOZ4Q3ZbkdEJ0a+R0QnQ78j+fEH3xAXE6k7mvl8OZzL2Rw5nM6/MV712XPZ7JLB/PZOouH+LsRaNJP3/R6A15GfumPZzJ3PfV45nMvZnjmcwXZg5nMrc7E45mMvd7G05mMvfbs+LL/YHr6Ru/2OIl2CYmlt+zUePIClqnMn+3TSx2eT7w+bPw9lS5w71mWyNnt2HsTRzdhvHCxMltGNtW0XiBP6Zkrvda9ouN8qYNgo38vFH8UNIPJ6nzx5tWNNc/auJw4922PuVv7tz9XZvEAJHW01B+Z2Mpx7s2anznPvBdGzhUf2eDP16X4o/XpV6cDRHvayN683iJSP5/oD01UT6tihfHdZzUxf5UmKgKfrjTMif9m5NlBCfLyJs2KkU56u60nq2NOEPl8ZJ+83Qa+AnXd0/agZ88zL17Sk7MBz3w3frA7lRLm3bZbV9mbNhlsc9t6HsnIBWJtcKyHoDw81Sp7TnL4XKPLvt8k5juToQr+GAoXz4Y+HcliVurpD4vyQsjyMHUTJvH2Rkp8cWgZd2A9MPIbtIwnma9MoFIztu3Ym1sd9SObtekTttXr8/b91VJjtr3hZHD9t0lYRy37+7Qv8/bl68LO+U35/XodjWHYpaLaZnP+XYCgep+Mwe+s9fjKeovniUWDPlS2zyLff4suxub7ngW5GA/8L34zn4Pe7eRKb9ng1COr4k+79rQN21U+pvN8isbcTjlA9+uU0Gd0ps2CDbK83fm/hzn2IdMa7t8P4NZ7eO9/3sTZx+ERn/UxOEhW7v6zDjoJ+u1qc9dCvXJOSzbUhR8lZblLMifpdDPI5jVjyPY/pRwwgUcxE+fZW+DcWOTPK+PwtvrKs+OK98aOZsT25s4mhN7YeJkTmx7HP7Rx+3+QP2Tb9vttRNHZdhfXHE017C77ubwCuO9jbMbjMsu+ez8zpytmcP+SZ/3T/q4f+6vrDq9/OeFlRsumzrtI3sbh30k3dNH0ud9JH3eR9LHfWT3IRgpfZLXFINyaoBjipCXJbTExyUgnNj4GEcuA1rRUxM5GrSst8QIHddCWc6NWwzk41qI88DXJIvfGFDM6sk7BiSOvvsyXHrPAL9lIOpA3qsDiTqQ9+pA4xH0vTpYDbxVB+vFAW/VAc5R1ffqoMYj1PfqYDXwVh3UmAit+l4JdLpzrW+VwK45RrX36mA18F4JKl529F4rxGl060GW3/ZG7U7VE7wZ1qmG31iI7ydZj43/lYW4v/x6WoZdLcQ5AHXdSnD890hrXF+O359ge03U6b0V1x+2QRiD0bJM2zZInYbXyIqWL5X5bfc+b7OqYn1ivQ1aj1+0kpF8d23KsEu4qSUONU2VMz8djlbe7SDCnCC10QoGgXb+0g//WFJMkqRjAxyniPNjQh5lOC8BFvLWj7ffjFssDCyreMcGKGGnTlrnA0h+YSIyOtL6BfobE0g7ajMRz0xU2U68R1Xk600TsWngy11Mv3iQ9bi99bKvX5hA0P2agvULExrzsqT5vUaluHGMSN8zkWM19FEr6b1SIJUsX29VZylY111nEZOdh/+MBMFl+u8XhUgJO1FTfatnpRx984HvlYKR6cjLRRK/MiFIR6/23oPETqWU6b0HyTE2SpnfexCJ/v34UH2vFIrbt9eLF35jwlAXRm+Z0BiaaJF3DCxzMvxePVzLJJU879x1dyDP525qcYrXenT8bypCcOc3f1iT7xl4TMjHWhgvD3E+HODIeH2MTd4akMQ6xQPfGpDEKJXXQ6byuVchq1t1PQjh67Cs2na37IXdsotf/cYxI9pakael2D5IfEMmW+fFvpmw7Q6ioy3uttscdrbFfW/ibIv7doAXpfhy0+7PytjN/IoiXIqmp4dwvzASV7ultg/oqZHdYcZ84SYULpvH2X8IxSvI9Pkh0ba7lOk0m2j/ODUi12OUlZ8/zu7soce8Z4y/bUlJMjm3ISVuNJCS37SBa4hEltfyDxv50yW1V8W4UIz8vBjbY5krwpCuqxTfP5Vtex9SxQf347Gffirvn0dRraqbptklzF/xRZCvZY9a+XY5gl9n+zQYYduPpeWkjB9GtmtigjN7HvzlYPTrN2VZcrSXjUw/y0I3uPC2anFNQqa8K8n2cvdali3AujPDfzgm5RTRMdO1eWPQNmVCcFTNJsPR6E+H2NYo8Thf0r6/PU7evkVjpE3rjVM/SrK76+m8u22/OuK8GuUlx+h7NMjb425jd9YSC74dRmovrnqKW1q/XH1XvvXWvL1bPYL9Y0BzPTeyrY9kSKVdBiY/6mM3HtC03Fq3DCpK/WZk01lxWhWvyXQ/TNgNUbpcN0TpXU7JL6L09oFOY2PJt8TGUm7wvl0j1xh9ftn98b2Ri9wQGYv+6YepuENmvRfkx9PYDYGRrzueRrdd1jBi2zzO7v6nhwfGATiX7YzkG1qY7+iu28dJhnffeoHtj8eRO5pY//S7T+JDR5Wex/rd/sDHZG6sxF3L6OZHLJHtYck486EsH7L2/Vae3XbJHNs3vlzLQ/ZtXLI7Ao8ypunLslCcy/eS7L65Dk8HeVGSmH6i9eionyXZj1+P9sXYdinpaCpu3zYFW1llqdafbXPH6HV/LACW+GSZy/pRkt2eJcZtYXyt45tf+M2ji86eVmjZCfLDb/SGD65t2l1MVBTN9s78YJHY+FC0bOYHd7c/Hc4P7vYrHc4Pbk0cXvP3Yl4Ol8nJ85ufbbdf6XhyT7d97OgCjOuOCtke94qDZ43enx48C2V7I2db/Gx3mN7pFj/bbSY92+K3fXs/JqKjeRvbuzM/y/fNkjj725mfs9bZGzlsHUs3tM5279JZ6+xnoL6eYGtvz0AdVizfUbFyR8V+vHP5/Ht811/3Rs6mOx9B74bvrJdWjpr4lZWzNk7XdcP25YeV8nkr51vc58UkxZn77I0cV229pWrt46rdTqwJzj+sTz9h2xTGZmSRIwGn5PUGpu9TjduZG8Hao2xuK3s1c3PYwnpHCye+o4WT/NEWtjj70JZT4P5GC+96SUL6Q1qzF3608G7XPRbLeZ2v/GGEb4iPL4yctvB2hHLcwpQ/buHdRBQh3YrWZKefbbwbF5QrjkB/fI7KpnnyDV7Md8RpviVO77b2nbfxboHrhjbOOLEzrwsPP9s47/bQ19gIVGw9tfNHG8sdfnxHpOZbInWWW9r488HsduITZ0ak9XyCbxOfj3LsPvOP9gzubZxtG3xh42jn4N7G2ebBcxv8ro2jLYQvbBztItzbONtIeG7j3fo42074wsbRjsK9jbNNhec23q2Ps62FL2wc7S7c2zjbYHhu4+1yHG0z3C6bnJ6Hvl974YKcuev5Mnu6dpPzmqJplNYZy5+nh2/nxfVvxOWc0y8e5/AY8xdGzs6I3xs5PCP+xVLSSVr43sRRXvcLEydbzV4srJ0OQ+SWKQH5eEogXXrDtrWHle1JXCf71l7YONq49uJpDveuvbByuPdsv97ICfnVy8LWb1c+D5dx6x1dVm/psvr5LNZ+IZexpLwch/W9YtuZMbtvrEhLzmnN3fv+NHV3heh6z8u6p/r74f11m6h9sEn+hYmTXfKvTBxsk3+xNo6Tha8vw7zvxdh8WRWOPLeyXq7+gRF7ukp/mi6gV9r0su1NUQXJ72U99fn74+wWtuSKa3wkrUcU/zCyve2WOD442/7FW8wkel65hxtBd1k/2zSKK97l5eLnKZ6P59mMCDC2qcsmzO+pNg8bevT1u26gzz86Sv10xPiiHDgtdU0u+24jbReTTqP89jKvw4FJuuiGgUnaLWsdDkz2Ns4GJvunOdwF/sLK6cBk7zgVc7/X8+W1R1F2mzXia6ssj/N99mp7xfrZkVmv0qDOxkd6Q/ZB2l4nfu456fMVguOdcOX5TriUtvu2Km7Sq8uJAd+TELdbV04XCOiOITDVW5r4jgWCRJ8vEOzWGI5n5V9sojmr2L2R04rdpcz8omL5j/rOY04jsta/rG7/2BS7v8M+puUvoY0D7rrsPVbOjoh8YePojMhXNk4OiXzxWX54GMurKYKzN/GLiaSTIwJemDg5N+nF9N7ZVXYvjJxddbjfgJYk/Ibq811sj3ffLr5GPFo2W50fA3UZdlcsD/J9LJ9227VqXOtd7flFhw8b21FaHGhKunyPf7/pcG/lMfpab9XkzV2jaZfDZCUu/DC+NpdqpsK7Z/rwNApKeTnrLG1aZzegwGXn187EvloPTxJ+YedRUJyHVPRtOxe20bSPqvK2neWm7wfL23YU9zBfaw77r+3Ycu7zVd/tvhpfcKZCu+57bMXetmI4Xsf4TSvnhz+/7MmHJ2u/eKrDU7FfWTk7F7vfeHpH3fANwx6+YdjDHw97diuJhly8ZcRzvWOA3jLAcdebrBehnhvAst16ROVvDMQpCuuM8G8MHN1PsC3ByVkqu1Y42o+zPbQujulMsm7HycfnniaJyaPH6ry9ZaLG9R1pvXDvNyZMY179utI7JujCRSRfrl7+RSmQ1ZK+jpx/YWLZg5PeepCUKm5/tvdKkXGrdlkvUfuFiRJj3sfAjJ+aeJR2d1vf52dU5nDTx1jxvdrA2UuPV2f6uELfNEEc++dJ1utbf2Eiom5aj1p524S8ZSLHoP+B9T0TgiM/Nb9lgjFg5/JeXWQzeAl/buK9Ri2xQPpYDEzvmcCRn0XkTRN4kPVU3N+YiBFjKvW9Ri2Gk0iut0pRYlW01LdqAv2K6flDPOZyd4NwwokqtM7SHZ+qzmHgy3m2v3iMeKFKeasiObbV8Tq6+YUBXOVn+T0D199YuXzLwJdDBn5TiTHCey/QSYqpuGwfluC9Zuz7tmICYMnhOL/9hHDgHy1Nma5v03i0uxCo4it5Of/wF8VgzCYyrcfaf7vg7VGM3cUPpwmhjwH5LVZ2J/0TbpandYFDfmPFYuudrfNW32xs574JxVizdX+0L23PW1HMwy/TIPrDyG6PCxGuqly+A34a2e4VXRJJuKTNyhFtt2wffte8sHL4UfGwIp+P6F9YOR3UE31+ovUvHmgzon7V1AUL0o93Zt009W7B8kuG6JfT2L6XZre36ryRjq1sa2Zr5bipdys4x029rVyM9inX662P+yRon+0rKG/nEQmVcuUlPUzqr8yUjOnIsk4knt+a8/isxVeUrNv5fjzS9iDBHBsCHiaX1/v1vZl3k8aPVokjah4s1/OK2W3Sf8x9YN3fbMnG/0XFPD6jcPbXl7uov1XM/lMEXzPLXcP8/b26247+mGmOwdejOteDjOqPJtreORyZgFR4Hcjab6wsEaqo7azYtuuWvzUa/GmF70gHJP48HZC2+54Pr5R5WMnbGY2jizseVrZLqifXTbyoE0wI75IK93VymA74sLI9s/XsDpCHlX3EPbpBo0+OffwW4v2pU0c3krxwQ75wVXWuGwfaHeZnMeB+LIiiKFW/29gF29McK5I7cqxI+HNX3mW+HOfC+kfT88nzs/uIXpTl2IV2G7HOXUivz8OKXne44S4j9tgNt5Vy7IaynWDDICEveUE/PWhnBJc4pvVEoR9GdicEakwA17Seh/d9hKDbd3vcXti+xd+2EiNKWkcrvy7LYqW+bQW7sWg9Cev9suj7tau4oWVZ8vigLLat3e3xiTEJVuVNGxWT/dd6x+QPI/WOEy+o6udxv9Y74n61O4ZwdkOstVtird0Ra7eVcvwy3DbQ8Rjb+JYGkhsa6MyGbutEPx+nb+v1dJCRr+uGQUbe3oN1Vq9bG8cdP1+fZwy8qJR7BhlVcY3Vkpz6fXyQr22gjUNOZHmb/qwT/Xg5cV8Q7NyppewKsn314ISS600bhqX/L5k+P4zszht8zOrHDr7trG++ZXNW/nxz1sNGueElmLe7s07j/b4sx3Ep3TF/kLdrW4dxKd0xB5F3+7OO41LSPx+XkLK3i0tbI8SxuEXr0Vo/gtt2bQu3pidZj6PRH1Z2h6ewxoFU60r/j/BG2z1a4UE5r5s0fpRk91q/YmLm8ZLKbxrBgcSPzmDvGokRxmOGf1OS7a1aQmjj3ePsVm+SxcRzslLfM0JXnClFX+5h/GFkt+M6IsqXs+Dqr8qBWzQu2bTNblHsjnIkLImlWt6s1GVR7AMj0Vs/MLK+vmjTR8p2SQxvjLzeDfQrIyXR31o8/cAIv2sE9yWVUt42gtRVthse530juiyp1c+N8PWuEU4wsrx0fhqxj314Xw5BBurOc3YLPqexZBvlOWKJ7GLadgnsNMpvj/49jfL8eXTdl+MwyrP+2XKcRvkXRtINRg6j/NbIaZTfDl5Po/zWyGmUPzfC7xo5jPIvjJxF+ePHed/IYZQ/NbKN8lsjp1FeP4+u+3IcRnnNfzbKa+Qc0TqT9LMcfIPzbY2cOt+5EX7XyKHzvTBy5nzHj/O+kUPnOzWydb6tkVPnq+XjTr8vx6Hz7Za6Dsux/RonxT27ddO8+3WUw6/x7ZLO6ThtZ+R4nGafx9Z9OQ7HaZb/bDlOx2kvjKQbjByO07ZGTsdpu6MHj18VWyOnr4pzI/yukcNXxQsjZ6+K48d538jhq+LUyPZVsTVy+Koo1+ffWvtynL0qyvX5rMA+yp99jZd0w5zr1shplC/p4+j6ohxnUb4k/rPlOIzyr4ykG4ycRfm9kcMoX+iGOde9kcMo/wsj/K6Rsyj/yshRlD9/nPeNnEX5YyO7KL83chrl6ePo+qIch1E+pz8b5Q+/xkvONzjf1sip850b4XeNHDrfCyNnznf8OO8bOXS+UyNb59saOXW+3RavQ+fbl+PQ+crHswL71AWJnCrS9Dz/oWx3d52mLpTtRaGHqQul1M9TF8puQes0dWFv5DB14YWRs9SFst/YdTZZUu5Y1Cp3LGqVzxe1yh2LWuXzRa1yx6JWuWNRq9yxqFXuWNQqdyxqlTsWtcodi1rljkWtcseiVrljUavcsahV7ljUKncsapXPF7XKHYta5fNFrRdR/nCyZLtIcBrld0aOo7x+Hl335TiM8mp/thynUf6FkXSDkcMovzVyGuV3C1rHUX5r5DTKnxvhd40cRvkXRs6i/PHjvG/kMMqfGtlG+a2R0yj/+bLWi3IcRnnjPxvlTydLdtdYHTvf1sip850b4XeNHDrfCyNnznf8OO8bOXS+UyNb59saOXQ+vj5OGXhRjjPn4911Wofl2H6NH6YucLphIwHfsajFdyxq8eeLWnzHohZ/vqjFdyxq8R2LWnzHohbfsajFdyxq8R2LWnzHohbfsajFdyxq8R2LWnzHohbfsajFdyxq8eeLWnzHohZ/vqj1IsqffY1zvmHOdWvkOMp/vk3rRTkOo3zWP1uO0yifb5hzfWHkMMrnG+Zcudww57o3chrlyw1zri+MHEb5csOc6/njvG/kMMqXG+Zc90ZOo/zn27RelOMwynP+s1H+8Guc+YaNBHsjp87HN2wkeGHk0Pn4ho0E54/zvpFD5+MbNhLsjZw6n3ycMvCiHIfOJx/PCuxTF1bnq5sj57ZGatxxT3Xx4F8aSRVG3i2JRR/JV94cZLk/UjPuOyK29bKLX52PK3HKB0nJ71oxnH1im1N2T78qFF2Nj8/jTxIXWiZdzp0/t0ApDrZ5jPquZxYe5dvltkRqS11OgVH7bmKXlK0pTlDSpS4eUem7ld0nVlzwy8sdGD9t1N312lcYyVfBa+LH9fZcd8dk+eXobsVo6WR/w8ru2KHTk1t5d7XW8eFFvFsjODy8iOvp4tru8CLebdM6Prxob+X0mDmunx87tLVxfOwQ2w3HDu0b6PQEPza6o2p361qnVXtoQ7cdZdfxz07w29fr6UlZbHeclMV2Q5e1O7qsXHd0WbvjpKx91E+GxY+8iddybfNeK87fe5R6a6fcEPfl4hvivuxWuA7jvlx6Q9yX3RrXcdzfl+XUFSXdcZimpM8P09zaOHfFdMNhmvtKOXbF7SBO4kK7tSDfB3Gyu7ur5LjqquTl4LvHl/IvSlLjAue6uPLfKMlu/wfHSZiPl2vaOGGyOwIC3XEbh9Dnt3EI3XHzhGzvdDp2Qvr8No6tjXMn3J1MeOyE20q5xQktlvFtufzoZ9ffLnilgsvHld91whptfKW0Kcr+7Dp886dl98XPnp/v+ByTfMfnmOTPP8ck3zEq9R0wn3vhbu3r1At3Ns69MN9wh8y+Us69cDfiEcw2a911/rKde4uy0Fq5f8PKboRwxRnXJS1d7oc3b8vymF2RmF2x7RPxHS/V3cauc3febuw6duftzq5Dd94lcJ27M98ysuUbRrZ8y8iW7xjZ8h0j233nTwmb5taL/H50ft6NEmpcE1rs0ncdMcWVNvnLjXU/y1LveK/yLaNbuWV0KzeMbuWW0a3cMrqVG0a3csvoVu4Y3co9o9vdYMNwuedyJ9TPFYt9SrVi6dSeGhHd9tmjOx9kt8vr9M6HbUEO73zY2zi782Fr4/TOB9nt4Tm+80H0jouPRD+/+Ej0jouPRO+442dfluPYtlseO49tu+Wx09i2s3Ee23ZrBMexbVspt8S2fk7iy7h0bZe28b2wWPi+Jiz1jgVdqZ8v6IrdsaArdseCrtgtMwh2ywyC3TCDYHcs6IrdsRQrdsvXv91wZf3+gY5Drd2xGKvby7ZOK1evz0PtqY3dYuz+ae6p2dOXmF53THzppTfU7B1dX68bJr72lXL8pWx3LMdqoluWY3W3OHYctTXdcYGyps8vUNZ0xwXKmu64QHlflmNXTHdcoKz0+aWeWxvnrkg3XOq5r5RjV6yfL4Iq3TFfq3THfK3SHfO1Sp/P1yrdMV+r+Y75Ws2fz9dubZx3/XzDfO2+Uu7p+odLj7pbCTqeItXd0tZ538/1jr6/WyA77fvluqPvlzumEbTcMLYtd0wjaLlhGmFfKed9/46lRy16w3KfljtyaLTcscqgfMcqg/LnqwzKd6wyKN+xyqD8+SrD1sa5C/ENqwz7Sjl1oX3nP11iU7Y73h/bxbHjzr9bHDvv/LvlsdPOv1sHOu/824Wt484v/Hnn39k47/yiN3T+baUcdv7tlOtyxKw+31Wku6WgjHuHM2vdfLtvV8f8LuAx/bUU5dHavzBSUswjlKV1fhrZddkcLkhlGU4+ptu/W9nduY0jgKlc+CDL5UdZNt1NOBYeH2vqiyPnHy20+yBLsdTw+JqtOyu7ThtLfmVxwZx/Vys4fqEo7WrllhFCvWWEUG8YIezWts7neXbbx87nebZWjqeh6w2htt4SausdofbwcbYz4ttGPl4lsOuO5rEbZhEObezrZOc8Z1u29vV6PMLYrTScjzB260nH9Sp3dPs7lsf2lXI8vN6+T/0Wg9Hxlzfhj/dp3S0oHcf8ulvaOo75dbd97DDm193WseOYX3dbx45j/r4spy5Urzt2Pdbr812PWxvHLlTTDbse95VyjwsJw4VMNi60Wx7L6YrRfloSLH70/bT96jg7DWxr5PQ0sJo+PrzjRTnOTgOrqf7ZchyeBvbKSLrByNlpYHsjh6eBVbrhLqW9kcMDiX5hhN81cnYg0SsjRwcSnT/O+0bODiQ6NrI7kGhv5PBAopo/vkvpRTnODiSq+eODkV68KyJF+PGu0M27YrcaxleJjL5rTQuUXxkhDiNVNkZ2I1mOFJMi5RYj9tTIcc3qtZkYqttln3IhHz3X58+zW8YSjYk70XXK+ldGKkdv+5Iz8CsjFmc96UX2npHH8ntcuvWYjX/XSESTxwfC9Z6Rx2BuGqmJNv2+bA9AII7JzPbFfouZRG8+Uo6XxsNbN2XZ7vE6f6RfmNk80ovJYtOzed7dvLWkGA7LLnet7s6hq/FxW1mfz2fW3VoYx0fceuPcj5nVyneky1T+PF2m8ull5dsv291C2PmXLd+RulO3lysdf9nK5+ckbW2cf9nuFrGOv2y3lXL+Zbt1QtxPuKYM/HRC2XVbM6xBmS3LR/J9CCe7xNpMFFs2vywF/zCze6ZTd9Y7VnCrfr6CW7ejHpL4VifdutB51S7b337XQo/nsOi6lPRdMxTD2wfLpr/sbwfTaOi0a+j68aravhyHHe6W1bB6w2pYvWVCv9Y78mVq/TxfZmvjPGbXG/Jl9pVyGrN/4z3Ll4PU34R+jcLkmm0T+u2OhJlqt4RbuyHc2h0JM9XuSJip9vkq7tbGee+3G1Zx95VyQ8JMwjdDys+3XNruOMXHVHPMoT9Y5Kn/2HaLlcaCclrP820nVvymMBrHVDy4XpvC7LbeWIUfmi1fzt/M7CqXMIgjlU3lbvsbvuAffW+dG6n83c4uHTzHy50K43F+nD69t0Jo6bI5ffphZbuehe1R19Jd/oYVuyHGWbo+jnG2vRPqNBXC0h2n11r6/KtsXydnaQz7OjmN+5bu2Opo6Y5tipZuSEHYP9DpiGXvhnyFG/Iy5/rTgXYHKhoOErn0+dH4RndsLDe6Y2O50ecby227Y+z063Bv5bjz0x0JCEafJyBsbZw7UL4hAWFfKccORNuza2L95LEuq5u+vzNSI8/+4fTPL6iw3QrZY3CB+Xl0/Ov7u317niKlGPI8eu3bVnIkZazjjF+XZbFS37aCBJGHM91RFn2/djWcmZZklQ/KYtva3X2/x8yIVXnTRo0Il67MGyPljk3lVj7fVG7ljk3lVvSOwVe5IdaWW2It3xFryx077fcNdDw65jvyuO2G/WKnNnRbJ/z5CLvccYKBcb1jkLFblzquV7uj4++2ih13/G2l3DPIqHFy7UMuPR8fyDbQHp3UZ9tNXocn9W0LcnhS397G2Ul9WxunJ/XZbsr3+KQ+0zvWGEw/X2MwvWPHjekdO272ZTmOS3rHBgbTzzcwbG2cxyW9Y/ZA+c/HpWigfVzaGSHskqQ1t++Hke0hiH6WeS+JLLmO7ZPsm5Xd7AHHPXC6Lhj+CG/b25awvzHnZXyefpRk91pf95/m/KYRpCznpPaukRhh5MfX4cbI7vwDIbTx9nG2pwGdJdhvjZwm2Jt9fEXui3KcJdib5T9bjsME+1dG0g1GzhLs90YOE+xtezfYYYL93shhgv0vjPC7Rs4S7F8ZOUqwP3+c942cJdgfG9kl2O+NnCXYP0KOfuzD+3IcJdg/ymGfx5JtlOeIJfI8ptG1vQ3sLMrvjRxG+YeRT6Prq3IcRfmHEf6z5TiL8i+NpBuMHEX5F0bOovyj6a+Po/wLI2dR/jdG+F0jR1H+pZGTKP+Lx3nfyFGUPzeyifIvjJxGebKPfXhfjsMon9OfjfLrve6yqdT8+R7GF0ZOne/cCL9r5ND58ud7GH/xOO8bOXS+UyNb58uf72F8vGfpY+fL+QbnK+Vz59t9jZPiWOm6ad79OsrR1/jDiN4wTtsZOR6nlc9j674ch+M0Tn+2HKfjtBdG0g1GDsdp5fTW5N04jeWGV8XWyOmr4twIv2vk8FXxwsjZq+L4cd43cviqODWyfVVsjZy+KuTzb619OQ5fFaKfxxK54WtcPp9z3Rs5jvL6eXSVz+dcH+XIf7Ycp1FePp9zfWXkMMrL53OuLYf+hiivn8+5/sYIv2vkMMrr53Ouv3ic940cRnn9fM71hZHTKF8/j656x5xrtT8b5U+/xi3d4HyWbnC+cyP8rpFD53th5Mz5jh/nfSOHzndqZOt8WyOHzpd2+6oOO/2+HGfOl66PTzbapy5I5FSRpqf5D49ylM9TFx5W+OPUhYcR+Th1gdKlH6cuvDBylrrwyshR6gKl3Ram08mSdMeiVrpjUSt9vqiV7ljUSp8vaqU7FrXSHYta6Y5FrXTHola6Y1Er3bGole5Y1Ep3LGqlOxa10h2LWumORa10x6JWumNRK32+qJXuWNRKHy9qvYryZ5MlabtIcBrld0aOo3z+PLruy3EY5bP+2XKcRvkXRtINRg6j/NbIaZTf3tV1GuW3Rk6j/LkRftfIYZR/YeQsyh8/zvtGDqP8qZFtlN8aOY3yny9rvSjHYZTn/Gej/OFkSdqda3jsfFsjp853boTfNXLofC+MnDnf8eO8b+TQ+U6NbJ1va+TU+aR83On35Th0PpGPy7H9Gj9MXUjy+UYCSncsaqU7FrXS54ta6Y5FrfT5ola6Y1Er3bGole5Y1Ep3LGqlOxa10h2LWumORa10x6JWumNRK92xqJXuWNRKdyxqpTsWtdLni1rpjkWt9Pmi1osof/g1bnfMudodc672eXS1O+Zcjf9sOU6jvN0x52p3zLnaDXOudN0w57o3chjlf2GE3zVyFuVfGTmK8ueP876Rsyh/bGQX5fdGDqM8fbxN61U5zqI8pfRno/zh1zilGzYS7I2cOt+5EX7XyKHzpRs2Epw/zvtGDp3v1MjW+dINGwmIPt5I8KIch85Hn28k2KYurM5XN0fObY3UHK/PunjwL42kCiPvlsSij+Qrb46g3B+GGTf2EK8XRP3uZFvBdfdS8rtWDGef2OZ83O2pwSVODc7L9ePfTg0m2m/UYsX147ycWifpV2ZwUeODl+OufprZbX/ROPcnr4cHKX83sk3QXi7J4ZKeH7fzsLPbAVPj4JIHrlcU0G+s4JTpdp3vzspuSivHPVGpXOVdK0XixcHLcWI/rZTPD8561UgljolK25OVyM/cfz7CxznTxNfukcod1XtshdK7Vs4bSW9opG3lZnwN5rqr3BexoXLEhvXs3x+xgbe3JsRJeHkZwrH8qihaEKbW9+LPouzOMr4U2XiXLgMf+T5W4DuOjn9VGhwvq+kqsjGzu/NgOdJrOe3z4ZynL6THYAXjlrSkF7YDQ//fx3/+4z/9y7//w1//7Z/+8T//5d/+9T/aXxI9/m9qiWSUG7XRMZUgDpIgDapBNilfjVrgySmIglyjRchcglyjPB4rS5BrNCfNNcg12ilhxTXayZzFNdopqYWCcpBrtKFc4SAJ0iDXaKd5FZvErtF6PKcgCnKNNiLiEsRBrtEuq2ENqkGu0c7aEtdo52VJCqIg12gHYYlrtC4mHNQ0ckt7FQ3qGo+IIeb/9iipXkEpiIJyUAniIAnSoBoUGjU0amjU0KihUUOjhkYNjRoaNTRqaFhoWGhYaFhoWGhYaFhoWGhYaFhopOsCJiABM7AAGShABVYg1BLUkqu1lfWUCOhqbVSeUgEyUIAKrEALpAuYgASEGkGNoEZQI6gR1AhqGWoZahlqGWoZahlqGWoZahlqGWoFagVqBWoFagVqBWoFagVqBWoFagw1hhpDjaHGUGOoMdQYagw1hppATaAmUBOoCdQEagI1gZpATaCmUFOoKdQUago1hZpCTaGmUFOoVahVqFWoVahVqFWoVahVqFWoVagZ1AxqBjWDmkHNoGZQM6gZ1CzU6LqACUjADCxABgpQgRUItQS1BLUENcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxBJCLCHEEkIsIcQSQiwhxJKMWJIRSzJiSUYsyYglGbEkI5ZkxJKMWJIRSzJiSUYsySOW5IZdrTYsQAYKsKu1cf6IJY6u1i6xyD2WtKmI3GNJRwK6Wv+OKEBX8++HHks6KtDV2jRK7rHEsceS9pWbeyzpSEBXa197uceSjq7WjprPPZawf8wo0NXagmnuscSxx5I2D5B7LOlIQFdr81O5x5KOrtYObs49lnRUoKu1bK/cY4ljjyVtMjH3WNLR1dr3f+6xpGMBulr7asg9lnR0tXb9Ye6xpN0+mHssceyxpKOrtWtaco8lHV2tTQTmHks6MtDV2qUquceSjk2ttFFx9ljS0WPJwKZWkn8lEjD/ZayoZI8lJbUyeCwZKI6tSjyWDHS1tnKRPZZ09Fgy0NXcAzyWDHS1doNO9lgykIGu5h3cY8lAV/Ne7bGko8eS0qaBsseSgQR0tfblmz2WDHQ177QeSwYqsAJdrc2mFo8lA12t9erisaS0rlw8lgwswK7WvrkvAbqauLEKtECPJaX16uKxZKCrta5cPJYMLEBXa726eCwZ6GqtVxePJUV9CsACPZaU6tMBCehq7ZO6eCwZWICu1pyheCwZ6GqtKxePJQMt0GNJsVYcjyUDXa3tiyweSwY2NW7Zm8VjyUABqqM1rMCmxq1XF48l3Lpy8VgykIDZsZXBY8lAV2tduXgsGahAV2u9ungs6eixhFtXLh5LBhLQ1VqvLh5LBrpa69XFYwm3WF08lgx0tdyqxGNJR48l3AJ08VgykICuVnz+pgBdrQXo4rFkoAJdzTu4x5KOHkvYe7XHkoGu1lY/iseSgQXoam0+tngsGehqLdGxeCzhdgtB8VjiG4aLx5KBruYd3GPJwAwsQFfrs1MCVGBXaw9Uu5rPX3W19kAeS7hNiBePJQObmlyOBdjUxLuRxxJpd/QVjyUDK7CpSduCzB5LBjY1aV2DPZZIccxAV2sTeeyxZKAAXY0dK9DVWrYaeywRcXS1VuvssURanbHHkoEFyEABKrACLdBjycAEhBpBjaBGUCOoEdQIagS1DLUMtQy1DLUMtQy1DLUMtQy1DLUCtQK1ArUCtQK1ArUCtQK1ArUCNYYaQ42hxlDjrtZanhnoai0qs8eSgRVogR5LBiYgATOwABkINYGaQE2gplBTqCnUFGoKNYWaQk2hplBTqFWoVahVqFWoVahVqFWoVahVqFWoGdQMagY1g5pBzaBmUDOoGdQs1OS6gAlIwAwsQAYKUIEVCLUEtQS1BLUEtQS1BLUEtQS1BLUENYIaQY2gRlAjqBHUCGoENYIaQS1DLUMtQy1DLUMtQy1DLUMtQy1DrUCtQK1ArUCtQK1ArUCtQK1ArUCNocZQY6gx1BhqDDXEEkEsEcQSQSwRxBJBLBHEEkEsEcQSQSwRxBJBLBHEEkEsEcQSQSwRxBJBLBHEEkEsEcQSQSwRxBJBLBHEEkEsEcQSQSwRxBJBLBHEEkEsEcQSQSwRxBJBLBHEEkEsEcQSQSwRxBJBLBHEEkEsUcQSRSxRxBJFLFHEEkUsUcQSRSxRxBJFLFHEEkUsUcQSRSxRxBJFLFHEEkUsUcQSRSxRxBJFLFHEEkUsUcQSRSxRxBJFLFHEEkUsUcQSRSxRxBJFLFHEEkUsUcQSRSxRxBJFLFHEEkUsUcQSRSxRxBJFLFHEEkUsUcQSRSxRxBJFLFHEEkUs0RFLtKGrtbkK9Viibf5BPZYMbGraZsrUY4m27yH1WKLty109lmgb06rHkoFNTcXXXZuatgGReiwZKEAFVqCrVV+vvYAJSMAMLEAGClCBFQi1CrUKtQq1CjWPJX6VrnosGdjUasuHVo8lA6tjqzOPJbV9gKjHkto+XtVjSW3pgOqxpLakTvVYMrCp1ZaRoh5LBrpay4NTjyUDXS27XVdrH5nVY8nABCSgq7VPmOqxZCADBehq7azl6rFkoKu1L9bqsaS2nJXqsWQgzTauHksGdrWrIQNdrX07VY8lte06rR5LavtErB5LOnosGehq7cOxeiwZ6M/Wun31WFLbbo7qsaSar/ILUIEV2NSsHRNWPZZYS1SoHksGkmOT8FhirWGrxxLfX1Q9llhrt+qxZKA6tkJ6LBlogR5LrCUGVo8lAwnoaq25aylABrqaV6rHEmtTEdVjyUAL9FhiLbWpeiwx9n91NfF/zUBXa5GgeiwxbyGPJQMVWIEW6LFkYAISMAMLEGoCNYGaQE2gplBTqCnUFGoKNYWaQk2hplBTqFWoVahVqFWoVahVqFWoVahVqFWoGdQMagY1g5pBzaBmULOu5nkrFehqLS/IPJYMTEACZmABMlCACqxAqCWoJaglqCWoJaglqCWoJaglqCWoEdQIagQ1ghpBjaBGUCOoEdQIahlqGWoZahlqGWoZahlqGWoZahlqBWoFagVqBWoFagVqBWoFagVqBWoMNYYaQ42hxlBjqDHUGGoMNYaaQE2gJlATqAnUBGoCNYGaQE2gplBTqCnUFGoKNYWaQk2hplBTqFWoVahVqFWoVahVqFWoVahVqFWoGdQMagY1g5pBzaBmUDOoGdQQS9KFYNJu112YFs4Ll4V5YVlYF64LL7r/fxvnshu3EUTRf/Gai6nqd35FCALbEQIBQmIotgHDP++u0+rmXXgzOENKfUqcqRqQcykTr4nXxGviNfGaeE28Jl4Tr4nXxevidfG6eF28Ll4Xr4vXxeviTeJN4k3iTeJN4k3iTeJN4k3iTeLN4s3izeLN4s3izeLN4s3izeLN4i3iLeIt4i3iLeIt4i3iLeIt4i3ireKt4q3ireKt4q3ireKt4q3ireJt4m3ibeJt4m3ibeJt4m3ibeJt4u3i7eLt4u3i7eLt4u3i7eLt4u3iHeId4h3iHeId4h3iHeJd0yrSzZPx9gqPwytcu9mE8cY5hq187Wa8gyDsmlcRNrAVsd3chPHGN7O2UrbvvObVYM01r97ZhfHGmaitqO3mwn8oWBHdKtyEe/AK7Ma82hzzajK1xbyaTD0xrw4nmOMQ8+owXqMGr8JNGC+xQ5K3mxPetALEJuzCeBO1pSyMN1FbqsJ443TXiOAeHjdnvHFaY6RwD+PNHKuMt1BDzsJFGG+hntyE8Za15ri5PITxFl7T4sJ4K8e2ZOEijLdSZ2nCeBu1FbyNeupDGG/jWFUXxtuooWbhIoyXPiKfexhvp4Y6bm4PYbyrR5oL41190bJweO3B+yTm1eEm3GFe05hXm2NeTcYb8+qwCyfhDPO39CKMd/VFx7t6oXfhcfPAu/pimDDe1QsjCWdhvKsvRhXGu3phdOFxmADvZIdNGC99QYZ3coWzMN7INhgx3sN444qBEeQ9PG42vPQUWd7DeOkF0ryHszDeQm3Mq814C7UxrzbjjXiDEeo9bMJ442t3I9d7GC99QbJ3MjUwrzY3Ybz0BenezcwroxfI9x52Ybz0BRHfw3jpBUK+h5swXvqCnO9m5pXRFyR9J1MP82oz3sGxYl5txstnBHHfw004vE5PkfjdzLxyPiPI/B524QRTG/Nqc4GpjXm1ObzuvE+YV5vHzcyr+UrBJozXOc7MK3eOG/OKe7qMBPBhvKtHmFebu/C4mXnFTaJGDviwC+Nd/cW88ry4CFdhvHymEAc+jLewJvPK1/ufebUZb4mb9L5/fHv5+On1+f8Pf/yMm+W+/ft53xg3n3798WXv+fT28vr68s9fX97++/z897e357iJLvZ9eMRDtOzTnEpucZOdvW9/mtec8jUvMZU/2fg0z8v7NU/D63yeYn/coD6vO8Vzlphfb6ZrPvTYYPzEvOI9H0as60c1X6CUYlOKTbHUHB3F9jJzFpQWu/Nd3Lg8x6ZyL5IvZ916b2pX8tjU9rpzzOW8152f5+URu/v5jdkmg0XGvUi5Ej9lvzs2dlb2K/upeJZf2S9/pF0+t8WNi78A",
      "verification_key": "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"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "target_contract",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "reward_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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Tbx1vM8PtIXe5wcGMIICJtDrthDzKYRJ/Gh6j/U7S58sODGDbcvE+5D32IG+Zd4O3mMdfbLgRN+y7BhBAROYQQUL6DZ1tIXhAgMYQQHT3GOfFlj9yPu0wIm2MF6g1/W/FiMoYAJbanhT+7TAiQWsoC303/mBAYwLW794jPR1jhvLxmnjvLFuXDauGxvcfioXb17dvLp5dfNqrx+d68YG9xPaHPu/bmeTT3pbHDaOG8vGaeOySlaq+49WR//RGthr+wlqceNe288167X9rLG8sW5cNq4b22Kf7LY4bBw3lo3Txnlj3bhsXDfevGHzhl6/OPc61ZlTwaezLeZU8Alti8PGcWPZOG2cN9aNN2/cvHHzyuYV9/qQkk9uWywbp43zxrpx93auG7vXrxV8ktvisLHX9xECn7v24OhcN/Y6Plrl09fGuVRG1+0cN5aNe31xzhvrxmWd72V03c70oaKbVzevbl7dvKPrOhf/M34b7zPQFqeN+7b1P68bl417m/i51/t3596//Sa09P49OG7cvd6GvX8PzhvrxmXjurHB1r1+rHvfHxw3lo3Txnlj5ViPPt62ufY+7seo9j4+OG4sG6eN88a6Mce6XnVjjnUN18Zh9WufkLZYNk4b541147Jx3djgSGbW0fc7cy7V0fd920bf77ztV9z2K277Jdt+Sdg4biwbp403r2xe2byyeWXzps2bNm/avGnzps2bNm/avGnzps2btvYcWdF5O455O455O455O455O455O455O455O4558+rm1c2rm1c3r25e3by6eXXz6ubVzVs2b9m8ZfOWzVs2b9m8ZfOWzdvzxzO/9vzp3PNncNg4biwbp5X/deRPZ92450z7XagjT6KzbNx/m3zbxrWE95FxLdG5bFw35vy069o4bEy22yUbp43zxnit97XaOWwcN5aV4db72uC8ctt6XxtcNiaTTchkG7+zncPGcWPZOG1MJlvva4PLxnVjg/O1cVjHyCdwVX/K5hO4BvqY0cAARlDABGZQwQJiU2wFW8FWsBVsBVvBVrAVbH657c8gfQLXQL9/HBjACAqYwAwqWEBsFZthM2yGzbAZNsNm2AybYbNpKz6Ba2IAIyhgAjOoYAEriC1gC9gCtoAtYAvYAraALWAL2CK2iC1ii9gitogtYovYIraITbAJNsEm2ASbYBNsgk2wCbaELWFL2BK2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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "10492081608786484886": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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AwQEAQAiBAIFLQoFBi0OAgYtCwQFACIFAgUtDgUEJwIGBActCAAHLQoECC4IgEgACS4IgEQACgAIAAYAJQAADd4tAgAALQoIBTAKAAIAAycCAgAEMAoABQACHgIAAgA0AgACJwIDBAAnAgUEAwAqAwUELQgBAgAIAQQBJwMCBAEAIgICBC0OAwQAIgQCBC0OAwQnAgQEAwAqAgQDACICAgUtCwUEJwIGBAIAKgUGAzsOAAQAAyMAAAfCJwICAlUnAgMCbicCBAJrJwIFAm8nAgYCdycCBwIgJwIIAnMnAgkCZScCCgJsJwILAmMnAgwCdCcCDQJyJwIOAnsnAg8CfS0IARAnAhEEHAAIAREBJwMQBAEAIhACES0KERItDgISACISAhItDgMSACISAhItDgQSACISAhItDgMSACISAhItDgUSACISAhItDgYSACISAhItDgMSACISAhItDgcSACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDgcSACISAhItDg4SACISAhItDggSACISAhItDgkSACISAhItDgoSACISAhItDgkSACISAhItDgsSACISAhItDgwSACISAhItDgUSACISAhItDg0SACISAhItDg8SCyCARIBHAAIkAgACAAAJjicCAwQeLQgBBCcCBQQeAAgBBQEtCgQFKgMABQWRm1yiPiCelgAiBQIFACIQAgYnAgcEGy4CAAaAAy4CAAWABC4CAAeABSUAAA9dJwIGBBsAKgUGBS4MgEkABQAiBQIFLQ4BBQAiBQIFPA4DBCgAgAQEeAANAAAAgASAAyQAgAMAAAm2KgEAAQX3ofOvpa3UyjwEAgEmJQAACY4tCwIDLQsBBA0iAAOASgAFJAIABQAACdklAAAPowAiBAIGACoGAwctCwcFLQgBBicCBwQCAAgBBwEnAwYEAQAiBgIHLQoHCC0OBQgBIgADgEgABQ4qAwUHJAIABwAACiElAAAPtS0OBAEtDgUCLQoGASYlAAAJji0LBAYLIgAGgEQAByQCAAcAAApQJwIIBAA8BggBLQsDBgsiAAaAQwAHJAIABwAACt0jAAAKaS0LAQctCwIIDSIABoBDAAkkAgAJAAAKhiUAAA+jLgIAB4AD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",
      "debug_symbols": "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"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    }
  ],
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Crowdfunding"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "donation_receipts",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Claim"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "target_contract",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "reward_token",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "proof_retrieved_note",
                    "type": {
                      "fields": [
                        {
                          "name": "note",
                          "type": {
                            "fields": [
                              {
                                "name": "owner",
                                "type": {
                                  "fields": [
                                    {
                                      "name": "inner",
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  ],
                                  "kind": "struct",
                                  "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                                }
                              },
                              {
                                "name": "randomness",
                                "type": {
                                  "kind": "field"
                                }
                              },
                              {
                                "name": "value",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 128
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "uint_note::uint_note::UintNote"
                          }
                        },
                        {
                          "name": "contract_address",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "metadata",
                          "type": {
                            "fields": [
                              {
                                "name": "stage",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 8
                                }
                              },
                              {
                                "name": "maybe_note_nonce",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::note::note_metadata::NoteMetadata"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::note::retrieved_note::RetrievedNote"
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Claim::claim_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Claim::claim_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "target_contract",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "reward_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Claim::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Claim::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Claim::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Claim::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Claim::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Claim::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "102": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "105": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY, call_interface_stubs::stub_fn, stub_registry,\n    },\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_authorize_once, fn_has_noinitcheck, get_fn_visibility,\n        is_fn_contract_library_method, is_fn_initializer, is_fn_internal, is_fn_private,\n        is_fn_public, is_fn_test, is_fn_utility, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\npub(crate) comptime fn create_authorize_once_check(f: FunctionDefinition) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[private] or #[public] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_fn_private(f) {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "107": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "110": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "111": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "112": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "113": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "114": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "115": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "116": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "117": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PlaintextLen * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let env = TestEnvironment::new();\n\n        // Log decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"utilityGetIndexedTaggingSecretAsSender\").returns(\n                IndexedTaggingSecret::deserialize([69420, 1337]),\n            );\n            let _ = OracleMock::mock(\"privateIncrementAppTaggingSecretIndexAsSender\").returns(());\n\n            // Encrypt the log\n            let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the log\n            let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec =\n                BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "133": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "145": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "148": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "153": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "154": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "155": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(utilityGetContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(utilityGetBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(utilityGetTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(utilityGetChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(utilityGetVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "156": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "157": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "159": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_membership_witness.nr",
      "source": "use protocol_types::constants::{ARCHIVE_HEIGHT, NOTE_HASH_TREE_HEIGHT};\n\nglobal NOTE_HASH_TREE_ID: Field = 1;\nglobal ARCHIVE_TREE_ID: Field = 4;\n\n// Note: We have M here because we need to somehow set it when calling get_membership_witness function and one way to\n// do it is to set M here and then set type of the return param, e.g.:\n//\n// `let witness: MembershipWitness<NOTE_HASH_TREE_HEIGHT, NOTE_HASH_TREE_HEIGHT + 1> = get_membership_witness(...);`\n//\n// Another way to do it would be to add \"type_hint: [Field; T]\" as argument to `get_membership_witness` but that's\n// a bit too boilerplatey for my taste.\npub struct MembershipWitness<let N: u32, let M: u32> {\n    pub index: Field,\n    pub path: [Field; N],\n}\n\n#[oracle(utilityGetMembershipWitness)]\nunconstrained fn get_membership_witness<let N: u32, let M: u32>(\n    _block_number: u32,\n    _tree_id: Field,\n    _leaf_value: Field,\n) -> MembershipWitness<N, M> {}\n\n// Note: get_nullifier_membership_witness function is implemented in get_nullifier_membership_witness.nr\n\npub unconstrained fn get_note_hash_membership_witness(\n    block_number: u32,\n    leaf_value: Field,\n) -> MembershipWitness<NOTE_HASH_TREE_HEIGHT, NOTE_HASH_TREE_HEIGHT + 1> {\n    get_membership_witness(block_number, NOTE_HASH_TREE_ID, leaf_value)\n}\n\n// There is no `get_public_data_membership_witness` function because it doesn't make sense to be getting a membership\n// witness for a value in the public data tree.\n\npub unconstrained fn get_archive_membership_witness(\n    block_number: u32,\n    leaf_value: Field,\n) -> MembershipWitness<ARCHIVE_HEIGHT, ARCHIVE_HEIGHT + 1> {\n    get_membership_witness(block_number, ARCHIVE_TREE_ID, leaf_value)\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "161": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "162": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "163": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "165": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "167": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/notes.nr",
      "source": "use crate::note::{note_interface::NoteType, retrieved_note::RetrievedNote};\n\nuse dep::protocol_types::{\n    address::AztecAddress, indexed_tagging_secret::IndexedTaggingSecret, traits::Packable,\n};\n\n/// Notifies the simulator that a note has been created, so that it can be returned in future read requests in the same\n/// transaction. This note should only be added to the non-volatile database if found in an actual block.\npub fn notify_created_note<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        notify_created_note_oracle_wrapper(\n            storage_slot,\n            note_type_id,\n            packed_note,\n            note_hash,\n            counter,\n        )\n    };\n}\n\n/// Notifies the simulator that a note has been nullified, so that it is no longer returned in future read requests in\n/// the same transaction. This note should only be removed to the non-volatile database if its nullifier is found in an\n/// actual block.\npub fn notify_nullified_note(nullifier: Field, note_hash: Field, counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_nullified_note_oracle_wrapper(nullifier, note_hash, counter) };\n}\n\n/// Notifies the simulator that a non-note nullifier has been created, so that it can be used for note nonces.\npub fn notify_created_nullifier(nullifier: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe to\n    // call.\n    unsafe { notify_created_nullifier_oracle_wrapper(nullifier) };\n}\n\nunconstrained fn notify_created_note_oracle_wrapper<let N: u32>(\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: [Field; N],\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_created_note_oracle(storage_slot, note_type_id, packed_note, note_hash, counter);\n}\n\n#[oracle(privateNotifyCreatedNote)]\nunconstrained fn notify_created_note_oracle<let N: u32>(\n    _storage_slot: Field,\n    _note_type_id: Field,\n    _packed_note: [Field; N],\n    _note_hash: Field,\n    _counter: u32,\n) {}\n\nunconstrained fn notify_nullified_note_oracle_wrapper(\n    nullifier: Field,\n    note_hash: Field,\n    counter: u32,\n) {\n    notify_nullified_note_oracle(nullifier, note_hash, counter);\n}\n\n#[oracle(privateNotifyNullifiedNote)]\nunconstrained fn notify_nullified_note_oracle(_nullifier: Field, _note_hash: Field, _counter: u32) {}\n\nunconstrained fn notify_created_nullifier_oracle_wrapper(nullifier: Field) {\n    notify_created_nullifier_oracle(nullifier);\n}\n\n#[oracle(privateNotifyCreatedNullifier)]\nunconstrained fn notify_created_nullifier_oracle(_nullifier: Field) {}\n\n#[oracle(utilityGetNotes)]\nunconstrained fn get_notes_oracle<Note, let M: u32, let MaxNotes: u32>(\n    _storage_slot: Field,\n    _num_selects: u8,\n    _select_by_indexes: [u8; M],\n    _select_by_offsets: [u8; M],\n    _select_by_lengths: [u8; M],\n    _select_values: [Field; M],\n    _select_comparators: [u8; M],\n    _sort_by_indexes: [u8; M],\n    _sort_by_offsets: [u8; M],\n    _sort_by_lengths: [u8; M],\n    _sort_order: [u8; M],\n    _limit: u32,\n    _offset: u32,\n    _status: u8,\n    // This is always set to MAX_NOTES. We need to pass it to TS in order to correctly construct the BoundedVec\n    _max_notes: u32,\n    // This is always set to <RetrievedNote<Note> as Packable>::N. We need to pass it to TS in order to be able to\n    // correctly construct the BoundedVec there.\n    _packed_retrieved_note_length: u32,\n) -> BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\nwhere\n    // TODO(https://github.com/noir-lang/noir/issues/9399): `Note: Packable` should work here.\n    RetrievedNote<Note>: Packable,\n{}\n\npub unconstrained fn get_notes<Note, let M: u32, let MaxNotes: u32>(\n    storage_slot: Field,\n    num_selects: u8,\n    select_by_indexes: [u8; M],\n    select_by_offsets: [u8; M],\n    select_by_lengths: [u8; M],\n    select_values: [Field; M],\n    select_comparators: [u8; M],\n    sort_by_indexes: [u8; M],\n    sort_by_offsets: [u8; M],\n    sort_by_lengths: [u8; M],\n    sort_order: [u8; M],\n    limit: u32,\n    offset: u32,\n    status: u8,\n) -> [Option<RetrievedNote<Note>>; MaxNotes]\nwhere\n    Note: NoteType + Packable,\n{\n    let packed_retrieved_notes: BoundedVec<[Field; <RetrievedNote<Note> as Packable>::N], MaxNotes>\n         = get_notes_oracle::<Note, M, MaxNotes>(\n            storage_slot,\n            num_selects,\n            select_by_indexes,\n            select_by_offsets,\n            select_by_lengths,\n            select_values,\n            select_comparators,\n            sort_by_indexes,\n            sort_by_offsets,\n            sort_by_lengths,\n            sort_order,\n            limit,\n            offset,\n            status,\n            MaxNotes,\n            <RetrievedNote<Note> as Packable>::N,\n        );\n\n    let mut notes = BoundedVec::<_, MaxNotes>::new();\n    for i in 0..packed_retrieved_notes.len() {\n        let retrieved_note = RetrievedNote::unpack(packed_retrieved_notes.get(i));\n        notes.push(retrieved_note);\n    }\n\n    // At last we convert the bounded vector to an array of options. We do this because that is what the filter\n    // function needs to have on the output and we've decided to have the same type on the input and output of\n    // the filter and preprocessor functions.\n    //\n    // We have decided to have the same type on the input and output of the filter and preprocessor functions because\n    // it allows us to chain multiple filters and preprocessors together.\n    //\n    // So why do we want the array of options on the output of the filter function?\n    //\n    // Filter returns an array of options rather than a BoundedVec for performance reasons. Using an array of options\n    // allows setting values at known indices in the output array which is much more efficient than pushing to a\n    // BoundedVec where the write position depends on previous iterations. The array can then be efficiently converted\n    // to a BoundedVec using utils/array/collapse.nr::collapse function from Aztec.nr. This avoids expensive dynamic\n    // memory access patterns that would be required when building up a BoundedVec incrementally. For preprocessor\n    // functions we could use BoundedVec return value as there the optimization does not matter since it is applied in\n    // an unconstrained context. We, however, use the same return value type to be able to use the same function as\n    // both a preprocessor and a filter.\n    let mut notes_array = [Option::none(); MaxNotes];\n    for i in 0..notes.len() {\n        if i < notes.len() {\n            notes_array[i] = Option::some(notes.get_unchecked(i));\n        }\n    }\n\n    notes_array\n}\n\n/// Returns true if the nullifier exists. Note that a `true` value can be constrained by proving existence of the\n/// nullifier, but a `false` value should not be relied upon since other transactions may emit this nullifier before the\n/// current transaction is included in a block. While this might seem of little use at first, certain design patterns\n/// benefit from this abstraction (see e.g. `PrivateMutable`).\npub unconstrained fn check_nullifier_exists(inner_nullifier: Field) -> bool {\n    check_nullifier_exists_oracle(inner_nullifier)\n}\n\n#[oracle(utilityCheckNullifierExists)]\nunconstrained fn check_nullifier_exists_oracle(_inner_nullifier: Field) -> bool {}\n\n// TODO: Oracles below are generic private log oracles and are not specific to notes. Move them somewhere else.\n\n/// Returns the derived app tagging secret ready to be included in a log for a given sender and recipient pair,\n/// siloed for the current contract address.\npub unconstrained fn get_app_tag_as_sender(sender: AztecAddress, recipient: AztecAddress) -> Field {\n    get_indexed_tagging_secret_as_sender_oracle(sender, recipient).compute_tag(recipient)\n}\n\n#[oracle(utilityGetIndexedTaggingSecretAsSender)]\nunconstrained fn get_indexed_tagging_secret_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) -> IndexedTaggingSecret {}\n\n/// Notifies the simulator that a tag has been used in a note, and to therefore increment the associated index so that\n/// future notes get a different tag and can be discovered by the recipient.\n/// This change should only be persisted in a non-volatile database if the tagged log is found in an actual block -\n/// otherwise e.g. a reverting transaction can cause the sender to accidentally skip indices and later produce notes\n/// that are not found by the recipient.\npub fn increment_app_tagging_secret_index_as_sender(sender: AztecAddress, recipient: AztecAddress) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe {\n        increment_app_tagging_secret_index_as_sender_wrapper(sender, recipient);\n    }\n}\n\nunconstrained fn increment_app_tagging_secret_index_as_sender_wrapper(\n    sender: AztecAddress,\n    recipient: AztecAddress,\n) {\n    increment_app_tagging_secret_index_as_sender_oracle(sender, recipient);\n}\n\n#[oracle(privateIncrementAppTaggingSecretIndexAsSender)]\nunconstrained fn increment_app_tagging_secret_index_as_sender_oracle(\n    _sender: AztecAddress,\n    _recipient: AztecAddress,\n) {}\n\n/// Gets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// The value persists through nested calls, meaning all calls down the stack will use the same\n/// 'senderForTags' value (unless it is replaced).\npub unconstrained fn get_sender_for_tags() -> Option<AztecAddress> {\n    get_sender_for_tags_oracle()\n}\n\n#[oracle(privateGetSenderForTags)]\nunconstrained fn get_sender_for_tags_oracle() -> Option<AztecAddress> {}\n\n/// Sets the sender for tags.\n///\n/// This unconstrained value is used as the sender when computing an unconstrained shared secret\n/// for a tag in order to emit a log. Constrained tagging should not use this as there is no\n/// guarantee that the recipient knows about the sender, and hence about the shared secret.\n///\n/// Account contracts typically set this value before calling other contracts. The value persists\n/// through nested calls, meaning all calls down the stack will use the same 'senderForTags'\n/// value (unless it is replaced by another call to this setter).\npub unconstrained fn set_sender_for_tags(sender_for_tags: AztecAddress) {\n    set_sender_for_tags_oracle(sender_for_tags);\n}\n\n#[oracle(privateSetSenderForTags)]\nunconstrained fn set_sender_for_tags_oracle(_sender_for_tags: AztecAddress) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "172": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "173": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 1;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. PXE is using version '1', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "185": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> HasStorageSlot<M + 1> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the historical block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   historical block header that is being referenced by this private function.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "203": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "206": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "207": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "209": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "210": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "212": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "214": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "219": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.historical_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "226": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "245": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "291": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "305": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "307": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "316": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        // Q: I don't understand this comment. We could still compute a siloed nullifier from a zero contract address.\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "326": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "330": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut result = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         result\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Serialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the serialized member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize(self.$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    result[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; _];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Serialize::serialize(self.$param_name)\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "331": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "332": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "342": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "357": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "359": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "360": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "377": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "380": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "415": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "50": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/claim_contract/src/main.nr",
      "source": "use dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Claim {\n    use dep::aztec::{\n        history::note_inclusion::ProveNoteInclusion,\n        macros::{functions::{initializer, private, public}, storage::storage},\n        note::{\n            note_interface::NoteHash, retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        protocol_types::address::AztecAddress,\n        state_vars::PublicImmutable,\n    };\n    use dep::uint_note::uint_note::UintNote;\n    use crowdfunding::Crowdfunding;\n    use token::Token;\n\n    // TODO: This can be optimized by storing the addresses in Config struct in 1 PublicImmutable (less merkle proofs).\n    #[storage]\n    struct Storage<Context> {\n        // Address of a contract based on whose notes we distribute the rewards\n        target_contract: PublicImmutable<AztecAddress, Context>,\n        // Token to be distributed as a reward when claiming\n        reward_token: PublicImmutable<AztecAddress, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(target_contract: AztecAddress, reward_token: AztecAddress) {\n        storage.target_contract.initialize(target_contract);\n        storage.reward_token.initialize(reward_token);\n    }\n\n    #[private]\n    fn claim(proof_retrieved_note: RetrievedNote<UintNote>, recipient: AztecAddress) {\n        // 1) Check that the note corresponds to the target contract and belongs to the sender\n        let target_address = storage.target_contract.read();\n        assert(\n            target_address == proof_retrieved_note.contract_address,\n            \"Note does not correspond to the target contract\",\n        );\n        assert_eq(\n            proof_retrieved_note.note.get_owner(),\n            context.msg_sender(),\n            \"Note does not belong to the sender\",\n        );\n\n        // 2) Prove that the note hash exists in the note hash tree\n        // Note: The note has been inserted into the donation_receipts set in the Crowdfunding contract.\n        let note_storage_slot = Crowdfunding::storage_layout().donation_receipts.slot;\n        let header = context.get_block_header();\n        header.prove_note_inclusion(proof_retrieved_note, note_storage_slot);\n\n        // 3) Compute and emit a nullifier which is unique to the note and this contract to ensure the reward can be\n        // claimed only once with the given note.\n        // Note: Only the owner of the npk_m will be able to produce the nsk_app and compute this nullifier.\n        // The nullifier is unique to the note and THIS contract because the protocol siloes all nullifiers with\n        // the address of a contract it was emitted from.\n        // TODO(#7775): manually computing the hash and passing it to compute_nullifier func is not great as note could\n        // handle it on its own or we could make prove_note_inclusion return note_hash_for_nullify.\n        let note_hash_for_nullify =\n            compute_note_hash_for_nullify(proof_retrieved_note, note_storage_slot);\n        let nullifier =\n            proof_retrieved_note.note.compute_nullifier(&mut context, note_hash_for_nullify);\n        context.push_nullifier(nullifier);\n\n        // 4) Finally we mint the reward token to the sender of the transaction\n        Token::at(storage.reward_token.read())\n            .mint_to_public(recipient, proof_retrieved_note.note.get_value())\n            .enqueue(&mut context);\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "60": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "61": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "68": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between a #[private] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[private] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[private] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[private] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[private] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp =\n            inputs.historical_header.global_variables.timestamp + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// TODO(https://github.com/AztecProtocol/aztec-packages/issues/14025) - we\n    /// are considering making msg_sender: Option<AztecAddress>, since\n    /// a returned value of `Option:none` will be clearer to developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `-1` for the first function call of the tx.\n    ///\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[private] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[private]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some historical block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[private] macro.\n    ///\n    /// # Arguments\n    /// * `returns_hasher` - A hasher containing the return values to hash\n    ///\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[private] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a heft function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "69": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between a #[public] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[public] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[public] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[public]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases, and is enforced by the protocol's kernel circuits.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the account or contract that called\n    ///   this function\n    ///\n    /// # Examples\n    /// ```rust\n    /// #[aztec(public)]\n    /// fn transfer(context: &mut PublicContext, to: AztecAddress, amount: u64) {\n    ///     let sender = context.msg_sender();\n    ///     // Only the sender can transfer their own tokens\n    ///     assert(sender == get_token_owner(), \"Unauthorized\");\n    /// }\n    /// ```\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    /// * Globally visible unlike private execution where it's contract-local\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[public] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "71": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "73": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "75": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "79": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/history/note_inclusion.nr",
      "source": "use dep::protocol_types::abis::block_header::BlockHeader;\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::{\n    note::{\n        note_interface::NoteHash, retrieved_note::RetrievedNote,\n        utils::compute_note_hash_for_nullify,\n    },\n    oracle::get_membership_witness::get_note_hash_membership_witness,\n};\n\nmod test;\n\npub trait ProveNoteInclusion {\n    fn prove_note_inclusion<Note>(\n        header: BlockHeader,\n        retrieved_note: RetrievedNote<Note>,\n        storage_slot: Field,\n    )\n    where\n        Note: NoteHash;\n}\n\nimpl ProveNoteInclusion for BlockHeader {\n    fn prove_note_inclusion<Note>(self, retrieved_note: RetrievedNote<Note>, storage_slot: Field)\n    where\n        Note: NoteHash,\n    {\n        let note_hash = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n\n        // Safety: The witness is only used as a \"magical value\" that makes the merkle proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_note_hash_membership_witness(self.global_variables.block_number, note_hash)\n        };\n\n        // Note inclusion is fairly straightforward, since all we need to prove is that a note exists in the note tree -\n        // we don't even care _where_ in the tree it is stored. This is because entries in the note hash tree are\n        // unique.\n        assert_eq(\n            self.state.partial.note_hash_tree.root,\n            root_from_sibling_path(note_hash, witness.index, witness.path),\n            \"Proving note inclusion failed\",\n        );\n    }\n}\n"
    },
    "87": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "92": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "96": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "97": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    }
  }
}
