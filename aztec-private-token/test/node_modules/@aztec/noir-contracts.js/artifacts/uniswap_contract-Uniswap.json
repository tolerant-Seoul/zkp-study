{
  "transpiled": true,
  "noir_version": "1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec",
  "name": "Uniswap",
  "functions": [
    {
      "name": "_approve_bridge_and_exit_input_asset_to_L1",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_bridge",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2550444873539515884": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "9283123155612446889": {
            "error_kind": "string",
            "string": "Function _approve_bridge_and_exit_input_asset_to_L1 can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "portal_address",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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NsWm2BSbYTNshs2wGTbDZtgMm2EzbA1bw9awNWwNW8PWsDVsDVvD5tgcm2NzbI7NsTk2x+bYyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWJLIkkSWJLElkSSJLElmSyJJEliSyJJEliSxJZEkiSxJZksiSRJYksiSRJYksSWRJIksSWZLIkkSWpJElGhg2DzSwgb5wZMnABGZQwAJWEJthM2yGrWFr2Bq2hi2ypA8SWazoN1FBAxvoC0eWWGACM9htfdjSYkW/iRUMWzRqZMmNDfSJMTltYgIzGLYWGDYPrKCCBjbQF0aW3JjADAqILWFL2BK2hC1hy9gytowtY8vYMraMLWPL2DI2wSbYBJtgE2yCTbAJNsEm2Aq2gq1gK9gKtoKtYCvYCraCrWKr2Cq2iq1iq9gqtoqtYqvYFJtiU2yKTbEpNsWm2BSbYjNshs2wGTbDZtgMm2EzbIatYWvYGraGrWFr2Bq2hq1ha9gcm2NzbI7NsTk2x+bYHJsvm1wXmMAMCljACipoYAOxkSVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClghZImSJkCVClhSypJAlhSwpZEkhS2JmXutjnxYz8yYa2EBfGFlyY7f1J0sWM/Mmdlsf67NYdnBiBRU0sIG+MLLkxgSGzQIFLGAFFTSwgd3WJytazNebmMAMCljACnZbnz5oMV9vYgPjuIV4ZMnABGZQwAJWUEEDG4itYqvYKraKrWKr2Cq2iq1iq9gUm2JTbIpNsSk2xabYFJtiM2yGzbAZNsNm2AybYTNshq1ha9gatoatYWvYGraGrWFr2BybY3Nsjs2xOTbH5tgcmy9bvS4wgRkUsIAVVNDABmJL2BK2hC1hS9gStoQtYUvY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4+mc6Tp+mm5d27RtbOPnaTWvGuXR3a+nD6/2XjXqu1eMn2wHy5LsE8l+rWHfkfL69pJArxr+HRcmdr1/YXKs8fDC5Lg3malkcuWvVnl8YXLsOI1h38sPHef0FEvW3VbZdueX0avjM6x1c1L2V+f056vxb5ho8EmRp9dH5t/Rc9rbzwaev/VWPn7r7bUhp3e0GmvRt205jvI7r6k8fDbw2WsqD6c8fMslcNNvOcRvPx04vjDzbEz+s9dlHjZr+45mPc2Ned6sp6dZ39BzRJif/sPj7F+mt53myF0Myl+aD93vdMJ+T5VnC8h8UuPRCjKf1Xhyvn5yUy5r2uDrJj99eYDg2e/wJ8NIPBffP0X8WyNRLDi6v4v7OxPLHy4F/0mRZ58KOL9qlnT1m9w+fl8tpeNDgpVH22tVj9dXqCyFUn+4DH9c4NERud4dXDwuJsC3pFL9+OruXGLdtab9Fe/fKfHwujudJvU8vO4+13h03f30u4mH0cDzt6guBpvkSyUeXrQfd0TXVmT7WomH8Xm9n52nyXzX9uUn/dJB7YMXawBiuzD9rRJ8ly+1r23FNoIh/rWtqHz2om6T6X+rhPJtouZf2xHWHpH8tR0R3iCV+rUd0XWCJ7WvbYUZizf5185OZlUlz18qYWs8yYp+pYCvm7d9XtevwXn8dM/byy6xTJDnr+3G6mFu9c12+FqB10DlOphZ9w8PPF+zKa917tK+uMGXS+iXSsha9CnJ1b5WQkkrky+VqGtd+ldafa0thC+plR++SPPFEl87qGU9pngNyaevlSCtiuoXS7AjP6z++hsl1h3v63fwawe1OO/+X1/airKeTZT2pZbgvPrhw7Q/FUjp9PpUyvwC5f1u+fFCXnUV+OGn+Dd2Yy1gqOVLDVnXeyx1v3D/jQIsWu3ytQLXf/P84EsFfnit93caca1P9bWg07RuicXf3IKvHsYnE12OBZ68YH28D30yT+Z6d3jjuMrtawR0/6hi/fi199e1+GmFvrLWwvR6ffxluFeV42OTN5dNfB1/4878w4+Bvx7Onr5k+OR74p+1Kj/CV5OP52Kdy7x+cbj/KfbVMheLPbxGdlL5ahlVTpX9G9q/Wcb4Au+1v2f9u2WcO9R2ta+euLYGQNy2X6T/5sR9XMW/XMW5GPf6xSp9FijH6Wof1/nsHN6GAJrkrzawV+adtvTVptluM7ydDtPxWdnjpjnXeThcf67xbLj+kxofDtf/z9f/+ed/+cvf/+mv//ov//zvf/nXv/3b6+/9Vy/197/88//665/v//t//uNv/7L913////+/+V/+19//8te//uX//tP/+/u//suf//d//P3PvVL/b3+67v/5H62/lOavNv2f//Cn9Pr/rq9LI1fr/19e//91i11z/2/9D79StfzD63+8/4v409fr3vX1P/4//6tv7v8H"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2550444873539515884": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7952883935970497419": {
            "error_kind": "string",
            "string": "L1 portal address of output_asset's bridge is 0"
          },
          "9283123155612446889": {
            "error_kind": "string",
            "string": "Function _approve_bridge_and_exit_input_asset_to_L1 can only be called internally"
          },
          "10492081608786484886": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17695220409134080280": {
            "error_kind": "string",
            "string": "L1 portal address of input_asset's bridge is 0"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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gFYAFQAQABEnAhABAC0IAQ0nAhEEIQAIAREBJwMNBAEAIg0CEScCFQQgQwOiABKAVgAVABAAEScCEQEALQgBECcCEgQhAAgBEgEnAxAEAQAiEAISJwIVBCBDA6IAE4BWABUAEQASJwISAQAtCAERJwITBCEACAETAScDEQQBACIRAhMnAhUEIEMDogAUgFYAFQASABMnAhIC8ScCEwKBJwIUAoYnAhUC2C0IARYoAgAXBAEFAAgBFwEnAxYEAQAiFgIXLQoXGC0OEhgAIhgCGC0OExgAIhgCGC0OFBgAIhgCGC0OFRgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhguDIBYABgAIhgCGC4MgFgAGAAiGAIYLgyAWAAYACIYAhgu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",
      "debug_symbols": "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"
    },
    {
      "name": "swap_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "input_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "input_asset_bridge",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "input_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "output_asset_bridge",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "nonce_for_transfer_to_public_approval",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "uniswap_fee_tier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "minimum_output_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "secret_hash_for_L1_to_l2_message",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_L1",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "285656119219400463": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 32 limbs"
          },
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4456244908619624852": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "6668324276689745315": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 4 limbs"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "7952883935970497419": {
            "error_kind": "string",
            "string": "L1 portal address of output_asset's bridge is 0"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16275222249430394394": {
            "error_kind": "string",
            "string": "input_asset address is not the same as seen in the bridge contract"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17695220409134080280": {
            "error_kind": "string",
            "string": "L1 portal address of input_asset's bridge is 0"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "verification_key": "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"
    },
    {
      "name": "swap_public",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "sender",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "input_asset_bridge",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "input_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "output_asset_bridge",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "nonce_for_transfer_approval",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "uniswap_fee_tier",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "minimum_output_amount",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "secret_hash_for_L1_to_l2_message",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          },
          {
            "name": "caller_on_L1",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::eth_address::EthAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "_nonce_for_swap_approval",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "939615093317106671": {
            "error_kind": "string",
            "string": "Invalid response from registry"
          },
          "2550444873539515884": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "4939791462094160055": {
            "error_kind": "string",
            "string": "Message not authorized by account"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7952883935970497419": {
            "error_kind": "string",
            "string": "L1 portal address of output_asset's bridge is 0"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17695220409134080280": {
            "error_kind": "string",
            "string": "L1 portal address of input_asset's bridge is 0"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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CwIOJwIPBCBDA6IABoBVAA8ADQAOJwINAQAtCAEGJwIOBCEACAEOAScDBgQBACIGAg4nAg8EIEMDogADgFUADwANAA4cCgcDACcCDQEALQgBBycCDgQhAAgBDgEnAwcEAQAiBwIOJwIPBCBDA6IAA4BVAA8ADQAOJwINAQAtCAEDJwIOBCEACAEOAScDAwQBACIDAg4nAg8EIEMDogAIgFUADwANAA4nAg0BAC0IAQgnAg4EIQAIAQ4BJwMIBAEAIggCDicCDwQgQwOiAAmAVQAPAA0ADicCDQEALQgBCScCDgQhAAgBDgEnAwkEAQAiCQIOJwIPBCBDA6IACoBVAA8ADQAOJwIKAvEnAg0CgScCDgKGJwIPAtgtCAEQKAIAEQQBBQAIAREBJwMQBAEAIhACES0KERItDgoSACISAhItDg0SACISAhItDg4SACISAhItDg8SACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABIAIhICEi4MgFcAEgAiEgISLgyAVwASACISAhIuDIBXABItDhACJwIKBCAnAg0EJCcCDgREJwIPBGQnAhAEhCcCEQSkJwISBMQnAhME5C4IgFgAASMAABqdDCoBChQkAgAUAAAkpCMAABqvLQsCAy4JgE4AAgAiAgICLgYAAoBOLQgBAgAAAQIBLgyATgACLgiAWAABIwAAGt4NIgABgFAABCQCAAQAACQFIwAAGvMtCwIEJwIGBA0tCAANLQoDDi4IgF0ADy4IgFUAEAAIAAYAJQAAKkktAgAALQoOAi0KDwUtCwIDACIDAgMtDgMCByIABYBQAAMNIgADgFMABiQCAAYAABtQJQAAKSEAIgICBwAqBwMILQsIBicCCAQEBioFCAkEKgkICwIqBQsHAyiAUAAHAAgPIgAHgFAACSQCAAkAABuPJQAALOEFKIBcAAgACScCDQQACioNCAskAgALAAAbwwYqCQgPCyIAD4BcAA4kAgAOAAAbwyUAACzzDCoJCgskAgALAAAb4CMAABvVLgiAWAABIwAAG+4aKgYJCy0KCwEjAAAb7g0iAAiAUAALJAIACwAAHA4jAAAcAy4IgFgABiMAABwcGCoBCQgtCggGIwAAHBwDKIBS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",
      "debug_symbols": "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"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    }
  ],
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "TokenBridge"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Uniswap"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "portal_address",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_bridge",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "Uniswap::_approve_bridge_and_exit_input_asset_to_L1_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Uniswap::_approve_bridge_and_exit_input_asset_to_L1_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "portal_address",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Uniswap::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Uniswap::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Uniswap::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Uniswap::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "input_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "input_asset_bridge",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "input_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "output_asset_bridge",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "nonce_for_transfer_to_public_approval",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "uniswap_fee_tier",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "minimum_output_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "secret_hash_for_L1_to_l2_message",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "caller_on_L1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Uniswap::swap_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Uniswap::swap_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "sender",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "input_asset_bridge",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "input_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "output_asset_bridge",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "nonce_for_transfer_approval",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "uniswap_fee_tier",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "minimum_output_amount",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "secret_hash_for_L1_to_l2_message",
                    "type": {
                      "kind": "field"
                    }
                  },
                  {
                    "name": "caller_on_L1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::eth_address::EthAddress"
                    }
                  },
                  {
                    "name": "_nonce_for_swap_approval",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "Uniswap::swap_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Uniswap::swap_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "Uniswap::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "Uniswap::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "102": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n\n    if is_fn_private(f) {\n        if is_static_call {\n            create_private_static_stub(f)\n        } else {\n            create_private_stub(f)\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            create_public_static_stub(f)\n        } else {\n            create_public_stub(f)\n        }\n    } else {\n        create_utility_stub(f)\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "103": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY, call_interface_stubs::stub_fn, stub_registry,\n    },\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_authorize_once, fn_has_noinitcheck, get_fn_visibility,\n        is_fn_contract_library_method, is_fn_initializer, is_fn_internal, is_fn_private,\n        is_fn_public, is_fn_test, is_fn_utility, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\npub(crate) comptime fn create_authorize_once_check(f: FunctionDefinition) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[private] or #[public] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_fn_private(f) {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "108": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "111": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "112": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "113": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "114": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "115": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "116": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "117": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "118": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PlaintextLen * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let env = TestEnvironment::new();\n\n        // Log decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"utilityGetIndexedTaggingSecretAsSender\").returns(\n                IndexedTaggingSecret::deserialize([69420, 1337]),\n            );\n            let _ = OracleMock::mock(\"privateIncrementAppTaggingSecretIndexAsSender\").returns(());\n\n            // Encrypt the log\n            let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the log\n            let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec =\n                BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "134": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "146": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "149": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "153": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "154": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "155": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "156": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(utilityGetContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(utilityGetBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(utilityGetTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(utilityGetChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(utilityGetVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "157": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "158": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "162": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "163": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "164": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "166": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "171": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "173": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "174": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 1;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. PXE is using version '1', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "186": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> HasStorageSlot<M + 1> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the historical block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   historical block header that is being referenced by this private function.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "204": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "207": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "208": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "210": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "211": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "213": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "215": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "220": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.historical_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "227": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "246": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "292": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n"
    },
    "293": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/eth_address.nr",
      "source": "use crate::traits::{Deserialize, Empty, Packable, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct EthAddress {\n    inner: Field,\n}\n\nimpl Empty for EthAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for EthAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl EthAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn from_field(field: Field) -> Self {\n        field.assert_max_bit_size::<160>();\n        Self { inner: field }\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n\n    pub fn to_be_bytes(self) -> [u8; 20] {\n        let field_bytes: [u8; 32] = self.inner.to_be_bytes();\n        let mut bytes = [0; 20];\n        for i in 0..20 {\n            bytes[i] = field_bytes[i + 12];\n        }\n        bytes\n    }\n}\n\nmod test {\n    use crate::{\n        address::eth_address::EthAddress,\n        constants::ETH_ADDRESS_LENGTH,\n        traits::{Deserialize, Serialize},\n    };\n\n    #[test]\n    fn serialization_of_eth_address() {\n        let item = EthAddress::from_field(1);\n        // We use the ETH_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n        // implementation and the constant.\n        let serialized: [Field; ETH_ADDRESS_LENGTH] = item.serialize();\n        let deserialized = EthAddress::deserialize(serialized);\n        assert_eq(item, deserialized);\n    }\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "306": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "308": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "317": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        // Q: I don't understand this comment. We could still compute a siloed nullifier from a zero contract address.\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "327": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "331": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut result = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         result\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Serialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the serialized member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize(self.$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    result[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; _];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Serialize::serialize(self.$param_name)\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "332": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "333": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "343": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "358": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "360": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "361": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "378": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "381": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "390": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/sha256/v0.2.0/src/sha256.nr",
      "source": "use std::hash::sha256_compression;\nuse std::runtime::is_unconstrained;\n\nuse constants::{\n    BLOCK_BYTE_PTR, BLOCK_SIZE, HASH, INITIAL_STATE, INT_BLOCK, INT_BLOCK_SIZE, INT_SIZE,\n    INT_SIZE_PTR, MSG_BLOCK, MSG_SIZE_PTR, STATE, TWO_POW_16, TWO_POW_24, TWO_POW_32, TWO_POW_8,\n};\n\npub(crate) mod constants;\nmod tests;\n\n// Implementation of SHA-256 mapping a byte array of variable length to\n// 32 bytes.\n\n// Deprecated in favour of `sha256_var`\n// docs:start:sha256\npub fn sha256<let N: u32>(input: [u8; N]) -> HASH\n// docs:end:sha256\n{\n    digest(input)\n}\n\n// SHA-256 hash function\n#[no_predicates]\npub fn digest<let N: u32>(msg: [u8; N]) -> HASH {\n    sha256_var(msg, N as u64)\n}\n\n// Variable size SHA-256 hash\npub fn sha256_var<let N: u32>(msg: [u8; N], message_size: u64) -> HASH {\n    let message_size = message_size as u32;\n    assert(message_size <= N);\n\n    if std::runtime::is_unconstrained() {\n        // Safety: SHA256 is running as an unconstrained function.\n        unsafe {\n            __sha256_var(msg, message_size)\n        }\n    } else {\n        let (mut h, mut msg_block, mut msg_byte_ptr) =\n            process_full_blocks(msg, message_size, INITIAL_STATE);\n\n        finalize_sha256_blocks(msg, message_size, N, h, msg_block, msg_byte_ptr)\n    }\n}\n\npub(crate) unconstrained fn __sha_var<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    initial_state: STATE,\n) -> HASH {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    let mut h: STATE = initial_state;\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n\n    finalize_last_sha256_block(h, message_size, msg)\n}\n\n// Helper function to finalize the message block with padding and length\npub(crate) unconstrained fn finalize_last_sha256_block<let N: u32>(\n    mut h: STATE,\n    message_size: u32,\n    msg: [u8; N],\n) -> HASH {\n    let modulo = message_size % BLOCK_SIZE;\n    let (mut msg_block, mut msg_byte_ptr): (INT_BLOCK, u32) = if modulo != 0 {\n        let num_full_blocks = message_size / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_full_blocks;\n        let (new_msg_block, new_msg_byte_ptr) = build_msg_block(msg, message_size, msg_start);\n        (new_msg_block, new_msg_byte_ptr)\n    } else {\n        // If we had modulo == 0 then it means the last block was full,\n        // and we can reset the pointer to zero to overwrite it.\n        ([0; INT_BLOCK_SIZE], 0)\n    };\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    // If we don't have room to write the size, compress the block and reset it.\n    let (h, mut msg_byte_ptr): (STATE, u32) = if msg_byte_ptr >= MSG_SIZE_PTR {\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        (sha256_compression(msg_block, h), 0)\n    } else {\n        (h, msg_byte_ptr + 1)\n    };\n    msg_block = attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n// Variable size SHA-256 hash\nunconstrained fn __sha256_var<let N: u32>(msg: [u8; N], message_size: u32) -> HASH {\n    __sha_var(msg, message_size, INITIAL_STATE)\n}\n\npub(crate) fn process_full_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    mut h: STATE,\n) -> (STATE, MSG_BLOCK, u32) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n    let mut msg_byte_ptr = 0;\n    let num_blocks = N / BLOCK_SIZE;\n    for i in 0..num_blocks {\n        let msg_start = BLOCK_SIZE * i;\n        let (new_msg_block, new_msg_byte_ptr) =\n        // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        // Verify the block we are compressing was appropriately constructed\n        let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n        if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n        }\n\n        // If the block is filled, compress it.\n        // An un-filled block is handled after this loop.\n        if (msg_start < message_size) & (msg_byte_ptr == BLOCK_SIZE) {\n            h = sha256_compression(msg_block, h);\n        }\n    }\n    (h, msg_block, msg_byte_ptr)\n}\n\n// Take `BLOCK_SIZE` number of bytes from `msg` starting at `msg_start`.\n// Returns the block and the length that has been copied rather than padded with zeros.\npub(crate) unconstrained fn build_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_start: u32,\n) -> (MSG_BLOCK, BLOCK_BYTE_PTR) {\n    let mut msg_block: MSG_BLOCK = [0; INT_BLOCK_SIZE];\n\n    // We insert `BLOCK_SIZE` bytes (or up to the end of the message)\n    let block_input = if message_size < msg_start {\n        // This function is sometimes called with `msg_start` past the end of the message.\n        // In this case we return an empty block and zero pointer to signal that the result should be ignored.\n        0\n    } else if message_size < msg_start + BLOCK_SIZE {\n        message_size - msg_start\n    } else {\n        BLOCK_SIZE\n    };\n\n    // Figure out the number of items in the int array that we have to pack.\n    // e.g. if the input is [0,1,2,3,4,5] then we need to pack it as 2 items: [0123, 4500]\n    let int_input = (block_input + INT_SIZE - 1) / INT_SIZE;\n\n    for i in 0..int_input {\n        let mut msg_item: u32 = 0;\n        // Always construct the integer as 4 bytes, even if it means going beyond the input.\n        for j in 0..INT_SIZE {\n            let k = i * INT_SIZE + j;\n            let msg_byte = if k < block_input {\n                msg[msg_start + k]\n            } else {\n                0\n            };\n            msg_item = lshift8(msg_item, 1) + msg_byte as u32;\n        }\n        msg_block[i] = msg_item;\n    }\n\n    // Returning the index as if it was a 64 byte array.\n    // We have to project it down to 16 items and bit shifting to get a byte back if we need it.\n    (msg_block, block_input)\n}\n\n// Verify the block we are compressing was appropriately constructed by `build_msg_block`\n// and matches the input data. Returns the index of the first unset item.\n// If `message_size` is less than `msg_start` then this is called with the old non-empty block;\n// in that case we can skip verification, ie. no need to check that everything is zero.\nfn verify_msg_block<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    msg_block: MSG_BLOCK,\n    msg_start: u32,\n) -> BLOCK_BYTE_PTR {\n    let mut msg_byte_ptr = 0;\n    let mut msg_end = msg_start + BLOCK_SIZE;\n    if msg_end > N {\n        msg_end = N;\n    }\n    // We might have to go beyond the input to pad the fields.\n    if msg_end % INT_SIZE != 0 {\n        msg_end = msg_end + INT_SIZE - msg_end % INT_SIZE;\n    }\n\n    // Reconstructed packed item.\n    let mut msg_item: u32 = 0;\n\n    // Inclusive at the end so that we can compare the last item.\n    let mut i: u32 = 0;\n    for k in msg_start..=msg_end {\n        if k % INT_SIZE == 0 {\n            // If we consumed some input we can compare against the block.\n            if (msg_start < message_size) & (k > msg_start) {\n                assert_eq(msg_block[i], msg_item as u32);\n                i = i + 1;\n                msg_item = 0;\n            }\n        }\n        // Shift the accumulator\n        msg_item = lshift8(msg_item, 1);\n        // If we have input to consume, add it at the rightmost position.\n        if k < message_size & k < msg_end {\n            msg_item = msg_item + msg[k] as u32;\n            msg_byte_ptr = msg_byte_ptr + 1;\n        }\n    }\n\n    msg_byte_ptr\n}\n\n// Verify the block we are compressing was appropriately padded with zeros by `build_msg_block`.\n// This is only relevant for the last, potentially partially filled block.\nfn verify_msg_block_padding(msg_block: MSG_BLOCK, msg_byte_ptr: BLOCK_BYTE_PTR) {\n    // Check all the way to the end of the block.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_BLOCK_SIZE);\n}\n\n// Verify that a region of ints in the message block are (partially) zeroed,\n// up to an (exclusive) maximum which can either be the end of the block\n// or just where the size is to be written.\nfn verify_msg_block_zeros(\n    msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    max_int_byte_ptr: u32,\n) {\n    // This variable is used to get around the compiler under-constrained check giving a warning.\n    // We want to check against a constant zero, but if it does not come from the circuit inputs\n    // or return values the compiler check will issue a warning.\n    let zero = msg_block[0] - msg_block[0];\n\n    // First integer which is supposed to be (partially) zero.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        let zeros = INT_SIZE - modulo;\n        let mask = if zeros == 3 {\n            TWO_POW_24\n        } else if zeros == 2 {\n            TWO_POW_16\n        } else {\n            TWO_POW_8\n        };\n        assert_eq(msg_block[int_byte_ptr] % mask, zero);\n        int_byte_ptr = int_byte_ptr + 1;\n    }\n\n    // Check the rest of the items.\n    for i in 0..max_int_byte_ptr {\n        if i >= int_byte_ptr {\n            assert_eq(msg_block[i], zero);\n        }\n    }\n}\n\n// Verify that up to the byte pointer the two blocks are equal.\n// At the byte pointer the new block can be partially zeroed.\nfn verify_msg_block_equals_last(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n) {\n    // msg_byte_ptr is the position at which they are no longer have to be the same.\n    // First integer which is supposed to be (partially) zero contains that pointer.\n    let mut int_byte_ptr = msg_byte_ptr / INT_SIZE;\n\n    // Check partial zeros.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Reconstruct the partially zero item from the last block.\n        let last_field = last_block[int_byte_ptr];\n        let mut msg_item: u32 = 0;\n        // Reset to where they are still equal.\n        msg_byte_ptr = msg_byte_ptr - modulo;\n        for i in 0..INT_SIZE {\n            msg_item = lshift8(msg_item, 1);\n            if i < modulo {\n                msg_item = msg_item + get_item_byte(last_field, msg_byte_ptr) as u32;\n                msg_byte_ptr = msg_byte_ptr + 1;\n            }\n        }\n        assert_eq(msg_block[int_byte_ptr], msg_item);\n    }\n\n    for i in 0..INT_SIZE_PTR {\n        if i < int_byte_ptr {\n            assert_eq(msg_block[i], last_block[i]);\n        }\n    }\n}\n\n// Set the rightmost `zeros` number of bytes to 0.\n#[inline_always]\nfn set_item_zeros(item: u32, zeros: u32) -> u32 {\n    lshift8(rshift8(item, zeros), zeros)\n}\n\n// Replace one byte in the item with a value, and set everything after it to zero.\nfn set_item_byte_then_zeros(msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR, msg_byte: u8) -> u32 {\n    let zeros = INT_SIZE - msg_byte_ptr % INT_SIZE;\n    let zeroed_item = set_item_zeros(msg_item, zeros);\n    let new_item = byte_into_item(msg_byte, msg_byte_ptr);\n    zeroed_item + new_item\n}\n\n// Get a byte of a message item according to its overall position in the `BLOCK_SIZE` space.\nfn get_item_byte(mut msg_item: u32, msg_byte_ptr: BLOCK_BYTE_PTR) -> u8 {\n    // How many times do we have to shift to the right to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    msg_item = rshift8(msg_item, shifts);\n    // At this point the byte we want is in the rightmost position.\n    msg_item as u8\n}\n\n// Project a byte into a position in a field based on the overall block pointer.\n// For example putting 1 into pointer 5 would be 100, because overall we would\n// have [____, 0100] with indexes [0123,4567].\n#[inline_always]\nfn byte_into_item(msg_byte: u8, msg_byte_ptr: BLOCK_BYTE_PTR) -> u32 {\n    let mut msg_item = msg_byte as u32;\n    // How many times do we have to shift to the left to get to the position we want?\n    let max_shifts = INT_SIZE - 1;\n    let shifts = max_shifts - msg_byte_ptr % INT_SIZE;\n    lshift8(msg_item, shifts)\n}\n\n// Construct a field out of 4 bytes.\n#[inline_always]\nfn make_item(b0: u8, b1: u8, b2: u8, b3: u8) -> u32 {\n    let mut item = b0 as u32;\n    item = lshift8(item, 1) + b1 as u32;\n    item = lshift8(item, 1) + b2 as u32;\n    item = lshift8(item, 1) + b3 as u32;\n    item\n}\n\n// Shift by 8 bits to the left between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise multiplies by 256.\n#[inline_always]\nfn lshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        // Brillig wouldn't shift 0<<4 without overflow.\n        if shifts >= 4 {\n            0\n        } else {\n            item << (8 * shifts)\n        }\n    } else {\n        // We can do a for loop up to INT_SIZE or an if-else.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item * TWO_POW_8\n        } else if shifts == 2 {\n            item * TWO_POW_16\n        } else if shifts == 3 {\n            item * TWO_POW_24\n        } else {\n            // Doesn't make sense, but it's most likely called on 0 anyway.\n            0\n        }\n    }\n}\n\n// Shift by 8 bits to the right between 0 and 4 times.\n// Checks `is_unconstrained()` to just use a bitshift if we're running in an unconstrained context,\n// otherwise divides by 256.\n#[inline_always]\nfn rshift8(item: u32, shifts: u32) -> u32 {\n    if is_unconstrained() {\n        if 8 * shifts >= 32 {\n            0\n        } else {\n            item >> (8 * shifts)\n        }\n    } else {\n        // Division wouldn't work on `Field`.\n        if shifts == 0 {\n            item\n        } else if shifts == 1 {\n            item / TWO_POW_8\n        } else if shifts == 2 {\n            item / TWO_POW_16\n        } else if shifts == 3 {\n            item / TWO_POW_24\n        } else {\n            0\n        }\n    }\n}\n\n// Zero out all bytes between the end of the message and where the length is appended,\n// then write the length into the last 8 bytes of the block.\nunconstrained fn attach_len_to_msg_block(\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) -> MSG_BLOCK {\n    // We assume that `msg_byte_ptr` is less than 57 because if not then it is reset to zero before calling this function.\n    // In any case, fill blocks up with zeros until the last 64 bits (i.e. until msg_byte_ptr = 56).\n    // There can be one item which has to be partially zeroed.\n    let modulo = msg_byte_ptr % INT_SIZE;\n    if modulo != 0 {\n        // Index of the block in which we find the item we need to partially zero.\n        let i = msg_byte_ptr / INT_SIZE;\n        let zeros = INT_SIZE - modulo;\n        msg_block[i] = set_item_zeros(msg_block[i], zeros);\n        msg_byte_ptr = msg_byte_ptr + zeros;\n    }\n\n    // The rest can be zeroed without bit shifting anything.\n    for i in (msg_byte_ptr / INT_SIZE)..INT_SIZE_PTR {\n        msg_block[i] = 0;\n    }\n\n    // Set the last two 4 byte ints as the first/second half of the 8 bytes of the length.\n    let len = 8 * message_size;\n    let len_bytes: [u8; 8] = (len as Field).to_be_bytes();\n    msg_block[INT_SIZE_PTR] = (len_bytes[0] as u32) << 24\n        | (len_bytes[1] as u32) << 16\n        | (len_bytes[2] as u32) << 8\n        | (len_bytes[3] as u32);\n\n    msg_block[INT_SIZE_PTR + 1] = (len_bytes[4] as u32) << 24\n        | (len_bytes[5] as u32) << 16\n        | (len_bytes[6] as u32) << 8\n        | (len_bytes[7] as u32);\n\n    msg_block\n}\n\n// Verify that the message length was correctly written by `attach_len_to_msg_block`,\n// and that everything between the byte pointer and the size pointer was zeroed,\n// and that everything before the byte pointer was untouched.\nfn verify_msg_len(\n    msg_block: MSG_BLOCK,\n    last_block: MSG_BLOCK,\n    msg_byte_ptr: BLOCK_BYTE_PTR,\n    message_size: u32,\n) {\n    // Check zeros up to the size pointer.\n    verify_msg_block_zeros(msg_block, msg_byte_ptr, INT_SIZE_PTR);\n\n    // Check that up to the pointer we match the last block.\n    verify_msg_block_equals_last(msg_block, last_block, msg_byte_ptr);\n\n    // We verify the message length was inserted correctly by reversing the byte decomposition.\n    std::static_assert(\n        INT_SIZE_PTR + 2 == INT_BLOCK_SIZE,\n        \"INT_SIZE_PTR + 2 must equal INT_BLOCK_SIZE\",\n    );\n    let reconstructed_len_hi = msg_block[INT_SIZE_PTR] as Field;\n    let reconstructed_len_lo = msg_block[INT_SIZE_PTR + 1] as Field;\n\n    let reconstructed_len: Field =\n        reconstructed_len_hi * TWO_POW_32 as Field + reconstructed_len_lo;\n    let len = 8 * (message_size as Field);\n    assert_eq(reconstructed_len, len);\n}\n\n// Perform the final compression, then transform the `STATE` into `HASH`.\nfn hash_final_block(msg_block: MSG_BLOCK, mut state: STATE) -> HASH {\n    let mut out_h: HASH = [0; 32]; // Digest as sequence of bytes\n    // Hash final padded block\n    state = sha256_compression(msg_block, state);\n\n    // Return final hash as byte array\n    for j in 0..8 {\n        let h_bytes: [u8; 4] = (state[j] as Field).to_be_bytes();\n        for k in 0..4 {\n            out_h[4 * j + k] = h_bytes[k];\n        }\n    }\n\n    out_h\n}\n\npub(crate) fn finalize_sha256_blocks<let N: u32>(\n    msg: [u8; N],\n    message_size: u32,\n    total_len: u32,\n    mut h: STATE,\n    mut msg_block: MSG_BLOCK,\n    mut msg_byte_ptr: u32,\n) -> HASH {\n    let modulo = total_len % BLOCK_SIZE;\n    // Handle setup of the final msg block.\n    // This case is only hit if the msg is less than the block size,\n    // or our message cannot be evenly split into blocks.\n    if modulo != 0 {\n        let num_blocks = total_len / BLOCK_SIZE;\n        let msg_start = BLOCK_SIZE * num_blocks;\n        let (new_msg_block, new_msg_byte_ptr) =\n        // Safety: separate verification function\n            unsafe { build_msg_block(msg, message_size, msg_start) };\n\n        if msg_start < message_size {\n            msg_block = new_msg_block;\n        }\n\n        let new_msg_byte_ptr = verify_msg_block(msg, message_size, msg_block, msg_start);\n        if msg_start < message_size {\n            msg_byte_ptr = new_msg_byte_ptr;\n            verify_msg_block_padding(msg_block, msg_byte_ptr);\n        }\n    }\n\n    // If we had modulo == 0 then it means the last block was full,\n    // and we can reset the pointer to zero to overwrite it.\n    if msg_byte_ptr == BLOCK_SIZE {\n        msg_byte_ptr = 0;\n    }\n\n    // Pad the rest such that we have a [u32; 2] block at the end representing the length\n    // of the message, and a block of 1 0 ... 0 following the message (i.e. [1 << 7, 0, ..., 0]).\n    // Here we rely on the fact that everything beyond the available input is set to 0.\n    let index = msg_byte_ptr / INT_SIZE;\n    msg_block[index] = set_item_byte_then_zeros(msg_block[index], msg_byte_ptr, 1 << 7);\n\n    msg_byte_ptr = msg_byte_ptr + 1;\n    let last_block = msg_block;\n\n    // If we don't have room to write the size, compress the block and reset it.\n    if msg_byte_ptr > MSG_SIZE_PTR {\n        h = sha256_compression(msg_block, h);\n\n        // `attach_len_to_msg_block` will zero out everything after the `msg_byte_ptr`.\n        msg_byte_ptr = 0;\n    }\n\n    // Safety: separate verification function\n    msg_block = unsafe { attach_len_to_msg_block(msg_block, msg_byte_ptr, message_size) };\n\n    verify_msg_len(msg_block, last_block, msg_byte_ptr, message_size);\n\n    hash_final_block(msg_block, h)\n}\n\n/**\n * Given some state of a partially computed sha256 hash and part of the preimage, continue hashing\n * @notice used for complex/ recursive offloading of post-partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the preimage to hash\n * @param message_size - the actual length of the preimage to hash\n * @return the intermediate hash state after compressing in msg to h\n */\npub fn partial_sha256_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            __sha_partial_var_interstitial(h, msg, message_size)\n        }\n    } else {\n        let (mut h, _, _) = process_full_blocks(msg, message_size, h);\n\n        h\n    }\n}\n\n/**\n * Given some state of a partially computed sha256 hash and remaining preimage, complete the hash\n * @notice used for traditional partial hashing\n *\n * @param N - the maximum length of the message to hash\n * @param h - the intermediate hash state\n * @param msg - the remaining preimage to hash\n * @param message_size - the size of the current chunk\n * @param real_message_size - the total size of the original preimage\n * @return finalized sha256 hash\n */\npub fn partial_sha256_var_end<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n    real_message_size: u32,\n) -> [u8; 32] {\n    assert(message_size % BLOCK_SIZE == 0, \"Message size must be a multiple of the block size\");\n    if std::runtime::is_unconstrained() {\n        // Safety: running as an unconstrained function\n        unsafe {\n            h = __sha_partial_var_interstitial(h, msg, message_size);\n\n            // Handle setup of the final msg block.\n            // This case is only hit if the msg is less than the block size,\n            // or our message cannot be evenly split into blocks.\n\n            finalize_last_sha256_block(h, real_message_size, msg)\n        }\n    } else {\n        let (mut h, mut msg_block, mut msg_byte_ptr) = process_full_blocks(msg, message_size, h);\n        finalize_sha256_blocks(msg, real_message_size, N, h, msg_block, msg_byte_ptr)\n    }\n}\n\nunconstrained fn __sha_partial_var_interstitial<let N: u32>(\n    mut h: [u32; 8],\n    msg: [u8; N],\n    message_size: u32,\n) -> [u32; 8] {\n    let num_full_blocks = message_size / BLOCK_SIZE;\n    // Intermediate hash, starting with the canonical initial value\n    // Pointer into msg_block on a 64 byte scale\n    for i in 0..num_full_blocks {\n        let (msg_block, _) = build_msg_block(msg, message_size, BLOCK_SIZE * i);\n        h = sha256_compression(msg_block, h);\n    }\n    h\n}\n\nmod equivalence_test {\n\n    #[test]\n    fn test_implementations_agree(msg: [u8; 100], message_size: u64) {\n        let message_size = message_size % 100;\n        // Safety: test function\n        let unconstrained_sha = unsafe { super::__sha256_var(msg, message_size as u32) };\n        let sha = super::sha256_var(msg, message_size);\n        assert_eq(sha, unconstrained_sha);\n    }\n}\n"
    },
    "414": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "50": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/uniswap_contract/src/main.nr",
      "source": "// docs:start:uniswap_setup\nmod util;\n\n// Demonstrates how to use portal contracts to swap on L1 Uniswap with funds on L2\n// Has two separate flows for private and public respectively\n// Uses the token bridge contract, which tells which input token we need to talk to and handles the exit funds to L1\nuse dep::aztec::macros::aztec;\n\n#[aztec]\npub contract Uniswap {\n    use dep::aztec::{\n        authwit::auth::{\n            assert_current_call_valid_authwit_public, compute_authwit_message_hash_from_call,\n            set_authorized,\n        },\n        macros::{functions::{initializer, internal, private, public}, storage::storage},\n        protocol_types::{\n            abis::function_selector::FunctionSelector,\n            address::{AztecAddress, EthAddress},\n            traits::ToField,\n        },\n        state_vars::PublicImmutable,\n    };\n\n    use crate::util::{compute_swap_private_content_hash, compute_swap_public_content_hash};\n    use dep::token::Token;\n    use dep::token_bridge::TokenBridge;\n\n    #[storage]\n    struct Storage<Context> {\n        portal_address: PublicImmutable<EthAddress, Context>,\n    }\n\n    #[public]\n    #[initializer]\n    fn constructor(portal_address: EthAddress) {\n        storage.portal_address.initialize(portal_address);\n    }\n    // docs:end:uniswap_setup\n\n    // docs:start:swap_public\n    #[public]\n    fn swap_public(\n        sender: AztecAddress,\n        input_asset_bridge: AztecAddress,\n        input_amount: u128,\n        output_asset_bridge: AztecAddress,\n        // params for using the transfer approval\n        nonce_for_transfer_approval: Field,\n        // params for the swap\n        uniswap_fee_tier: Field,\n        minimum_output_amount: u128,\n        // params for the depositing output_asset back to Aztec\n        recipient: AztecAddress,\n        secret_hash_for_L1_to_l2_message: Field,\n        caller_on_L1: EthAddress,\n        // nonce for someone to call swap on sender's behalf\n        _nonce_for_swap_approval: Field,\n    ) {\n        if (!sender.eq(context.msg_sender())) {\n            assert_current_call_valid_authwit_public(&mut context, sender);\n        }\n\n        let input_asset_bridge_config =\n            TokenBridge::at(input_asset_bridge).get_config_public().view(&mut context);\n\n        let input_asset = input_asset_bridge_config.token;\n        let input_asset_bridge_portal_address = input_asset_bridge_config.portal;\n\n        // Transfer funds to this contract\n        Token::at(input_asset)\n            .transfer_in_public(\n                sender,\n                context.this_address(),\n                input_amount,\n                nonce_for_transfer_approval,\n            )\n            .call(&mut context);\n\n        // Approve bridge to burn this contract's funds and exit to L1 Uniswap Portal\n        Uniswap::at(context.this_address())\n            ._approve_bridge_and_exit_input_asset_to_L1(\n                input_asset,\n                input_asset_bridge,\n                input_amount,\n            )\n            .call(&mut context);\n        // Create swap message and send to Outbox for Uniswap Portal\n        // this ensures the integrity of what the user originally intends to do on L1.\n        let output_asset_bridge_portal_address =\n            TokenBridge::at(output_asset_bridge).get_config_public().view(&mut context).portal;\n        // ensure portal exists - else funds might be lost\n        assert(\n            !input_asset_bridge_portal_address.is_zero(),\n            \"L1 portal address of input_asset's bridge is 0\",\n        );\n        assert(\n            !output_asset_bridge_portal_address.is_zero(),\n            \"L1 portal address of output_asset's bridge is 0\",\n        );\n\n        let content_hash = compute_swap_public_content_hash(\n            input_asset_bridge_portal_address,\n            input_amount,\n            uniswap_fee_tier,\n            output_asset_bridge_portal_address,\n            minimum_output_amount,\n            recipient,\n            secret_hash_for_L1_to_l2_message,\n            caller_on_L1,\n        );\n        context.message_portal(storage.portal_address.read(), content_hash);\n    }\n    // docs:end:swap_public\n\n    // docs:start:swap_private\n    #[private]\n    fn swap_private(\n        input_asset: AztecAddress, // since private, we pass here and later assert that this is as expected by input_bridge\n        input_asset_bridge: AztecAddress,\n        input_amount: u128,\n        output_asset_bridge: AztecAddress,\n        // params for using the transfer_to_public approval\n        nonce_for_transfer_to_public_approval: Field,\n        // params for the swap\n        uniswap_fee_tier: Field, // which uniswap tier to use (eg 3000 for 0.3% fee)\n        minimum_output_amount: u128, // minimum output amount to receive (slippage protection for the swap)\n        // params for the depositing output_asset back to Aztec\n        secret_hash_for_L1_to_l2_message: Field, // for when l1 uniswap portal inserts the message to consume output assets on L2\n        caller_on_L1: EthAddress, // ethereum address that can call this function on the L1 portal (0x0 if anyone can call)\n    ) {\n        let input_asset_bridge_config =\n            TokenBridge::at(input_asset_bridge).get_config().view(&mut context);\n        let output_asset_bridge_config =\n            TokenBridge::at(output_asset_bridge).get_config().view(&mut context);\n\n        // Assert that user provided token address is same as expected by token bridge.\n        // we can't directly use `input_asset_bridge.token` because that is a public method and public can't return data to private\n        assert(\n            input_asset.eq(input_asset_bridge_config.token),\n            \"input_asset address is not the same as seen in the bridge contract\",\n        );\n\n        // Transfer funds to this contract\n        Token::at(input_asset)\n            .transfer_to_public(\n                context.msg_sender(),\n                context.this_address(),\n                input_amount,\n                nonce_for_transfer_to_public_approval,\n            )\n            .call(&mut context);\n\n        // Approve bridge to burn this contract's funds and exit to L1 Uniswap Portal\n        Uniswap::at(context.this_address())\n            ._approve_bridge_and_exit_input_asset_to_L1(\n                input_asset,\n                input_asset_bridge,\n                input_amount,\n            )\n            .enqueue(&mut context);\n\n        // Create swap message and send to Outbox for Uniswap Portal\n        // this ensures the integrity of what the user originally intends to do on L1.\n\n        // ensure portal exists - else funds might be lost\n        assert(\n            !input_asset_bridge_config.portal.is_zero(),\n            \"L1 portal address of input_asset's bridge is 0\",\n        );\n        assert(\n            !output_asset_bridge_config.portal.is_zero(),\n            \"L1 portal address of output_asset's bridge is 0\",\n        );\n\n        let content_hash = compute_swap_private_content_hash(\n            input_asset_bridge_config.portal,\n            input_amount,\n            uniswap_fee_tier,\n            output_asset_bridge_config.portal,\n            minimum_output_amount,\n            secret_hash_for_L1_to_l2_message,\n            caller_on_L1,\n        );\n        context.message_portal(storage.portal_address.read(), content_hash);\n    }\n    // docs:end:swap_private\n\n    // docs:start:authwit_uniswap_set\n    // This helper method approves the bridge to burn this contract's funds and exits the input asset to L1\n    // Assumes contract already has funds.\n    // Assume `token` relates to `token_bridge` (ie token_bridge.token == token)\n    // Note that private can't read public return values so created an internal public that handles everything\n    // this method is used for both private and public swaps.\n    #[public]\n    #[internal]\n    fn _approve_bridge_and_exit_input_asset_to_L1(\n        token: AztecAddress,\n        token_bridge: AztecAddress,\n        amount: u128,\n    ) {\n        // Since we will authorize and instantly spend the funds, all in public, we can use the same nonce\n        // every interaction. In practice, the authwit should be squashed, so this is also cheap!\n        let authwit_nonce = 0xdeadbeef;\n\n        let selector = FunctionSelector::from_signature(\"burn_public((Field),u128,Field)\");\n        let message_hash = compute_authwit_message_hash_from_call(\n            token_bridge,\n            token,\n            context.chain_id(),\n            context.version(),\n            selector,\n            [context.this_address().to_field(), amount as Field, authwit_nonce],\n        );\n\n        // We need to make a call to update it.\n        set_authorized(&mut context, message_hash, true);\n\n        let this_portal_address = storage.portal_address.read();\n        // Exit to L1 Uniswap Portal !\n        TokenBridge::at(token_bridge)\n            .exit_to_l1_public(this_portal_address, amount, this_portal_address, authwit_nonce)\n            .call(&mut context)\n    }\n    // docs:end:authwit_uniswap_set\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/uniswap_contract/src/util.nr",
      "source": "// docs:start:uniswap_public_content_hash\nuse dep::aztec::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    hash::sha256_to_field,\n    traits::ToField,\n};\n\n// This method computes the L2 to L1 message content hash for the public\n// refer `l1-contracts/test/portals/UniswapPortal.sol` on how L2 to L1 message is expected\npub fn compute_swap_public_content_hash(\n    input_asset_bridge_portal_address: EthAddress,\n    input_amount: u128,\n    uniswap_fee_tier: Field,\n    output_asset_bridge_portal_address: EthAddress,\n    minimum_output_amount: u128,\n    aztec_recipient: AztecAddress,\n    secret_hash_for_L1_to_l2_message: Field,\n    caller_on_L1: EthAddress,\n) -> Field {\n    let mut hash_bytes = [0; 260]; // 8 fields of 32 bytes each + 4 bytes fn selector\n    let input_token_portal_bytes: [u8; 32] =\n        input_asset_bridge_portal_address.to_field().to_be_bytes();\n    let in_amount_bytes: [u8; 32] = input_amount.to_field().to_be_bytes();\n    let uniswap_fee_tier_bytes: [u8; 32] = uniswap_fee_tier.to_be_bytes();\n    let output_token_portal_bytes: [u8; 32] =\n        output_asset_bridge_portal_address.to_field().to_be_bytes();\n    let amount_out_min_bytes: [u8; 32] = minimum_output_amount.to_field().to_be_bytes();\n    let aztec_recipient_bytes: [u8; 32] = aztec_recipient.to_field().to_be_bytes();\n    let secret_hash_for_L1_to_l2_message_bytes: [u8; 32] =\n        secret_hash_for_L1_to_l2_message.to_be_bytes();\n    let caller_on_L1_bytes: [u8; 32] = caller_on_L1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime {\n        keccak256::keccak256(\n            \"swap_public(address,uint256,uint24,address,uint256,bytes32,bytes32,address)\".as_bytes(),\n            75,\n        )\n    };\n\n    hash_bytes[0] = selector[0];\n    hash_bytes[1] = selector[1];\n    hash_bytes[2] = selector[2];\n    hash_bytes[3] = selector[3];\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = input_token_portal_bytes[i];\n        hash_bytes[i + 36] = in_amount_bytes[i];\n        hash_bytes[i + 68] = uniswap_fee_tier_bytes[i];\n        hash_bytes[i + 100] = output_token_portal_bytes[i];\n        hash_bytes[i + 132] = amount_out_min_bytes[i];\n        hash_bytes[i + 164] = aztec_recipient_bytes[i];\n        hash_bytes[i + 196] = secret_hash_for_L1_to_l2_message_bytes[i];\n        hash_bytes[i + 228] = caller_on_L1_bytes[i];\n    }\n\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:uniswap_public_content_hash\n\n// docs:start:compute_swap_private_content_hash\n// This method computes the L2 to L1 message content hash for the private\n// refer `l1-contracts/test/portals/UniswapPortal.sol` on how L2 to L1 message is expected\npub fn compute_swap_private_content_hash(\n    input_asset_bridge_portal_address: EthAddress,\n    input_amount: u128,\n    uniswap_fee_tier: Field,\n    output_asset_bridge_portal_address: EthAddress,\n    minimum_output_amount: u128,\n    secret_hash_for_L1_to_l2_message: Field,\n    caller_on_L1: EthAddress,\n) -> Field {\n    let mut hash_bytes = [0; 228]; // 7 fields of 32 bytes each + 4 bytes fn selector\n    let input_token_portal_bytes: [u8; 32] =\n        input_asset_bridge_portal_address.to_field().to_be_bytes();\n    let in_amount_bytes: [u8; 32] = input_amount.to_field().to_be_bytes();\n    let uniswap_fee_tier_bytes: [u8; 32] = uniswap_fee_tier.to_be_bytes();\n    let output_token_portal_bytes: [u8; 32] =\n        output_asset_bridge_portal_address.to_field().to_be_bytes();\n    let amount_out_min_bytes: [u8; 32] = minimum_output_amount.to_field().to_be_bytes();\n    let secret_hash_for_L1_to_l2_message_bytes: [u8; 32] =\n        secret_hash_for_L1_to_l2_message.to_be_bytes();\n    let caller_on_L1_bytes: [u8; 32] = caller_on_L1.to_field().to_be_bytes();\n\n    // The purpose of including the following selector is to make the message unique to that specific call. Note that\n    // it has nothing to do with calling the function.\n    let selector = comptime {\n        keccak256::keccak256(\n            \"swap_private(address,uint256,uint24,address,uint256,bytes32,address)\".as_bytes(),\n            68,\n        )\n    };\n\n    hash_bytes[0] = selector[0];\n    hash_bytes[1] = selector[1];\n    hash_bytes[2] = selector[2];\n    hash_bytes[3] = selector[3];\n\n    for i in 0..32 {\n        hash_bytes[i + 4] = input_token_portal_bytes[i];\n        hash_bytes[i + 36] = in_amount_bytes[i];\n        hash_bytes[i + 68] = uniswap_fee_tier_bytes[i];\n        hash_bytes[i + 100] = output_token_portal_bytes[i];\n        hash_bytes[i + 132] = amount_out_min_bytes[i];\n        hash_bytes[i + 164] = secret_hash_for_L1_to_l2_message_bytes[i];\n        hash_bytes[i + 196] = caller_on_L1_bytes[i];\n    }\n    let content_hash = sha256_to_field(hash_bytes);\n    content_hash\n}\n// docs:end:compute_swap_private_content_hash\n"
    },
    "53": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/authwit/auth.nr",
      "source": "use crate::{\n    authwit::{\n        authorization_interface::AuthorizationInterface,\n        authorization_selector::AuthorizationSelector,\n    },\n    context::{gas::GasOpts, PrivateContext, PublicContext},\n    hash::hash_args_array,\n    macros::authorization::authorization,\n    oracle::{execution_cache::load, offchain_effect::emit_offchain_effect},\n};\nuse dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    constants::{\n        CANONICAL_AUTH_REGISTRY_ADDRESS, GENERATOR_INDEX__AUTHWIT_INNER,\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER, GENERATOR_INDEX__AUTHWIT_OUTER,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Serialize, ToField},\n};\n\n/**\n * Authentication witness helper library\n *\n * Authentication Witness is a scheme for authenticating actions on Aztec, so users can allow third-parties\n * (e.g. protocols or other users) to execute an action on their behalf.\n *\n * This library provides helper functions to manage such witnesses.\n * The authentication witness, is some \"witness\" (data) that authenticates a `message_hash`.\n * The simplest example of an authentication witness, is a signature. The signature is the \"evidence\",\n * that the signer has seen the message, agrees with it, and has allowed it.\n * It does not need to be a signature. It could be any kind of \"proof\" that the message is allowed.\n * Another proof could be knowing some kind of secret, or having some kind of \"token\" that allows the message.\n *\n * The `message_hash` is a hash of the following structure:\n * hash(consumer, chain_id, version, inner_hash)\n * - consumer: the address of the contract that is \"consuming\" the message,\n * - chain_id: the chain id of the chain that the message is being consumed on,\n * - version: the version of the chain that the message is being consumed on,\n * - inner_hash: the hash of the \"inner\" message that is being consumed, this is the \"actual\" message or action.\n *\n * While the `inner_hash` could be anything, such as showing you signed a specific message, it will often be\n * a hash of the \"action\" to approve, along with who made the call. As part of this library, we provide a few\n * helper functions to deal with such messages.\n *\n * For example, we provide helper function that is used for checking that the message is an encoding of the current call.\n * This can be used to let some contract \"allow\" another contract to act on its behalf, as long as it can\n * show that it is acting on behalf of the contract.\n *\n * If we take a case of allowing a contract to transfer tokens on behalf of an account, the `inner_hash` can be\n * derived as:\n * inner_hash = hash(caller, \"transfer\", hash(to, amount))\n *\n * Where the `caller` would be the address of the contract that is trying to transfer the tokens, and `to` and `amount`\n * the arguments for the transfer.\n *\n * Note that we have both a `caller` and a `consumer`, the `consumer` will be the contract that is consuming the message,\n * in the case of the transfer, it would be the `Token` contract itself, while the caller, will be the actor that is\n * allowed to transfer the tokens.\n *\n *\n * The authentication mechanism works differently in public and private contexts. In private, we recall that everything\n * is executed on the user's device, so we can use `oracles` to \"ask\" the user (not contract) for information. In public\n * we cannot do this, since it is executed by the sequencer (someone else). Therefore we can instead use a \"registry\"\n * to store the messages that we have approved.\n *\n * A simple example would be a \"token\" that is being \"pulled\" from one account into another. We will first outline\n * how this would look in private, and then in public later.\n *\n * Say that a user `Alice` wants to deposit some tokens into a DeFi protocol (say a DEX).\n * `Alice` would make a `deposit` transaction, that she is executing using her account contract.\n * The account would call the `DeFi` contract to execute `deposit`, which would try to pull funds from the `Token`\n * contract. Since the `DeFi` contract is trying to pull funds from an account that is not its own, it needs to\n * convince the `Token` contract that it is allowed to do so.\n *\n * This is where the authentication witness comes in The `Token` contract computes a `message_hash` from the\n * `transfer` call, and then asks `Alice Account` contract to verify that the `DeFi` contract is allowed to\n * execute that call.\n *\n * `Alice Account` contract can then ask `Alice` if she wants to allow the `DeFi` contract to pull funds from her\n * account. If she does, she will sign the `message_hash` and return the signature to the `Alice Account` which\n * will validate it and return success to the `Token` contract which will then allow the `DeFi` contract to pull\n * funds from `Alice`.\n *\n * To ensure that the same \"approval\" cannot be used multiple times, we also compute a `nullifier` for the\n * authentication witness, and emit it from the `Token` contract (consumer).\n *\n * Note that we can do this flow as we are in private were we can do oracle calls out from contracts.\n *\n *\n *  Person          Contract              Contract               Contract\n *  Alice          Alice Account          Token                   DeFi\n *   |                  |                  |                      |\n *   | Defi.deposit(Token, 1000)           |                      |\n *   |----------------->|                  |                      |\n *   |                  | deposit(Token, 1000)                    |\n *   |                  |---------------------------------------->|\n *   |                  |                  |                      |\n *   |                  |                  | transfer(Alice, Defi, 1000)\n *   |                  |                  |<---------------------|\n *   |                  |                  |                      |\n *   |                  | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |<-----------------|                      |\n *   |                  |                  |                      |\n *   | Please give me AuthWit for DeFi     |                      |\n *   | calling transfer(Alice, Defi, 1000) |                      |\n *   |<-----------------|                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   | AuthWit for transfer(Alice, Defi, 1000)                    |\n *   |----------------->|                  |                      |\n *   |                  | AuthWit validity |                      |\n *   |                  |----------------->|                      |\n *   |                  |                  |                      |\n *   |                  |       throw if invalid AuthWit          |\n *   |                  |                  |                      |\n *   |                  |       emit AuthWit nullifier            |\n *   |                  |                  |                      |\n *   |                  |       transfer(Alice, Defi, 1000)       |\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  | success              |\n *   |                  |                  |--------------------->|\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *   |                  |                  |           deposit(Token, 1000)\n *   |                  |                  |                      |\n *   |                  |                  |                      |\n *\n *\n * If we instead were in public, we cannot do the same flow. Instead we would use an authentication registry to store\n * the messages that we have approved.\n *\n * To approve a message, `Alice Account` can make a `set_authorized` call to the registry, to set a `message_hash`\n * as authorized. This is essentially a mapping from `message_hash` to `true` for `Alice Contract`. Every account\n * has its own map in the registry, so `Alice` cannot approve a message for `Bob`.\n *\n * The `Token` contract can then try to \"spend\" the approval by calling `consume` on the registry. If the message\n * was approved, the value is updated to `false`, and we return the success flag. For more information on the\n * registry, see `main.nr` in `auth_registry_contract`.\n *\n * Person          Contract              Contract            Contract               Contract\n * Alice          Alice Account          Registry             Token                   DeFi\n *   |                  |                    |                   |                      |\n *   | Registry.set_authorized(..., true)    |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | set_authorized(..., true)              |                      |\n *   |                  |------------------->|                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |         set authorized to true         |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   | Defi.deposit(Token, 1000)             |                   |                      |\n *   |----------------->|                    |                   |                      |\n *   |                  | deposit(Token, 1000)                   |                      |\n *   |                  |-------------------------------------------------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |              transfer(Alice, Defi, 1000) |\n *   |                  |                    |                   |<---------------------|\n *   |                  |                    |                   |                      |\n *   |                  |                    | Check if Defi may call transfer(Alice, Defi, 1000)\n *   |                  |                    |<------------------|                      |\n *   |                  |                    |                   |                      |\n *   |                  |          throw if invalid AuthWit      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |           set authorized to false      |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    | AuthWit validity  |                      |\n *   |                  |                    |------------------>|                      |\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | transfer(Alice, Defi, 1000)\n *   |                  |                    |                   |<-------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   | success              |\n *   |                  |                    |                   |--------------------->|\n *   |                  |                    |                   |                      |\n *   |                  |                    |                   |     deposit(Token, 1000)\n *   |                  |                    |                   |                      |\n *\n *\n * --- FAQ ---\n * Q:   Why are we using a success flag of `poseidon2_hash_bytes(\"IS_VALID()\")` instead of just returning a boolean?\n * A:   We want to make sure that we don't accidentally return `true` if there is a collision in the function selector.\n *      By returning a hash of `IS_VALID()`, it becomes very unlikely that there is both a collision and we return\n *      a success flag.\n *\n * Q:   Why are we using static calls?\n * A:   We are using static calls to ensure that the account contract cannot re-enter. If it was a normal call, it\n *      could make a new call and do a re-entry attack. Using a static ensures that it cannot update any state.\n *\n * Q:   Would it not be cheaper to use a nullifier instead of updating state in public?\n * A:   At a quick glance, a public state update + nullifier is 96 bytes, but two state updates are 128, so it would be\n *      cheaper to use a nullifier, if this is the way it would always be done. However, if both the approval and the\n *      consumption is done in the same transaction, then we will be able to squash the updates (only final tx state diff is posted to DA), and now it is cheaper.\n *\n * Q:   Why is the chain id and the version part of the message hash?\n * A:   The chain id and the version is part of the message hash to ensure that the message is only valid on a specific\n *      chain to avoid a case where the same message could be used across multiple chains.\n */\n\npub global IS_VALID_SELECTOR: Field = 0x47dacd73; // 4 last bytes of poseidon2_hash_bytes(\"IS_VALID()\")\n\n/// A struct that represents a contract call the user can authorize. It's associated identifier is\n/// generated by serializing and hashing it. The user is expected to sign this hash to signal the contract\n/// call can be performed on their behalf\n#[authorization]\nstruct CallAuthorization {\n    msg_sender: AztecAddress,\n    selector: FunctionSelector,\n    args_hash: Field,\n}\n\n/// A struct that represents a request to authorize a call, which is used to emit an offchain effect\n/// so the user/wallet can understand what they are being asked to sign. It is generated from a\n/// CallAuthorization by adding metadata to it, such as the selector for the authorization, the inner hash,\n/// and the actual arguments that are being passed to the function call.\n#[derive(Serialize)]\nstruct CallAuthorizationRequest {\n    selector: AuthorizationSelector,\n    inner_hash: Field,\n    msg_sender: AztecAddress,\n    fn_selector: FunctionSelector,\n    args_hash: Field,\n}\n\nunconstrained fn emit_authorization_as_offchain_effect<let N: u32>(\n    authorization: CallAuthorization,\n    inner_hash: Field,\n) {\n    let args: [Field; N] = load(authorization.args_hash);\n    let authorization_request = CallAuthorizationRequest {\n        selector: authorization.get_authorization_selector(),\n        inner_hash: inner_hash,\n        msg_sender: authorization.msg_sender,\n        fn_selector: authorization.selector,\n        args_hash: authorization.args_hash,\n    };\n    emit_offchain_effect(authorization_request.serialize().concat(args))\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call with a valid authentication witness\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Additionally, this function emits the identifying information of the call as an offchain effect \n * so PXE can rely the information to the user/wallet in a readable way. To that effect, it is generic over N, \n * where N is the number of arguments the authorized functions takes. This is used to load the arguments \n * from the execution cache. This function is intended to be called via a macro, which will use the turbofish\n * operator to specify the number of arguments.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit\npub fn assert_current_call_valid_authwit<let N: u32>(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n) {\n    let args_hash: Field = context.get_args_hash();\n\n    let authorization = CallAuthorization {\n        msg_sender: context.msg_sender(),\n        selector: context.selector(),\n        args_hash,\n    };\n    let inner_hash = compute_inner_authwit_hash(authorization.serialize());\n    // Safety: Offchain effects are by definition unconstrained. They are emitted via an oracle\n    // which we don't use for anything besides its side effects, therefore this is safe to call.\n    unsafe { emit_authorization_as_offchain_effect::<N>(authorization, inner_hash) };\n\n    assert_inner_hash_valid_authwit(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit\n\n/**\n * Assert that a specific `inner_hash` is valid for the `on_behalf_of` address\n *\n * Used as an internal function for `assert_current_call_valid_authwit` and can be used as a standalone function when\n * the `inner_hash` is from a different source, e.g., say a block of text etc.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n * @param inner_hash The hash of the message to authorize\n */\npub fn assert_inner_hash_valid_authwit(\n    context: &mut PrivateContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    // We perform a static call here and not a standard one to ensure that the account contract cannot re-enter.\n    let result: Field = context\n        .static_call_private_function(\n            on_behalf_of,\n            comptime { FunctionSelector::from_signature(\"verify_private_authwit(Field)\") },\n            [inner_hash],\n        )\n        .get_preimage();\n    assert(result == IS_VALID_SELECTOR, \"Message not authorized by account\");\n    // Compute the nullifier, similar computation to the outer hash, but without the chain_id and version.\n    // Those should already be handled in the verification, so we just need something to nullify, that allows the same inner_hash for multiple actors.\n    let nullifier = compute_authwit_nullifier(on_behalf_of, inner_hash);\n    context.push_nullifier(nullifier);\n}\n\n/**\n * Assert that `on_behalf_of` has authorized the current call in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the current call\n */\n// docs:start:assert_current_call_valid_authwit_public\npub unconstrained fn assert_current_call_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n) {\n    let inner_hash = compute_inner_authwit_hash([\n        (*context).msg_sender().to_field(),\n        (*context).selector().to_field(),\n        (*context).get_args_hash(),\n    ]);\n    assert_inner_hash_valid_authwit_public(context, on_behalf_of, inner_hash);\n}\n// docs:end:assert_current_call_valid_authwit_public\n\n/**\n * Assert that `on_behalf_of` has authorized a specific `inner_hash` in the authentication registry\n *\n * Compute the `inner_hash` using the `msg_sender`, `selector` and `args_hash` and then make a call out to the\n * `on_behalf_of` contract to verify that the `inner_hash` is valid.\n *\n * Note that the authentication registry will take the `msg_sender` into account as the consumer, so this will only\n * work if the `msg_sender` is the same as the `consumer` when the `message_hash` was inserted into the registry.\n *\n * @param on_behalf_of The address that has allegedly authorized the `inner_hash`\n */\npub unconstrained fn assert_inner_hash_valid_authwit_public(\n    context: &mut PublicContext,\n    on_behalf_of: AztecAddress,\n    inner_hash: Field,\n) {\n    let results: [Field] = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"consume((Field),Field)\") },\n        [on_behalf_of.to_field(), inner_hash].as_slice(),\n        GasOpts::default(),\n    );\n    assert(results.len() == 1, \"Invalid response from registry\");\n    assert(results[0] == IS_VALID_SELECTOR, \"Message not authorized by account\");\n}\n\n/**\n * Compute the `message_hash` from a function call to be used by an authentication witness\n *\n * Useful for when you need a non-account contract to approve during execution. For example if you need a contract\n * to make a call to nested contract, e.g., contract A wants to exit token T to L1 using bridge B, so it needs to allow\n * B to transfer T on its behalf.\n *\n * @param caller The address of the contract that is calling the function, in the example above, this would be B\n * @param consumer The address of the contract that is consuming the message, in the example above, this would be T\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param selector The function selector of the function that is being called\n * @param args The arguments of the function that is being called\n */\n// docs:start:compute_authwit_message_hash_from_call\npub fn compute_authwit_message_hash_from_call<let N: u32>(\n    caller: AztecAddress,\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    selector: FunctionSelector,\n    args: [Field; N],\n) -> Field {\n    let args_hash = hash_args_array(args);\n    let inner_hash =\n        compute_inner_authwit_hash([caller.to_field(), selector.to_field(), args_hash]);\n    compute_authwit_message_hash(consumer, chain_id, version, inner_hash)\n}\n// docs:end:compute_authwit_message_hash_from_call\n\n/**\n * Computes the `inner_hash` of the authentication witness\n *\n * This is used internally, but also useful in cases where you want to compute the `inner_hash` for a specific message\n * that is not necessarily a call, but just some \"bytes\" or text.\n *\n * @param args The arguments to hash\n */\npub fn compute_inner_authwit_hash<let N: u32>(args: [Field; N]) -> Field {\n    poseidon2_hash_with_separator(args, GENERATOR_INDEX__AUTHWIT_INNER)\n}\n\n/**\n * Computes the `authwit_nullifier` for a specific `on_behalf_of` and `inner_hash`\n *\n * Using the `on_behalf_of` and the `inner_hash` to ensure that the nullifier is siloed for a specific `on_behalf_of`.\n *\n * @param on_behalf_of The address that has authorized the `inner_hash`\n * @param inner_hash The hash of the message to authorize\n */\npub fn compute_authwit_nullifier(on_behalf_of: AztecAddress, inner_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [on_behalf_of.to_field(), inner_hash],\n        GENERATOR_INDEX__AUTHWIT_NULLIFIER,\n    )\n}\n\n/**\n * Computes the `message_hash` for the authentication witness\n *\n * @param consumer The address of the contract that is consuming the message\n * @param chain_id The chain id of the chain that the message is being consumed on\n * @param version The version of the chain that the message is being consumed on\n * @param inner_hash The hash of the \"inner\" message that is being consumed\n */\npub fn compute_authwit_message_hash(\n    consumer: AztecAddress,\n    chain_id: Field,\n    version: Field,\n    inner_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [consumer.to_field(), chain_id, version, inner_hash],\n        GENERATOR_INDEX__AUTHWIT_OUTER,\n    )\n}\n\n/**\n * Helper function to set the authorization status of a message hash\n *\n * Wraps a public call to the authentication registry to set the authorization status of a `message_hash`\n *\n * @param message_hash The hash of the message to authorize\n * @param authorize True if the message should be authorized, false if it should be revoked\n */\npub unconstrained fn set_authorized(\n    context: &mut PublicContext,\n    message_hash: Field,\n    authorize: bool,\n) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_authorized(Field,bool)\") },\n        [message_hash, authorize as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n\n/**\n * Helper function to reject all authwits\n *\n * Wraps a public call to the authentication registry to set the `reject_all` flag\n *\n * @param reject True if all authwits should be rejected, false otherwise\n */\npub unconstrained fn set_reject_all(context: &mut PublicContext, reject: bool) {\n    let res = context.call_public_function(\n        CANONICAL_AUTH_REGISTRY_ADDRESS,\n        comptime { FunctionSelector::from_signature(\"set_reject_all(bool)\") },\n        [context.this_address().to_field(), reject as Field].as_slice(),\n        GasOpts::default(),\n    );\n    assert(res.len() == 0);\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "61": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "62": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "69": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between a #[private] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[private] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[private] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[private] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[private] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp =\n            inputs.historical_header.global_variables.timestamp + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// TODO(https://github.com/AztecProtocol/aztec-packages/issues/14025) - we\n    /// are considering making msg_sender: Option<AztecAddress>, since\n    /// a returned value of `Option:none` will be clearer to developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `-1` for the first function call of the tx.\n    ///\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[private] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[private]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some historical block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[private] macro.\n    ///\n    /// # Arguments\n    /// * `returns_hasher` - A hasher containing the return values to hash\n    ///\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[private] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a heft function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "70": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between a #[public] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[public] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[public] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[public]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases, and is enforced by the protocol's kernel circuits.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the account or contract that called\n    ///   this function\n    ///\n    /// # Examples\n    /// ```rust\n    /// #[aztec(public)]\n    /// fn transfer(context: &mut PublicContext, to: AztecAddress, amount: u64) {\n    ///     let sender = context.msg_sender();\n    ///     // Only the sender can transfer their own tokens\n    ///     assert(sender == get_token_owner(), \"Unauthorized\");\n    /// }\n    /// ```\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    /// * Globally visible unlike private execution where it's contract-local\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[public] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "71": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "72": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "74": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "76": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "88": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "93": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "97": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "98": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    }
  }
}
