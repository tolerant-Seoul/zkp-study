{
  "transpiled": true,
  "noir_version": "1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec",
  "name": "FPC",
  "functions": [
    {
      "name": "_complete_refund",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "accepted_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "max_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "6131214474596857170": {
            "error_kind": "string",
            "string": "Function _complete_refund can only be called internally"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "12569728078551279707": {
            "error_kind": "string",
            "string": "max fee not enough to cover tx fee"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBIJwAABAMnAgQEAycCBQQAHwoABAAFgEUdAIBHgEcGLgiARQABLgiARgACLgiARwADJQAAAFglAAAAaSgCAAEEgEgnAgIEADsOAAIAASkAgEME/////ygAgEQEAAMmJQAAAkQeAgAEAB4CAAUAMyoABAAFAAYnAgQBASQCAAYAAACSJQAAAm0eAgAEAR4CAAUACioEBQYkAgAGAAAAriUAAAJ/HgIABAIcCgQFACsCAAYA/////////////////////w4qBQYHJAIABwAAAN8lAAACkRwKBAUGDCoDBQQnAgYBAAoqBAYHJAIABwAAAQAlAAACowIqAwUEDioFAwYkAgAGAAABFyUAAAK1HAoEAwApAgAEAJr09+QnAgYEAycCCAQDACoGCActCAEFAAgBBwEnAwUEAQAiBQIHLQ4GBwAiBwIHLQ4GBycCBwQDACoFBwYtCgYHLQ4EBwAiBwIHLQ4DBwAiBwIHLQ4CBwAiBQIELQsEAycCBgQCACoEBgI5A6CAQ4BDAAEAAwACIAIAASECAAInAgMEAC0IAQUAIgUCCC0LCAcnAgkEAgAqCAkGIjoAAgADAAYtCgIHJwIJBAMAKgcJCAAIAQgBJwMFBAEAIgUCCS0OBwkAIgkCCS0OBwktCgcEBiIEAgQkAgABAAACLSMAAAIELQsFAQAiAQIBLQ4BBQAiBQIGLQsGAicCBwQCACoGBwE8DgIBIwAAAi0KKgQDASQCAAEAAAJDJwICBAA8BgIBJigAgAQEeAANAAAAgASAAyQAgAMAAAJsKgEAAQX3ofOvpa3UyjwEAgEmKgEAAQW+Hj//PqT2+jwEAgEmKgEAAQVVFnMUgBQ1UjwEAgEmKgEAAQVaAuQbtR6pnzwEAgEmKgEAAQWucKUXFU1oWzwEAgEmKgEAAQUohpKwR9z9QzwEAgEm",
      "debug_symbols": "tVfbauMwEP0XP+dB0szo0l8ppaSpWwImCW6ysJT8+87YGtkpSHSz3Zf4eBwdnbnK/uxe+5fL+/P+8Hb86B4eP7uXcT8M+/fn4bjbnvfHA1s/OyM/1vIFN3yl7iHw1fG9NQIiA8sAIAO0CjwDWURikVUklsjAWwUpg4Ddg5NVgS1OVkWcgTOUgYiYQczA8aaOBIjFMxAZM1ALqkVkzIBlONbjRMYM1DLJmIDISAxEBjgGCRTEGYABBWqxTkHIwKnFqQWsAp8BGgWUAamFUIFu4XVTr4RBtwhCyGGBaBVQBskoyBacNHM0cNIcBfBy5JyiswooAzAKUEHKANVCutzrcq+WoJaglqiWqFsk3SIpocRZAIkw4FyQVN0MSIHIYN9pEjaBmIHkfQZqIY4Ysu/kXQbBKBAZeL1uOi3+5/PY91L7q27gHjltx/5w7h4Ol2HYdL+2w2X608dpe5iu5+3IT1l1f3jlKxO+7Yde0HWzrDb1pRZIkjktt+B9KBTWhBsS2yAxrnAYdCsKvKFwDYqQoleOkBIVkmBvOKDOAY5bI3MwdljjaLqSksqwNlVdoR9wxf9vVyiWrMR6VmKdIoSoFCFiVURqOMLjxqojgPivjlhXd6RV5jyyCwfH1tfLvFWkadUsidBUnWlXaaAltalK0nQHrFvcAVd35ycK1f5EpX4/O4BVdxokRF7DShRjoaAvvjSKlQ94CpmDcaj64kwrIIhQAoKrifr9gBBhKL4kW/PFNWrV66EQl7SSu13eqFIK6oO3S4Xa+O39rTGlZ6GmoBWCWCqcoku1EJhWBEgnjzerNPwNQ4glCqsm+5qG2DpfQ4kDxHVhw10qvK+pANM8oMvM4Z3NkhB/KwNaY9gFA6VLg43VI7pNQuWA5ZfcaotBa4SiKXOYcfJ3KQHjyvQDUx/mQC0l3J5FibfuTiXL+AM+7aokoaXEe1yUxHinEp9WSuqBbR35GMrwAH71vjM7Ni7vpa4eE2yQAL+5a4oZR1tV0uwdT6WFjV814JfeQWgdtb60Dr9UFQr01+sT3213+/HmQ/gqXON++zL0+fbtctitnp5/n/SJfkifxuOuf72MvTCtvqb595GVb/iF9kk+quWWP375pH26yvZ/AA=="
    },
    {
      "name": "_pay_refund",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "refund_recipient",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "max_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "accepted_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "656596039621769501": {
            "error_kind": "string",
            "string": "Function _pay_refund can only be called internally"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "15548924666521662104": {
            "error_kind": "string",
            "string": "Max fee paid to the paymaster does not cover actual fee"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBHJwAABAMnAgQEAycCBQQAHwoABAAFgEQdAIBFgEUGLgiARAABLgiARQACLgiARgADJQAAAFglAAAAYigCAAEEgEcnAgIEADsOAAIAASkAgEME/////yYlAAACXh4CAAQAHgIABQAzKgAEAAUABicCBAEBJAIABgAAAIslAAAChx4CAAQBHgIABQAKKgQFBiQCAAYAAACnJQAAApkeAgAEAhwKBAUAKwIABgD/////////////////////DioFBgckAgAHAAAA2CUAAAKrHAoEBQYMKgIFBCcCBgEACioEBgckAgAHAAAA+SUAAAK9AioCBQQOKgUCBiQCAAYAAAEQJQAAAs8eAgACABwKBAUAKQIABACMnlRyJwIGAAAnAggEBScCCgQDACoICgktCAEHAAgBCQEnAwcEAQAiBwIJLQ4ICQAiCQIJLQ4ICScCCQQDACoHCQgtCggJLQ4ECQAiCQIJLQ4CCQAiCQIJLQ4BCQAiCQIJLQ4FCQAiCQIJLQ4GCScCAQQFACIHAgUtCwUEJwIGBAIAKgUGAjkDoIBDgEMAAwAEAAIgAgABIQIAAicCAwQALQgBBQAiBQIILQsIBycCCQQCACoICQYiOgACAAMABi0KAgcnAgkEAwAqBwkIAAgBCAEnAwUEAQAiBQIJLQ4HCQAiCQIJLQ4HCS0KBwQGIgQCBCQCAAEAAAJHIwAAAh4tCwUBACIBAgEtDgEFACIFAgYtCwYCJwIHBAIAKgYHATwOAgEjAAACRwoqBAMBJAIAAQAAAl0nAgIEADwGAgEmKACABAR4AA0AAACABIADJACAAwAAAoYqAQABBfeh86+lrdTKPAQCASYqAQABBb4eP/8+pPb6PAQCASYqAQABBQkcsp6GlXkdPAQCASYqAQABBVoC5Bu1HqmfPAQCASYqAQABBdfI4Jo7VTKYPAQCASYqAQABBSiGkrBH3P1DPAQCASY=",
      "debug_symbols": "tZjdbio5DMffZa65iD+SOLzKqqpoS4+QEK04sNKq4t3XHuIMrJSoYntuOr8xzT+2Y2cy8zW9bV/Ov553h/eP39P6r6/p5bjb73e/nvcfr5vT7uOg1q8p2B8INK15pVeZ1lmvoPcQFBAUwCBVIHYoCjaIzWKj2CyiELlCQoc8rdFGZbWgjcq5QpEroDkxA4CDTopRwdzAZJAqkFvILebGFdQNVH/Q3LiCW2Y3DMwNCgZqIVQQs9hcBRzSFSiAg1vALRArYHBwC7nFMnaFUoHJQSpEt8RcIfkUySfNLph9iuyC4lOICxYXLCaoIXNAB7fMUcyQKqBbZp+LgQqyLhyzDmcyyBUiOKQKKTjECtkt4sPFhxe3lGqJAR3cAuBQp4gYHLjC7BgapAqzYzOYG5qEODs2AzuUCtktYj2QDaSCFYBBsgLgfLmsJu+d59Nxu7XWuWkmbbHPzXF7OE3rw3m/X01/b/bn+Z9+f24O8/W0OeqvWnfbw5teVfB9t98aXVbL6NAfClopWIeDlkZuEhDynQgMRAI2jcB4I8F3EjiQyEWSa+RSYhPJcKdBfQ1CClI1lJF7GsNQSnE3AEo3lPgDoaQ/HUqUtirSXxXpS+QsLpGFu06UQSDEATwQYv6/gQD2AxmVOWKLBDS3qV/moyItN81SIoduMOMqzXFZ2tIVGYZDgEs4hP1wfqJQ4Scq9furQ9wNZyAiustXDYm0ZDX+J5ZBsSLq47JqKOduLBhGCWF7jNSE8M2O+v2ECEtZYqFeLDio1RSawDIc74cPqjRmjyHBkkuQb88PIbSepZ4Hw+WM0CLI2EvBSCFDU8gEjyhIC0IEuyWF8gM9huXP9phkxpaNUnqx0Ggf1hNjOyrIbZPSI15I7maUaHjYaPunzhyW4kr3bhCPdpwcqO04Weu6d9wYi8R2WMBC3WWh0f7JoT1TlEt6yBMK2KqMQv/BRDLyJJb2qOYE+KAny1ZO+uTuifBoC+WUePFE5EFPUrnxpJtYxpEnuW2E+nIFD64OyHLGxkFOBiIUMfoSKwt0PRn2ToqthUNKqdc7nEZbWmqtowfEJsHpcnnSu83r7nj3TeBiWsfd5mW/rbfv58Prza+nfz79F/+m8Hn8eN2+nY9bU7r9sKCvRXoIXAHkJ/uuYLf6aq+fE54uNv2/"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "accepted_asset",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "admin",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "fee_entrypoint_private",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "max_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4456244908619624852": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "verification_key": "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"
    },
    {
      "name": "fee_entrypoint_public",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "max_fee",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tb3djiS/cad9LzrWQTIYH6RvxVgYsle7ECDIhmwv8MLwvb/FICN+7B43O7uq5sTz6O+ZeDKZGVGZJJP8rz/87z//83/+33/6y9/+z7/++x/+4R//6w///Pe//PWvf/m///TXf/2XP/3HX/71b4//+l9/uMb/KfyHfyil83//8Q9l/O8+/vcf/9Bl/qHzD5t/tPlH9z/Kda0/y/qT1p91/cnrT1l/6vrT1p9t/bnilRWvrHhlxSsrXlnxyopXVryy4pUVr6x4tOLRikcrHq14tOLRikcrHq14tOLRildXvLri1RWvrnh1xasrXl3x6opXV7y64vGKxyser3i84vGKxyser3i84vGKxyuerHiy4smKJyuerHiy4skjnow/bf3Z1p99/qnX+rOsP2n9WdefvP6U9eeKpyuePuLp+LPPP+1af5b1J60/6/rzEa+PP8fx1QEaYAEtoC9oV8A4ax5AATWAAyRAAyygBfQF/QqIyD0i94js2TLO1fPFQQNG5NHMnjUOfQKNxCGHEkABNYADJEADLKAF9AUlIpeIXCJyicgjjagOkAANsIAW0BeMZJpQAiigBkRkisgUkSkiU0SmiFwjco3INSLXiFwjco3INSLXiFwjco3IHJE5Io8UIxlQAzhAAjTAAlpAXzBSbUIJiMgSkSUiS0SWiCwRWSKyRGSNyBqRNSJrRNaIrBFZI7JGZI3IGpEtIltEtohsEdkiskVki8gWkS0iW0RuEblF5BaRW0RuEblF5BaRW0RuEblF5B6Re0TuEblH5B6Re0TuEblH5B6R+4pcryugBIzIbUAN4AAJ0AALaAF9geegQwmIyCUil4hcIvLIwVoGWEALeESujwJZRw5OKAEUUAM4QAI0wAJaQESuEblG5BqR66obtXKABGiABbSAVZEqXwElgAIiMkdkjsgckUcO1j6gBfQFIwcnlAAKqAEcIAEaEJElIktE1oisEXnkIF8DagAHSIAGWEAL6AtGDk4oARHZIrJFZIvIIwe5DrCAFjAi2wNGDk4oARRQAzhAAjTAAlpARO4RuUfkHpF7RO4RuUfkHpF7RO4Rua/IfF0BJYACagAHSIAGWEALiMglIpeIXCJyicglIpeIXCJyicglIpeITBGZIjJFZIrIFJEpIlNEpohMEZkico3INSLXiFwjco3INSLXiFwjco3INSJzROaIzBGZIzJH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",
      "verification_key": "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"
    },
    {
      "name": "get_accepted_asset",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "verification_key": "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"
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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Tbx1vM8PtIXe5wcGMIICJtDrthDzKYRJ/Gh6j/U7S58sODGDbcvE+5D32IG+Zd4O3mMdfbLgRN+y7BhBAROYQQUL6DZ1tIXhAgMYQQHT3GOfFlj9yPu0wIm2MF6g1/W/FiMoYAJbanhT+7TAiQWsoC303/mBAYwLW794jPR1jhvLxmnjvLFuXDauGxvcfioXb17dvLp5dfNqrx+d68YG9xPaHPu/bmeTT3pbHDaOG8vGaeOySlaq+49WR//RGthr+wlqceNe288167X9rLG8sW5cNq4b22Kf7LY4bBw3lo3Txnlj3bhsXDfevGHzhl6/OPc61ZlTwaezLeZU8Alti8PGcWPZOG2cN9aNN2/cvHHzyuYV9/qQkk9uWywbp43zxrpx93auG7vXrxV8ktvisLHX9xECn7v24OhcN/Y6Plrl09fGuVRG1+0cN5aNe31xzhvrxmWd72V03c70oaKbVzevbl7dvKPrOhf/M34b7zPQFqeN+7b1P68bl417m/i51/t3596//Sa09P49OG7cvd6GvX8PzhvrxmXjurHB1r1+rHvfHxw3lo3Txnlj5ViPPt62ufY+7seo9j4+OG4sG6eN88a6Mce6XnVjjnUN18Zh9WufkLZYNk4b541147Jx3djgSGbW0fc7cy7V0fd920bf77ztV9z2K277Jdt+Sdg4biwbp403r2xe2byyeWXzps2bNm/avGnzps2bNm/avGnzps2btvYcWdF5O455O455O455O455O455O455O455O4558+rm1c2rm1c3r25e3by6eXXz6ubVzVs2b9m8ZfOWzVs2b9m8ZfOWzdvzxzO/9vzp3PNncNg4biwbp5X/deRPZ92450z7XagjT6KzbNx/m3zbxrWE95FxLdG5bFw35vy069o4bEy22yUbp43zxnit97XaOWwcN5aV4db72uC8ctt6XxtcNiaTTchkG7+zncPGcWPZOG1MJlvva4PLxnVjg/O1cVjHyCdwVX/K5hO4BvqY0cAARlDABGZQwQJiU2wFW8FWsBVsBVvBVrAVbH657c8gfQLXQL9/HBjACAqYwAwqWEBsFZthM2yGzbAZNsNm2AybYbNpKz6Ba2IAIyhgAjOoYAEriC1gC9gCtoAtYAvYAraALWAL2CK2iC1ii9gitogtYovYIraITbAJNsEm2ASbYBNsgk2wCbaELWFL2BK2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"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "192384619482506110": {
            "error_kind": "string",
            "string": "Only admin can pull funds"
          },
          "656596039621769501": {
            "error_kind": "string",
            "string": "Function _pay_refund can only be called internally"
          },
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2550444873539515884": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6131214474596857170": {
            "error_kind": "string",
            "string": "Function _complete_refund can only be called internally"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "10492081608786484886": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "12569728078551279707": {
            "error_kind": "string",
            "string": "max fee not enough to cover tx fee"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "15548924666521662104": {
            "error_kind": "string",
            "string": "Max fee paid to the paymaster does not cover actual fee"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "JwACBAEoAAABBIBNJwAABAMnAgIEAScCAwQAHwoAAgADgEwuCIBMAAElAAAARSUAAACHKAIAAQSATScCAgQAOw4AAgABKQCAQwT/////KACARAQAAygAgEUBAAAoAIBGBAAAKACARwAAACgAgEgBAAEoAIBJBAABKACASgAAASgAgEsEAAImJQAAE4MpAgACAEGM3XUKKgECAy0IAQInAgQEAgAIAQQBJwMCBAEAIgICBC0KBAUuDIBKAAUnAgQABi0IAQUnAgYEAgAIAQYBJwMFBAEAIgUCBi0KBgctDgQHJwIGBAAnAggEAwAqBggHLQgBBAAIAQcBJwMEBAEAIgQCBy0OBgcAIgcCBy0OBgcnAgcEAwAqBAcGJAIAAwAAAScjAAAH+S0IAQYnAgcEAwAIAQcBJwMGBAEAIgYCBx8wgEuASQAHLQgBBwAAAQIBLQ4GBy0IAQYAAAECAS4MgEYABicCCQQKLQgACi0KBwstCgYMAAgACQAlAAATrC0CAAAtCgsIASIACIBJAAotCwoJJwIKBAstCAALLQoHDC0KBg0ACAAKACUAABOsLQIAAC0KDAgBIgAIgEkABy0LBwYeAgAHAC0IAQgnAgoEAwAIAQoBJwMIBAEAIggCCjYOAAcACgABIgAIgEkACy0LCwoBIgAIgEsADC0LDAscCgoIAAQqCAsMJAIACgAAAhgnAggEADwGCAEtCAEIJwIKBAMACAEKAScDCAQBACIIAgo2DgAHAAoCASIACIBJAAotCwoHASIACIBLAAstCwsKHAoHCAAEKggKCyQCAAcAAAJqJwIIBAA8BggBLQgBBycCCAQCAAgBCAEnAwcEAQAiBwIIHzCASYBGAAgBIgAHgEkACi0LCggcCggKBBwKCgcALQgBCCcCCgQDAAgBCgEnAwgEAQAiCAIKHzCAS4BJAAoBIgAIgEkADS0LDQoBIgAIgEsADi0LDg0tCAEIJwIOBAQACAEOAScDCAQBACIIAg4tCg4PLgyARwAPACIPAg8uDIBHAA8AIg8CDy4MgEcADysCAA4AAAAAAAAAAAMAAAAAAAAAAC0IAQ8nAhAEBQAIARABJwMPBAEAIg8CEC0KEBEuDIBHABEAIhECES4MgEcAEQAiEQIRLgyARwARACIRAhEtDg4RLQgBEAAAAQIBLQ4IEC0IAQgAAAECAS0ODwgtCAEPAAABAgEuDIBGAA8tCAERAAABAgEuDIBFABEnAhIALCcCEwQULQgAFC0KEBUtCggWLQoPFy0KERgtChIZAAgAEwAlAAAUIy0CAAAnAhIEEy0IABMtChAULQoIFS0KDxYtChEXLQoKGAAIABIAJQAAFCMtAgAAJwIKBBItCAASLQoQEy0KCBQtCg8VLQoRFi0KDRcACAAKACUAABQjLQIAACcCDQQSLQgAEi0KEBMtCggULQoPFS0KERYACAANACUAABVBLQIAAC0KEwotCAEIJwINBAQACAENAScDCAQBACIIAg0tCg0PLgyARwAPACIPAg8uDIBHAA8AIg8CDy4MgEcADy0IAQ0nAg8EBQAIAQ8BJwMNBAEAIg0CDy0KDxAuDIBHABAAIhACEC4MgEcAEAAiEAIQLgyARwAQACIQAhAtDg4QLQgBDgAAAQIBLQ4IDi0IAQgAAAECAS0ODQgtCAENAAABAgEuDIBGAA0tCAEPAAABAgEuDIBFAA8nAhAADScCEQQSLQgAEi0KDhMtCggULQoNFS0KDxYtChAXAAgAEQAlAAAUIy0CAAAnAhAEES0IABEtCg4SLQoIEy0KDRQtCg8VLQoHFgAIABAAJQAAFCMtAgAAJwIHBBAtCAAQLQoOES0KCBItCg0TLQoPFC0KChUACAAHACUAABQjLQIAACcCCgQQLQgAEC0KDhEtCggSLQoNEy0KDxQACAAKACUAABVBLQIAAC0KEQcKKgsHCCQCAAgAAAXDJQAAFbULIgAMgEcABx4CAAgBCioMCAoSKgcKCCQCAAgAAAXnJQAAFccnAggECi0IAAotCgULLQoCDAAIAAgAJQAAFdktAgAALQoLBycCCgQLLQgACy0KBwwuCIBLAA0uCIBFAA4ACAAKACUAABYkLQIAAC0KDAg0AgAILQgBBycCCAQEAAgBCAEnAwcEAQAiBwIILQoICi4MgEcACgAiCgIKLgyARwAKACIKAgouDIBHAAorAgAIAAAAAAAAAAACAAAAAAAAAAAtCAEKJwILBAUACAELAScDCgQBACIKAgstCgsMLgyARwAMACIMAgwuDIBHAAwAIgwCDC4MgEcADAAiDAIMLQ4IDC0IAQgAAAECAS0OBwgtCAEHAAABAgEtDgoHLQgBCgAAAQIBLgyARgAKLQgBCwAAAQIBLgyARQALJwIMBA0tCAANLQoIDi0KBw8tCgoQLQoLES0KCRIACAAMACUAABQjLQIAACcCDAQNLQgADS0KCA4tCgcPLQoKEC0KCxEtCgYSAAgADAAlAAAUIy0CAAAnAg0EDi0IAA4tCggPLQoHEC0KChEtCgsSAAgADQAlAAAVQS0CAAAtCg8MLQgBBycCCAQEAAgBCAEnAwcEAQAiBwIILQoICi0OCQoAIgoCCi0OBgoAIgoCCi0ODAouCIBGAAMjAAAHvQ0iAAOARAAGJAIABgAAE1EjAAAH0h4CAAMANAIAAwAiBAIHLQsHBicCCAQCACoHCAM7DgAGAAMjAAAH+SkCAAMACbA7cwoqAQMGLQsEAwAiAwIDLQ4DBCQCAAYAAAghIwAACvAtCAEDJwIGBAQACAEGAScDAwQBACIDAgYfMIBEgEkABi0IAQYAAAECAS0OAwYtCAEDAAABAgEuDIBGAAMnAggECS0IAAktCgYKLQoDCwAIAAgAJQAAF+UtAgAALQoKBwEiAAeASQAJLQsJCCcCCQQKLQgACi0KBgstCgMMAAgACQAlAAAX5S0CAAAtCgsHASIAB4BJAAotCwoJJwIKBAstCAALLQoGDC0KAw0ACAAKACUAABflLQIAAC0KDAcBIgAHgEkABi0LBgMcCgMHBhwKBwYAHAoGAwYeAgAGAB4CAAcAMyoABgAHAAokAgAKAAAJGCUAABhcHgIABgEeAgAHAAoqBgcKJAIACgAACTQlAAAYbh4CAAYCHAoGBwArAgAKAP////////////////////8OKgcKCyQCAAsAAAllJQAAGIAcCgYHBgwqAwcGCyIABoBFAAokAgAKAAAJhCUAABiSAioDBwYOKgcDCiQCAAoAAAmbJQAAGKQcCgYDACkCAAYAmvT35CcCCgQDJwIMBAMAKgoMCy0IAQcACAELAScDBwQBACIHAgstDgoLACILAgstDgoLJwILBAMAKgcLCi0KCgstDgYLACILAgstDgMLACILAgstDgkLACIHAgktCwkGJwIKBAIAKgkKAzkDoIBDgEMACAAGAAMgAgADIQIABi0IAQgAIggCCy0LCwonAgwEAgAqCwwJIjIABoBGAAktCgYKJwIMBAMAKgoMCwAIAQsBJwMIBAEAIggCDC0OCgwAIgwCDC0OCgwtCgoHBiIHAgckAgADAAAKrCMAAAqDLQsIAwAiAwIDLQ4DCAAiCAIJLQsJBicCCgQCACoJCgM8DgYDIwAACqwLIgAHgEYAAyQCAAMAAArFJwIGBAA8BgYBLQsEAwAiAwIDLQ4DBAAiBAIHLQsHBicCCAQCACoHCAM7DgAGAAMjAAAK8CkCAAMAr4RirwoqAQMGKQIAAwCMnlRyJwIHBAUkAgAGAAALGSMAAA3rLQgBBicCCAQEAAgBCAEnAwYEAQAiBgIIHzCARIBJAAgtCAEIAAABAgEtDgYILQgBBgAAAQIBLgyARgAGJwIKBAstCAALLQoIDC0KBg0ACAAKACUAABflLQIAAC0KDAkBIgAJgEkACy0LCwonAgsEDC0IAAwtCggNLQoGDgAIAAsAJQAAF+UtAgAALQoNCQEiAAmASQAMLQsMCxwKCwwGHAoMCQAcCgkLBicCDAQNLQgADS0KCA4tCgYPAAgADAAlAAAX5S0CAAAtCg4JASIACYBJAAgtCwgGHgIACAAeAgAJADMqAAgACQAMJAIADAAADBAlAAAYXB4CAAgBHgIACQAKKggJDCQCAAwAAAwsJQAAGLYeAgAIAhwKCAkAKwIADAD/////////////////////DioJDA0kAgANAAAMXSUAABiAHAoICQYMKgsJCAsiAAiARQAMJAIADAAADHwlAAAYyAIqCwkIDioJCwwkAgAMAAAMkyUAABikHgIACQAcCggLACcCDAQFJwIOBAMAKgwODS0IAQgACAENAScDCAQBACIIAg0tDgwNACINAg0tDgwNJwINBAMAKggNDC0KDA0tDgMNACINAg0tDgkNACINAg0tDgoNACINAg0tDgsNACINAg0uDIBHAA0AIggCCy0LCwonAgwEAgAqCwwJOQOggEOAQwAGAAoACSACAAYhAgAILQgBCgAiCgINLQsNDCcCDgQCACoNDgsiMgAIgEYACy0KCAwnAg4EAwAqDA4NAAgBDQEnAwoEAQAiCgIOLQ4MDgAiDgIOLQ4MDi0KDAkGIgkCCSQCAAYAAA20IwAADYstCwoGACIGAgYtDgYKACIKAgstCwsIJwIMBAIAKgsMBjwOCAYjAAANtAsiAAmARgAGJAIABgAADc0nAggEADwGCAEAIgQCCS0LCQgnAgoEAgAqCQoGOw4ACAAGIwAADespAgAGAGcC2BsKKgEGCCQCAAgAAA4GIwAAEYUtCAEGJwIIBAIACAEIAScDBgQBACIGAggfMIBJgEkACAEiAAaASQAJLQsJCB4CAAYAHgIACQAzKgAGAAkACiQCAAoAAA5RJQAAGFwtCwIGACIGAgYtDgYCLQsFBgAiBgIGLQ4GBScCCQQKLQgACi0KBQstCgIMAAgACQAlAAAV2S0CAAAtCgsGJwIFBAktCAAJLQoGCi4IgEsACy4IgEUADAAIAAUAJQAAFiQtAgAALQoKAh4CAAUAMyoAAgAFAAYkAgAGAAAO0yUAABjaLwiASgACJwIFAAIvCgAFAAYeAgAFAQoqBQYJJAIACQAADvslAAAY7B4CAAUAKQIABgD/eUnyJwIKBAInAgwEAwAqCgwLLQgBCQAIAQsBJwMJBAEAIgkCCy0OCgsAIgsCCy0OCgsnAgsEAwAqCQsKLQoKCy0OBgsAIgsCCy0OBQsAIgkCCi0LCgYnAgsEAgAqCgsFOgOggEOAQwACAAYABSACAAUhAgAGLQgBCgAiCgINLQsNDCcCDgQCACoNDgsiMgAGgEYACy0KBgwnAg4EAwAqDA4NAAgBDQEnAwoEAQAiCgIOLQ4MDgAiDgIOLQ4MDi0KDAkGIgkCCSQCAAUAABADIwAAD9otCwoFACIFAgUtDgUKACIKAgstCwsGJwIMBAIAKgsMBTwOBgUjAAAQAwsiAAmASQAFJAIABQAAEBwnAgYEADwGBgEBIgAKgEQABi0LBgUcCgUJBhwKCQYAHgIABQAnAgoEBScCDAQDACoKDAstCAEJAAgBCwEnAwkEAQAiCQILLQ4KCwAiCwILLQ4KCycCCwQDACoJCwotCgoLLQ4DCwAiCwILLQ4FCwAiCwILLQ4ICwAiCwILLQ4GCwAiCwILLgyARwALACIJAgYtCwYFJwIIBAIAKgYIAzkDoIBDgEMAAgAFAAMgAgACIQIAAy0IAQYAIgYCCS0LCQgnAgoEAgAqCQoHIjIAA4BGAActCgMIJwIKBAMAKggKCQAIAQkBJwMGBAEAIgYCCi0OCAoAIgoCCi0OCAotCggFBiIFAgUkAgACAAARTiMAABElLQsGAgAiAgICLQ4CBgAiBgIHLQsHAycCCAQCACoHCAI8DgMCIwAAEU4LIgAFgEYAAiQCAAIAABFnJwIDBAA8BgMBACIEAgUtCwUDJwIGBAIAKgUGAjsOAAMAAiMAABGFJwICAnQnAgMCcicCBAJuJwIFAnMnAgYCZScCBwJsJwIIAmMnAgkCVScCCgJrJwILAm8nAgwCdycCDQIgJwIOAnsnAg8CfS0IARAnAhEEHAAIAREBJwMQBAEAIhACES0KERItDgkSACISAhItDgQSACISAhItDgoSACISAhItDgQSACISAhItDgsSACISAhItDgwSACISAhItDgQSACISAhItDg0SACISAhItDgUSACISAhItDgYSACISAhItDgcSACISAhItDgYSACISAhItDggSACISAhItDgISACISAhItDgsSACISAhItDgMSACISAhItDg0SACISAhItDg4SACISAhItDgUSACISAhItDgYSACISAhItDgcSACISAhItDgYSACISAhItDggSACISAhItDgISACISAhItDgsSACISAhItDgMSACISAhItDg8SCyCARYBIAAIkAgACAAATUScCAwQeLQgBBCcCBQQeAAgBBQEtCgQFKgMABQWRm1yiPiCelgAiBQIFACIQAgYnAgcEGy4CAAaAAy4CAAWABC4CAAeABSUAABj+JwIGBBsAKgUGBS4MgEoABQAiBQIFLQ4BBQAiBQIFPA4DBBwKAwYAASiASgAGAAgAIgcCCQAqCQMKLQsKBjAKAAYACAEiAAOASQAGLQoGAyMAAAe9KACABAR4AA0AAACABIADJACAAwAAE6sqAQABBfeh86+lrdTKPAQCASYlAAATgy0LAgMtCwEEDSIAA4BLAAUkAgAFAAATziUAABlEACIEAgYAKgYDBy0LBwUtCAEGJwIHBAIACAEHAScDBgQBACIGAgctCgcILQ4FCAEiAAOASQAFDioDBQckAgAHAAAUFiUAABlWLQ4EAS0OBQItCgYBJiUAABODLQsEBgsiAAaARQAHJAIABwAAFEUnAggEADwGCAEtCwMGCyIABoBEAAckAgAHAAAU0iMAABReLQsBBy0LAggNIgAGgEQACSQCAAkAABR7JQAAGUQuAgAHgAMoAIAEBAAEJQAAGWguCIAFAAkAIgkCCgAqCgYLLQ4FCwEiAAaASQAFDioGBQckAgAHAAAUuyUAABlWLQ4JAS0OCAItDgUDLgyARQAEIwAAFUAnAgYEBy0IAActCgEILQoCCS0KAwotCgQLAAgABgAlAAAZ9i0CAAAtCwEGLQsCBy0LBAguAgAGgAMoAIAEBAAEJQAAGWgu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",
      "debug_symbols": "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"
    },
    {
      "name": "pull_funds",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "to",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "192384619482506110": {
            "error_kind": "string",
            "string": "Only admin can pull funds"
          },
          "2550444873539515884": {
            "error_kind": "string",
            "string": "Trying to read from uninitialized PublicImmutable"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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tsk/cNuTf+C2J79927ObxDOYi7fuOt9fCCAvBaixx4iuG3DdD8BrO1133/pGgFg6YR0R/k6AW+vivr0073YLwjsf4WxXqou1OZOu3+DkcjuExuBR0vXzqm+E6LFsdFo3evlOCPu+YN4HHEd6JYQcLID9Ycu/bxwFs1rSxzvnb4RYPrxJL51ISp1dB8drR5HZzbGsm3d8I0SJe97HjVl9GiKl3fujH1iYMkeaPu4VX2sNFlxK687lrzboiyGkxkfzouu2Yd8IEVU3reurvBxCXwqR46b/gf21EMo6ny2/FKJyw17La22R2fm4fNhG8sUQr3VqiRekj5eB6bUQrPNZVF8MwYl82JDhGyHijjGV/lqnlsHyI8dLR1HirWjpL7UE11WV5yfxKNLbLGMZFVlH6e7fX0WAD4vYfuM04gdVy0sNWeNburre3XwjAFvIjPxagON/eHP5UoAPKwt8pxHjDu+1QqcphuLyePMIPnfj/3783z/+65///s9/+du//vEff/7bX//j8ff++wz19z//8V/+8qfr//7f//zrvy7/9R///7/7f/mXv//5L3/587/987///W//+qf/859//9MZ6fxvvx3X//yvfn5m3B9j/f/7n35Lj/8/zgUfRh3H4//n87+PdDz+u5z/P51/QevR/ukx9innv0j2JySdfyL/7/8+D/n/AQ=="
    }
  ],
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "FPC"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "accepted_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "max_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "FPC::_complete_refund_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::_complete_refund_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "refund_recipient",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "max_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "accepted_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FPC::_pay_refund_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::_pay_refund_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "accepted_asset",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "admin",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FPC::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "max_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FPC::fee_entrypoint_private_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::fee_entrypoint_private_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "max_fee",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FPC::fee_entrypoint_public_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::fee_entrypoint_public_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "FPC::get_accepted_asset_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "fields": [
                  {
                    "name": "inner",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::get_accepted_asset_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FPC::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "to",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "FPC::pull_funds_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::pull_funds_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "FPC::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "FPC::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "103": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n\n    if is_fn_private(f) {\n        if is_static_call {\n            create_private_static_stub(f)\n        } else {\n            create_private_stub(f)\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            create_public_static_stub(f)\n        } else {\n            create_public_stub(f)\n        }\n    } else {\n        create_utility_stub(f)\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "104": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "107": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY, call_interface_stubs::stub_fn, stub_registry,\n    },\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_authorize_once, fn_has_noinitcheck, get_fn_visibility,\n        is_fn_contract_library_method, is_fn_initializer, is_fn_internal, is_fn_private,\n        is_fn_public, is_fn_test, is_fn_utility, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\npub(crate) comptime fn create_authorize_once_check(f: FunctionDefinition) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[private] or #[public] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_fn_private(f) {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "109": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "112": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "113": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "114": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "115": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "116": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "117": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "118": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "119": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PlaintextLen * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let env = TestEnvironment::new();\n\n        // Log decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"utilityGetIndexedTaggingSecretAsSender\").returns(\n                IndexedTaggingSecret::deserialize([69420, 1337]),\n            );\n            let _ = OracleMock::mock(\"privateIncrementAppTaggingSecretIndexAsSender\").returns(());\n\n            // Encrypt the log\n            let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the log\n            let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec =\n                BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "135": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "147": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "150": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "154": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "155": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "156": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "157": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(utilityGetContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(utilityGetBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(utilityGetTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(utilityGetChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(utilityGetVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "158": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "159": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "163": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "164": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "165": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "167": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "172": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "174": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "175": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 1;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. PXE is using version '1', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "187": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> HasStorageSlot<M + 1> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the historical block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   historical block header that is being referenced by this private function.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "205": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "208": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "209": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "211": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "212": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "214": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "216": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "221": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.historical_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "228": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "247": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "293": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "307": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "309": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "318": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        // Q: I don't understand this comment. We could still compute a siloed nullifier from a zero contract address.\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "328": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "332": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut result = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         result\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Serialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the serialized member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize(self.$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    result[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; _];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Serialize::serialize(self.$param_name)\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "333": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "334": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "344": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "359": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "361": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "362": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "379": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "382": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "412": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/fees/fpc_contract/src/main.nr",
      "source": "mod config;\nmod utils;\n\nuse dep::aztec::macros::aztec;\n\n/// Fee Payment Contract (FPC) allows users to pay for the transaction fee with an arbitrary asset. Supports private\n/// and public fee payment flows.\n///\n/// ***Note:***\n/// Accepted asset funds sent by the users to this contract stay in this contract and later on can\n/// be pulled by the admin using the `pull_funds` function.\n#[aztec]\npub contract FPC {\n    use crate::{config::Config, utils::safe_cast_to_u128};\n    use dep::uint_note::uint_note::PartialUintNote;\n    use aztec::{\n        macros::{functions::{initializer, internal, private, public}, storage::storage},\n        protocol_types::address::AztecAddress,\n        state_vars::PublicImmutable,\n    };\n    use token::Token;\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n    }\n\n    /// Initializes the contract with an accepted asset (AA) and an admin (address that can pull accumulated AA funds\n    /// from this contract).\n    #[public]\n    #[initializer]\n    fn constructor(accepted_asset: AztecAddress, admin: AztecAddress) {\n        let config = Config { accepted_asset, admin };\n        storage.config.initialize(config);\n    }\n\n    /// Pays for the tx fee with msg_sender's private balance of accepted asset (AA). The maximum fee a user is willing\n    /// to pay is defined by `max_fee` and is denominated in AA.\n    ///\n    /// ## Overview\n    /// Uses partial notes to implement a refund flow which works as follows:\n    /// Setup Phase:\n    /// 1. This `fee_entrypoint_private` function:\n    ///     - Transfers `max_fee` of AA from private balance of the user to the public balance of this contract,\n    ///     - prepares a partial note for the user (which will later on be used to refund the user any unspent fee),\n    ///     - sets a public teardown function, where at the end of the tx a partial note will be finalized\n    ///       with the refund amount (also denominated in AA),\n    ///     - sets itself as the `fee_payer` of the tx; meaning this contract will be responsible for ultimately\n    ///       transferring the `tx_fee` -- denominated in fee juice -- to the protocol, during the later \"teardown\"\n    ///       phase of this tx.\n    ///\n    /// Execution Phase:\n    /// 2. Then the private and public functions of the tx get executed.\n    ///\n    /// Teardown Phase:\n    /// 3. By this point, the protocol has computed the `tx_fee` (denominated in \"fee juice\"). So now we can\n    /// execute the \"teardown function\" which was lined-up during the earlier \"setup phase\".\n    /// Within the teardown function, we:\n    ///     - Compute how much of the `max_fee` (denominated in AA) will be refunded back to the user. Since\n    ///       the protocol-calculated `tx_fee` is denominated in fee juice, and not in this FPC's AA, an equivalent\n    ///       value of AA is computed based on the exchange rate between AA and fee juice,\n    ///     - finalize the refund note with a value of `max_fee - tx_fee` for the user.\n    ///\n    /// Protocol-enshrined fee-payment phase:\n    /// 4. The protocol deducts the protocol-calculated `tx_fee` (denominated in fee juice) from the `fee_payer`'s\n    /// balance (which in this case is this FPC's balance), which is a special storage slot in a protocol-controlled\n    /// \"fee juice\" contract.\n    ///\n    /// With this scheme a user has privately paid for the tx fee with an arbitrary AA (e.g. could be a stablecoin),\n    /// by paying this FPC. This FPC has in turn paid the protocol-mandated `tx_fee` (denominated in fee juice).\n    ///\n    /// ***Note:***\n    /// This flow allows us to pay for the tx with msg_sender's private balance of AA and hence msg_sender's identity\n    /// is not revealed. We do, however, reveal:\n    /// - the `max_fee`,\n    /// - which FPC has been used to make the payment,\n    /// - the asset which was used to make the payment.\n    // docs:start:fee_entrypoint_private\n    #[private]\n    fn fee_entrypoint_private(max_fee: u128, authwit_nonce: Field) {\n        let accepted_asset = storage.config.read().accepted_asset;\n\n        let user = context.msg_sender();\n        let token = Token::at(accepted_asset);\n\n        // TODO(#10805): Here we should check that `max_fee` converted to fee juice is enough to cover the tx\n        // fee juice/mana/gas limit. Currently the fee juice/AA exchange rate is fixed 1:1.\n\n        // Pull the max fee from the user's balance of the accepted asset to the public balance of this contract.\n        token.transfer_to_public(user, context.this_address(), max_fee, authwit_nonce).call(\n            &mut context,\n        );\n\n        // Prepare a partial note for the refund for the user.\n        let partial_note = token.prepare_private_balance_increase(user).call(&mut context);\n\n        // Set a public teardown function in which the refund will be paid back to the user by finalizing the partial note.\n        FPC::at(context.this_address())\n            ._complete_refund(accepted_asset, partial_note, max_fee)\n            .set_as_teardown(&mut context);\n\n        // Set the FPC as the fee payer of the tx.\n        context.set_as_fee_payer();\n    }\n    // docs:end:fee_entrypoint_private\n\n    /// Executed as a public teardown function and is responsible for completing the refund in the private fee payment\n    /// flow.\n    // docs:start:complete_refund\n    #[public]\n    #[internal]\n    fn _complete_refund(\n        accepted_asset: AztecAddress,\n        partial_note: PartialUintNote,\n        max_fee: u128,\n    ) {\n        let tx_fee = safe_cast_to_u128(context.transaction_fee());\n\n        // 1. Check that user funded the fee payer contract with at least the transaction fee.\n        // TODO(#10805): Nuke this check once we have a proper max_fee check in the fee_entrypoint_private.\n        assert(max_fee >= tx_fee, \"max fee not enough to cover tx fee\");\n\n        // 2. Compute the refund amount as the difference between funded amount and the tx fee.\n        // TODO(#10805): Introduce a real exchange rate\n        let refund_amount = max_fee - tx_fee;\n\n        Token::at(accepted_asset).finalize_transfer_to_private(refund_amount, partial_note).call(\n            &mut context,\n        );\n    }\n    // docs:end:complete_refund\n\n    /// Pays for the tx fee with msg_sender's public balance of accepted asset (AA). The maximum fee a user is willing\n    /// to pay is defined by `max_fee` and is denominated in AA.\n    ///\n    /// ## Overview\n    /// The refund flow works as follows:\n    /// Setup phase:\n    /// 1. This `fee_entrypoint_public` function:\n    ///     - Transfers the `max_fee` from the user's balance of the accepted asset to this contract.\n    ///     - Sets itself as the `fee_payer` of the tx.\n    ///     - Sets a public teardown function in which the refund will be paid back to the user in public.\n    ///\n    /// Execution phase:\n    /// 2. Then the private and public functions of the tx get executed.\n    ///\n    /// Teardown phase:\n    /// 3. At this point we know the tx fee so we can compute how much of AA the user needs to pay to FPC and how much\n    /// of it will be refunded back. We send the refund back to the user in public.\n    ///\n    /// Protocol-enshrined fee-payment phase:\n    /// 4. The protocol deducts the actual fee denominated in fee juice from the FPC's balance.\n    #[private]\n    fn fee_entrypoint_public(max_fee: u128, authwit_nonce: Field) {\n        let config = storage.config.read();\n\n        // We pull the max fee from the user's balance of the accepted asset to this contract.\n        // docs:start:public_call\n        Token::at(config.accepted_asset)\n            .transfer_in_public(context.msg_sender(), context.this_address(), max_fee, authwit_nonce\n                )\n            .enqueue(&mut context);\n        // docs:end:public_call\n\n        context.set_as_fee_payer();\n        FPC::at(context.this_address())\n            ._pay_refund(context.msg_sender(), max_fee, config.accepted_asset)\n            .set_as_teardown(&mut context);\n    }\n\n    /// Pays the refund to the `refund_recipient` as part of the public fee payment flow. The refund is the difference\n    /// between the `max_fee` and the actual fee. `accepted_asset` is the asset in which the refund is paid.\n    /// It's passed as an argument to avoid the need for another read from public storage.\n    #[public]\n    #[internal]\n    fn _pay_refund(refund_recipient: AztecAddress, max_fee: u128, accepted_asset: AztecAddress) {\n        let actual_fee = safe_cast_to_u128(context.transaction_fee());\n\n        assert(actual_fee <= max_fee, \"Max fee paid to the paymaster does not cover actual fee\");\n        // TODO(#10805): Introduce a real exchange rate\n        let refund = max_fee - actual_fee;\n\n        Token::at(accepted_asset)\n            .transfer_in_public(context.this_address(), refund_recipient, refund, 0)\n            .call(&mut context);\n    }\n\n    /// Pulls all the accepted asset funds from this contract to the `to` address. Only the admin can call\n    /// this function.\n    #[public]\n    fn pull_funds(to: AztecAddress) {\n        let config = storage.config.read();\n\n        assert(context.msg_sender() == config.admin, \"Only admin can pull funds\");\n\n        let token = Token::at(config.accepted_asset);\n\n        // We send the full balance to `to`.\n        let balance = token.balance_of_public(context.this_address()).view(&mut context);\n        token.transfer_in_public(context.this_address(), to, balance, 0).call(&mut context);\n    }\n\n    /// Note: Not marked as view as we need it to be callable as an entrypoint since in some places we need to obtain\n    /// this value before we have access to an account contract (kernels do not allow for static entrypoints).\n    #[private]\n    fn get_accepted_asset() -> AztecAddress {\n        storage.config.read().accepted_asset\n    }\n}\n"
    },
    "52": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/fees/fpc_contract/src/utils.nr",
      "source": "pub(crate) fn safe_cast_to_u128(field: Field) -> u128 {\n    field.assert_max_bit_size::<128>();\n    field as u128\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "62": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "63": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "70": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between a #[private] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[private] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[private] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[private] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[private] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp =\n            inputs.historical_header.global_variables.timestamp + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// TODO(https://github.com/AztecProtocol/aztec-packages/issues/14025) - we\n    /// are considering making msg_sender: Option<AztecAddress>, since\n    /// a returned value of `Option:none` will be clearer to developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `-1` for the first function call of the tx.\n    ///\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[private] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[private]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some historical block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[private] macro.\n    ///\n    /// # Arguments\n    /// * `returns_hasher` - A hasher containing the return values to hash\n    ///\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[private] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a heft function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "71": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between a #[public] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[public] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[public] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[public]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases, and is enforced by the protocol's kernel circuits.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the account or contract that called\n    ///   this function\n    ///\n    /// # Examples\n    /// ```rust\n    /// #[aztec(public)]\n    /// fn transfer(context: &mut PublicContext, to: AztecAddress, amount: u64) {\n    ///     let sender = context.msg_sender();\n    ///     // Only the sender can transfer their own tokens\n    ///     assert(sender == get_token_owner(), \"Unauthorized\");\n    /// }\n    /// ```\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    /// * Globally visible unlike private execution where it's contract-local\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[public] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "72": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "73": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "75": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "77": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "89": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "94": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    },
    "98": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "99": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    }
  }
}
