{
  "transpiled": true,
  "noir_version": "1.0.0-beta.11+5b65f9637e85a4177692c3190cb35ea678fb15e9-aztec",
  "name": "AMM",
  "functions": [
    {
      "name": "_add_liquidity",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "config",
            "type": {
              "kind": "struct",
              "path": "config::Config",
              "fields": [
                {
                  "name": "token0",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "token1",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "liquidity_token",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "refund_token0_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "refund_token1_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "liquidity_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount0_max",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount1_max",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount0_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount1_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "6314906928197983276": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14234046914994891820": {
            "error_kind": "string",
            "string": "AMOUNT_0_BELOW_MINIMUM"
          },
          "15854867267750979296": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY_MINTED"
          },
          "16715174358392770615": {
            "error_kind": "string",
            "string": "Function _add_liquidity can only be called internally"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18164859091538951175": {
            "error_kind": "string",
            "string": "AMOUNT_1_BELOW_MINIMUM"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "_remove_liquidity",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "config",
            "type": {
              "kind": "struct",
              "path": "config::Config",
              "fields": [
                {
                  "name": "token0",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "token1",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "liquidity_token",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "liquidity",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token0_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token1_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount0_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount1_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "13588333240659585881": {
            "error_kind": "string",
            "string": "INSUFFICIENT_1_AMOUNT"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14258647237672879755": {
            "error_kind": "string",
            "string": "Function _remove_liquidity can only be called internally"
          },
          "17059742737981442965": {
            "error_kind": "string",
            "string": "INSUFFICIENT_0_AMOUNT"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "_swap_exact_tokens_for_tokens",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token_in",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_out",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount_in",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount_out_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "token_out_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3366597361638591147": {
            "error_kind": "string",
            "string": "INSUFFICIENT_OUTPUT_AMOUNT"
          },
          "4669293913791681502": {
            "error_kind": "string",
            "string": "Function _swap_exact_tokens_for_tokens can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6314906928197983276": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7554404838130415698": {
            "error_kind": "string",
            "string": "INSUFFICIENT_INPUT_AMOUNT"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "_swap_tokens_for_exact_tokens",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "internal"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token_in",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_out",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount_in_max",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount_out",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "change_token_in_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_out_partial_note",
            "type": {
              "kind": "struct",
              "path": "uint_note::uint_note::PartialUintNote",
              "fields": [
                {
                  "name": "commitment",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3366597361638591147": {
            "error_kind": "string",
            "string": "INSUFFICIENT_OUTPUT_AMOUNT"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6314906928197983276": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8349750481146185694": {
            "error_kind": "string",
            "string": "Function _swap_tokens_for_exact_tokens can only be called internally"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "add_liquidity",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount0_max",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount1_max",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount0_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount1_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4456244908619624852": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "9973162865762580702": {
            "error_kind": "string",
            "string": "INCORRECT_TOKEN1_LIMITS"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11541850750363945201": {
            "error_kind": "string",
            "string": "INCORRECT_TOKEN0_LIMITS"
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15296099587266009905": {
            "error_kind": "string",
            "string": "INSUFFICIENT_INPUT_AMOUNTS"
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "verification_key": "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"
    },
    {
      "name": "constructor",
      "is_unconstrained": true,
      "custom_attributes": [
        "public",
        "initializer"
      ],
      "abi": {
        "parameters": [
          {
            "name": "token0",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token1",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "liquidity_token",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "get_amount_in_for_exact_out",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "balance_in",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "balance_out",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount_out",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3366597361638591147": {
            "error_kind": "string",
            "string": "INSUFFICIENT_OUTPUT_AMOUNT"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6314906928197983276": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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QmF9mm0WisXz79u1mwk+eSb44vn37Xjmj//isrEd57CY88d/sWysG/eNBzwLwuK0cd64bLx5Z0GwHrk2C8Ji3bhvPOBZEBanjfPGZeO68ebtm7dv3vmwMOxazJowedaExWnjvHHZuG7cNpaNdePNO/DKrAnWtSizJizOG5eN68ZtY9lYN+4bDzht3rR50+ZNmzdt3rR50+ZNmzdt3rR58+bNmzdv3rx58+bNmzdv3rx58+bNm3fWB+tJlVkfFueNy8Z147axbKwb940HPB9IrHt1rpX5uPYv6HOtTOeycd24bSwb68Z94wE3nxnU53zNhRm8pOn6fL2vBTQXt41lY924bzzguejV4mRcjPPGZeO6cdtYNtaN+8YDjo9Fusy18h52zedaeYt1477xgOf6mYvTxnnjsnHdePP2zds3b9+8ffOOzTs279i8Y/OOzTs271zX69q/oa/1M63Hea2fuXgEr/UzF6eN88Zl47px29i/t+hzzubCDk7pdWOuxTYXp43zxmXjunHbWDa2k7Ue5LXY5uIBzwX0FqeN88Zl47px29i816YNXecCeov7xgOeC+gtThvnjcvGdWP/yqTP2ZwLFZzSbDzguXre4rRx3rhsXDduG8+Tbca6cd94wHP1zsVp47xx2bhuPL12R80Cs3jAs8DMm2oWmMUz/jAuG9eNLb71Sq/VOxfrxn3jAc/VOxenjfPGZeO68ebVzaubVzevbt6+efvm7Zu3b96+efvm7Zu3b96+eWdFmvfVrEiL08Z547Jx3dimlNklncXGOvbXgp2L08YzZDEuG9eN28aysW7cNx7wrDeL08abd9YV65NfC3PaaPxamHNx33jAs64sThvnjWcvjRjXjdvGsrFu3Dce8OodnTzjJ+PZbvPP28aysW48z0uNBzxLyOK0cd64bFw3nudl13f1mk7WjfvGA169ppPTxnnjsrFw7m07r1lCFg94lpDF23nJdl6ynZds57VKyGTZWDfezku289LtvHQ7L93OS7fz0rrx1p66ted8cZrn3rfzWqVict64bLydV9/Oq2/n1bfz6tt90rf7ZGz3ydjOa2znNbbzGtt5je28xnZeY7tPxtaeg/aci4/Oc1+Lj9p5rcVHF7eNZWPOay0+upjzWouPLk4b543LxpzXSG1j2Vg37htv55UfG6eN88bzvIaxbKwb940HPJ9HFqeN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"
    },
    {
      "name": "get_amount_out_for_exact_in",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "balance_in",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "balance_out",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount_in",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "integer",
            "sign": "unsigned",
            "width": 128
          },
          "visibility": "public"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6314906928197983276": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7554404838130415698": {
            "error_kind": "string",
            "string": "INSUFFICIENT_INPUT_AMOUNT"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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"
    },
    {
      "name": "process_message",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [
          {
            "name": "message_ciphertext",
            "type": {
              "kind": "struct",
              "path": "std::collections::bounded_vec::BoundedVec",
              "fields": [
                {
                  "name": "storage",
                  "type": {
                    "kind": "array",
                    "length": 17,
                    "type": {
                      "kind": "field"
                    }
                  }
                },
                {
                  "name": "len",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "message_context",
            "type": {
              "kind": "struct",
              "path": "aztec::messages::processing::message_context::MessageContext",
              "fields": [
                {
                  "name": "tx_hash",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "unique_note_hashes_in_tx",
                  "type": {
                    "kind": "struct",
                    "path": "std::collections::bounded_vec::BoundedVec",
                    "fields": [
                      {
                        "name": "storage",
                        "type": {
                          "kind": "array",
                          "length": 64,
                          "type": {
                            "kind": "field"
                          }
                        }
                      },
                      {
                        "name": "len",
                        "type": {
                          "kind": "integer",
                          "sign": "unsigned",
                          "width": 32
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "first_nullifier_in_tx",
                  "type": {
                    "kind": "field"
                  }
                },
                {
                  "name": "recipient",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                    "fields": [
                      {
                        "name": "inner",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                }
              ]
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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6ta1TdvGNn6eVvOqUR7d/Xr68mrvVaN+esX4i+1geZJ9Jtkfa9h3pLx+vDTQq4Z/x4WJXZ9fmBxrPLwwOe5NZiqZXPndKo8vTI4dpzHse/mh45yeYsm62yrb7vxh9Or4DGvdnJT9FTr9+TfnGyYa/KLI0+sj8+/oOe3jZwPP334rX7/99tqQ03tajTXp27Ysx8/LJhzfVHn4bOBXb6o8nPLwLZfATb/lEH/8dOD4zsyzMflfvTHzsFnbdzTraW7M82Y9Pc36hp4jwgT1Hx5np9+ZI3cxKH9pPnS/0wn7PVWeLSTzixqPVpL5VY0n5+svbsplTRt8HdT09gDBs9/hXwwj8Vx8/yTxb41EsfDo/kKu/M7g3rMl4X9R5NknA84vmyVd/Sa3r99YS+n4kGDl0fZe1Y/tcbpIY0mU+sNl+OMCj47I9eng4nFRAb4plerXV3fnEuuuNe3vef9OiYfX3ek0qefhdfe5xqPr7qffTzyMBp6/SXUx2CRvlXh40X7cEV1bke29Eg/j8/o8O0+T+a7tC1D61kHtgxdrAGK7MP2tEnyfL7X3tmIbwRB/bysqn7+o22T63yqhfKOo+Xs7whokkt/bEeEVUqnv7YiuE/x1//feVpixiJO/d3Yyqyp5fquErfEkK/pOAV83b/u8rj8G5/ETPh8vv8RyQZ7f243Vw9zqh+3wXoHXQOU6mFn3xeaer92U13p3aV/f4O0S+lYJWYs/vbC9V0JJK5O3StS1Pv0rrd5rC+GLauWH9QPfLPHeQS3rMcVrSD69V4K0KqpvlmBHflgF9jdKrDve1+/gewe1OC//X29tRVnPJkp7qyU4r378QO1PI4np9PpUyvwC5f1uuT3eilXgh5/i39iNtZChlrcasq73WOoPCzQ9L8Di1S7vFbj+i+cHbxX44bXe32nEtUjVe0Gnad0Si3+4Be8exicTXY4FnrxgfbwPfTJP5vp0eOO42u1rBHT/uGL9+rX317X4aaW+stbE9Hp9/YW4V5XjY5MPl0983VYbd+ZffhT89XD29EXDJ98V/1Wr8iN8Nfl6Lta5zOsXh/ufYu+WuVjs4TWyk8q7ZVQ5VfZvaf9mGeNLvNf+nvXvlnHuUNvV3j1xbQ2AuG2/SP/Fifu4ir9dxbkY9/pmlT4LlON0ta/r/Ooc3oYAmuR3G9gr805berdpttsMb6fDdHxW9rhpznUeDtefazwbrv9FjS+H6//76//8wz/+9V//x9/+5R//4d/++i///P9ef+8/e6l//es//M+//dP9f//3v//zP27/9d/+//93/pf/+a9//dvf/vp//sf//dd/+cd/+l///q//1Cv1//aX6/6f/9b6S2n+atP//nd/Sa//7/q6NHK1/v/l9f9ft9g19//W//ArVcvfvf7H+7+IP3297l1f/+P//T/75v5/"
    },
    {
      "name": "public_dispatch",
      "is_unconstrained": true,
      "custom_attributes": [
        "public"
      ],
      "abi": {
        "parameters": [
          {
            "name": "selector",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": null,
        "error_types": {
          "2233873454491509486": {
            "error_kind": "string",
            "string": "Initializer address is not the contract deployer"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3366597361638591147": {
            "error_kind": "string",
            "string": "INSUFFICIENT_OUTPUT_AMOUNT"
          },
          "4669293913791681502": {
            "error_kind": "string",
            "string": "Function _swap_exact_tokens_for_tokens can only be called internally"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "6314906928197983276": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7554404838130415698": {
            "error_kind": "string",
            "string": "INSUFFICIENT_INPUT_AMOUNT"
          },
          "8349750481146185694": {
            "error_kind": "string",
            "string": "Function _swap_tokens_for_exact_tokens can only be called internally"
          },
          "10492081608786484886": {
            "error_kind": "fmtstring",
            "length": 27,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "13588333240659585881": {
            "error_kind": "string",
            "string": "INSUFFICIENT_1_AMOUNT"
          },
          "13699457482007836410": {
            "error_kind": "string",
            "string": "Not initialized"
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14234046914994891820": {
            "error_kind": "string",
            "string": "AMOUNT_0_BELOW_MINIMUM"
          },
          "14258647237672879755": {
            "error_kind": "string",
            "string": "Function _remove_liquidity can only be called internally"
          },
          "15854867267750979296": {
            "error_kind": "string",
            "string": "INSUFFICIENT_LIQUIDITY_MINTED"
          },
          "16715174358392770615": {
            "error_kind": "string",
            "string": "Function _add_liquidity can only be called internally"
          },
          "17059742737981442965": {
            "error_kind": "string",
            "string": "INSUFFICIENT_0_AMOUNT"
          },
          "17618083556256589634": {
            "error_kind": "string",
            "string": "Initialization hash does not match"
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18164859091538951175": {
            "error_kind": "string",
            "string": "AMOUNT_1_BELOW_MINIMUM"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tZ3bjuW2sYbfZa59IR6LlVcJgsBJnMCA4QTe9gY2DL/7Vv11Yk8gzerVq29mff2PWOKZVJGifv/yjx/+9tu//vrjz//89/98+dOff//yt19+/OmnH//115/+/ffvf/3x3z+f6u9fDvmnzPblT+W7L4Wq/dKXP9Xzd1X7tb/Z/uaJ33oU+7W/i/1dhv7Ww367/bL+ztNOl9+pv1Ts1/5e9veyv/kMP+R34bcdzX5Jf+W++J36W0/7JL+kv63Y77Bf1t/e7df+Hs1+z3DlOGEOB7uCLAQt/V12J4mp/LLdifXvfhz229VQL9XBrqjFfof96p16a/ard+rd/u6apj6KGRpsgFIcAmeQsk5AeQLIYLmyXGFXWOzwd1+G5CpAslVhGkiBKgyDJkVcBJaBRFRBas1ZfEOiqjANpivTFXJFcraeqRiSpQA+HIYDK0zJVgVRzmyZhQykDiicdtqZP1OiqjAMuivdleHKOKPRzlRMiSGA5L+awDBYosjdV3dgA3ZFqqwAHdWBDIorkr3tLAKS7FUYBs2V5kp3pZ+W+9maaFSH03I/I0ZoX4BpgBYGcGW5slyRfFboDqywpMEpLINSHeymq5rB1QXOolyIxhCQdnnm6pI8VBgGy5XlCruCVg9YCox2DyADiYaC3OIsJm5kINFQ8P8argxXpivS0BXYQFq6wjJYzcFvIW1HQfLwbA7lkAZvNILYqbSg5SQV1SisSIdlRE49tB7XSZMf0iMfUpyjgaYTclKpBy2jIhXSyEOUUoJCq0eQWOmg5dRq0HSSKjoLqAex0whthDZDk75LSTovI3KSVBpNJ0nllDzA8GM0nGr8bw2thdZSYyfpv4yWkzQxI3KacTep3kpSv+cB6kHsJBXIiJykChlNo3YcQcMJaVMKrcZ1UnOmlBGGOqPQUB5KPWg5IW1KEWJGCGkYShQahRWkDYS0KZETR1w4rLCH6EcL8rj0ElpxK73WII9fb0dQDworPUL0CDFKUGhIZQeNIHaiFkROqH9KEYLDCqfmVgZSOUDLSdqWkvSZk0AyHZCyHJisVJBoEtMhbd+InaQdrQJaTtIfGIVGoVFoMg0wmk5SWkbDaEpNNJK7SaymtCMjdmrxvy20HloPTSZYRuQko4TRdJLhyijuJiOFkVg+QMuJWxAZkUxPjaZTOYJ6EDshbUqhtbhO2tFqoOE0QkN5KC0npE1pOlGEoAgh7UhphbbCCtKmREYLaVMaQW5llRYUIWoNCk3q2uqg6YRUKvWg5SS9hVGEmGFlhkZhBakk0GmFcV+pf0bkxKGxa3zUoOkkJWg0gthJxigjuZvEgGWMMiKnHloPbYQmaVOSPsJoBLGTpM0o7iY9oZFYxvOStC2jqVQxUzDqQewkJWhETlKCRsuphdbiOhnBeICWE9KmNJ2QNqUeFCEoQkj/p7RCW2EFaVMaQWxUjhbkVjDLMPIQmGUYpRZWWg/y+JVegzwuZYSVESFGhJgRl0glZhk8QeQkvbzRCGInaY1GHqIeNSi0UoLECoPYCfVUKbQWWgsNZalETihLpekkbdAo7iZtUGnhOfbsyCuencsxgPKceCxBPJbKU+SJFCjDk+MMbKl2dRic86jigOukGmIS4Tgcu3S7HbAManNwpbnSXOn6ZF+7lLDCcGCD2RyWgTTPc2IKXIHSQB1T5VQ51HHUxBmIB2PDEYiHY8OemMZa3GJ0qJK0Ib1Jkef2iqHaEaUg1Weg8BT5SFyOE0VqGMGmRlIRFgiel5ZIga0mzsDeE9ULUae5SCoGcMAsDsOADodQ2AB5L1Vncgmyq8icJSd0B7stnpUV7LZUXanTQCaFsEhtOXW/qnu4URz8tsMiR9NvO12h5kBucY0gv4o9HFt011EdLHKrFAdX6uGAbJZmuLQcFFEO0nrxQO2YqicEAzFgukVPyJoeIU/IIleWR3HNuCdnTLR6yY1Yq5diqsUscjGL7CXCXiLcDgfLa+6umOvthOX35BExYe07cCPtO4CUqlctXm5xucXlEWKPEJsf8LByOcH8dUc57J4Nj+SGtdqNTqTAlqoMtueYJYjSMZyB0kc7pjrzWiTLkAPRYxmmilZjmDfmvAWHWg7cogNxY4KDVNSGC2QMKuLROjt9CkTaGoIhbQ3B0L+Lt+lECpSWY4hy6rCABIkD6BxBjsRUV6pSVo4cyKlyqBXVz3AFYsAypMCaKgYsRXQMHY7h1hM5sOMWE7gCUYSGM1BTrNgTMxhlMMpgK9WVKqfKYaEdYbeVI3EE1lRrXlvTAkqzw9WN0lRETTUciRw4emKq8Csbwpi0gKYFqyjXiheuNRSsYaooWHGUNTz/K6pPXBGlaSi3ED9Sw5P/+SQLpMCWaksVaTOcgSPVkSqK0HAkciBaoWGqaIWGuPHC0kFJnI7jwC0YOBI5sLRECsSEyzCD1QzWMlhLtafaUx1pYabdmXdDTTVMdeW1Ky2gNMXZdNaMnrgcJ2ZKhjMQ/Y5hqqi/hjBWBVGwhrhWGu9EwRqmioIVD8uJM3CmitJURGnOCYQqVRlOhPM54ES45os4Xxqc86dDQBB1UhwxDX55xxGIsjCUfBC3zOkba4mpjlQRScMZSKkikoqIJHUgVOmulkZSErQ0kkCNpOIKRJ6RJBMTBsdUZ6rIM0XkmWGqqPaK6LmIgVhKkuzD87ohei7DFYjppyGCSVbjAd2wH4krUBepKpAM+3HUQL2bopSQuDf6gSwxTBXlZohbdEFkyZqCyJKFZTuUkCKlSqliUDMcgZwqbyo7FvR9hisQnYJhqugGDePGpZVE3IKBHIjZu6EYY6w6oiIaUiBSbDgSOZAyGGWwlcFWBlsZjEPFWrFjWKilJUYka0215rUtLSDF4uzoOnYrooIbzkBNkBQ3HPBFnvtPxN0mFlxbYqj6nGxIgWhvhqnWVFFCihpfxRGICm64qRw48sYjozNxiwWcgaiThjDGWDE+EnviCkRzMpyOWKt27IkRTEdpwwxWU615bUsLPe32iCQe5B3z2pEWJMVVfBbnkveRuAKlNA2xMeFowOk4sD3BUJaOj4518yOxJ65ArBwbzsCWwVoGaxmsp9pTHanOtDDTLuXdsO1CcaW68lpOCwy7A8iO8AQ4UiC2ZRjOwJpqHYkwJt3KbBTYce0CzsCRKlb2Dyk3DLdVNyTI0GG4Ul2pSmeuiEHYMVXsJFHEZpJSgFCldZPuP1BMtaeKslAcLTFVlIUiNiGIg6ZjnbyK96RjFbyKG6Qv7DdQRD5guwUGVsfhFvA07pgqpUqpapZI9i3UXyCj/hqmWlLV3AFq7iim2lJFpTWMu7Fu1lBcgSPVQYEzbzwzOkiQ7Pfo8IY7ciCaaZX8xTDuSIbnVLkkjkQOLC0xg9UMVjNYzWAtg7VUe1470sJIu7Mmpkp5LaUFTaZsW8GDuSH2qQDLcQSisLB9Bc5uxxWo8SUg1CWIEjJMdaSqUQdq1BVTpVRRqxVXSRyB6GEMN5Ud8TTuGNHB03gV98KJMxAlZCjGxNMw8AjuyIFIpiEFooQM08LIYDODzQxGGYwy2Ep15bWcFjjs4hHcMdXSEsNC02Q2IAei91TsNVF3yg04zBVcma7MYUCHgyvLldUd2ADpACyFrn67A7gCw9M/enj6hw7iik03A45uzv2BLWew6JHuHmkskncAGazq4Aq7wqZgNB4ANijdYRlIjBTIINznJ1Jgr4mpjlRHqrMkjkA6EnsiB6688UpjHLcwrzv2s6m7X+JrTnVFeDanoDrVFTlwUCBmeoYZjI5Ed8ufi/w1cQbCJWHonv8zlS1R/aHD3eqDzCs9yLzSJ3QHNmiu2JbEQd3d1QPr4I6IHwM5cKY63SK5RXKLyyO0PEK2o/IEU5YtE4zlmyrH8l2Vw93rY9m+yhOGg9122dbKE+y2q7tiywRj+fbKk9hp+lXTw1F18Nsuj9zy27IrtkwwzLcuecXHDCzu3B5cRmBN1RPibvXBXiLsCWFb7xjsCcGitoJF0XzruOfMmFCNGxEFrlTD8zywnO3ozu2pj+OGqZaSOBI5sPbEVFtLpMCet+ipDnd5T/O1k+B0l/dUBzs2cWIt23C5y3uqV70hGLvLe6pXHViOEYjnhzaBGFygYkg3TLWlqsOeIgf2VHuqGN0NVyBGd0MKpFQxuitioOgHsCdyIIYLcdyfuByxju04A5Fiw56YwWoGqxmspdpS7an2tDDS7sy7YSRUpFQpr6W0gCcm2QY7dXRX5JI4EtlRB3rDVDHQG8KY1JKGgjXEtbLBt6FgDVNFwfYFxG7lAxuPe2KqM9W5AmVodUx1pYpkKmJibTgdOybWhqmiNA1x4wpcgbUl4hZNEKVpOAPxoGXYE1fgyGAjg80MNlOlVCnVlRZW2uW8m+4Gb9i93RPj2lFqIuxKEcLX7jgSORDzccMV2FPFvEgRMyNZGziRAzE7HQRcgZSqFiwLajIVKRD1VzzlJ05HbMtz7IkrECk2zGA1g9UM1lJtqfZUe1oYaXfk3ZBMw1Qpr6W0gI5pYmM9HjsMORAdkyE5qnfAMFU8ChvCmJQxof4a4lopIUL9NUwVvZGsDUzsEDAcqY5U0RspoqYapoq2aYh8kDImTdACLkfsqHdMVQsLiOppmKqWkCLyTGoJNupVWcA4kQMRdUVEXRFRlxWOqQ4IRURdEVXOUG4syw9TfRGypDDVF6FYUi2pop4ZjsCWattUDtRUKK5AjIWGqWIsNMwbU0aH8hYrb4yxUBYwJnYJGKKEDJFnLK9paDKBmkzFkciBqHKGaaFlsJbBWgbrqfZUR6ozLcy0S3k3dCCKK9WV13JawAAo6ymEXXmGSJvhDEQRyhoJ6XRG1khIpzOGqfZUUYSGHDhSHami1zBcgeg1DClwpQp3qCLnjTmjg+FAFnJInRWGKxCdo6ycELYOGKK9GY5EDsRwYJjBegbrGaxnsJHBRqozr6W0QGl3ZSRXqpzXclrQFDNeF6JA1FRFLU1FKQsuQAkmaySkcxjDVHuqaJCKSJBhqjNV1FRFlKbhDIQjxjBVlKZh3pgjOvBnVNlZeyIFojQNYUzeqMJbdY4jkQNRmoYU2DNYz2A9g40MNjLYTHXmtZQWVtpdGUlOlfNaDgtDUyxljC2Hjhyopamobh/SaQvAle6KOXII7hEFV6YrcxpQcRgG5n0i25F4COqORMWeyI6YoBji+U8Aj3wCkrNSdNhWqLAMpivTFXIF7zoBhgEfDt1B/UhE9q7oCfr4T9j4r7AMbOca+V5CIntj9ARXbOfaCeZ1IEwTjPyq6eFsMyS5s4N8LyG5s4MwX1AgA98USVh0AGGmQAALt8xrQ+7sIN9LSO7sOE27Yj4CgrMDz/pkuwiBw/0LhLULw5mqJ2SRWyS36AnxvYS0PCGLXTGvDfHhXgeyXYTA4v6FEymwpmqv8BL2CCi4RS8R30t4guU1D1eGRRETBuSnbiJUcs8DYfu+YWy2O5EDOVX2a1e6PFa6PFa6PE5MFZ4cw57IgS1VlJV4NBY288OjsbCbHx6NpX4OcWMs7N13ZPNoLN1I2BAMnkxxC5w1qAeGn2PBz9EOsYuXAttRgRRYUi2pSh/rOANbqi1VfdNWcSRyoJSYY6rSCTjixh1vnJbEGYi3cWURc2FBw5EDuSWSI/YlOI7ECIYtCo6p1lRrqi0t9LTb826jJqY689qZFibsTkHqiStw1cQZyCUxVLxT6AhjUvJNC1YR17KgFqxiqihYaTgLrxYa9lRRmoooTfGNL/g5mnjBF/wcjqlSqkiborRCx1Q5VRQhsKPSGs7AUhJTxSvWhrgxAVdga4m4heQO1kIcZyDeFjfsiStwZrCZwSiDUaor1ZUqpwUOu/BzOHJgSbXktbUmwq6U5tDSVByJHNhb4gocqaL+KqL+ymrvwtsMhjLgNVknXfBzGK5UUbDo5QYKFjjRIA0lvrI4urCH4ayNQKhSQphIOHIgyk0R5SZrlCdS4Eh1pIqmp4gSqgwcgSvVlapGXXE5YtphqFFXlKijB8f6iqEMbY4UiH5SEfUMXTzeWjCcqcocyRC53ioQqrRCTDUM0T8YsiPWUpqcRrDwGmETB/daqFGGqdZU0XAU0XAMU+2pogAUUQCGMxDVyDBVPXdBMW9MGR1N2wJSIBqOIYxJAcCN4TgSORC9vSEF1gxWM1jNYC2DtQzWU+157UgLM+3OjCSlSnktpQWkWNzeC0sxjmzIeKPQUZ8CzpRXBzKI17v4iNe7+GhH4gjsqdq7Xoz3BwGkU3Q+bPGXD1v85YNdscVfxhQDUHTSfkJ3YIPaHMigVQed0XGxNTsuttR1rpoVh2Fgb8RwmaGwAdmbSKy7GJX8KvZwtmbHxV7t4WqvkHC1RVSuxRWbjjMOHYDFWpdT86uah+vFYThY5KrNX7kOV2ztkbHNAZNnxt4GR19o5bp6YqqeEDgLBJo9V3DzhDR7R4mbJ6RVV+y5guE00HvqmwWK8YYSt3hDifWlQEO3ON2il4gfrcONPEL2XMFtubI8iv6AxM0fkLh7Qro9IHH3EvFDdrjbAxL7MTvcmyv2gMTd3xpjfYMANHzSzrpL0ZAD4zUe7jNVymvjyYL18B1DCuRUYzGV9QUCw7gF9i46dntE4KGLqZIGffGw4QJ9o0fa50DjNRz2iHB2Q4c9IvCIN3oYuxQdVyBGlY5gGFXkNRPWsdwwVU4VkzQg3g9wTLWkirFREd2t4QjEWTiGm8qB6G5lzY11sFfEWGOIW0iFxKsCjiORAzXFihS4MtjKYCuDcaocKh2h6mzAMOxizcJxBbZUW17b0wLmCDj/RucIhj1xBWIuakiBlCrmoop6slEFrkAMqbKOxjiIQHEdNRGq1JKlhxspporSVERpyirYiVAlQTh8wDHVkaqmTZEDZ6ozVRSh4QrEU5MhBXKqmC4A4bRoEyf8YEg15EBMF+SdFcZbDoaYchvOQKTYsCdmsJ7BegYbqY5UZ6ozLVDaXXk31FRFTpXzWnYLcn4RDDdlSka9dR4bczImhs6bjnrsDJsDjCJ2xvUTjEJ23nQUs6x+CXMyGqgxileWxYRFx6kqByYiTZa1yoFdmcEjGaXpLHmCc1gOTEeCN71tOlql80wem460GCMtOMnlwKKHM8rNeSSjV3VGHOSMiQNrHMGbju7UGP0pDeWZ3Da9bXrvGyPOyH9MSxqRMifPTZ+bjnIxRrnQUqZkdJjKTdNijLSgHJuWi/Gma1qUkRac03KoJwJnxRzqisBpJ4f6Ioznps9NR6fhvJLXpq9NR71ypmBsvgieyWXT0Y6cMw7qmXDGvVAW2IMRTMmoe2sqz2T0m85945WMjsR5C0tbWNrC0hZ2bWHXpnNej4lMcNofpWy86XW7vm52NB9QN3AwkjPqqjMnI42M+oB9GMGbTpuOumqMdDlvOm86RglldVk4j2SZrgXvOifXtnHGDbtHG86MObB91Bll7QybqCd6cqFz33glo6ydZzJtYWkLS1vYtYVdW1jedM7rcYaDczk2zjjreYfO2/V1s6P5gHquZx86r2R4pZx9U/PJupXWeCZT2XjTMSs/0J9gshOcOqY7wZteNr1set30uult09um903vmz42fWw6tjk6z2TadNr0tel6loUxJ2Mlz3kF60kQzhkH3tKOfSDOtWyc92I9qcO4b5xxgO8keIvDlg+85QNv+cBbPthyj/EWB9rutbY4rO1evMUh60A5sg4UXfcxLmXjkVyPjfvGnNzaxiu5b/fqWxzGdq+xxWFu95pbHOZ2L9riQNu91haHtd2Ltzhw3kvPmnDOe8GzE9w3zjjonEqWrk/G2O3MyejbnVfy2MKOTdf+TRmeM2PMqZw3nTdd+3MwfDzBaV+Xgpw3fUsLXlh1bpudttnvZWM4cboyJ2sal/JKnpsOR6HzTMZ5tMbaPxsjbsj/pmk03nSMy86I2wCrs9B4JetbGcacrO85GG/62K7XvlpZ32royit5ZfybjsXKW7rw5mrwSC6ZV9gREjwjjb2VjTddxxrjTIt6hJwz/l3HGuPMn05t401f2/X67gYYez66LMYWPTKyH3pWKo6OlaVQ4ZVcN13qXj+Qb9gG0uXl15Mlzv1Q++LqcZ6bLvPhLguEwpyMXRfOlIzzg53HxltY3sLyCp5H2zhtYjmnH2gXmP/0YylTct90HIRrrGk0HsnYR+K89EDiE6W6GSIlhjMQjmtDcsQ+VMe4Fps9+iBlSf/A/bAW46x3Md6uwWHLg5U5GAsywRJvnPRa9OBlZ0qum143vW261G9nqd/dztLFUdLG2InjZ+yWjWcybWGlr+l9KoudjnyAF8UYvpNgTkad7kt5JSMtzjNZ5g3BfeMtbN9s9k0fm82x2ZybzbnZnFtY2sLSFhbLHTiJucCzoqxHO3ZxnBY93LE31fXQbOV6bDw25mS0YXlf4+SBuBXllYxDto1RLs7bNQt2qjInaxmBMZYHUzLi7LzpOO5bzlcqelCjs5aLMtqqMyWPLSzaqvNmR9PSlcfGnKzpMqZkLhtn2HocG+962qylbZw2q6Z3KFOypteYk/tIRptypigX7PsIHsmUOs6L0L6lYkzVfqNiR6Yz6rPx3K6Z0Z/URn3jTUce6gnUGF+duW6cOjZbBG96KRsP7x/sdEfnldxmci8bb2FRdhX1AX6EXrvySMZ9nSkZY4kzJ7ctbM+w+IJAlw0GcrJ333glIy3Om652ljLa8qGMtoz2ojscnVeyntVvTMm06ehjnTebvOmcOh19400vbeOMA/Y/Bs9k1LdWlFeypsUYcUYe2ncHjGeyfn3AeNM1zmgXeJZ2Rv0x1n7SGPFBnuu45gybaCM6rjmP5LHpY9PnpqPtKGv/D7/AOW2W9JaivJJRLsbo/53JWY8cDF7JpSdjHJHtUkUP+HNGP+Y8g7WvNlY7Qxn2CYwylcVX4ZmMTws4j2Tkm/Omo3yN52ZzbjptOm362vS1xYG3OPB2L9QHZe17ZXX5ZPS9zjMZ84FalMfGnIw67LzpHP1qqxx9pp7DZ9yOmVz6xtF/6gF8wZveol/VM/ice91408emj02fZePoGxv81MErec1kLhtnWOxXt7R3lKOmq1PZmJPXdo3Oi1mZgsdRN455ZsOSdfBIrpteN71tOsZW50zj6JlGvHkXzMloy84ZFr5US/vUsXUpZ/liydh5btfoPB9phM80eNc54jxzbG04qt6ZN51Tx6ax4KwDVDKNOKzeuWYaSef5xpScY2vXPkdWeOXrC4iz6mgvxpg/O69kzZOmPJNRP503nTadNn1t+tp0rVdVeQZjrS64b7ySS914C4t+Q9OL15g6vk/Si6bRmCKNRdNovOmaRmPYGWCtA8a7jvycYIwRzpmfRfscMPYgB8/kUjfO+OB96+DterQd581+y/tWS+8ff3z3xb8E9tdff/nhB/kQ2PZpsD///uU/3//yw8+/fvnTz7/99NN3X/73+59+w0X/85/vf8bvr9//cv7vmbs//PyP8/c0+M8ff/pB6I/vMvRxHVQqm4U+604PA6dj9FETZ133CEgTeMZExWvaMHEuiPKliXYTi47RWKMh55mFEeoPRwP7IjQaZyk9lZIVsTjnROXSxLw2sdizk48RBs51xocN0AoD69LAujYgvpliJuQjQFmm57j4xgjf5ATJqrDmBK0tHnM8XLO6LNRrkZ6Lj5eZKVO4y7TIVNDTck6ltvpZ3rYSOX/s0sqQIwDVyCxziwm9tXFTQ88uaYWRc949rmqoeF0vs6TiXQHNk9O5fVnNb1MzG0dqVr1OzU0lk+P8vXjPCUPamF+VDd3EYxWv6ufc9MbGw/Fo1zYezg++zI96U1dpers/H6/CQn9HJKi2qB1E15God7VjeQcmM9vLzKg31bTiwFLN0PMx/9rGo/G4sfFwfqx+nR/zMwtl9ayh47rd15vetB44IkBz9KhbV/hVk638guHtPiZ4B8Jicpp50shxbEYuu7F2V0EGx5QhB0mpbo+XzMySWeWyZNpNZ3rOCWPyMyjL5fQ8PGzj9OaOGdmxtt706+y4G7Fr84FunauCl0NUoxfUkNuItJIRmTcRuRv4eUU8jq3xr7cm+m1nOjwa8qpxzh1qeWvjZuA/V9y8XMao2XTbOyzE9GOMPRaPW5jRh53Yn7IQQ9OY2+SlvSMvZVeOdYLb9Py/8vKuH+0tOtK+jmsbd/UzirRvE6hzuv/Wwl3PU7jEyHTwtY2byjmiA9wnLe+yENPJWcZz6cChlZaOXp+zQSV6HbpJyTe6rnj4k66rPTWXXNFjyELkZT8sj+WXVeMoMact/cbG/Hg1H/Txaj7WR6v54I9X83l8tJrfWniomt+mo+ZEch/U3mXjwWp+X0PzAZD3J4Svn3bubHDUrtNTdD3bmPPjs427eMjkK+LR13U87p7u5b2kyJDRj6tmP/n2OZRGPofy8UzfUbPd132m8HVqqNxNe0a0t22UH+8p2p6RuC7aOydDq/GY0M6lxYzF2ycN6rcDfYmBfm4ly2+nTXTTj3acgK6Z0Xq7tvGCfpRe0I/Sh/tRekE/uj7cj64P96P0gn6UXtCP3tfQ5ZVcji++rF1r3D3Up4v1ZOKrbmPdVFFxKbR0L7TLJ9Db1FD0X4M2X9x/peauJz16JOZceMlcrV8lhj/eVvj4aFvh8vG2wvWjbeXWwkNt5TYdD7aVWxuvaCuUmUHjunbx3QNTxYvbNqqcfuyras533eiaMUwv6pdV9D4ix6oZkePa53zcVdLSMiqykHtp5c6bf3oWw+3TTofHtTf/uKto4TOex82If7zEm3+8xJ1/l5wZbvTZbrz5x3xBx1wOekHPfFdPZlY2ejNd/8pte9y6S1esPrXON1X2prJxrV7CchzE1ayu3NmYzev8fDPBfTvlv8nSGXGYlS4X8+4MjBYx6E8ZCO/1pPWMAaoUI1x7aj3yWCXWI4+1VYqv1yPvPCbYNWuLu9s8/+v1yIdN8KWJuwqxjpjnr7N+X/dft73g9gR39qR0s6Z5Z+aoYeXoNx1Hra/oB+8Wnd6xrHmbII51vFL4JkHjJQman5+gsbLe35XQTa0lWm7kXEe7ichdf9rwDoyvLPaPJ6fU+tSj9hkuknNWqWNe1/1WX+AEKa29wgtym6JcdDm53exQaC+pt+0l9fbxMmr9qV6ORqSH5lbOXw+/d2tR79hzcXxyptCY3oLk9N7L5PT60dnEo7GY5XpO028mrVSi0lPdtuV8PRjfGjmfhCgbYNn8CXO+xwo+ImBW6vb8/E4ruQHktNKurbxggvEOI89NMSinfKc3r17PW+/GjCgcohsT4yUzg9E+u+1RjykobRsO/is541Pb3haLdRzXsaAXtL07I4+3vXsrj7a9b1h5sO3N8oK297iRJ9veitTI4dzPtL11TK/wcoTxpYl5U1nr4FjZfdPNl3fYmOF+Ogv6eM7G4Jo2ylM2Wosh6/T4jGsbN/OAzuHdkG+kPmkjXAqdmZ+NR2wIOY7jKRujxnRx1Pa0jVht2rcgvKtcek0Xy3zWxor58yjrORsrNiu3009zaeNuxerRPP2GjQ/naT9yOfOg5/Kjl3hUOx2k13X9rgtqfdsG1p7qxXrsElznuuRTJnLv05r0pInlQ+6ixpcmbtescHydOVve7HCZjxv5+OxhT8oq17lxt2D18OzhftWrhhUcGHc5Yt9bmePYFs/mpZW7tZqSO3zPtpkJ6u/I19Wjlu0bSd9Ty3KHiZwyfWmC+wtq2Z2RF9SyTIocTn2dlFfMUe+MPF7L7q08WMvq3dLVC2rZm7WEeZmv9bjfahdbjeXgkX6dmPqCyf83rDw4+f+Wlccm//WYH5/8v8PIc5N/Ob7bC/mctT7TlcjJzG5iVn7SRFS12ctzJmJzPe8vCL3LRGzx58n9KRMjegCm4zIv6t37UnLaWN/WBLbs+MrIzeA9jhp7RY5Gz5mI0Xsc+8PD407VA8db+HLNWNf5sT5zhHgbj3FcFm29e13qHCajho3tLcWv2/2djYeHiG9YeXSIqO1Thwg5N5AzIns9q+8xsnKplK5H8Hq3evXoZOTWyCuq2pvEzOsqf7d29XBV45dUNX5FVbtdunpBVWscq9Anj+tacvf+wMMO3nq3bvWaFadz7W1mgtpxnSD61Br7Nh7jetC6W7V6dAJ9a+Txed69lUfned+w8uA8r7cXzPMeN/LcPO9cLMx3U+UEhctS7vMVzef2taoXNR9emaBarxPEn9x89njc9EujvKD53Bl5vPncW3m0+XzDyoPN524B6+Hm87iRp5tPvHIhp8Jcd5J3L1o9/jR8a+XxYl4vKeb1imKe9QXF/LiRZ4u5xWbsc/l9XG55qLfe7JwU930H5Ffe7MdtXHvmv2Ej9vr3OV9gg+gZz/yZkVlfe3/uwbr00eKVuLNg+DkjRDkIEl8PgvSKTQKVPnuTwJmIWHyRxF0PgvSpjv638Vjlut3crUY9+tRDr/DBfsPKo08963N9sGdmZv/a97chvs7YVV/wbLzq59aSPTF84x67W5Z6eKp0u0D2cDW5t/JwNVmfXE24ZcfGN16Hu3eyHq4md0ZeUU22xIzjuO6lub2gmtwZebya3Ft5tJrw/NxqQi326Zy8bqrJesX4x/zZ4x+1eLlcEnfpf2xH+dQq+zYePK/j8YIqe2vk4aeDb1h58OngW1Yeezpod29oPfp08A4jTz4dUM85KHV6biJLY3trbVwbafdWHmyDrdRPb4MjXuGXxLXrBPXPbYNv4nG9BNjuzuZ7uA3eGXm8Dd5bebQNfsPKg23wbsXp4Tb4uJFn2yCVHMJu1lfa7YGBUe1rvdwVeW8hHiQrj6cs5JF052VPxiFfce5PWaB4m476c6mgGfvD+bmcXOGXXn191MJ8Mg7R6Bevp3wc54wsO59V2nNDwxpphK+XqVt7wa6sWyOv6I7fJKaP68S8YF/WrZGHZ/HfsPLgLL71z/UJ1INbnkHE17sqWn+FF6v1z/ZinYnYjufk610EODjp86rsV/GY17P4/ooq21/xuss3rDw6g+iveN2ljRe87vIOI8/NIKp8+duNyBeCn+mqaynxLm4t5dpIG694/7WNz37/tcp3VDNBrVwn6FO3an0Vj3m5K6LdnQT4cBu8M/J4G7y38mgb/IaVB9vg7C9og48bebYNtjxGT75ycl3Kdx1Tyc1nb2pseY8NihZYrud+9zZqnCAjX2R7Nh4jbdBzNratZ3T0j9so/JwNyjPG3jyhvc/GdpR6e9IG53nb5VkbuSC8rsv2G5U9ng2qfGrmuQGnz5lG+Ekj48iYjNqeNBJdUT076OunlFVe8JSyyucON28SM28S84LTBW6NPP6Ucm/l0aeURZ/7lFJWjHtyVN+1W3Dx55bwm3hcn4nV+AX7s26NPF7C91YeLeHbd7ceK+G7zzC1eC+478fI/NcHkO4WtbYjGzIKbw+Kv9v8GidA0nbYynvOCVtp4Pqksm+cEdjXdhI4X34q41tWwqH4ESsjnYon87NxyU9dlFEuTwjqd2s/8rm9iMsY25mFX1u5O1qkxcyqtm3gfN/R9Y+dr3n/SYMeH2aY47nPKoQ3bOzDTHu0ucm3V2MmUun6Gyb97pDBLJO+nZf49UdM7qOxTXapXFbUexsjk8Lt8oG13y5endUv/N/y8b9nYnJWiNz7flwfqdVvP3B1tpc87mGW+lxM8vypVo7r4r1b7DnvHoPdyWs9F5M4PVFiMq9jcneI67bVrvVVniudsvLMwHqTJ/X+pOHYdCufZCvPxKRv6/vnwHedJ3fnDn688XWsoXo0ro/XvbeRM+8+Rr1Oyv1BGnl8fN+75vfEJPeWnjzWdUzokxtfp3wFplNt1zHhT258PY9MkJhcd42tfHLj6+vIerJu8uT2tMFXNL4PT1XLWtuHt+gpC9knLnrGQu9xJFDf53enj+XROJTsg8q2VPr1RObWxIwOtazxlIm2fZuSn4vFqJGQsX3y710msjzG4ucSkt7DVp9LSMsOrI2nEvLoye13scg338t+3PF7TGz74vez895jgo/NQf2UCeq5G2E+Y4BjE/q+KvqeROzHC8+bT2XdHSL48ZbOeaBCfS4jopkzjQ/m5HMGHjvC+/jos/3x0Wf7OwMPHSJ+V5+vDxH/y/nn93//8Ze/bt/O/v0PMfXLj9//7acf7M9//vbz37f//fX//uP/87dffvzppx//9df//PLvv//wj99++UEsyf99OeyfP1c6R71zwan85bsvDX+fHuRKNM+/h/y9Bn1Xucj/FwRopzvm/IdEKCLIJ4TPf9Zf/pAo/z8="
    },
    {
      "name": "remove_liquidity",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "liquidity",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount0_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount1_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4456244908619624852": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "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",
      "verification_key": "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"
    },
    {
      "name": "swap_exact_tokens_for_tokens",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_in",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_out",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount_in",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount_out_min",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4456244908619624852": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11096770892590629967": {
            "error_kind": "string",
            "string": "TOKEN_IN_IS_INVALID"
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14520021557936622750": {
            "error_kind": "string",
            "string": "SAME_TOKEN_SWAP"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18208603774526826647": {
            "error_kind": "string",
            "string": "TOKEN_OUT_IS_INVALID"
          }
        }
      },
      "bytecode": "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",
      "debug_symbols": "tb3djiS/cad9LzrWQTIYH+TeirEwtF7tQoAgG7K9wAvD9/4Wg4z4sXvU7OyqmhPP479m4slMZkRlkkzyv/7wv//8v/7z//7zX/72f/713//wP/7pv/7wv/7+l7/+9S//95//+q//8qf/+Mu//u3xX//rD9f4P4X/8D8KXdd///EPZfz/ffz/f/xDl/mHzj9s/tHmH93/KNe1/izrT1p/1vUnrz9l/anrT1t/tvXnildWvLLilRWvrHhlxSsrXlnxyopXVryy4tGKRyserXi04tGKRyserXi04tGKRyteXfHqildXvLri1RWvrnh1xasrXl3x6orHKx6veLzi8YrHKx6veLzi8YrHKx6veLLiyYonK56seLLiyYonj3gy/rT1Z1t/9vmnXuvPsv6k9Wddf/L6U9afK56uePqIp+PPPv+0a/1Z1p+0/qzrz0e8Pv4cx1cHaIAFtIC+oF0B46x5AAXUAA6QAA2wgBbQF/QrICL3iNwjsmfLOFfPFwcNGJHHZfascegTaCQOOZQACqgBHCABGmABLaAvKBG5ROQSkUtEHmlEdYAEaIAFtIC+YCTThBJAATUgIlNEpohMEZkiMkXkGpFrRK4RuUbkGpFrRK4RuUbkGpFrROaIzBF5pBjJgBrAARKgARbQAvqCkWoTSkBElogsEVkiskRkicgSkSUia0TWiKwRWSOyRmSNyBqRNSJrRNaIbBHZIrJFZIvIFpEtIltEtohsEdkicovILSK3iNwicovILSK3iNwicovILSL3iNwjco/IPSL3iNwjco/IPSL3iNxX5HpdASVgRG4DagAHSIAGWEAL6As8Bx1KQEQuEblE5BKRRw7WMsACWsAjcn0UyDpycEIJoIAawAESoAEW0AIico3INSLXiFxX3aiVAyRAAyygBayKVPkKKAEUEJE5InNE5og8crD2AS2gLxg5OKEEUEAN4AAJ0ICILBFZIrJGZI3IIwf5GlADOEACNMACWkBfMHJwQgmIyBaRLSJbRB45yHWABbSAEdkeMHJwQgmggBrAARKgARbQAiJyj8g9IveI3CNyj8g9IveI3CNyj8h9RebrCigBFFADOEACNMACWkBELhG5ROQSkUtELhG5ROQSkUtELhG5RGSKyBSRKSJTRKaITBGZIjJFZIrIFJFrRK4RuUbkGpFrRK4RuUbkGpFrRK4RmSMyR2SOyByROSJzROaIzBGZIzJHZInIEpElIktElogsEVkiskRkicgSkTUia0TWiKwRWSOyRmSNyBqRNSJrRLaIbBHZIrJFZIvIFpEtIltEtogcOciRgxw5yJ6DfUAN4AAJ0AALaAF9geegQwmIyD0i94jcI3KPyD0i94jcV2S5roASQAE1gAMkQAMsoAVE5BKRS0QuEblE5BKRS0QuEblE5BKRS0SmiEwRmSIyRWSKyBSRKSJTRKaITBG5RuQakWtErhG5RuQakWtErhG5RuQakTkic0TmiMwRmSMyR2SOyByROSJzRJaILBFZIrJEZInIEpElIktElogsEVkjskZkjcgakTUia0TWiKwRWSOyRmSLyBaRLSJbRLaIbBHZIrJFZIvIFpFbRG4ROXJQIgclclAiByVyUCIHJXJQIgclclAiByVyUCIHJXJQIgclclAiByVyUCIHNXJQIwc1clAjBzVyUCMHNXJQIwc1clBHDgo9YOTghBJAATWAAyRAAyygBURkisgUkSkiU0SmiEwRmSIyRWSKyBSRa0SuEblG5BqRa0QeOSh1gAZYwIgsA/qCkYMTSgAF1AAOkAANsICIzBFZIrJEZInIEpElIktElogsEVkiskRkjcgakTUia0TWiKwRWSOyRuSRg9IG9AUjByeM/phrAAXUAA6QAA2wgBbQF4wcnBCRW0RuEblF5JGDOtpr5OAEC2gBfcHIwQklgAJqAAdE5B6Re0TuEXnkoD56cmzk4IQSQAE1gAMkQAMsoAVE5BKRS0QuEblE5BKRS0QuEblE5BKRS0SmiEwRmSIyRWSKyBSRKSJTRKaITBG5RuQakWtErhG5RuQakWtErhG5RuQakTkic0TmiMwRmSMyR2SOyByROSJzRJaILBFZIrJEZInIEpElIktElogsEVkjskZkjcgakTUia0TWiKwRWSOyRmSLyBaRLSJbRLaIbBHZIrJFZIvIFpFbRG4RuUXkFpFbRG4RuUXkFpFbRG4RuUfkHpF7RPYc1AEcIAEaYAEtoE9onoMOJYACagAHSIAGWEALiMglIpeIXCJyicglIpeIXCJyicglIpeITBGZIjJFZIrIFJEpIlNEpohMEZkico3INSLXiFwjco3INSLXiFwjco3INSJzROaIzBGZIzJHZI7IHJE5InNE5ogsEVkiskRkicgSkSUiS0SWiCwRWSKyRmSNyBqR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",
      "verification_key": "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"
    },
    {
      "name": "swap_tokens_for_exact_tokens",
      "is_unconstrained": false,
      "custom_attributes": [
        "private"
      ],
      "abi": {
        "parameters": [
          {
            "name": "inputs",
            "type": {
              "kind": "struct",
              "path": "aztec::context::inputs::private_context_inputs::PrivateContextInputs",
              "fields": [
                {
                  "name": "call_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::call_context::CallContext",
                    "fields": [
                      {
                        "name": "msg_sender",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "contract_address",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "function_selector",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "is_static_call",
                        "type": {
                          "kind": "boolean"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "historical_header",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                    "fields": [
                      {
                        "name": "last_archive",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                          "fields": [
                            {
                              "name": "root",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "next_available_leaf_index",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "content_commitment",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                          "fields": [
                            {
                              "name": "blobs_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "in_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "out_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "state",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::state_reference::StateReference",
                          "fields": [
                            {
                              "name": "l1_to_l2_message_tree",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                "fields": [
                                  {
                                    "name": "root",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "next_available_leaf_index",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "partial",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                                "fields": [
                                  {
                                    "name": "note_hash_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "nullifier_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "public_data_tree",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                      "fields": [
                                        {
                                          "name": "root",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "next_available_leaf_index",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "global_variables",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                          "fields": [
                            {
                              "name": "chain_id",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "version",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "block_number",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "slot_number",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "timestamp",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 64
                              }
                            },
                            {
                              "name": "coinbase",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "fee_recipient",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                "fields": [
                                  {
                                    "name": "inner",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "gas_fees",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      },
                      {
                        "name": "total_fees",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "total_mana_used",
                        "type": {
                          "kind": "field"
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "tx_context",
                  "type": {
                    "kind": "struct",
                    "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                    "fields": [
                      {
                        "name": "chain_id",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "version",
                        "type": {
                          "kind": "field"
                        }
                      },
                      {
                        "name": "gas_settings",
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                          "fields": [
                            {
                              "name": "gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "teardown_gas_limits",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas::Gas",
                                "fields": [
                                  {
                                    "name": "da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  },
                                  {
                                    "name": "l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "max_priority_fees_per_gas",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                                "fields": [
                                  {
                                    "name": "fee_per_da_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  },
                                  {
                                    "name": "fee_per_l2_gas",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 128
                                    }
                                  }
                                ]
                              }
                            }
                          ]
                        }
                      }
                    ]
                  }
                },
                {
                  "name": "start_side_effect_counter",
                  "type": {
                    "kind": "integer",
                    "sign": "unsigned",
                    "width": 32
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_in",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "token_out",
            "type": {
              "kind": "struct",
              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
              "fields": [
                {
                  "name": "inner",
                  "type": {
                    "kind": "field"
                  }
                }
              ]
            },
            "visibility": "private"
          },
          {
            "name": "amount_out",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "amount_in_max",
            "type": {
              "kind": "integer",
              "sign": "unsigned",
              "width": 128
            },
            "visibility": "private"
          },
          {
            "name": "authwit_nonce",
            "type": {
              "kind": "field"
            },
            "visibility": "private"
          }
        ],
        "return_type": {
          "abi_type": {
            "kind": "struct",
            "path": "aztec::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs",
            "fields": [
              {
                "name": "call_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::call_context::CallContext",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "function_selector",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    }
                  ]
                }
              },
              {
                "name": "args_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "returns_hash",
                "type": {
                  "kind": "field"
                }
              },
              {
                "name": "min_revertible_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "is_fee_payer",
                "type": {
                  "kind": "boolean"
                }
              },
              {
                "name": "include_by_timestamp",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 64
                }
              },
              {
                "name": "note_hash_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifier_read_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::read_request::ReadRequest",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "key_validation_requests_and_generators",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::validation_requests::key_validation_request_and_generator::KeyValidationRequestAndGenerator",
                          "fields": [
                            {
                              "name": "request",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::validation_requests::key_validation_request::KeyValidationRequest",
                                "fields": [
                                  {
                                    "name": "pk_m",
                                    "type": {
                                      "kind": "struct",
                                      "path": "std::embedded_curve_ops::EmbeddedCurvePoint",
                                      "fields": [
                                        {
                                          "name": "x",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "y",
                                          "type": {
                                            "kind": "field"
                                          }
                                        },
                                        {
                                          "name": "is_infinite",
                                          "type": {
                                            "kind": "boolean"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "sk_app",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "sk_app_generator",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "note_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::note_hash::NoteHash",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "nullifiers",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::nullifier::Nullifier",
                          "fields": [
                            {
                              "name": "value",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "note_hash",
                              "type": {
                                "kind": "field"
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 5,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_call_request::PrivateCallRequest",
                          "fields": [
                            {
                              "name": "call_context",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::call_context::CallContext",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "function_selector",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::abis::function_selector::FunctionSelector",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "integer",
                                            "sign": "unsigned",
                                            "width": 32
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "args_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "returns_hash",
                              "type": {
                                "kind": "field"
                              }
                            },
                            {
                              "name": "start_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "end_side_effect_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_call_requests",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                                "fields": [
                                  {
                                    "name": "msg_sender",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "contract_address",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "is_static_call",
                                    "type": {
                                      "kind": "boolean"
                                    }
                                  },
                                  {
                                    "name": "calldata_hash",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "public_teardown_call_request",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::public_call_request::PublicCallRequest",
                  "fields": [
                    {
                      "name": "msg_sender",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "contract_address",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                        "fields": [
                          {
                            "name": "inner",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "is_static_call",
                      "type": {
                        "kind": "boolean"
                      }
                    },
                    {
                      "name": "calldata_hash",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "l2_to_l1_msgs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 2,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::messaging::l2_to_l1_message::L2ToL1Message",
                                "fields": [
                                  {
                                    "name": "recipient",
                                    "type": {
                                      "kind": "struct",
                                      "path": "aztec::protocol_types::address::eth_address::EthAddress",
                                      "fields": [
                                        {
                                          "name": "inner",
                                          "type": {
                                            "kind": "field"
                                          }
                                        }
                                      ]
                                    }
                                  },
                                  {
                                    "name": "content",
                                    "type": {
                                      "kind": "field"
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "private_logs",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 16,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::private_log::PrivateLogData",
                          "fields": [
                            {
                              "name": "log",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log::Log",
                                "fields": [
                                  {
                                    "name": "fields",
                                    "type": {
                                      "kind": "array",
                                      "length": 18,
                                      "type": {
                                        "kind": "field"
                                      }
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "note_hash_counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "contract_class_logs_hashes",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::utils::arrays::ClaimedLengthArray",
                  "fields": [
                    {
                      "name": "array",
                      "type": {
                        "kind": "array",
                        "length": 1,
                        "type": {
                          "kind": "struct",
                          "path": "aztec::protocol_types::abis::side_effect::counted::Counted",
                          "fields": [
                            {
                              "name": "inner",
                              "type": {
                                "kind": "struct",
                                "path": "aztec::protocol_types::abis::log_hash::LogHash",
                                "fields": [
                                  {
                                    "name": "value",
                                    "type": {
                                      "kind": "field"
                                    }
                                  },
                                  {
                                    "name": "length",
                                    "type": {
                                      "kind": "integer",
                                      "sign": "unsigned",
                                      "width": 32
                                    }
                                  }
                                ]
                              }
                            },
                            {
                              "name": "counter",
                              "type": {
                                "kind": "integer",
                                "sign": "unsigned",
                                "width": 32
                              }
                            }
                          ]
                        }
                      }
                    },
                    {
                      "name": "length",
                      "type": {
                        "kind": "integer",
                        "sign": "unsigned",
                        "width": 32
                      }
                    }
                  ]
                }
              },
              {
                "name": "start_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "end_side_effect_counter",
                "type": {
                  "kind": "integer",
                  "sign": "unsigned",
                  "width": 32
                }
              },
              {
                "name": "historical_header",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::block_header::BlockHeader",
                  "fields": [
                    {
                      "name": "last_archive",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                        "fields": [
                          {
                            "name": "root",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "next_available_leaf_index",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "content_commitment",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::content_commitment::ContentCommitment",
                        "fields": [
                          {
                            "name": "blobs_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "in_hash",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "out_hash",
                            "type": {
                              "kind": "field"
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "state",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::state_reference::StateReference",
                        "fields": [
                          {
                            "name": "l1_to_l2_message_tree",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                              "fields": [
                                {
                                  "name": "root",
                                  "type": {
                                    "kind": "field"
                                  }
                                },
                                {
                                  "name": "next_available_leaf_index",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "partial",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::partial_state_reference::PartialStateReference",
                              "fields": [
                                {
                                  "name": "note_hash_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "nullifier_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                },
                                {
                                  "name": "public_data_tree",
                                  "type": {
                                    "kind": "struct",
                                    "path": "aztec::protocol_types::abis::append_only_tree_snapshot::AppendOnlyTreeSnapshot",
                                    "fields": [
                                      {
                                        "name": "root",
                                        "type": {
                                          "kind": "field"
                                        }
                                      },
                                      {
                                        "name": "next_available_leaf_index",
                                        "type": {
                                          "kind": "integer",
                                          "sign": "unsigned",
                                          "width": 32
                                        }
                                      }
                                    ]
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "global_variables",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::global_variables::GlobalVariables",
                        "fields": [
                          {
                            "name": "chain_id",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "version",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "block_number",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 32
                            }
                          },
                          {
                            "name": "slot_number",
                            "type": {
                              "kind": "field"
                            }
                          },
                          {
                            "name": "timestamp",
                            "type": {
                              "kind": "integer",
                              "sign": "unsigned",
                              "width": 64
                            }
                          },
                          {
                            "name": "coinbase",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::eth_address::EthAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "fee_recipient",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::address::aztec_address::AztecAddress",
                              "fields": [
                                {
                                  "name": "inner",
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "gas_fees",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    },
                    {
                      "name": "total_fees",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "total_mana_used",
                      "type": {
                        "kind": "field"
                      }
                    }
                  ]
                }
              },
              {
                "name": "tx_context",
                "type": {
                  "kind": "struct",
                  "path": "aztec::protocol_types::abis::transaction::tx_context::TxContext",
                  "fields": [
                    {
                      "name": "chain_id",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "version",
                      "type": {
                        "kind": "field"
                      }
                    },
                    {
                      "name": "gas_settings",
                      "type": {
                        "kind": "struct",
                        "path": "aztec::protocol_types::abis::gas_settings::GasSettings",
                        "fields": [
                          {
                            "name": "gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "teardown_gas_limits",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas::Gas",
                              "fields": [
                                {
                                  "name": "da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                },
                                {
                                  "name": "l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 32
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          },
                          {
                            "name": "max_priority_fees_per_gas",
                            "type": {
                              "kind": "struct",
                              "path": "aztec::protocol_types::abis::gas_fees::GasFees",
                              "fields": [
                                {
                                  "name": "fee_per_da_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                },
                                {
                                  "name": "fee_per_l2_gas",
                                  "type": {
                                    "kind": "integer",
                                    "sign": "unsigned",
                                    "width": 128
                                  }
                                }
                              ]
                            }
                          }
                        ]
                      }
                    }
                  ]
                }
              }
            ]
          },
          "visibility": "databus"
        },
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "1186437190978851533": {
            "error_kind": "string",
            "string": "Non-zero hint for zero hash"
          },
          "1589673740894288059": {
            "error_kind": "string",
            "string": "Hint values do not match hash"
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "4456244908619624852": {
            "error_kind": "string",
            "string": "Preimage mismatch"
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7136043998373234005": {
            "error_kind": "string",
            "string": "Field failed to decompose into specified 40 limbs"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "7764445047318889914": {
            "error_kind": "string",
            "string": "Public data tree index doesn't match witness"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "9199403315589104763": {
            "error_kind": "string",
            "string": "Proving public value inclusion failed"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11096770892590629967": {
            "error_kind": "string",
            "string": "TOKEN_IN_IS_INVALID"
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14520021557936622750": {
            "error_kind": "string",
            "string": "SAME_TOKEN_SWAP"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          },
          "18208603774526826647": {
            "error_kind": "string",
            "string": "TOKEN_OUT_IS_INVALID"
          }
        }
      },
      "bytecode": "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Ols80dnqic55nuic74nOBZ7oXOiJzkWe6GzzROdiT3Qu8UTnUk90LvNE53JPdK7wROdKRKec38K9ylN9rvZE57Oe6Fzjic61nuhc54nO9Z7o3OCJzuc80fm8Jzo3eqJzkyc6X/BE52ZPdL7oic4tnujc6onObZ7ofMkTnds90bnDE50ve6LzFU90vuqJzp2e6Nzlic7XPNG52xOdr3ui8w1PdO7xROebnujc64nOfZ7o3O+Jzrc80XnAE50HPdH5tic63/FE57ue6HzPE53ve6LzA090HvJE54ee6Dzsic4jnuj8yBOdRz3R+bEnOj/xROennug85onO457oPOGJzs880XnSE52fe6LzC090fumJzq880fm1JzpPeaLztCc6z3ii86wnOs95ovMbT3Se90TnBU90fuuJzoue6Lzkic7vPNF52ROdVzzRedUTnd97ovMHT3Re80Tnj57o/MkTndc90XnDE50/e6Lzf57o/MUTnTc90fmrJzpveaLztic673ii864nOn/zROc9T3Te90Tn757o/MMTnX96ovOBJzofeqLzL090/u2Jzkee6PzHE53/eqLzsSc66hCumHlJQTM6gSc6VZ7opDzRSXuiU+2JTo0nOm080an1RCfjiU5bT3TaeaJT54lOe0906j3RyXqi08ETnY6e6HTyRKezJzpdPNHp6olON090unui08MTnZ6e6OzkiU4vT3R6e6LTxxOdvp7o9PNEp8ETnf6e6AzwRGegJzqDPNEZ7InOzp7o7OKJzhBPdHb1RGeoJzrDPNEZ7onObp7ojPBEZ3dPdPbwRGdPT3T28kRnb0909vFEZ19PdPbzRGd/T3QO8ETnQE90DvJE52BPdA7xROdQT3QO80TncE90Rnqi0+iJzihPdEZ7ojPGE52xnugc4YnOOE90jvRE5yhPdI72RGe8JzoTPNGZ6InOJE90JnuiM8UTname6EzzRGe6JzozPNE5xhOdmZ7ozPJE51hPdI7zROd4T3RO8ETnM57onOiJzkme6Mz2ROdkT3TmeKJziic6cz3RmeeJTpMnOqd6ojPfE53TPNFZ4InO6Z7oLPREZ5EnOmd4onOmJzqLPdFZ4onOWZ7oLPVEZ5knOss90Vnhic7Znuis9ERnlSc6qz3RWeOJzlpPdM7xRGedJzrneqKz3hOdnCc6GzzR2eiJziZPdDZ7orPF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",
      "debug_symbols": "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",
      "verification_key": "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"
    },
    {
      "name": "sync_private_state",
      "is_unconstrained": true,
      "custom_attributes": [
        "utility"
      ],
      "abi": {
        "parameters": [],
        "return_type": null,
        "error_types": {
          "576755928210959028": {
            "error_kind": "string",
            "string": "0 has a square root; you cannot claim it is not square"
          },
          "1004672304334401604": {
            "error_kind": "fmtstring",
            "length": 48,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "2920182694213909827": {
            "error_kind": "string",
            "string": "attempt to subtract with overflow"
          },
          "3206131020419630384": {
            "error_kind": "fmtstring",
            "length": 75,
            "item_types": []
          },
          "3305101268118424981": {
            "error_kind": "string",
            "string": "Attempted to delete past the length of a CapsuleArray"
          },
          "3738765135689704617": {
            "error_kind": "fmtstring",
            "length": 58,
            "item_types": [
              {
                "kind": "field"
              }
            ]
          },
          "5019202896831570965": {
            "error_kind": "string",
            "string": "attempt to add with overflow"
          },
          "5727012404371710682": {
            "error_kind": "string",
            "string": "push out of bounds"
          },
          "6485997221020871071": {
            "error_kind": "string",
            "string": "call to assert_max_bit_size"
          },
          "7233212735005103307": {
            "error_kind": "string",
            "string": "attempt to multiply with overflow"
          },
          "8270195893599566439": {
            "error_kind": "string",
            "string": "Invalid public keys hint for address"
          },
          "10676044680617262041": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              },
              {
                "kind": "field"
              }
            ]
          },
          "11732781666457836689": {
            "error_kind": "fmtstring",
            "length": 77,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "13649294680379557736": {
            "error_kind": "string",
            "string": "extend_from_bounded_vec out of bounds"
          },
          "14101993474458164081": {
            "error_kind": "fmtstring",
            "length": 61,
            "item_types": [
              {
                "kind": "field"
              },
              {
                "kind": "field"
              }
            ]
          },
          "14225679739041873922": {
            "error_kind": "string",
            "string": "Index out of bounds"
          },
          "14657895983200220173": {
            "error_kind": "string",
            "string": "Attempted to read past the length of a CapsuleArray"
          },
          "15200354114977654233": {
            "error_kind": "fmtstring",
            "length": 144,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "15760694058516861966": {
            "error_kind": "fmtstring",
            "length": 128,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "16218014537381711836": {
            "error_kind": "string",
            "string": "Value does not fit in field"
          },
          "16446004518090376065": {
            "error_kind": "string",
            "string": "Input length must be a multiple of 32"
          },
          "16954218183513903507": {
            "error_kind": "string",
            "string": "Attempted to read past end of BoundedVec"
          },
          "17149600165939355391": {
            "error_kind": "string",
            "string": "DstLen too large for offset"
          },
          "17226037485472400844": {
            "error_kind": "fmtstring",
            "length": 132,
            "item_types": [
              {
                "kind": "integer",
                "sign": "unsigned",
                "width": 32
              }
            ]
          },
          "17610130137239148460": {
            "error_kind": "fmtstring",
            "length": 98,
            "item_types": []
          },
          "17843811134343075018": {
            "error_kind": "string",
            "string": "Stack too deep"
          }
        }
      },
      "bytecode": "H4sIAAAAAAAA/+29CZxc11UnfKu7utUltbq0WpIlSyVLsmRb3pfstmXJi7xJlrwkJomRbWE7si3bkmzJsuOyNjteyOIMQ1gGCIQESMgwBCb5PoaBBGY+CB4ywBASkskCfIGZQBySECYTJpMn1en617/+79ZbTrfKcd/fT+pX757zP+eee+6563uvEo6lOa2/u/bdd/ut9z9490Pbdm+/ddfu7/+f3K20cquhYKr0FPNrq47ljLQoBoBz8Pv/GiGboBGSmI+/+c4RBszFHwZHWjzF5B8rf8JTsPxhuPX3nc02P+piuNO+/28GXN9C8svYr4z+cyI6W92sb7bpGyFTGveLDU3B+81dn/7FTz7367/3gd3vf9+Pzf7szPfMWDv98cOHv7b4H5b8xIuHf954L2u2daqGfHWapMubhfjHdb+iWYh/wPivbLZvNuzion8/eMtdv/adnTOuOPjhhz/7mev2zFyy7ePLnnrfLb//zmV/d+sR492oeP/22Z98vP7hd/1s4/QXvjV8xdu/eus3Ng698rMvPLroEwe++3cvPm+8VyneP7nlu5//SP35R/Y+97H9r1wzd9sHn//01//Hf/7kr9a/8aUPPfDpC4z36ma7zEXiwDXNQvyzjP/aZujW/Ylf+MDn1z33wtl/9d3pT1+77dDe857505v//pGF71/1N2/50JIPzjbe6xTvl3evf+fuBfde+Pcjf/zcOT+3+KQvfPP9H/nKP+3b/sqvfuVvf3P5N4x3k+LtkYx3c7Obd+G5q191/49/at7n1pz8l5f8zgfPfPeib6587ec+euXPvfidP/hn4L1e8KakCsvd0mxn5LD1uH9ubRbirxr/Dc1C/IPGf2OzzV8J+X3tpmYh/nH5NzcL8Y/b7/XNNn+O8teN/w3N9s1GyJSGjPeWpuStHDx517+uPVe59uMHzvjI6PSP/926n7l0/QufPPT0svoHf8Z4f0jwnvba2ovve/qth8MX3/8/f/SfTvutS86YvXTd7DP/7Cf/fPF9D/7QoheN940t3pxlXmL8b2q2+Un3aDL+NzcLyR/nv7XZ5s8hf9znfrjZvtkImdK4v2xrtmXn0H28zm9rFuIfNv7bm4X4pxn/Hc1C/CPGv71ZiL9m/D/SLMQ/3fjvbBbin2H8dzUL8Y8a/93NQvwzjf8tzUL8Y8a/o9nmzxHvGsZ/T7MQ/xnGf2+zEP/Zxn9fsxD/Oca/s9nmz2G/S4z//mYh+euM/4FmIf7LjP/BZiH+y41/V7MQ/3XGv7tZiP9W49/TLMS/zfgfahbiv834H24W4r/d+Pc2C/HfYfz7moX4txv/I81C/D9i/PubhfjvNP5Hm4X47zL+x5qF+O82/rc2C/HvMP7Hm4X47zH+ZrMQ/73G/0SzEP99xn+gWYh/p/EfbBbiv9/4DzUL8T9o/Iebhfh3Gf+RZiH+3cb/ZLMQ/x7jf6pZiP8h439bsxD/XuN/ulmIf5/xP9MsxL/f+J9tFuJ/zPifa7ZvNkKm9G7j/dFmbt5/Zbxvb+bm/f+M9x3N3Lx/MD0cW+PbsejYjWTdb2Urc8/uu++5e/e+dbt2bX9w9/qd996/bffdt92zfdOD226/Z/tN2x/cdffO+xiwQr9tPY7vJ3Lmd8q5YvvuS+/ZefuO6/bce9v2BysEWhECbHAUBPjcLvAb7r53+/fXk++9nyEGUqCrKdCLuqDX77xv9/etsnvdHXc8uH3XrjQdKyGeEvDZXeAtS6dpVwx0/V3b7r5v4x0MOpQR1JZyh4E+RzPbPNqin0byERuX63MMgU9SnsI1gPg10iWnvEqF8Ewel8/czMpeE7rURR7buCbk1IScusjjYV0ZrEOOWI84Yh1wxDrkiNV0xHrMEesJR6z9jlg7HLE8be/Zhg73KdYeRyxPn/C0vad/7XXE8mzbnj7xsCOWZ4x+yhGrX/tHm06NhO7xQZEjBDOK8Q9aWabjTaGT4dtYB8dGlZS/hsV5JqtGWDl1r8R0R/24HqaDPCxjGtb0nFgjIq9IndQi5WL8NHo1XjX60Qg+0o+Fbh8zXivrTMjLsx0cs/soYBp+okO9dd2a/GzYftueO6/ZeSdjo+uheZYQne3qDYRus85IwQr0ewndGwQ8TAneCZ3qX7599+133bDtzju33/H9Quwihi6EDU19nychSFPSIQeKNuyCQa2SJSgdVaz1N7GqnTZrWfWandvuWL/t/l177tk+gNChc1rIVkFUvMf1jnmDdG+Q6DY0O3/bKRemCwLHam6U7jdCpjTTvGKmyLS8McCeRnl1yKtR3izAstU1y5sNebZ6xvZLEtsAy5ro8sCiNi7TcTmwHscoD0NXHWSzP0wXcqzcA4J+BmGldS2DGeSpbpeXMGLLLFlaqZUjSXUhg+t4AqLJvH6PJiWHVHMrxI/yENP0MVuPijzDsvY7FHT3OAPKgPTc9qt07zOtv3XCTJKdSosNF/DeAOj4p1Q2tD37URk7I57phfcQvxZK+W0lVq9qiFgyds/JYnfUh2M92xbjIvoR0o9CGZAer5NUpXtfaf2th26fYz+aKcqD99CPvkRlQ9uzHxW087qsfmT4tVDKbyuxesXysR8VHGJfksXuqI8aF6BtsQ9FP0L6mVAGpMfrJFXp3rdaf+uh2+fYj8ZEefAe+tHXWtcjKeVphEzpYTWeYj9EO+Q5pZjVDw2/Fkr5RSVmR9Ue1ZjQeOsij7c56kJOXcipi7xDTT+sA45YDzti7XPEOtynWI85Yj3hiLXfEWuHI9bjjlieft+P9or1U3mxkuTpq0ccsR51xPL0Vc8y7nHE6te2/Ywj1r2OWHbSiseBhp+kkdDd9vLObRDP9MR7iF8jXYqOdZRd1JjRyjermLzZFeJHeYhp+vC6Gds2+WcrnDjmRvpZUAakx+skVenexS2D1wkzSTzmni3Kg/dwzP2qFu6YKA+vb+T1V+RnGyIf+2uZ+kQ80xPvIX4tlGoflZj/KLtY+WYXkzcrS/2iPmbrOSLPsOzAHvor0s+GMiA9XiepSvc2k7+ib7O/zhHlwXvor1dVOsuGtmc/Kmjny7L6keHXQim/rcTqFcvHfjSnmLwNWeyO+pit54o8w5rX+o1+hPRzoAxIj9dJqtK9N5Mfoc+xH80V5cF76Eevb+GOpJSnEbIlbmOGgdhoh+z1VPl6Vj80/Foo5ReVmB1Ve7TyzSskr/Ii+w7KQ0zTx2w9X+QZlu3boh8i/TwoA9LjdZKqdO9e8kPEZN+ZL8qD99AP76R4hrZnPypm53BpVj8y/Foo47dtP1L1qtqjlW9+MXnrstgd9TFbnyDyDGtB6zf6EdLPhzIgPV4nqUr39pMfoc9xPDtBlAfvoR/taeGOifLw/kKsvSFuXfAbnfLJHHHzBlXnOfgf4Do0DNQN6ySHP52Ttb0Yfi10+0eR9rKA5KXVt5V9odClLvK4jhYKOQuFnLrI43WNMlj7HLF2OGI97Ij1uCPWHkesxxyxmo5Ynj6x1xFrtyPWYScsFT/L6HWo6Yd1xBHLs20/44jlGQs92+MTjlie9fisI5anT3ja3qttB+cyevrEAUesfo0Tnnq9HMZMU33a8bO9Z3t8xBHLs4xv61O9PMcTnmXk/UGcW1Zaf0dCd9vLMW+9qEJ4pifeQ/wa6ZJTXiVmFywfz5MXCV3qIo/nyYuEnEVCTl3kccwvg7XPEWuHI5ZnGR9zxHrCEeuII5an7Z9xxJqqx3xYzzpiefrEXkesA45YnvHrsCOWp+09fdXT9v0avzx91dO/mo5YnvXo6V+ebcjTvw45Yu1xxPIsY7+O5TzL6Dme6Nd67Nex3Nscsfp1nOM5xpwaT/xgtCHPOOGpl5d/Jde8LlpGryebflietj/kiGV9LZ8bM/wklVwDW14hPNMT7yF+LXTXpdcamDpjZuVbVExeI0s9oD5m6xNFnmEtbv3Gs1VIvwjKgPR4naQq3XuwVei6wOQzeieK8uC9AdDxntaPMVGesnsVyM82RD7214L1OZjVXw2/Fkq1j0rMf5RdlP8Yr6pXtn/Weo1hjQX/2DtflGdU8HE9o3457J75WQjDr4VSflWJ2V/Zxcq3uJi8WRxLUB5imj5m6yUiz7BOav3GuIT0i6EMSI/XSarSvbdTXEJMjktLRHnwHsalt1FcUm2maLtAfrYh8rG/FqzPoaz+avi1UKp9VGL+o+yi/Md4Vb2y/bPW60sRy/xvcUROrJ0qOchvdKOCj/0P9cvuD5UvZvU/w6+FUv5eidlf2cXKd1IheZUvcIxDeYhp+pitl4o8w1rW+o3xEulPgjIgPV4nqUr3/i3FS8TkeLlUlAfvYbz85YHOsvH7AJNUzs6hntWPDL8Wyvht249Uvap2bOVbWkzeWBa7oz5m62Uiz7Aard/oR0i/FMqA9HidpCrd+23yI/Q5ftZimSgP3kM/+mjrx0iP8vRIX1J1kYP/Z0dCt61y8J86ErrtmYP/o8a/vBj/bxr/ycX4nzD+FcX4X2/8K4vxv8n4VxXjX2P8pxTjP8/4Vxfj/1vjX1OM/0rjP7UY/8eM/7Ri/ONfNj69GP96419bjP9bxn9GMf7njf/MYvwvGv/ZwJ9nbcf4zy3GP/4K5HPwptDJ8K0vOAvoKyl/DYvzTFaNsIr2m0p31I/HpeeAPCxjGtY5ObFGRF6ROjk7pJcL8UcjurCeSeJ3mBQtc5L2OmLtcsQ65ISVXPPYoIxe9znqtdRJr+R6mSNWwxFr2AkrSfxlzjJ6LXfSK7k+uU+xVjhirXTEWuWIdYoj1mpHrDVOWEniLwqW0etUR70OOup1mpNeyfXpjlhefUdyvdYR6wxHrDMdsWb3IVaSbmwe+1tyvWBjyfWCV5dcL7i25HrB1pLrBVeUXC/YUHK+f42NlVfBzUrrr5rL5xi3X1chvBD0/Mfwa6RLTnnj859TSB6Xj/c/Vgtd6iKPfXy1kLNayKmLPD4LVQbrKUesPY5YjztiPeaItdcRa4cjVtMRa58j1uE+xfL01f2OWF62V/1iv/iqZ3s84ojVr+3xSUcszzbUr7Z/1BHLM0549rWeMdrT9p726lf/8hybeNajp+1fDnHiGSes5JrnkGX0esBRr4aTXp5YSbq/6afXcke9vGyfpN2OWJ4+sSL4YQ07YSXJyyeStMsJK7k+OfhgJcmzHj318vLVfo6F8xz18oxfnvXoqVc/2itJnr7Ka5/90nd4xa8kPeuI5Tn+esQRy3NNwXNM7jlX8Fx7PNzCsnXsFZBXaf0tuYY/ViE80xPvIX6NdMkpL7qGj+Xjs7+ri8mbmaUeUB+z9RqRZ1i2J4xnf5F+NZQB6fE6SVW696mW4euEmSQ++7tGlAfv4dnfPxzsLBvanv2ooJ0zf2PS8GuhlN9WYvWK5eO9IFVPdZHHY+as9lZ1d6jph3XAEethR6x9jliH+xTrMUesJxyx9jti7XDEOuiIdcgRy7Men3LE2uOIdcQRy7Nte/qXZxvyjKsvB9s3HbE8Y7TFQnu+E8czI6FTTt6xOfIbnRo3Jf8aIVPaUvJ5lptKPs+yycZFp8HNSuuvetYkxxjtiQrhhaDHhIZfI11yyhsfE64leVw+HhOeIXSpizw+H3SGkHOGkFMXeRy7ymA95Yi1xxHrcUesxxyx9jpi7XDEOuiIdcgRy9P2/eqrRxyx9jliefqXZ8w54Ij1crB90xHLs4yH+xTLs23vd8Tysn1yzWf/+sVX+3UM4Ik11W9P9dsvlb5jqt+e6ren+u0fTNv3q68+6YjlaS/PmONp+0cdsTzbkGe/3a8xul/HE55l9Bz7etajp+1fDnHiGSes5JrPKJTBWu2I5bVOnlyvccJKEp9vLKPXPEe9HnDSK0m7HbF2OWEl17w/NWX7eBn5fHYZrIYj1nInrCR52ut0J708fTVJnm2oX/2+X8v4gx4LPfVK0lTf8dLvO5L0oBNWcu155sHLXsn1Sie9kuuTHbEaTlhJ8uwfveyVpH7sO5L0rCOW55zvEUcszz0dz3UAz/UJz/M5h1tYdtYLz4ZVWn/VO5ETOY2QKa2tEJ7pifcQv0a65JRXidkFy2d2sbKfKXSpizyOh2cKOWcKOXWRx/5aBuuwI9bDjlgHHLGecsTa54h1yBHLU6+9jlg7HLGeccS61xHrWUcsT3s94Yjl2R6POGJ5+r1nLPSsx0ccsQ45Ynn6RNMRy9P2e/pUr4OOWIccsTzHJp79tmc99mv88vQvz/bYrzHaE8vTv/Y7YvG3j3F+U2n9Vd+fyTF3WlkhPNMT7yF+jXTJKa8Ss4uaw1rZzxa61EUe7wGrb6icLeTURd6hph/WAUeshx2x9jliHe5TrMccsZ5wxNrviLXDEeugI9YeR6xDjlhHHLE8/cvTXo87Ynn6l2cb8oyrnj7hGVf7tW0fcsTybENPOWJ5tseXg381HbE8xwD8HgQcL/N7EPKO2ZHf6EYFX6X1t+Q3H99ZITzTE+8hfi10l7nImF3ZX9klz/cIk2vP7+tx31IG6ylHrD2OWI87Yj3miOX5LcgdjlgHHbEOOWJ52r5fffWII9Y+RyxP//KMOQccsV4Otm86YnmW8XCfYnm27f2OWF62T669voubJE9f7dcxgCdWv/bbnrY/5IjlGaM9xxP96qtT/fbx69OmxuT5sKbG5MfPv6bGhcfPv/pxXJgkT3v1q68+6YjlaS/PmONp+0cdsTzbkGff0a8xul/7NM8yeo59PevR0/YvhzjxjBNWcs1nlMrodb+jXqud9Equ5zliee4PedprpaNeu530StIuJ6zkmp817gefSBI/c9kPtvds297t0asNJddrnLCS5NkeXw7+xe9BKYPVcMRa7oSVJE97ne6kl2csTJJnjO5Xv+/XMv6g97WeeiVpamzy0u87kvSgE5bneCJJXvZKrr3G5Mn1yY5YDSesJHn2j55zmH7sO5L0rCOW55rCI45YnvtWnutMnutfnucLD7ew+Pkyw0/SSOhuL4mcRsiURiuEZ3riPcSvkS455VVidlHnpK185xaTN6NC/CgPMU0fs/V5Is+wzm/9xm8JI/25UAakx+skVeneP7Ym5nXCTBJ/S/g8UR68NwA6fnW4s2xoe/ajgnY+KasfGX4tlPLbSqxeVftS9Wq8dZHHayRZ7a3q7lDTD+uAI9bDjlj7HLEO9ynWY45YTzhi7XfE2uGIddAR65Ajlmc9PuWItccR64gjlmfb9vQvT70869FTL8844ekTnvXYdMTyjPf8PB6Ojfh5vNj4UslBfqMbFXyV1t+R0D1GyTFeOlwhPNMT7yF+LXSXucj4TNlf2cXKfr7QpS7yeG3nfCHnfCGnLvK4jZXBesoRa48j1uOOWI85Yu11xNrhiHXQEeuQI5an7fvVV484Yu1zxPL0L0+9POvRUy/PuOrpE5712HTE8rT94T7F8owT+x2xvGyfXPOzff3iq/06nvDEmhoDTI0BJjKuTo0BpsYAU2OAqTFALyxPe/Wrrz7piOVpr36NE486Ynm2oX7tO/p17Nuv/uU5jvasR0/bvxzixDNOWMk1n2Mog7XaEctr/T65XuOElaT7m356zXPU6wEnvZK02xHLSy/vevS01y4nLG+f8KrH5HqZk17JdcMRa7kTVpI87XW6k17J9alOWEnqV1+dao/Hr4z96F9JmuqHpvye8x50wkquPc+IePrXSie9kuuTHbEaTlhJ8uxrveyVpH5sj0l61hHLcy76iCOW576V5/qE57qJ53mmwy0sOxs3DHmV1l87FzgP7idyGiFTqlYIz/TEe4hfI11yyhs/FziP5HH5zC5W9pOELnXKSxI/J3OSkHOSkDNZWKq+MPb2SDeyPQwDsfH8QY66WZjVFwy/FrrrpogvLCV5aXa1si8TutRFHtt4mZCzTMipizzexyyD9VZHLE+9DjhhJdejwQfLu4w7HLGajliHHbH2O2J52uuII9bTjlgHHbH2OWJ52v4xR6y9jlieZXzGEeteRywb29tzJNgvrQidctS4aF5EDvIb3ajgcxojzCw6Rig4Po2OEZRdrHzLiskbzVLfqI/ZuiHyDGt56zc+L470y6AMSI/XSarSvbe3HiKqE2aSeOzaEOXBewOg49tauGOiPOyvql6WClzlr0Y3IvgadvHNXZ/+xU8+9+u/94Hd73/fj83+7Mz3zFg7/fHDh7+2+B+W/MSLh3+hZH3fbPyNYvxzjX+50j2eho13ZTHZc4x/dTH+2ca/phj/BuM/FW427OKifz94y12/9p2dM644+OGHP/uZ6/bMXLLt48ueet8tv//OZX9365Mln2dbZ/znF+KvjPvcBUr3eBq324XjaLl0X2b8ryjEX3nR+F8J/AOZ+cOI8b+qGP+Fxv/qYvyvMP7XAH8O+zWM/7WF+CtfMP7XIWjr78o//3+mffuX3179d3/x4s6Hv3Xa8394xXO//SuvfdcLZ1zU3PpXP/YP1xrvRYK3h9xxn7tY8f7tsz/5eP3D7/rZxukvfGv4ird/9dZvbBx65WdfeHTRJw589+9efLfxXqJ44+k1xrtuXJNc9p5n/Jcq2X9yy3c//5H684/sfe5j+1+5Zu62Dz7/6a//j//8yV+tf+NLH3rg0xcm/cmvUH9SAT2mwbX5UZKsr0zSm5udNEmqEv3sWW2+D7fkjRJPCN3joAG4n8Mmi7AMltQ4yPBrobvsRcZBAySPy8drJVWhS53yksRj56qQUxVyFNazjlg7HLEOOmLtc8R6whFrryPWY45YnmXc74jVr/61xxHrkCPWEUcsT//ytNfjjlie/uXZhg44Ynn6hGdcPdzCGhV5PA4Ygvs5+uWBrOMAw6+F7n65yDhgiOSl2WXG9//NaV3v2X33PXfv3nfNzm13rN92/64992zH0QSOEFhKhVDxXiV0lh7zBuneINFd2ez8fXWzmy8I7CTfam4a3W+ETOlS84pLRablrQdsHlltgLwq5V0GWM81O/Muh7wfbbYxOLENsKzJ3wcWtXGZjsuB9bie8nAndwPIZn8YEnKs3AOCfpiwhgSf1VkveSVbaaWkrwyaj+MOtSqX4cciTtaIYbK8IobSPRZJ0S+wjGlYwzmxRkRekTqJRULEH43oovTkWJh15mX3p0X0QvoxIdt4zUb4tqi8vVOajbAtGH7SW9Rb163eYsP22/bcec3OOxkbXRbNs5DoLKQPhG5XGk7BCvR7Id0bBDxMsQl/lmZneiapLrBsIWJqQHEsTQ0oIE0NKMJLZ0ChOgpeCuQlwiQ17OKJX/jA59c998LZf/Xd6U9fu+3Q3vOe+dOb//6Rhe9f9Tdv+dCSD85JZK2pHSMdC7oTxWsr21CP8lWJ/v31Nt/alrykhS5o5bda6KV77tmxZfvuB+/e/tD278fyXYFSr2Z1bbPz93XNbj6VzCVUMzfzFgxcmQOl4deCruZGyJTGA6WakWL5igVKdgi0Sgj+gdJq0FKRQFlw5JY7UFYoDwMlB9GJCpRW1ryBEuuRAyU2cA6UyoNRjpV7QNAPEVYsyPWSNzXUOZamhjqQpoY64aUz1GG+odDd4o23SrQ/1BpSlGzpYTbwsY5TY4RjaWqMAGlqjBBeOmMEFYEqhDGRSzMoOzpp+/Lu9e/cveDeC/9+5I+fO+fnFp/0hW++/yNf+ad921/51a/87W8u/2bJaHNTySh5Y8K3lyaN/P4WvLYeLe2sjPFWif6ttTbfozBpXNXKb0Wim7bdc/cd23Zvv+y+B/Zs37P9jut27t6+a919d1z20Pb7dueeQm5sdv6+qtnNp9L00C7wbMLHQibJApTRW2gdBjlIwwYy+gMtoyQGe7rVkJXTmT6jxB9Cdxc2l3RvhEwpcxdm+DXSpWgXNpfkcfmKdWHszmgVRMV7HDYwbzK6sBPofiNkSrm7MN6owC5sDuVNVBdmZc3bhWE9chc2H/K4C0N/mCvkWLkHBP18wpor+LgLS5M3KPh46FKh+7hWN1vI5rW6n4Ko8tyidDvMDul2sN9qssD2tvwklfTlm7NGIcOvhe66LxKFTiB5XL5iUQg9BaXcRKhGg7SYbgLNkJ5/c+1VBR8nHjidQHlJslpdQDyNkCnNyVqrhl8LpbxovFYXkDwuHw/mFhaTN7tC/CgPMU0fs/UikWdYJ7Z+Y+tH+oVQBqTH6yRV6d6/a0WHOmEmiR/mWSTKg/fwEPUHaUCJ5ZlBZVP1skDg1gW/0Sk5J5SUc0JGORNRHqsnixl/BIPn/0C2nRsps+pt5mYs89yQLmdGSTkzhBxrB3iE4U3NzryRSF4NME8gzOnAx/vpMyFvE+WNAeYMwqxHMGcJzKTuHprexkv+qQfZsKexkaPVAb70AHnx9xDRJml9C6dKtJ8Bv/qvtc4yYP2xrVU7szyMe2wXFV8sD2MW23pxBHOJwEzKc+/0Tjq2V5JKPsh3U9a+zPBrpEvRvkw9KKoegCz5oOGNFeJHeYhp+pitV4k8wzql9Rv7MqRvQBmQHq+TVKV7X6G+bBXQcl+2SpQH72Ff9iVqF2j7Sspfw+V7HAdjD/di+zWfP/ph5VpnWbDdD4buOGELQ9z23w27+F+jPgX5uW5VOypa/qWijDE7l31wNmt7bbSua6FUfKjE2o96kN/Kt6qYvDlZ/Bv1MVufIvIMa03rN/oX0q+CMiA9Xiepyvmt+FwP3W2b2+spojx4D9vr/6b22gC6sv7aABpuF9hvY3sdpj5/GejKfX5yvbJ1XSX6x6C91lqYY6HbPxukVwP08iw/9/snOMpBLH4QU/kClt/sZ7ZBvz+F+NBXuc0pX18jZCt8w+jlGwum67Kl+YbJ4r7vNvCNEzP4xlhIr88x+o1xOhZfkH5l0OUaTqFPK9fyVlmSOcE7FnViGn/aOIL7PaNfCZjPL9J6YrnUS8E4NiK9io3KpvzCVyUb7cz7DMY/HOK+yHH3dGFT7o+Rf1ToYm13JGi/b4RM6dIs8QHxa6FU/1jJamvujwu+rGJdzE8Qk219msgzrLWt3+j3SL8GyoD0eJ2kKt17NfXHpwEt98enifLgPeyPz6d5GNq+bD+h2lqvmHsxxdxVoKuKufaykCrRXw0x91KKuaodTnT5ec68xlEOYnF/vJawuPxmP7MN+upa4jsD8pAO+2P05zOEbIWftT/ePF2XLc03TBa3pbPBN7aSbyC/1Z/ymzWUh3XN/XGvfug8oje9h0N8nFMl+lsi/bEau2CM4/7Y6N8U6Y9VnIn1x8oXVWxUNl1LWOrFq2hn7o+VTbH8J1H5jf6OjP2x8av1uVubnXm4PsfzFNyDaFAe7inw+B7X5+ZT3mLI4zi8BPLQR3h9blqkPPgoGq8X47ov76lMh7yFlDcT8hZRHq77nkh5dchbTHmzIG8JlNXWfflQzL7W/ZLnNeRRx9i6eiXlbwjZ+gM+woty5jrKQSw7ehzbcS4qB2Py8tApZyLmtUrOAkc5vDeLchYJOeZ/JxJfI2RKmc8LGX4tdMebIuP4E0kel6/YTj1GSLYKouK9SugsPebFduqT5HFeaAndb4RMKfd5IY6ieF6Io+hlgOV5XsjKmve8ENYjnxfCHozPC6E/nCjkWLkHBP1iwjpR8Fmd9ZI3KPj4lEKF7qedFzKMKtH/HIxGfoxGY0oWtjYeEZnuaSchWQejfx/o8PQijVlNKdfCFMyPTm/b4wPTNWYQmKpci6lcrMOJpIPRf1CM9AZDt/8pHzuRfuPIF3n5t/KZ2US/pEd5uJ6M/t9F6mmR0AF3cdmmrAPTLE7R4TeFDiLar995/75WtA+U+CEzjtZseT5XtUjgpCXDT7zQPHKQcNGLQ8o99gDjTUpuLygef5XCPdt3b08p+4DQTckcCDqNpuiWJOuZCvbxmccUhl8LOko1QqZUYc81eVw+frBDRfS6yMP6ZT+KyUnq1MbBrTrdunvng2lVmnWwURFqhZA+6KiEzqpAnpezG+QbWrIToFUQFe/FLN+rtj2e1+TupBEypdxDSz5ujkNLHnZO1NDSypp3aIn1yENLDAI8tER/WCTk8MFOpD+RsGLDwl7y1NCTj7NzxEgbWvIQzOg/D131c4s6y8mdKn49crh1PYET2NlZo8xLewI7i1CNBmkxzQLNkJ5/zyG+a5rdfJw4yjTofiNkSpM2gX17szMPo8w7mm0MTirKNFrXSUt4T44ogy0yS5RRk9vLKA8XDi6nPDwGdgXl4dL0lZSHRw42tq45Gnyblj4L9tdy6dOwxkK33XC5mH13UNzjpTXknxORM1ZSzpiQU9JWlZJtbZBHLUdvCp0arWv2W8tXfw2L83hcV/YRQ6V7rB7SetU0rEU5sUqOj8frZGGkXCq2KV2UnryYYVsxB1v7zckoYOaMTmx8PJZ76IJv/7gwq78Yvtc3I9UbFWPfjBwRutQpL0n8zeERIWdEyFFYBxyxnnTEesIRa68j1g5HLM8yetajZxkfdsTyLGPTEeugI9bjjlj7HLGOOGI95ojl6ROe7dGzDXn6hKe99jtiHXbE8rT9I45YnrY/5IjlaS/PWLjHEeuQI1a/xkJPe3nGnJfDmMnTJzz7bS/bJ9ejwQcrSZ5+72n7Rx2xPP3es4yeccJzDOBpr2ccsZ4lrKzzeqOfLujVupGtBeI6ofGOtH7j0dO8e6FpdsCjroZf4ssKZp4LiI6/rIChpZaCFej3BXRvEPAw4avpsmz+NAizETKlcyuEx2UIhO+1+dMgeVw+XlpST/DWRd7pcI15KEc97VQXedy9lsFqOmIddMR63BFrnyPWEUesxxyxPH3iCUesHY5Ynj7haa/9jlie9nrEEcvTXk86Ynn66l5HrJdDPR5yxPK0l2c/tMcR65AjVr/2Q5728oz3nv7lGXM826OnT3iOmbxsn1zzUkm/+L2n7R91xPL0e88yesaJfh1/PeOIZUsl6i0xfIC5IeQ0InKQv5EBS82HjX6NoI8tyagn3G3tgN820AiZ0kDM3msA0/BLLMk0Wr/PITpeksEQdkoKVqDf59C9tCUZPgX0T62TP2bGgqez5Ck+Pl2HS00nkf55VwaRfyQip1ZSTi2jnHkl5cwTckYFXyXlr8nhe7GdhHkkp+gpPyUHsewFHWY3XHZjP8h7Ig/5F6VgDYW2znc12zT8Eo5G63dVYCbJXqJaJfrR1jgjWXL9g9Zxu9jLVBN9xkbjuiIv6lol+jn1Nt/sFqays9W78gN+6GmOkKswuW3lrbua0CGGhfU1negbrd/DKfT8CKTRL4a64xei8Is5k4T+syhFB/QffEFmmv8sK+A/y0fjurL/TA+dso3+m2NtvpXkP2jjmP9Mpzx1alXFTD5hnTdmjgn9lJz5lIf68Uvz8EUS/NLwE0SZK5SHup8Q0X260MH64IKnw3M/STFGefgkRZ3yLoO8WZR3OeRx33UF5PHzYVdCHr+QZiPk8UtaroK8JZR3NeRNp7xrII+f28M0SL+xTpI2+kfQRpkukEz0mfWUhy/5QNujHfExeXzBiMUCHs+dAO15w2invLrQ1XwOX3yTw+fOqxBeCHrrzfBrpEtOeeNbb7NIHpePt97mCF1UvDoZrjEP5cSeNsA8XjIog3XYEethR6wDjlhPOWLtc8Q65IjlqddeR6wdjljPOGLd64j1rCOWp72ecMTybI9HHLE8/d4zFnrW4yOOWJ71eMgRy9NeBx2x9jhiHXLE8mxDnuMJT3s97og1FVePX1z1sn1yzVtv/eL3nrZ/1BHL0+89y+gZJ/Y7YvXrePU+RywbrxofztFxLaDkutGA8Rf8qNX4E+z4Ia/YGrbHWwVMltdbBZTusXrCt27wWwUU1pKcWCMir0id9HqrAK+fKV2UnuiLZct8ImFlXdvJW3djQp7xlmwDAzF7Y1kNv8Q2spnnXKLb0mzpErrd8sQUrEC/z6V7advIZkpcxuOtvDqVIa0a1VZePSJnekk50zPKqZWUU8soZ6yknLGMclaUlLNCyBkUcnDrTm1h4zbWn9M2lvk2bmPhVg5/X9XoT5zZ5vsMbWMhvz0VM0a/k2t+3zo+MGT+7/EAEOKFoLs3w6+Fbp8t0r3NJHlcPqvrfK8p4xaCVkFUvFcJ3dGkAprhPT74MI347ODMYEhPZjGruYIbD7k312qUhxs8vDF1GWB5vgzRypr3ZYhYj7xphdGGX4aI/jBTyLFyDwj6McKaKfisznrJGxR8NcKo0H2MOLOF7CrRfxM27fk920oWtjbzW243ae9OZh2M/p9BB35/80zgUeWqgT5of/uNbY2/PmzYMyHqfndUyw9CPpcPfTXtHdZYHqS3DPVO7rrgDyn32Ld5s7QeocVXVPFv5Yv8/m7rxdLKzvVv9NOg7Fz/04UO+Hgs2591YJrhFB1mCB3Kvb+boz7XEtfEdIGTlswaicea97J1uHWoe2keUPb93SMpMgeCTvwNHeMLod3jFRw7ZB6rGH4t6OjXCJlShT3X5HH5eGtf9RR1kZfWSnvJKfn+7rRBjAoWzB+ItyLuJSlx5730CWic5fPULO+qFPIbnZIzvaSc6RnlvJTfAcpYaqqTpJ3NY3/5vaunQsDlz63NAT0U5g3NTnp1ylKdWjP6Xh8zYVuqJYiYbLQld1BLcuq6VNDjSgyfTET9lubUdcsk6zpH6DoqZHNXUGZ1C/FMT7yH+DVRhiJdQcwuRxVr/c03beVzu2gVRMV7ldBZeszjiD+f6DY2O38XmbauovuNkCnlnrbyW2Zx2sprxRM1bbWy5p22Yj3ytLUBeTxtRX9YKuRYuQcEfYOwlgo+q7Ne8mIt3zAUX/L7YsETe+VKlhadJB5sNRyxVgks8/eCH6SenzVSHa8PUlvZ1whd6iIPz6NjHspZI+QorMWOWAudsJLEH6eewprCmsKawnqpYVke9tmriK8BfDYbU7MlnkmrfeWFEf3Uh5OVnBUl5awQcmJfE+O/JofvsRyls/roOtst72P0yL+KyoPnEnAT87mZWibO7JHXniGsEv00eHbnHTPTy4h2PlquZrfOI62/VcjLMa4ZS8beHz25LQfHKUd1bLZx09oP0t/doldjCVvQVXVtGL3q4CeoDtTnU2cJffjzqS/ClsZPUx3gmZdG0PJCD3nsI8OCHvHYR94rtjuUfjzHVT6Jdl6XIu8XxWqT8juTXdLv5iu/w/bKfpd13J3FT9Emyk+znFNCP+AVLP6cLteB4fGnb39N1HkWP1f1avQfyVivTvFE1ivaiutVrTSqfijmB1hf/Mwf1nnayixiYV1nqddZAp/r9T9G6lUdhEE9uV6N/uMZ6xXPGR7Fgbyy9Yq2ylKvSM/1qvpv9VHWeujuJ2cSVuwsZJKy1CvWQdqnql+I1Kta9Y/FYaP/VB/EYbRVlnpVOyNZ65XjMNbrMspTOxBFY7RhZY3RRv85Uec85ue4kKafslvJTcj59HtpihrzBH8g3grdm5eCZTjJPVy0Z5NbcYeDXgJlkxv9X0VOfswR/ElSIcrKU/YYfYXwTB+8h/i10O0SRZYeew09eekx64fj8naLE+CqSbLdk4pQi/kDYVXEPcxTrjoC98xV1bfhsIf+czpyqr6lGIt8auRv9DYCTRtdGF6V6L8V6YV6zdY4Wp8m6HFkbPqo8p9Geci3KEUO9o4Y+ddRWY3+uxl7R5M9Eb0j2oh7x7WQNyjo2d5nCPq1QMOrSmdAXqxJn0ZyeoUO9n/lp2r2rUbj6rhxFn9U/oU+sYby1GxO+YLRTcRKCZaHfSHWlpLEton5DtqmHnr7CbbLNSQnFpeSFPMFXF2w1bARwEY5jZAprTY5ajfesLF7zVFnt6NOllRXbfdqpEvRrnqQ5HH5uKuuCl3qlJek+5ttOs4bFPcGIlg7HLEOOmLtccQ65Ih1xBHrMUcsT3s97ojl6V9POGIdcMTy9Il9TljG76XX4aYflqdPPOyI5ekTTUcsz7jq2ba9fDVJ/RpXPX3CM355tiFPn/C0135HLE977XXE8vRVT72m+u3jZ69DjlieMdpzDPCkI5Zn/OpXn/CME/3aD3nOYTzL+LQj1lRc/cGIX571+JAjlqe9+jXm9Ou48BFHLM/26NnXetZjv45X73HE8tTLM64+6ojlGSf6NUZ76uVp+36NE55j8pfDvNaz336qT/U65IjlWY+e7dFzDuO57uuJ5ekT3IYqrftIY19SStKtzXY+0tuXjUruFd/Be7GGgdhDBbErhBdCp56B8EeFPNOrlpLXCPH0zdt/Z+xXn775gxXiN134Hp9PUK9RUXvaZit8/0kOW92mznCYbMurQt4Q5Q1BnumQ/P0vJ3fqN1xQvyz2Q/y6oOen0rLWxezQ6Qvo73YuBo98jlBeA/L42J86F4L0fF7NztUMp9DzeTWj/06rvaonW/BMTy1FHuqnzrLVBf8pKVhpp7NXp+hujzCpd7Kos03qNUNG3+usHT/Nh2Xg811rRHmwPvlJtPGzhqI8qv2ZT5U8QzXzeJ+h4nNSeIaKn87HM6BrKA/bToN0UG96UCfR+ekY5MUv/8W+8thP7Xoh+FKsXZ+UIg/1i7Vr5M/TrpN0Z1PrvjRnuz5J6NdP7XplxnZtPjXVrnu3a/VuqKztGr/6yl+EXQt5hotvAzmvdV0l+vMiPqvOFceeljxT0ONZY/6yJtr3TMpDvlMo70zI43OpZ4VuO6Be/J40o38N2OEz4INHy9JsyzC9Svr6OuXrZwEB+/rZkDco6LkuzhH0ZwON2aRO9Fwvae0GbXo16Wo2Ghb0iFcl+stF7Df9ML6dRbqvyan7fKH7aOhuM9imNrcOpKsz5fx41JqITObFGDScQm94VaLfLOzF/TW2A7TTEGEa/dZIPFDxNtaH9Yq3fBYf7bKW8tQbkCbwmY1Lj/czG1b/9dAdD7mfivX9atyW1f/Rhy6e3omrxkjIu7J1zWOk7TnHSMvgXt4xEvc3yk7KvxqUhzY9gXRQ/S7S8xzQ6O/N2N84+fMc5c/os+zPMf9MUt6+32xSD939Qdr4G7Gwrrm/Uc+8nSbweXy7N9LfNIB/Lel+Qk7ds7Y3bFMLqL9ZBnTc38TaOPOinLT+Jm1udiDS3ywD3XmsqPoboz8ciQfKlrH+ptdzYaaPsmmsL2q0rifwjRdzvd+gUzRW1kN3++En6BuQx/6/TMjJ6v/oQ8PU3/B6CGKhX1RIR/RHbDe29lkl+h+P+GOvvpRtHnvbDOqj1l94zoO6m50mcI3tpuP9Zh2rTzXGb1AetmMeW6t1NIwh7I/oR7iO9tVaJx1+8KLS+mt7Arg2kMPmmV8JYPg10iWnvPHnDEdIHpfP6i7fe5OH4Zqtgqh4rxI6S495g3RvkOiubHb+tppluiBwrOYKfvwg93uThylvA+RNo7zLAMvzvclW1rzvTcZ6XE95uFuyAWSzP4wIOVbuAUFfI6wRwWd11kveoOBTn2DB+9iLDAnZVaL/HehFnluUbgfcnWNM+32q0JPrwvJDaPtywQ9rzM4ahQy/FkpFvfEoVCN5XD6fKGRSZhGq0SAtplmgGdLzb/7o2DXNbj5OHIVm0/1GyJRco9AI5WEUenuzMw+j0DuabQxOKgpZWRO7vSdHFMLWmyUKWR5G+MsoD98Adjnl4bc5rqC8OuRdSXn43oONresqleEvWwAlzxR0+E0Iuo6nxi39Nm65ttn5u8i4peD3jF+S4xYrq+e4BVuO57hlNmFN9LhF8VVC5+yL63CYaEMo3RMNZo0Ihl8LpSLfeESYTfK4fGYHfkch8qpdXNQd81BOlu+0c++Ev3vpXPJFafx7JEWNAcEfiJebapZDfhiYeQHXdBkOcTevsu6t3lW900/xJymL2092R1jW7VWYiLl9TeiiDryhDbkOJ8lVk2Q9ZEWoFUI+V61QnnJVnJVdnSJ7OOgZIbuq0deFq9ZDp47In2CuqXXKvhLoBkN3+VjXjaSrokFdjX4+6Po06Yq257HuRtCFm9RVpHsjZEqZm5Th10iXok3qKpLH5Ss2tmTvQ6sgahC0QeT1ajkbmp2/i4wtr6H7jZApXWteca3ItLzrALtCeZsgbyPlbQYsHlteD3l5x5ZW1rxjS6zH6yjvasjbBLLZH64ScqzcA4L+asK6SvBZnfWSNyj4KoRRofu4JnalkM1PWJwFUYXXxFDWlaEzqcjCO6BJYnuH0B2FCvry67NGIcOvhe66LxKFriF5XL5iUQg9BaXcTKhGg7SYbgbNkJ5/c+0tE3ycDKdKOl/Z8qLE+17Vuh4L3d7LX3ZBHWLxvC74jU7JmVFSzgwhR73L0p5hUu96nE58OH55M/Gth7xNlLdBlEvN5hnz8gjmFSIv0e+FWZ10GI0qKX+TNCjusU2vErpa3WEE4JmYam3XROQgv9GNCr6y5VE6qzEXfuFm66w2D/bCGLXRjxut6yrR37CozXcTtbdrgd90VHbmtpjXztOFnIm2M7ep6xzlIJbVmdlmM2GxnRuta7MzjpI2E9/1kId0OCLYDPevF7IVvmH08sE7Z+mypfmgyaoS/avAB99S0AevozwceXJ/aHqgHZC+EXS5hlPo08r1QGROeJXgV7rzFyKui+ieJPZF5OeR60T4PMrs5T+PkP+YHdL8Z03rukr0J4P/PEb+gyO0iSh/rF3jSM5mZrF2reIH82EbnZtBh81C57rgNzo1AyvrG0rnXr7xDPmGxa403+DnX4x+BvjGj5JvYPw0HZWdeQyY184zhJyJtjOP77Y4ykEs7t9uICy2s9WT2Xkr5N1AfDdCHtJh/3YD3L9RyFb4Wfu3n5mly5bmgyarSvQvLmzzvTcyp4n54BbKQ5vyKssWYQdVBxXSeziFfguVy+h/SfRvsfa6BTA5lhv9BwGTz2eaXCyXmi3HfHGrKJey6Q2ht2y0M6+7Gv9w0OVP85Vfj9jU+IdSysM2NfrfjNhU2ShmU9XGbhDlGhNlvpGwrhZYaOcsNsXyX03lN/r/EBmHXSf41diBx5BqHIb0/NyiamNqbMJt7BMZx5A8tsG1BXsnilpbuJb4cK+D52LrIW8T5eHaAq9zXAZ53P9dDnnXU94VkIe+b2sLVSrrp1r3S+5JyHM2V5FuaWto+DeEbP3pAOmJciZi3SS5Xk5yrnaUc3VEzkTN59lu1zrKQawNzWN/1VyNvzCZd66G/LH5bLWknKqQw1jWxyQJx3j8nI/R/y3Eqc+d3Imp5tv4/iSe46i5tbVpXqNohEypYvxbivEPWlnUGooap/Eul+Wrv4bFeSarRlh5yx7THfVjP1HzoxjW9TmxRkRekTrZHCmX6leULkrPtLaBcmbCPR4rbYnohfRq/Gm8ZiOe/zRCpjQQs5EajybzRjvv2tpp2rD9tj13XrPzTsZGl0XzLCY6a94DoduVrk/BCvR7Md0bBDxMkxUulZyxknLGhJyJXqobIzlpU+Ha7DYPunHaVHh165qX6v47TIVHW5hqKpzW9Coh2zEek5d2NGYoRb/ZLZ3waEyFeLDMqyM647Iwy02SbfmxDie0dCjZ5clhLC8x4HCfwxGGs6soD4eSsWkTHzhQUz413awL/qtTsNKGKjylMvplUMdZhirYJnioog5/qCVetoOSE+uKN2aUUy8ppy7klB3KKDlKZ56eJglj0FqKQWq7CXnt0RzelvkjiEFnRWIQ6si/VTznGMTbRkzD/mn050dikBqeX9NM13kzyGC5SeIYNL4lRzGo4BBNxiDDUn0ov5Yubx+K/JPVh84hOROxpJ8kPuqAdcLxJe/wHPl5uJzWHq+YrWWq9sj9IdK/G9rjVdQe0Z9jY6/Y0nlamwgh2/ZN2ha5ikFJivVBRr8l0gfFpjNJik2X0/TDw3pIPxvKnIYVxD2jx/6Pl5CuJ9rNEdq06WVyfUHruuQUfqv581aRaXk3CJ0sD5e+NzfbdJz42BvqnNT3F+h1QEjH+qgtCcZUbX59s5PWyjwgcHlrENsx22tTU+vAdZykN7Roub0/MLuNfyf1MwWnuTdw/WHi+mPbcVL1Z3ol9Te2oo3LdCwT7Xwj5alXmPM8jOtj/3GyF7ZPTsfDXryl0ctelmflHRB8fLDZ5P00+OtbCa8Kstj/+fXdNwI+8yeJx2JGfwD6ijesiMvH+LUlpTw/QT6E9ZzDh9aZ7W8KnToh9s0FsbOMlxB/VMgzvWoiL8ur8D/xkde/Yc83f/KBCvGbLnyPl/9eL+gXCHqz1RuAP4etXmftCl8TZLItrwp5N1PeEOSZDupV+K8vqF8W+yF+XdD/cLNNl6cu6kIOj5XLYG0uiGWv6L8J+DneYX/O/YPqk5MY8NEe8UmNbzg+/AbFh4LjrfPVuInjw00FsbPGB8MfDen2rom8LPFh5tc3r7jiyP0bKqE7Dg6KexwflK+cIOhLtr+zVXzgGFCFvJsoD+OD6aDiQ8FYf3YW+yF+XdBzfMhaF3Uhh+NDGazNBbEsPqgxq4oPPB7aKsqD8YHH5P8vtfmCj1fK9R5+PAgfW00SzqV4nrI5goP3cEyFPDz/NvpPwJjud2Zr/awMm4R+6igN2vn3Z6fTbRV0ybabtf3WttsV23dvvWvbg9vv2Lr99ge37x6k0vNqFq868c6aSlZC/pjRFfSbZ+tVwsGRa69kMsdCt2XwZZEsR63wcsubL3RUchaWlLNQyFGzlErKX5PD92I7jwtJTuwxyDKHHBBP6Yn4Xo9Bqo1ytSukopvx1kUe78ipQ5xbhRyFxSuM6uBgJXS3zSyr1rGHFNJ2ZD8/W8tUO7JJ2tLi5YM7g7D6+kVafUW9Yu0JPzpTpD0tyijnxJJyThRyJrrdnkjlQb9hu+X1G+TP6jdfc/Kbjy1o8/1jBr+JlTH2oEzssFqvh262EFbWHYNqBjmxHYNqRjlZyhOTczzLY1hqpwnr4IZmul7XE1avfmArYalVbOWDrHPeUwhq50LJub6knOszypms8mwqKWdTRjmLSspZJORM9MHmRSQnLd4unNPmQT9Ni7d8asHo3w/xdnELUz1k8YNu562OchCLX3qQVp+rqT5jD4UlievT6N8O9XlahvpUtkkb+6LcWF1jvOXVKTVWvj5Crx4kUn3KBK4KZn61Me8MFNwBGZ+/qJU8LB++xmVe67o1y1+3fdc5575yw/en+Pvu3522QjgLhYL+TB/oN/MluvFY4GohI0nsP1uJjuvd7jN+Fp160fbKV7Euy8NmsViH/HlPHlr98MnD17baedZTH+hDsZOH/GKIzSm6D4oyTA+6vd7R1Pphma+OlNno10fKfH2PMvP4Pe3kOP5mukFRhpHQ7QOIoWy8OHTqntefkH+y+s7FJCetT9tEfVqvh+1f27rmVeRHoU/bQn2aGgtOdPnTTnBiuV4LNGlzG3WKLUm8Y2/0P9Qqe8n1OLmazrsA6gHypHxvojrtdWKf69To74M6/eEMdRprH+rkcSwWXBehV3NFtfYTGzda/fCLARohS6p8MYuPIn6NdMnpD+PjjdiLDpJUdLxhuF+AAqH+vcYbzBcbbzBtWtvjMcAWut9rvKF0SqPNO95QuzqV0O2LWdYmkd/ozD8Lrq83TJfxtV7QBX2e2+4m0JHboqKvkn6Mn7aOUA3aNtY38fhpN4wl3rji2LWqiyUp+oWQrS6Qf7LWiZeQnInoE5PEp8ixXtmH865Hx/Zeevnga1rXvcYqB3P2a7wDbPRLoV87Qv2aenpQ+VlsrYXLn3e8GGtvWdsP20jpnqS0J9HeS+OYgk+ibVYnFsxfS46RNmdpE4g/KuTxg9aYl+Uk0Hv/9MJPXLLzje/kPsp04XtZ1lpWCfpy45Vjr2w+KqPZ5scTDUmqQt4WyhuCPNNBnQQqOL65Nov9EL8u6NeDjnnqQmFdXRDLTu/EXjA22bEiba3CYgL3tR+IzNvVU4XqSbjYngLPCbiMHHOS1Ag6fY+S4Zn9pwlZfPrRaD8M5b51Raeuaesq1ZTyxJ6gqYR027AMdRrqdaFTt+sz6KbWTxAjbY8pwVB7buy3eZ86u07oo+SsKClnhZAT65P4r8nhe7H9uxUkJ20887s594fubvHy/tAojGd+j8Yz6ukIk6eerFcvZ2Hbpz3VyvHE6P8A2hU/1VqlMmM5Y36W9UkKo/8vk7Auw2Wqhu7YmqTLmkGWqdeThLExQ+xJddV/Mlba2i6Poa1sO+a3+f4b+fFAiJf/8mYnptFvm9fG/IucmFekYH5jThvzL6lt4FiMPzKNL/kaFPe4/SM/j9l4jtwImdL4i4vWF+Mff0kOvnliUOhk+GVfcIayaqHbxkXWu5TusXrAt1rw+pDCGsqJNSLyitRJNVIuxB+N6KL05DGGkoMfyeb5yIaIXkhvbQh903jNRpdBXg4bDcTqawNgGn6y1llvXed8cZGZZwHRWQgcCN0mXp+CFej3Aro3GPSLixLsL7XCqVpqOCdFZ9OB77EbI39sSWOkpJwRISeGdY7AMvrLBb36YrCVA13NeD2+T5XWJPDdlYbv4IZLiM5GAQMh3ft7ueESupfmhqqF8XtPVO+B5hkTGPxMzYaITCtrktT7KYzOenkbvSyae+zviJCfo8qf5NeWGgZiX14QO2sPyp8nRnmmV03kZVmt+lr9jD99w6rL/ijWzPAeN0v1YalzBX3J3YtDarUKX8OapCrkXU55Q5BnOqjVqoKh4VAW+yF+XdDzalXWulBYVxfEstUqDJ/WdiarLcew1MpShXRO+zQHxwqjb7RihfqyqLJDEPcGQnecuL557K/qkvjD05eJsuI9thvyG90ExqqhvLGqFrrLXGS0r/xW2YVfkYy89dAdq/h9DCqOXSXkvFSw0Df5tdyWr/6aHL7HcrCt8kemL3eUo/q6mJ8XlYNYfPp3oj5XZitTJfvGTeqdfJb4PWTKL3AVkMcauFLE9seVI34lOu5KXQLXnAbpN/fPt61o4zKdpcl616RaDcHV22vnapm4eovjJ15JM/qNsOq1eW56GdM+ZZV3Z/dGGisX3NmNvmP0B8nHi/jxewr6MY+9NolyqBOxVg4Vr/kpAoyxmyhPfa5BxTJ750AldMdT3g1LEq9Iq3msGjdxu847btoo5JQcG+X2Tf4kBu464ZiWk/Ix0znxsU9l8DHuO1k3ZQeMVawjlifru02N/iEYd/MuEL4/wTDvanaX2+ivAhmBMJLEsc/o91PsKxifZOzjfkONI0rKzfzJdMOvhe5YVmRcrvpTNS5NlsBamywZPlac1mtXCBXvVUJ3a6mAZnhviOiuanb+Nq/llsbYSb7VHK+INUKmtJkjAybVa3HUwF6LR1+4H8ifTMdns/J+Mt3KmveT6eq5Cn4TL5aJ9zDZ4+yelVu9we86wkobOQ1mkDco+PitOIov+X2p4FHnACopf0OIzyzYjh5YmwRWydHh3KyRyvC9PnTS6w26XPasHwTBDSDMQzmxcyiIVXXCShKvIExhTWFNYU1hTQaWmmXxjBL7KX6mE+MgzlAwD/WLbT4jf2yTe0VJOSuEnIl+PmQFlQf7SLabOp+7KSIH+TdRedJWvv54rpapVr6SZDM5Xol6Nax8/cncTp3Vhn6Sxuge18NRjGY3rx0eqEJejvHFWDIG/ujJbTls16FmGzfLOMTOONaJHsuufCFrHX2e6ojPWTIvny01+hVQR1+k1Um1uhlrV0pehco8HPTqKZ8tNfq/Ebt5Sr+0laS0L1asTJH3dyDveZoTod/hTvhRHMjLM45WfocrXux3WXfQYvFCta166I49vIOrzkzGzhMb/3DQdYBnPpH+m6LOs/i5qlej/3bGesVVxKM4kFe2XtFWXK9qd1z1UzE/wPqK7bytJ6z1AgvrOku9Dgh8rteBVqxR9Wr8WK+oJ9frOD1gxuoVz3cexYG8svWKtspSr+q8JcctpMd6NZuo/v0KysOYyHJU/EY/yFLnWD8cv41+tqhzHjtyXMjSv+CKZKtp24rk1t07H9zeWpIMlGJLiMnvtMef5wj+QLwVuscfvFLhExdZ2eQmezjoJSsOn0a/UJg8Fn6TFDsaXvKYeuZFbcP3OlreK6zxUlGsmWFeH7hqkmy1uyLUYv5AWBVxL4TeR5V5FKiilRrVca+V1nMYXpXo10R6DtUTqhmR0auRO/aOfPQYy8BPeiLfxhQ52KNhtOYezejPytijOc18ZI+GNuIeTa0sqLfBGb16shZXS3k2xE9oY556I07WZmjhlUMd8qqZlfKX2Ig7Zh/lXzji5icl1ZtelS/guYwkVSGv7CwYy8O+EKvbJLFt1JNtWN88asXzGrzyhO2Sn3xUs56svoCrHX9MM2Ksq4n47iufHboOYgE/qR07j5QknvEb/fUivsTKsFGUIdY20Ebs6+op5MneeeWzROh/fJYI/Y/PEuGZON6xTXvDICfuo9EOWc/LsT8Ybh6fR1+6lnwe29kZJDPv6iry99OjSmcILKNXY5zYo0rq7FPJM0njjyqpIa1aSXV4VGkF0fGjSjgb2JCCFej3Cro3CHiYlEtsTNHT5PZyCeRPcwk8nmSbGUl+2kPSR1qhtOQM6fnYke6SD1s+XyG8EPTsK+04NuqlHgPI8ljSn/zjE0/90O1/85lYk4oNqdQQ/0xBX/Kxn3fEhtnqsaTLKG8I8kwH9VhSwTDwjiz2Q/y6oOfHkvIeucS8LQWxZofuUGltZ7LavrVlGxo8I4Zak62LDTfeERn2qS5AfdRD6c42Xh8pl5KzPmO5YnLOLinnbCFnVPBVUv6aHL7HcpTOvTblfnpemwf9O22IfmeLlxdNXw8v3/jZFqYaXqQt5FdAntqg5/aKR31j/Z7Rvw/8k4/68sYbllPpfDnICKE7ZvBRX6P/Zep7J+KzdrFHoErKzbwqavjqkeAiq6IbSR6Xr9hRXz6mwB/aU+vKldBZeszrtfh5ZbPzd5GjvgUPaef+2DyPrHByyBNO/GAkH/XFTxHkPeqLD6/kOeqL9XgD5eEo60aQzf6wUcixcg8I+qsIa6PgszrrJU8t8PJIWvElv08VPJ4PK3o+kMhHs5HO/J1fB9YImVLmT28YvtenA3t9TozLrj6/pY7f8Owv7yezEGuLI9YmJ6wk8XHAKawprCms44+ljm3wA5zYH/An9jB28fGsvDNRtaet5MwrKWeekDPRR2rnUXnUQ7gVysPyxB4mR/6sD5N/Z56WmXVmOP4wOcwM/2Vep85qZpgkNQuPbSYaXcnNxJlqMxHtOtRs42bp7+2YsTo+ZGVXvpC1jkbmd+oTO2qI+vCq8LlQRzPoMAWubPID/702sPGBWaynrEdqjX5WS6deR2p5Tmf86khtkvhzeEY/D+RNwpHa2crvsD2w3+Gqe2wFKhYvVCyth+7Yw0f00Ma8MjJZx20bwh+4L2LfSNNP2c35iN7GFDVmCf5AvBW6NysFy3CSe7H3cKkjeuosEYeI1cLksSpL0tQRvZfcET1bpaoItZg/EFZF3Auh9xE97lViJlamUlEky+HuVwiXjkVYNcKKjQSwemNH9K6jPLUdz3LUofMkcY9m9Bdl7NFM9kT0aGgj7tHUMZ7YB9d6HePhpqZWU1SPlvehoaxH9HikFvMXVd6YfZR/qQ85xD4opHzB6CZiVF3mQbWixxf5wVG0U+zBtkrobv95fQFnT99J2XNLw03bA8MYgBh8jM7o3yhigGGq8wqxY3TqtYA4jDB91CuUrqI81UVOYGwaVf6I5Wd/jJU1SVlG22pUqkbbfLQYh0f8yqFefhPzR9zn/Wnar0V9TslQttjKA/LHPlA2UlLOiJATwzpFYBm9+qBl7Pgc7pwZb8mPhw/EYiHuxhl+ieNzZp7FRMfH5zCk3pCCFej3Yro3GOLH5yZ60Wuy3tTIx2Pe1Qq9JTdyD6qTw2bLkt9jO1ghvBD0jIo3VVEevzsH87Icu/vsx17z23Of+LOxCvGbLnwvS9M9TdCXbJ5N1T2ZbHXs7gbKwy7GdFDH7m4sqF8W+yF+XdDzsbusdaGwri6IZcfu1LfOJrst27DxX8Mwio/dTbQuJd+BlfsgCB8rwvaFdcqJlwlQ57xvikSbom5sIzVtZL8zHbK+KdLofxHqnI+P8ZQ8SbjwnfaUnVoCSBIfHzP6X6E+5HoqeyNkS+r4GD/FFfuGo5q6xr7Di/w4pSxRhtx+vIHyMK7yQRnsE/iw082Qxyt9r4c8frrmDZA3RHm3QB5/F/aHIG8T5b0R8njD6E2QxwfbMKl2it+p/KMT27hMF0gm+gyPETBeme3VBs5auMY805Xvsa8h/0AKH+qTpJKPK1RKHuEf//5W7D0pyqfUoxf817A4j7+SsKGY7tGvJKjlLPVuD17iLPrVEcQq+djCeJ30erdFli/jKD2zbEythXtZll+UvdVT38Zb8inGgZiNsC0YfokpqhXndKKzrludybw8BSvQ79PpXq8pqlrVKxqukD8WrnAlTp1D6XjNFq00qxP9OPTgTw8b/ckntPm+COcDvhQ5H3BN6MxDOdeS/utDO5mtS34sK/OmID8dVnATssI2NnlcvmIn1Ifgmq2CqHiPvRzzeO+P+avEV+SEesGAu5FPb2NSp7d5EIUtaT3lXQNYfEL9WsjLe0IdX32f54Q61iN36uqUnXkU+sMGIcfKPSDoLyOstGdyBjPIGxR8Q4RRofsYfa4UsqtE/12YcP0YTbiULGxtvU6ZME3a/nA4oa3D0yn7w9WUcvERED59j23NFlpY/nyIwNUTtPwg5HP50FeHU/TF8iD9CNiAj32o/Z6Qco99m59PujxCy7ENfytfvJLor+hRdq7/8RNPkfpfL3QwvZLE9mcdFI3SYa7QQfQi63fevy/lxAefV+Woz7XENbFe4KQls0bisea9bB1uHepemgckJbdzsuNDyHu270477cJlTethB4JOo0HrlqTjdYBpqJi86AEmLF/RA0xprbSXnJIHmNIGMSpYMH8g3oq4F1pq/8pIJ53ahMcmsrN57C9vwq+CBv18yoOoAymYdrTe6NVjY7FDM2rWqL5HFJs1xmRjJ8fBLe8BH3WoQ73LaEzod31OXbdMsq6XCV3VwRgONQVXSzOHGsP3+vJFzC5HFWv9LfeNHrQKouK9Skhv3RxRuHPa2Oz8XWRaVHBP9ka172JJrVfzfg2uV/P68esBi6dFb4C8vNMiK2veaRHW402Uh2+1uhlksz9cL+RYuQcE/VbCul7wWZ31khdr+Yah+JLfFwseNSWupPwNobtFJ4k7862OWDcIrJL71vOzRirDV+cMikQqdW5A7UerNsd76JjHSzg3CTk3CTkKa4sj1uVOWEnihw6nsKawprCmsF5qWOrczQ3Eh/0nP+iMMXVF6NQv754m8qftMVq++mty+F5s73QFycGFIdxgOnhCmwdtlHYcnR86Nfp/geXNI61rdaSWX2eHZ+6MbiLeIoxjgqFmGzfN35Cev6WDfW+sDvAMYawO3kF1YBhZHwkw+v8f6uB5qgNc3MHxd5o/K3nsI8MhRPfR2Ud+XCw/K/14Tqh8Eu28LkXeT4nVmQl8FGG+8jscd7LfZR2nZvFTtInyU17xUVsOsSdNjT/tSVPecjD694s6z+Lnql7HX72WsV6d4sn8iX7ERPkB1he/XECdd6vQb8TCus5Sr+qRRa7X34jUqzqkgHpyvRr9RzPWq9OXB2S9oq2y1GvsMT91Lhrrlc8UYT+5nrBi58mSlKVe1ZYd1+snIvWqVsljcdjo/1MfxGG0VZZ6Va+NzVqvHIexXmPfSOK2nDdGG1bWGG30fyLqnMfIHBfS9FN2c34Bw/UpaswT/IF4K3RvXgqW4ST3cJGbTc5vMEV6ZXKj/0xkJ/4ywZ+k2FFRjxe8I57pg/cQf7KPmvLyqWpmsabUq1ucAFdNku02VIRazB8IqyLuYZ5yVdxf5AdGcS8Ve+jP0xFAdCGeKajIp0b+Rm8j0LTRheFVif5/RnqhXrM1jtY3C3ocGfPDzViGmylP7c6wHOwdMfKvo7Ia/T9m7B1N9kT0jmgj7h1xZ2lQ0LO93yDo8WkKXoXBpyliTfpmktMrdLD/Kz9Vs281Go+9LKTXrIz9C33iJspLezXvUexmOw8fTE5SFfLKrpRgedgXYm0pSWybmO+gbeqht59gu7yJ5MTiUpJivoCrC7wapr4vtVHgGv1WwBoUGG9p0fMTxbMWHPurzpGossXOL8RWFVCfsdAd4/lpHuTDsw1HsZvtvH5ducvbF1jd1kO3r26lPByG8kofxi2zd+ITvzunk049+c1/TVe+xyuP6nWfvBvvIQex3kRycKiMK5ynLGjjsk3UsPk1resq0V+6oM13aus69h27KuWthXY2bWU6P39nUb1waCx0+wE/QqLKifbjeGD054Ken4H2kKQJ+O5eXbU7jFvc7lSMQfq8faTZRK1cbiIsdZ4LbdrrKWGuM8PjJ3RfB3XAs2IcS28h3a/OqbvqT1QcMd6j/VQrjoyRDhzP0/owVVdqxr8lBWtA6I/tlut9UMhW9OYTeBBfxecq0V8FdTV9pcYMKTpsStF5OIX+RtLB6K8T/hKLA+j/PA8y+usBkz/E0wvztSmYN0TGGqqd4i5p3v6UxxNoR55boe7cL94E8pn2IpKPeejnLDdE9OU+tZe+3N9Y3g7or25tXY8QXs5YPRirq7OEvlnralOkfIxlfNXQ7Y+xNoL2+JEFGnMoJ+bdok9XY5Vbm238HSnjkSTFlv14nMPt8BQak6ixAY9JHhDtUfX1hlWur698Me8L/HrZhmNCr2/s8hgb+5vZlDcZfemb5nTiXh/BTa5Xkx6xMV5y/YrWNcfhZiQOKxvGbK7miGhXfiMI1scNlKd8drL9EcvP/hgra5LyzofZH1X/ofyRx1kxv0lSzB+NN/GhTTS2Q135bUk3RvTpNeZOW78cTqHnmG/0/yoy7lHrP7F5Qq+1Q372AvulNwQtG9sl2oRfrmv0P5kxHjuteciX66Ld2P9jNkoS2/QWQY+2MpvUiR7tq/z/9ZSn1pFibTZr28D1udUUqz3X51SsNvpfybk+F4vVE7U+F4vVE+mr/bo+h76adX1uYYaxQGwvQPnj9UJ/ta7E9Y58i0Jvva4XetUFPz+jNhFrgyhTjTm4PHnXKJCf37K1xbE8Smf1AnRc6/xDmluomIO83A8Z/V/DXOkFmlfg27l4bJfVp/jZ2tjaTpLsucqJGwuGoeM9FuTxHvZj/DJ59eY89D3s047SNNv8puNE2AvbM9srFp+SlGVegW2CP3Oo3h6r1kz5CI+yZdbxAb6x8Wuze+uvPpmW1T/44w59tHd23Ptm9oW8e2ccL1GOipdcxxhfsV54L8novxkZ0yk/iPlNr7mW6ZPlDIBaf5/AGNLXfsNnANR6YFa/4RiC8Rz7aOu/Y+O3SujsJ7HP5ef6FQ5/0KJC96fDfeR7JZWZYzdjv4rozX7DKfS8jm30MxYe+xvb20jT4dWkw9YeOmwhHcZjh9BBjXl4DzbvZzORf3MKH9s+NpYeCd3teiKOZhp+LWg/bIRMqRJrT2qswE+6qHivxgUl7XKDesImkE5qj0Y99Y11zmmQfqPOiS/OXNnGZTrWR705d7LtsJnyMJ7bU5DqXKCd9Shio+U5bKTGBseznW8ROqo55vFq51uKyYu2czX3fqm0c14PmGrn/dnO1VhO2ShJjZAtxc7VlXx7z/Ks7dPwa6HbF4q0z6xz2JJva2nMCsfGnRyDz4dr9bURrC+v+ouNoya7/sqOo1T9qXGUZ/1h28pTf2qtdj5cYx6WJ7ZWi/yTtVY7n+SkrdXeurDNg3bIu1a7c2Gb77bWtVqr5fVYda50As95Dk70emGZsx+8DjAZ64Wfn631rwDuawQvt22k3yr0MHprc2kvjjVePke2G+a+T6ecFUl77ojXv4z+YcCc6PUvPmOCdo49AxNb/3J6Bmb58X4Ghv0ezzvwmQ5uX0nC9VD2T6Xr9SV05XrEuno9YRVdl32b8MsJfB5ued63diibxt7a0cumPIdCO/J5VHVuKxZ7i6x/3kr9F9bZxgwy1f6bep6PY5355Xug/vnMM56TMnn4zCv3z0b/U5FYp8oQ+1hur7N2sedDbojwYbscEbIadvG9eDI8851pQhafNzfaXwA73bpC61JhfXqk2Nsqy455K4QXgh7T8xsmC87Bo2+YVH5f8suUy7LMydQZPawvNdbGMfCv0hhYtTGMOxe2rrmNfQTGwL+WghmCbrexZ9VRnysy7O967P+rthvb3+V9YbUOYzrgOXc1VuIzaEb/W9A2Y8+E+ewnV75+vMdF3Pdhv8jzAeVfaV+3RBulnXXlfTCj/89iD8r0w/6Uz1Ruzql72jkSbovYNrgdq/Vw1eZi7R71tnPv3O4/Felbe53PzDt/5Ocy0ZaxNQw7j6nai9FNxD76ZJ5dsrpVZ5f4+Up8lsJkqthr9k58Yi3F3qzPX1QE1qDQo7V03PUc5pcj/tWrX8l7PpOfgcp6ls7a/gSejZuT9xndrPs6WfwR6zbLWS+15tXrOZxaSt+O/oK857WuOUZ/I+e6Rmw+nPUZirzv9uA4huM2fuZWvVcG9eJvkxj9/844XnBaR1l3vN8rw30uPuPAc2Xl62jTXut2XGdp86nhlv+p8YJ6tjTLPN/rWYqfmXXsOhbPsvTjzItxYziFPu2MzyxhL471afOSNYRp9HMBM8vcP3a+v1eMjPURvHamxjUTOD65tJ+fs+PxCbaNiXrO7hnyfxyL8NtyN0dkMi/KSfN//kyr0a+O+D/2lWp8vowwjf60iP97P9/C/Zp6TlqNrWLjJ6e9r8v6ee9rE+Wp5zvYD1BOkeeeH5nViavG58jbaF3z+Py1Of0LP9I6Wc9PXUN56hkGrse0fobnKUa/AewQG285zQfm9vOzMrzmpeKnWuOIxU/VX3L83BQZb10D/Lzncl1O3bO2N2xTd1J/cy3QcX8T299mXmzXaf2N4XHf8IZIf3Mt6M77Saq/Mfo3RuKBil2x/kbZfpMol7Ip90Wou/mCap9GV7J9zsv7no1YWZPEtlGxFX2X+xuMh9dSHrYNHstcK+Rk9X/0oa0t/y9n171H6Y/q0mxjDwpKw68S/f0tn6yBnva3mkGPb//cNz78vg/92R/OJv4kWR0lezZJ/e9Y1NahArQPL2rrvhv2uCuh8x3C/H69Ycizd/wl9E8uat83e1qelcuSfR3Q9BmBPKvfAbhn9WvtaBrIGa9LknsAyvco6TYQ0c2+Tlgl2mYLY4Tk5GyTgesMsczGmDcNdD20qBgd1qe9g4jrE/GwPo0O2/5wRF+TlfhfUf9ec+Rd//aKz/3L+l7+XRT/kzuu+61tl58/c6LwL3v/Hz6waN1fz58o/N/f8Xu3jM0KAxOFf8Z/n7fgx//62n+VJ76YL+C5a+OzNjMT7udoM6Oov6VBuof4NdIlp7zxPfaZJI/Lx3vsY8XkzagQP8pDTNPHbF0XeYbV6uo6xk5IPwZlQHq8TlKV7n2AxrR1oOWvqNVFefAexuH3pvRTvwFx/JfpmTuse6xrzEPZyo/rKfwhFO8PLW9aJG8kklcT5bK86cD3ZuKbITAT3X/pxPb9hM7ater/3t5s0yX/5kJelr55DsiZGzqx5vXA2kJYyD+PsOb3wOKv6SG/8ZqvmT0ua9kpsctv05ghZrN3NDXex2nMgOfQy44Z+Hw56lNJ+RtCd9xMErcFxOLndGYLOSXLNzNrfDf8GulSNL4rH8LycXw/oZi80QrxozzE5DpdIPIMq7W11hHfkf4EKAPS43WSqnTvTym+LwBaju8LRHnwHsb3F2icgLYv669oG6s/NR7BM2d/QesC2L5VX39Xi5fb+JkQM/6S+if0T65bVX4PP0O8EHQ7MvxaKNVuKzG/xvJxO1pQTN6MLH6H+pitF4o8w7Iwj/WO9AugDEiP10mq0r3/Qe0I2xy3o4WiPHgP29FfUztC25dtR7FYNBHtNUnWJmO2wJhs7dDaGNb7QuLDumKfU3W9SMhW+IbRK8Z8e5Eum4oxKItj8lyIMd+hGIP8Vn+x+DMWuts8v4erV3u2OuD2OCzoEa9K9JVWudTar/GjrVAvPmc/PqYDTF77VXEDx4y8vql8UcUZZdOFhDUgsLA8vP+gbIrt0/DYpjOETdXzbPxMPbblOZSHbXou5eG8cx7l4dyV5zE4F+U+G+ei6Ac/d2L7fq/2lCTus43+hIiPqBigxoRGf6KgXyTKPRa6/eJEykM+9q0TIY/Hgotbv9EOqNedzWN/q0S/FOwQ2y80vUruR4yq/YjFQDDUbOMm/5ZA3qCg57o4SdAvARqzSZ3oVXtVbR9tyu3VbDQs6BGPxwmnRtortvfFpPv8nLqPCt25/+I29e3IeDZLn4G4s4lexTfVl3F8Oy/SZ6gxfKzPMPoLj2OfgXZZSHlp47Gj2M1uzJLtc6Zqn1h+bp+xsiaJbaNiK/qulU29Y3U25aH/LyA5s4WcrP6PPvQXNNZWax/812TyPR4DI5atscTaEvrc1ha9Gnfw/KaX/24jLORnuy7sgXUbYaWNndN8AbFuJyw1To/1wYh1B2Eh/4mEtbgH1nbCQv7FhLWkB9aPEBbyLyGsk3pg3UlYyH8SYS3tgcVzLORfSljLemDdTVjIv4ywGj2w3kJYyN8grOU9sF5PWMhvvKMCy9q0rWWcDPcnYs3T8GukS05542s1J5M8Lh/PC1YIXeoij8ekK4ScFUKOwjrBEWuBI9ZCR6xFjlgnOmItdsRa4oh1kiPWUkesZY5Yjdb1RK+R81x81FGOWgtT4+AGXON6nBp/pGHwOrnaC8P1uKdo/cD41bscUFaV6H8N1uOeaV2PCf7YmhuvC8TmSrG5VZKyrMdlmVu9KzK3muh5kJqDVoQc9pMkea2dvScyF58t+Cdr7axKebh2xuv0uHZmNsW1s6JnwvhMA5aNzzRg2dSZhjHKmw55dcqbAXl4puWXqDyx82lYnumUh+11hPKw7qZF7DCD8tAfhihvCPLMJtNDvN0sh3t559T8LhhsB/x9FOTj2KXWNE0HG39gHEW9eP3R6D+Wcf3R9JqI9UecOw4127jJPzUXRHqui9h6JdqkTvRcLxzflE055pmNhgW9ivlG/3uRmIf9Fa+djubUPeu7VrBPtv666DnG/3BP7ZzPvn/aXX1yjvF3UX9Las73Ej3H+DsV4kd56hyjyasXkzfI63JcN9gfY2xCej4HiefX5oCwKt37EvU/2O/yWiWep+S9f8wbFPcGjhOWWkNFu1mdJXb9c7IF+lsl5a/h8j3WEetzsuctqj0k/xohUzqXx2uGgdjoNzl8/+asscTwa6FUW6vEfEyd6VVt03jVGvj9zTZdL/9DOQrrSJ9i7XPEajpiHXTE8rTXY45YTzhi7XfE2uGI5VnGA45Ynno97Ijl2R4963GvI5ZnGzrsiOVZj56++pQjlqd/HXLEetoRy9Pv+zXmeJbxGUesex2xnnXE8rSX59jE07/6dVzo6ff9Opbb44j1uCPWy2Es169+7zk2merT8mH161iuX2PhIUcsz1joWY+e9urX8dd9jlj9Ov56xBHLs20fcsTytJdnP+TZhvrV9p7xy3Ndrl/Xhjz9y3Ps269jzH7sO5Jr3lPy6DvGUrDxOrY3q+RUhM5qTxfPaI2E7vLm2dc1/rkF+U1v3L9Ve5h8Hgv3tiopfw2L80xWjbBy6l6J6R7by8V9ayxjGtacnFgjIq9IncyOlAvxRyO6KD3Z58uUedgRaxphqfZXF1hGr96/o/wg9v4dqzt8B06OuhuI1Z16R88MKNOe3Xffc/fufRu237bnzmt23snY2JTQPDcRnT0iNRC6XXxOClag3zfRvUHAw6TCaC1FT5PbK4yq44+TFa5HBZ/RlTyCk/mT8YZfC91lLhIe6yQvzS7qeI7xqmMwP9wEYaHzmEvyO/baLtV9lOwKb89qX8P36n5iYTpJbN8sYTpJDzTbdGVCa5Le5oh10BFrnyPWw45YRxyxPMu41xFrhyOWp0/sccTy9Im3OmK9HHziCUesA45Y/dq2PW3vaa9HHLE8y/i4I5ZnPXr6/X5HLE+/f9QRy9MnnnHE8vSJqfHXD0aM9uxrdztivRxi4bOOWJ4x5yFHrCcdsTzbkKe9PPu0fh0X9muf1q9zK0/be7YhT3t5xuipvuMHo+/wnFt5xsJDjlhTawrHrw152t6zjE87YvXrfMjT9o85YvXreqHnOGcqThy/8cRUnDh+tu/XOJFl/FWDe1e36NWrf+eETqy5PbD4U0nIn+WzS4jFn0pSRzqMb36KHHy9hvrUUpJGQ3fZKq2/JT8hNFghPNMZ7yF+TZShyD65+oQQlo/3ydUrnesij49wxT4dhHIU1hzSAf3Uyf4DRe0/p5i8qP1V+81r/7TXfVl+ko6XzaYVkxe1GZaviM2StL557K963SEfg1M6qE8G1QX/JHxK6TVZ6+Z4fUpJfSLMeOuUl6QHm206zhsU9wYiWHscsR5zxHrcEWufI9ZeR6wdjlhHHLEOOGJ5lvFhRyzPMjYdsQ46Yj3piOXpX57t0dO/PGOhp15POGJ5+v3LwScedcTy9K/DjlieZfS0/SOOWJ5+f8gRaypO/GDECc8yPu2I5Tme6FfbP+OINdWG8mHtdsSaakPHz/aec3fPObKty/MaUJIaIVOqqs/fVUInLn8OuBEypczrfoZfI11yyhtfW8r6uT4r+yKhS13k4ecHC9p7kD/VbdiIizInwt6GXwul6nfc3rFPMxxVrPWXP0WAvHWRx/bmT0k1Qqb0iPoEAtscP1+QwwbXZLW54ddCdzmL2DzrJxus7EuELnXKS9KuZpuO8wbFvYEI1gFHrCOOWPscsXY4Yj3qiLXHEeuwI5anvTzL6KWXilP94quHHLE827anTzzhiDUVv6bi10SW0dP2Dztiefr9k45Ynm27X9vjIUesfu1rPetxryPWy6EfejmU0VMvz7jar/32PY5Ynnp52uttjliPOWJ5jk36tU+bao/Hr4z92m+/HOZpnj7xkCNWv/r9QUesQ45Ynv71lCPWRMRo9Rlkfs5CrfcvishBfv4UM8qZU1LOnIxyppWUMy2jnAUl5SzIKGdhSTkLXwblGRV8ldbfkntAMyuEZ3riPcSvhe4ye+0BKbtY+ZYUkzeaJb6gPmbrk0SeYS1t/cbnqZB+CZQB6fE6SVW6908tkDphJok//XuSKA/eGwAdX2xlsK8kqREypfN5L850QVy0QY46Gsvqg4ZfC6V8ohKzoepzrOxLhS51kZfmLyhnqZBTF3lc71NYU1hTWMWwSsS/OvcLphviYgyYiLMvhl8LpeJtJWZT1YdY2ZcJXeoiz+ybwd4Dfzz3zXuGf+FNt5+xeuZlX184590HL/695w5cvHotx1zDRlyUmaP81az2NvxaKFW/4/ZeRvLSfNjK3hC61CkvSfZMZ0XkDYp7AylYqu8qipWkNzWP/S3R7i5g3zPdELcB9yei3TVa17VQyu8qMZti+dgPlgtd6iIvR7vjNDMQb0Pwzj0nfHrZFy7Yd/oJF+7c9NChL9zwobfO+/lTv1Jf+A97XvvQ//rczhHSKYSecs3c42WdAZlvbh77m4xhX9FqKGbDamjnDRJvcm02rBL9byxt8716aads9AP2sQG4n6PO12b1McOvkS5FfWyA5HH52McGhS51yksSP6M8KOQMCjkK64Aj1pOOWE84Yu11xNrhiPWUI9YeR6zHHbEec8Tq13r09FXP9uip18OOWPscsQ47Ynn6xCOOWJ4+ccgRy9NenvHLU68jjlie9eipV7/2HZ716Gl7z7btWcZnHLHudcR61hHr5dBve7btiehrbc8N52M2eR0jvuR6lPKqkIcYmIf6VSP6IX81hY/LYfPJYcpvhEypYvwjxfjHP/GJ7xIbFDoZvs0Ph1CJlL+GxXkmq0ZYecse0x31i+1582dDFda0nFgjIq9InQyH9HIh/mhEF6Un+mKan2MdcrsYieiF9GNCtvGajfAbmzlsNBCzEbYFwy/xeVMzz+lEd3WzpUvodqVpKViBfp9O9wYBD9MYYahwxc0urRrrKfxJGo3IGRV8Vr7poOMKyOdPsK4QOq6I6Ij8RqfkVErKqQg5jKWWFpO0s3nsb5Xof7u1nJj4wvOLOjFXCv1iTW6VoF8JNKaPso3xjgrZlZS/JieEuA+hDtxFrHKUswpohknOKY5yTgGamSRntaOc1UAzCnzJ7zWQh35mepwq9LBwehrcz9vlIJ7pg/cQv0a65JQ33nWfRvK4fBx7The61EUex93ThZzThRyFZfUxFrrrhz8DvUbIWRORMybklKzL09lWmCxvbegug+WdAXlYv5wG6TfqnMS8mSvbuEzH+qBNTbfJtsMayjsD6O1125Z3JuTZtmYRGy3PYSOsC9Pb+hwb2nwdtrP+nrazqkJnNZznT2SfLPIS+l9afuxatQvu9/O2C+Rfk4JVBazpgGV1VSX6sdaeakm/ulP5FcfhtQWxs8Zhw1d+bHrVRF41gy7vXvMPc3759v/9mQrxmy58j8cqZwh69Rlys9WZwJ/DVreN95vNNr/Jtrwq5K2lvCHIMx2SNvlfTu7U74yC+mWxH+LXRR6+CjtPXdRFnrWLsljY3jywRgpizQ4hdUygYhIf/c8bk5A/NiaYU1LOHCFnsvvCuZSHbQD149Srv9tXckwwFrrtwI9AqDEl3ost4Rid2ZvHlI2QKa1lm2JSNuWlHIyJaAdOyt6mc4L5XA57o01Nt5L92RlqLMVysaynUd5ZQL+12Zl3NuTlHYNZeRIbfSyHjdAfzqS80wRvSftlnpcZfi2UihOVWAxWbUj5svHWRR7aj/1iUNwbiGDZJ2vGBDbHhLzzv2lC58luCxwTzoI8rF9Ovfx9Zkl/n2w7nE55GBN4XuYVE5YXjJtnEq3pPtT6jWsbNpeqEu0vnNzm2bysUxb67E3Nzjysj1NB7tYWxljoti2PiVD/QXEvNiYyOiVnTkk5czLKWVNSzpqMcqaVlDNNyLF2he08R7s6W7UBS5Z3Tugug+WdC3l5xxymc94xB9rUdJtsO3A/fi7Q85jjPMjLG1/QRh8rOA4+h/LOFLwl7Zd5zGH4tdBdl0XGHGeRvLQ2xPWLvHWRxzHhbCHnbCFHYfGYA7E5JuSd900TOvdTTMD65dTL32eW9PfJtgOvBWNM4DGHV0xYXjJust9V4Z4aN/D66Lta44RkzPAOGnfguNtkJ3R/QnRrhN7HKx6tKSYvGo9U+80bj/jISZl4FBuj8CsO8o5RFgg5k90OF1Ce1xhl5g/QGKUf4pGK2ex3WeOR0f867dcUtHXHZ1kDYU2No7LHLZxflo1bsfVzfmVK3nHUQiFnstvrQsqbGkf1Z9xSsT3rmCdrfLu52Zlv9J+G8dZ/SxlHoR4J3YKG1t9okzQVtyZuvGV1MRa6fYTHW3nXthcIOf003pqsuIU2PV5x6wzKeynN/0z3rPHI6P95EsdbsbMzBc9bZI5bhl8jXYrGLdXO1d6S2sfhsx+Yx+MtFR/PEnIUFs8TEZvHW2rvL3aWY6HQuWRdnqn6N0vKjjzewpiN9ctJtUnTOW/cQpuabpNth7WUh/GO49Y5kJc3bqGNlhfcT+SYgGMe3DfjMc9aIaOknTO/co5jR8E90GjsUG0tOQduZ+Bbj69csX335j233XP37Vdv37dr3X13bN724O67t92z7o47Hty+axcqjYJmwn3Mx8Q0dj1b3EeMM3sUxh6YUYOnMwnrrB5YWwgL+c8irLN7YN1AWMiPvPh7KHTraRu6AxlwuAEqvbaSXhjUuNM/twfWNsJC/nMJ67weWLcRFvIjL/4eCt16sr1iOMm/C3rodXuzU6/zgf8CwrqwB9YdhIX8FxLWK3pgbScs5Ede/D0UuvVke8Vwkn+v7KHXjzQ79XoF8L+SsF7VA+tOwkL+VxHWq3tg3UVYyI+8+HsodOvJ9orhJP9e00Ovu5uder0a+I1XDbD4G2p5B1jIzx286gz5r8nhe7FDufyu4dc4ykEse6eX2eG1wI+xdVTcMxnW+b8O7ufojDO//8/wa6RLTnnjnf/rSB6XjycOFwld6iIP+1XMQzkXCTkK60xHrNdSeXCShO92u6nRKdPKig9gIi8/8GH0z8FBqje0MMdCt6+8JkMZXyfkGf3FrfvDgh7xqkT/5saxv8kg+h2tBlcXOl2Uogv3p+wnRpOkEZI9UW3E8Guhu/6LtJGLSV6av1nZLxG61EUejqUwD+VcIuQorHMcsV5H5UlrI/c2OmUWbSMPQRu5v4XZT21kT+PY3zJtBMdQo+Iet5GCPpu5jRh+jXQp2kZUXWD5uI1cLHSpizwcP6e1xYuFHIV1gSNW1jZyqNEp08qTtY0Y/a3QRp5sYao5BrcRNV85X8gzequzYUGPeFWif7Zx7G+vNnJBii7JNY6bR0O3/txGCvps5jZi+LXQ7T9F2oia72H5uI28SuhSF3k4Z2I7Dop7AxGsLHOurFjnU3nS2shPNjplFm0jV0Ib+TctzH5qIz/fOPY3axtRuk/E3EutL+B3LNJspHy3LvgvoLy1Qk4vH/lQQ+uT5iM2f68S/YXgI/+20Vn+vHYeCaXiQuY4ZPheC7691rA4Dl0odKmH7pjG30dQ8U6NCSYLawL7lKGXSp/yCqFLnfKSxPZX64uvEHJeKljJNX9fSY3Hs9SrkoN+NFnrZReQnAsc5SCWxWX2KQ85iMUvCEnrGz7daOMm/2wMk9Y32BpqlehPgb7hsy3MEaLJ2U5fZ7q/TmSqNbULKQ/nHOxHl0Ae1/06yEOf56Q2Vq2syThl9qo2LtNxObD/vIjyJqD/zHzY4qXQf7L9OB7l6fOSa9sXUGObk0jO+ULO+RE5JwmdS9Zl7nZyEuWpdpLV303nvIctlL9Pth14joXrF3zY4hLIy3vYAm20vOCBFF4fQxshHcZtNa9SelUEzvlEa3kDgrfRulZzoaUkI+9caKnQdwLHopnj4kthLKriYpkxX555HcqdiHmd4Xv1SyqOq295efhXWj1cEJFXcAw1/p7dXvv/Ji950ddw6K5DdVaB9XoV4Nu9tDYfO1dU5twHnysqc+6DzxUpG/A61XnLj/1N4vCK5Z00diZmNdCsal2rmI9reecQHZ+vSdJI6K6fiWh7hl8jXYq2PVUPWD70zWkh7iNYR2nnrc4VZWGfPaeHTuyzSpaqUzx/xnWKhyvXAt0FEbqzBZ3CSH7j+T/DqBLtK1sYiZ1PW9VZRnX4s0J5SVLzxtjhZn5BzAS8mDGzbxu+1+FydVYo6+Fy42WbJYnXcooeLp8orCxjhILnbzKvF/IDTmXHCL3OtBZ5wClJbP+iDzj1K1Zyvbx1zX5u+eqvyeF7ZWNJUTkqPk/kumSSeL2QzyGrv1nlqJdtWdvE/nIi5+D8EAGuRXBdXgJ5bP91kHc25V0KeXi2jpOau5sdkv7wjAzreSUfZOh7++V9iBAfNJmyX+f5WE6e9iv4MO85pvM5ItPycPzM9sO5ANsvtkeMY3jsNzgpG+HLn/OsuaOPWZmSB3Vs3t9+UOfq7ftu2nbP3Xds2333zvu2bH9gz/Zdu6uEzj3N2hQt7bdZDnFCROskDVAev4IRT8yrNCr4TIZ5Dlp/IlbODL8WSrX0SmxUoh7TZs9G3rrI49eOqRnhOUKOwrK6Vq/LWEZy8r4uY5nQebIft15GeRgh8va4U6/L6Ey9bLS85KP5lodx6NZmZx5+tYxf8Xwy5OGrLmKfl7DPDvHX3P9ji2eE6IqOAmKvdC44s39d1jiXNhNBvdQqQ5ZPPJz35U/MH/yRO36pErr7ntgqg9GrVYn5gr7kaOzV5pP4iQfs+ZNUhbzTKW8I8nAkxJ94KDizf3UW+yF+XdCvb7bp8tSFmlVyn5MVyz6lgK8ytrajvpSZ5ZNiI0Q7UeMBw6+FUm1+fDwQ+9Rakng8sEboUhd5/NXFvP00Ylk8VXXDr6HJ+xXTBULnknV5moqnllR849fQYPvE+uWk+jrTOe94AG3Kr4CfLDtUKU/tLqkxed7xANooz3gA64L7q6rgPV4xoVpMXjQmqDaUNybgJ73KxgSO11g3/IoX9fnJlRE5C4WcyW4L/IoXjAlYv5w8Y4Ly98m2w0rK67eYoOIm6z4kaFe0rqtE+y/L2zwrWuM21e/ZpzvVJ1BXUx7WY5XyVgmdKiQDT0lhbNjZ7CyD0Vdbeie2/MzJGnMgBRPrNEk4Fsa2eFQO5OXwwd9N9ProyW05aLMkDTU7dVZxCul5vqA+yYSxy2xQJ3oVI1Xswk/A2s66spfpOBH2Qh2y2Avp2V6nCnoV6+uh20ZDhDUksNCGMXuZjhNhL9SB7bW6h85sr5g/og1Uv3kyYSl7YXu8mnQ1/mFBj3hVom9ATOAn0jCucV2vENgYGyuEgeWYIcoxSnnIm+C+YmknrjoJpk4sG716qwo+qWh9hHpzjPGOCL6J3NWZyCcB1K4OlpmT6pvNDll3dSokx3DR/klinzhd6Kie+rggI67RqxNbMR9SeuMpNfahC4Xe6i1Ha1PkYP+OZUt7euUiaMv2qXcVT012yXg6puIp2ojjqWqzSJ+3zfKTFPgELZ8mRhubTOVf+FTphxqtgoZO32BZKA91Rdy0E8zDKfSGVyX6a0W8jvmzOo1b1J+xDGX9Ge11V7OzrEZ/w+T688yJ9mf1pqXYE/749pDzKU/5cyV0x7C88RVP69pT+UWfoI/5v5Utzf/5CXqjvyPi/8q+6mkpo4+9PaaX/19Eeci3NkVOWjxn/zf6HRn932RPhP+jjdj/s74VyegvEfTq7SzqjUQx/7+I5Hj5v725JcubiC6OyGReLFua/xtelej3R/z/EqFDrD7WCfpLgIb9H8uwjvKQb22KHPR/tBf7v9EfyOj/l7TuTYT/o43Y/y+FvEFBz/ZeL+hx/M1vClsPefymPbTxOpKj4mBW/8c3eN3bOHZd9E1cMf9Xb+JC+rQ3cb0r4v+qDaoT31njUcz/L6G8tKdPkRb9H+3F/m/078no/yZ7Ivz/EiBg/18HeYOCnu0day9ok3robhsx/7+E5Hj5P78BstLKwzUNW89Okp03qRL9R2mfH+2So36uHQWeABiIXXCP6doK4YWg97R4L5DlJUntd2U5D7L2rQ+fsWzf0NkV4jdd+B77l1ozO1HQm62GSfdGyJSuVm3QZKvzIFXKw3ZkOqjzIEMF9ctiP8SvC3p+aiJrXcwOnb6A/j7W+jvcBCyQk6Rprd9VwEB6w6oS/W/Bmzt+G2LY0XtCXkL3QoSukvL3KIa4V2123qs1u+kHm930Jnt6s1tHy5sBeeg7R2lav9FeiFWDfKT/Q9jDStII8Bh/XcgfIfkdeot72EYZa1DcM/qkfj7R0rFm90B23v3zJA0TP95j2eYb00O3b6LuWKemn9Ub2pTrFP2jCnodldn6jXWKWNhGkP4vqE6xbMZfF/LRLixLyec6Vb5eE/SJXf8r2LVGOFn7iU2P7Lx/y599+bPqSxAmqwz+/9y4/6c2f+qdz/fCT2L2DhiXcUzMG0P4vANi2fm8kn3XgPHjZ55Ddv4Kn6VFDMMeKabb97KOQQy/Fkr1k+PnakZIHpePxw21YvL+T/Lkt8UTbENYl2g7lDONdJheUAc1djGZauxichL5d6zq1KHgOPb/lPThf1HjYHwb2DdpD9Jsh/MvNT6pEv3/gjHFt+nMB8eUJE2H/Gki336bvQcELX++HX+b7mw3pDefGU4p6zCV1ei/B3PNpxdpTLQf6jWQgjmwoo35PGGaX4UQb3NGP0PQYxswfcZCd9uZQXyoey10pg79g64TpEUdkoTnqKcR7bQUOWwPpcOIwFH79DXSFWWyPySJ58KDQg62KezzSs45h1RfYsny+LOZmIdlu6XZpuM0SL9R5wTjCzQPQDrWR7Ulz77f7g/BfZbL8/9houWzN6jjkIOOdSFnmHCnRfSvEE5V8I0G3d7U36z6VoS+sTWVonIQ64eax/6W7PMWm57oJ9jnnbqijZvW56kxB/d5Z65o861tXffq8yyPx31JemOzfY9jOo+jECNJfF7DYuQw4CPN+Pon0Z8H/dDTNF6fJuQdfQsN2dOw0/rAGsk2+q1gz1eSPdFefP6T43iA39NBF6RNkvU/bINLQI/XrUiXZXYdjZQxwbh0haZDHZCOMYr2a2p8xW03y/iK2yryKRkcj9P6bvONGT3yp4uyBXFvQNCPpJQ3CNm1HrjTBI6K7zXKq4g8jj1YXoxbPObAuIBx69RIe6mEznJNp3KNRMpVEXzczlH3aRHdlf0wfhRdgxipjO753klv+chErXH89Wu+/r/2Xzz4xETh3zLw14t/Y+kv/UyeNRSr52GSZddob7yPYw/bj+F+7a5WfZRco5Cflea4EZufof48n0vSDSn6PwHx+x5qF2p+otpMWv87lFEXo39AzOvUugKuWRzFgbwcNq+qfUmMa0PNNm5avEX6vHNLs0k9dMfXLOfc0aY8pjEbDQc9v+dz20b/KNQBn9tWsdnysOwcFweFXLUWaW0soflxalcFx7fT1DjC0mhIj//sD1hGy+O1MsxT580rQgc1h8S9u/fAeIjpLKn4wO1VravExouq3Rl+v7U78/166K4X9resPpw2nlPysH6xrzYfTlvTxzaNc66fojnCMGCqNS2Op0b/6xDbf4ZiO8YX9gcVJ1iXEHQcyjKXHxV8Vi9qHyHP2g/WL+qJ9xC/FkrFlwrHW5PHdcRr/QXHCVXuY1GeqodZQdtU7QfwXFGt98TmSbF4otoft021jqD6kNh8zmTjmnmWcZNqW8jL/eS/h7b1QmTclDY2CkHPA5g+FvtQV2X76ZSn5v52PSMiR+k1KuhnRPTCmIy8LLtXGbL2VU5jxCHVV2GdcF+l7IL0bMeZgn4UaLiNzIS8GZSXtW+bTnlq7blX3/ZCSh+F5cD4x/Nb1caw78P+skK6oAyc/9t5xwrJGA56rdLwqkT/38QYmDEtXiTp7mY3ZkXICKHbLjyvNLrPgA4Przp2HdsPKHm2ayb6jiXVbxq+17sn1LxGnf8qOQ8YjfmpGu+odRjuD3ut3fL+iVo7ShKv7X6lVfd1wkwSn59T4w7VnyQ6fonWVidqz4bPcqbtp3+VYgg+l6v2FPk8s9F/Hfrir0X2FkzH6SEeU7C8HK+tTtP2wTmmGP23IjFFje9RL34u0+j/WayXxPxC1R/7MtKrswZqTMXrVCrWqT7a6CbifDmWn/voXmuxWcZsak+qTvSqP8V2wutrMV9MUmxPHdvOV0uuEX9p9j9dfeTj9c9N1BruHdue+sB/+uN3fzLPGm7MRshvNjJfVDbKOp5grEoEa6gHFn95Ja2NMJ/JLNm/Z/7CA/fvBc9iVbLahdfUVF9cF3k8j8u7LqHWyjywuO9D7DTfVvNOtFEIejyBtr2+2Sk3do6y4NpKZh/itZWy5yizrq2o9VxeK8DYz2Mp1S+MCDmThaX6Mq7LgutImdfJ+ExsQd+p5O171fo77ytgv8z2V322Ws94qWBh+4+tn2apVyUnNgeaqHkCn8ma5igHsfgrIXyuQf3NKgex+KvCVaFDUv6rVrZxsY7Txv9p+6XbV7b5rl3ZSWO6bwKaW1rXIyA7hNxtuab2bCypvTH2W7VOaHm49sX+gWtfI5Q3BjrgWVlOg/Qb7ZDIy/K+IWXLguOkvrJlVntZWRPMPF+UQH+zMuFcPNYOUC63g7vAxx+itqXWz1V7tvu99uxj5+mMt+SzFDO4bjGpumWfwLplnxiDPPaJOuRx+5oFeTzvw6T8BZ/1yNq+HkqJkSaDYyTPjdUZP4y9Ez23HOqBlWU+GMPKOk+dmlse37ll1RGrQuVB207G84OxMsTaSewMQEXoVXKtP/PcxvBrodueRfyxl13YH9VeQV3kcTzIuubvuX8wWVhq35H9Pm0/4b3UZxhf2n4Cj6uN/v0wnnhf6zrrswrscyyTz+kpn1ExLGZjFbtU2+Nn2bKch0XbYdm2No/95XMRH4b+NXaG0+ks2dDxXvs3m6j5etpZR5Sp1vLRb98rxitT64UyTa0Xhu7yc11OrRceS1PrhfqvyeF7U+uFPnKKrBd+Oed6IffNRv8vMK75m5T1wq8AzT9OrRe6rRf+49R6Yd+sF9oHDBK+sVVtepQTwtR6IbYT5RP9tF7I9ei1XvhlMf5Wc6u0dZ6s5z6NfkGrHCXH3vJ5QjwTzfrnwB5W4wlLam2jQnnq2UE1fhukPNWusvqUlTXR65EMPpXlGYhhUY7Y8xGT8QxEkux9oRXCDEGvOcbWjz3Oez34+z//htG/eeTOfnlm9zxqYwXnRMftmd1roP96xapOeZP9zO5rW/KnntnNtm8zEc/sXgF1cDyf2b2d2tXL9ZndPP3L1DO73fXC/pbVhz2e2TUfng73h5tt2hw2GzC9zTaDoa1TtdkmNHyrvxHIM7rxdbViuozb0N7panEeMVHXAaLn6yrdewjG30f1bXbqifcQ3+hnQJ7RD8I901G9g3ZGMx/WCGFNK4Fleql3Gk8rqJfCGiasPO/GvQt8uugY7u+/928em/7Jf/O9Iu+uxX4Q17Ueozlb0efc3w3joSaNh9QeydRz7rnlTT3nHrr3Vl8Oz7n/OLStX43MNbLsm0495975e+o59zYNt5F+ec79V1P6KCwHxr+sz7lb3/d/Afexq6vTjwUA",
      "debug_symbols": "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"
    }
  ],
  "outputs": {
    "globals": {
      "storage": [
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "Token"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "admin",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "minters",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000002"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000003"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "total_supply",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000004"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "public_balances",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000005"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "symbol",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000006"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "name",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000008"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  },
                  {
                    "name": "decimals",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "000000000000000000000000000000000000000000000000000000000000000a"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        },
        {
          "fields": [
            {
              "name": "contract_name",
              "value": {
                "kind": "string",
                "value": "AMM"
              }
            },
            {
              "name": "fields",
              "value": {
                "fields": [
                  {
                    "name": "config",
                    "value": {
                      "fields": [
                        {
                          "name": "slot",
                          "value": {
                            "kind": "integer",
                            "sign": false,
                            "value": "0000000000000000000000000000000000000000000000000000000000000001"
                          }
                        }
                      ],
                      "kind": "struct"
                    }
                  }
                ],
                "kind": "struct"
              }
            }
          ],
          "kind": "struct"
        }
      ]
    },
    "structs": {
      "functions": [
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "config",
                    "type": {
                      "fields": [
                        {
                          "name": "token0",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "token1",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "liquidity_token",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "config::Config"
                    }
                  },
                  {
                    "name": "refund_token0_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "refund_token1_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "liquidity_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "amount0_max",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount1_max",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount0_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount1_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::_add_liquidity_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::_add_liquidity_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "config",
                    "type": {
                      "fields": [
                        {
                          "name": "token0",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "token1",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        },
                        {
                          "name": "liquidity_token",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "config::Config"
                    }
                  },
                  {
                    "name": "liquidity",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token0_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "token1_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "amount0_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount1_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::_remove_liquidity_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::_remove_liquidity_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_in",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_out",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount_in",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount_out_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "token_out_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::_swap_exact_tokens_for_tokens_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::_swap_exact_tokens_for_tokens_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_in",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_out",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount_in_max",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount_out",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "change_token_in_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  },
                  {
                    "name": "token_out_partial_note",
                    "type": {
                      "fields": [
                        {
                          "name": "commitment",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "uint_note::uint_note::PartialUintNote"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::_swap_tokens_for_exact_tokens_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::_swap_tokens_for_exact_tokens_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "amount0_max",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount1_max",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount0_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount1_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::add_liquidity_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::add_liquidity_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token0",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token1",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "liquidity_token",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::constructor_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::constructor_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "balance_in",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "balance_out",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount_out",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::get_amount_in_for_exact_out_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::get_amount_in_for_exact_out_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "balance_in",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "balance_out",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount_in",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::get_amount_out_for_exact_in_parameters"
              }
            },
            {
              "name": "return_type",
              "type": {
                "kind": "integer",
                "sign": "unsigned",
                "width": 128
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::get_amount_out_for_exact_in_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "message_ciphertext",
                    "type": {
                      "fields": [
                        {
                          "name": "storage",
                          "type": {
                            "kind": "array",
                            "length": 17,
                            "type": {
                              "kind": "field"
                            }
                          }
                        },
                        {
                          "name": "len",
                          "type": {
                            "kind": "integer",
                            "sign": "unsigned",
                            "width": 32
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "std::collections::bounded_vec::BoundedVec"
                    }
                  },
                  {
                    "name": "message_context",
                    "type": {
                      "fields": [
                        {
                          "name": "tx_hash",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "unique_note_hashes_in_tx",
                          "type": {
                            "fields": [
                              {
                                "name": "storage",
                                "type": {
                                  "kind": "array",
                                  "length": 64,
                                  "type": {
                                    "kind": "field"
                                  }
                                }
                              },
                              {
                                "name": "len",
                                "type": {
                                  "kind": "integer",
                                  "sign": "unsigned",
                                  "width": 32
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "std::collections::bounded_vec::BoundedVec"
                          }
                        },
                        {
                          "name": "first_nullifier_in_tx",
                          "type": {
                            "kind": "field"
                          }
                        },
                        {
                          "name": "recipient",
                          "type": {
                            "fields": [
                              {
                                "name": "inner",
                                "type": {
                                  "kind": "field"
                                }
                              }
                            ],
                            "kind": "struct",
                            "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::messages::processing::message_context::MessageContext"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::process_message_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::process_message_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "liquidity",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount0_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount1_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::remove_liquidity_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::remove_liquidity_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_in",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_out",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount_in",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount_out_min",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::swap_exact_tokens_for_tokens_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::swap_exact_tokens_for_tokens_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [
                  {
                    "name": "token_in",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "token_out",
                    "type": {
                      "fields": [
                        {
                          "name": "inner",
                          "type": {
                            "kind": "field"
                          }
                        }
                      ],
                      "kind": "struct",
                      "path": "aztec::protocol_types::address::aztec_address::AztecAddress"
                    }
                  },
                  {
                    "name": "amount_out",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "amount_in_max",
                    "type": {
                      "kind": "integer",
                      "sign": "unsigned",
                      "width": 128
                    }
                  },
                  {
                    "name": "authwit_nonce",
                    "type": {
                      "kind": "field"
                    }
                  }
                ],
                "kind": "struct",
                "path": "AMM::swap_tokens_for_exact_tokens_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::swap_tokens_for_exact_tokens_abi"
        },
        {
          "fields": [
            {
              "name": "parameters",
              "type": {
                "fields": [],
                "kind": "struct",
                "path": "AMM::sync_private_state_parameters"
              }
            }
          ],
          "kind": "struct",
          "path": "AMM::sync_private_state_abi"
        }
      ]
    }
  },
  "file_map": {
    "101": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/aztec.nr",
      "source": "use crate::macros::{\n    dispatch::generate_public_dispatch,\n    functions::{stub_registry, utils::check_each_fn_macroified},\n    notes::NOTES,\n    storage::STORAGE_LAYOUT_NAME,\n    utils::{get_trait_impl_method, module_has_storage},\n};\n\n/// Marks a contract as an Aztec contract, generating the interfaces for its functions and notes, as well as injecting\n/// the `sync_private_state` utility function.\n/// Note: This is a module annotation, so the returned quote gets injected inside the module (contract) itself.\npub comptime fn aztec(m: Module) -> Quoted {\n    let interface = generate_contract_interface(m);\n\n    // Functions that don't have #[private], #[public], #[utility], #[contract_library_method], or #[test] are not\n    // allowed in contracts.\n    check_each_fn_macroified(m);\n\n    // We generate `_compute_note_hash_and_nullifier`, `sync_private_state` and `process_message`\n    // functions only if they are not already implemented. If they are implemented we just insert empty\n    // quotes.\n    let contract_library_method_compute_note_hash_and_nullifier = if !m.functions().any(|f| {\n        f.name() == quote { _compute_note_hash_and_nullifier }\n    }) {\n        generate_contract_library_method_compute_note_hash_and_nullifier()\n    } else {\n        quote {}\n    };\n    let sync_private_state = if !m.functions().any(|f| f.name() == quote { sync_private_state }) {\n        generate_sync_private_state()\n    } else {\n        quote {}\n    };\n    let process_message = if !m.functions().any(|f| f.name() == quote { process_message }) {\n        generate_process_message()\n    } else {\n        quote {}\n    };\n    let public_dispatch = generate_public_dispatch(m);\n\n    quote {\n        $interface\n        $contract_library_method_compute_note_hash_and_nullifier\n        $public_dispatch\n        $sync_private_state\n        $process_message\n    }\n}\n\ncomptime fn generate_contract_interface(m: Module) -> Quoted {\n    let module_name = m.name();\n    let contract_stubs = stub_registry::get(m);\n    let fn_stubs_quote = if contract_stubs.is_some() {\n        contract_stubs.unwrap().join(quote {})\n    } else {\n        quote {}\n    };\n\n    let has_storage_layout = module_has_storage(m) & STORAGE_LAYOUT_NAME.get(m).is_some();\n    let storage_layout_getter = if has_storage_layout {\n        let storage_layout_name = STORAGE_LAYOUT_NAME.get(m).unwrap();\n        quote {\n            pub fn storage_layout() -> StorageLayoutFields {\n                $storage_layout_name.fields\n            }\n        }\n    } else {\n        quote {}\n    };\n\n    let library_storage_layout_getter = if has_storage_layout {\n        quote {\n            #[contract_library_method]\n            $storage_layout_getter\n        }\n    } else {\n        quote {}\n    };\n\n    quote {\n        pub struct $module_name {\n            pub target_contract: dep::aztec::protocol_types::address::AztecAddress\n        }\n\n        impl $module_name {\n            $fn_stubs_quote\n\n            pub fn at(\n                addr: aztec::protocol_types::address::AztecAddress\n            ) -> Self {\n                Self { target_contract: addr }\n            }\n\n            pub fn interface() -> Self {\n                Self { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n            }\n\n            $storage_layout_getter\n        }\n\n        #[contract_library_method]\n        pub fn at(\n            addr: aztec::protocol_types::address::AztecAddress\n        ) -> $module_name {\n            $module_name { target_contract: addr }\n        }\n\n        #[contract_library_method]\n        pub fn interface() -> $module_name {\n            $module_name { target_contract: aztec::protocol_types::address::AztecAddress::zero() }\n        }\n\n        $library_storage_layout_getter\n\n    }\n}\n\n/// Generates a contract library method called `_compute_note_hash_and_nullifier` which is used for note\n/// discovery (to create the `aztec::messages::discovery::ComputeNoteHashAndNullifier` function) and to implement the\n/// `compute_note_hash_and_nullifier` unconstrained contract function.\ncomptime fn generate_contract_library_method_compute_note_hash_and_nullifier() -> Quoted {\n    if NOTES.len() > 0 {\n        // Contracts that do define notes produce an if-else chain where `note_type_id` is matched against the\n        // `get_note_type_id()` function of each note type that we know of, in order to identify the note type. Once we\n        // know it we call we correct `unpack` method from the `Packable` trait to obtain the underlying note type, and\n        // compute the note hash (non-siloed) and inner nullifier (also non-siloed).\n\n        let mut if_note_type_id_match_statements_list = &[];\n        for i in 0..NOTES.len() {\n            let typ = NOTES.get(i);\n\n            let get_note_type_id = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteType },\n                quote { get_id },\n            );\n            let unpack = get_trait_impl_method(\n                typ,\n                quote { crate::protocol_types::traits::Packable },\n                quote { unpack },\n            );\n\n            let compute_note_hash = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_note_hash },\n            );\n\n            let compute_nullifier_unconstrained = get_trait_impl_method(\n                typ,\n                quote { crate::note::note_interface::NoteHash },\n                quote { compute_nullifier_unconstrained },\n            );\n\n            let if_or_else_if = if i == 0 {\n                quote { if }\n            } else {\n                quote { else if }\n            };\n\n            if_note_type_id_match_statements_list = if_note_type_id_match_statements_list.push_back(\n                quote {\n                    $if_or_else_if note_type_id == $get_note_type_id() {\n                        // As an extra safety check we make sure that the packed_note BoundedVec has the expected\n                        // length, since we're about to interpret its raw storage as a fixed-size array by calling the\n                        // unpack function on it.\n                        let expected_len = <$typ as $crate::protocol_types::traits::Packable>::N;\n                        let actual_len = packed_note.len();\n                        assert(\n                            actual_len == expected_len,\n                            f\"Expected packed note of length {expected_len} but got {actual_len} for note type id {note_type_id}\"\n                        );\n\n                        let note = $unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n\n                        let note_hash = $compute_note_hash(note, storage_slot);\n    \n                        // The message discovery process finds settled notes, that is, notes that were created in prior\n                        // transactions and are therefore already part of the note hash tree. We therefore compute the\n                        // nullification note hash by treating the note as a settled note with the provided note nonce.\n                        let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n                            aztec::note::retrieved_note::RetrievedNote{ \n                                note, \n                                contract_address, \n                                metadata: aztec::note::note_metadata::SettledNoteMetadata::new(note_nonce).into()\n                            }, \n                            storage_slot,\n                        );\n\n                        let inner_nullifier = $compute_nullifier_unconstrained(note, note_hash_for_nullify);\n\n                        Option::some(\n                            aztec::messages::discovery::NoteHashAndNullifier {\n                                note_hash, inner_nullifier\n                            }\n                        )\n                    }\n                },\n            );\n        }\n\n        let if_note_type_id_match_statements = if_note_type_id_match_statements_list.join(quote {});\n\n        quote {\n            /// Unpacks an array into a note corresponding to `note_type_id` and then computes its note hash\n            /// (non-siloed) and inner nullifier (non-siloed) assuming the note has been inserted into the note hash\n            /// tree with `note_nonce`.\n            ///\n            /// The signature of this function notably matches the `aztec::messages::discovery::ComputeNoteHashAndNullifier` type,\n            /// and so it can be used to call functions from that module such as `discover_new_messages`, \n            /// `do_process_log` and `attempt_note_discovery`.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                storage_slot: Field,\n                note_type_id: Field,\n                contract_address: aztec::protocol_types::address::AztecAddress,\n                note_nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                $if_note_type_id_match_statements\n                else {\n                    Option::none()\n                }\n            }\n        }\n    } else {\n        // Contracts with no notes still implement this function to avoid having special-casing, the implementation\n        // simply throws immediately.\n        quote {\n            /// This contract does not use private notes, so this function should never be called as it will\n            /// unconditionally fail.\n            ///\n            /// This function is automatically injected by the `#[aztec]` macro.\n            #[contract_library_method]\n            unconstrained fn _compute_note_hash_and_nullifier(\n                _packed_note: BoundedVec<Field, aztec::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN>,\n                _storage_slot: Field,\n                _note_type_id: Field,\n                _contract_address: aztec::protocol_types::address::AztecAddress,\n                _nonce: Field,\n            ) -> Option<aztec::messages::discovery::NoteHashAndNullifier> {\n                panic(f\"This contract does not use private notes\")\n            }\n        }\n    }\n}\n\ncomptime fn generate_sync_private_state() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // All we need to do here is trigger message discovery, but this is already done by the #[utility] macro - we don't\n    // need to do anything extra.\n    quote {\n        #[$utility]\n        unconstrained fn sync_private_state() {\n        }\n    }\n}\n\ncomptime fn generate_process_message() -> Quoted {\n    // We obtain the `utility` function on the next line instead of directly doing\n    // `#[aztec::macros::functions::utility]` in the returned quote because the latter would result in the function\n    // attribute having the full path in the ABI. This is undesirable because we use the information in the ABI only\n    // to determine whether a function is `private`, `public`, or `utility`.\n    let utility = crate::macros::functions::utility;\n\n    // TODO(#15012): Here we use PRIVATE_LOG_CIPHERTEXT_LEN for message ciphertext length. Fix message vs log naming.\n    quote {\n        #[$utility]\n        unconstrained fn process_message(\n            message_ciphertext: BoundedVec<Field, aztec::protocol_types::constants::PRIVATE_LOG_CIPHERTEXT_LEN>,\n            message_context: aztec::messages::processing::message_context::MessageContext,\n        ) {\n            aztec::messages::discovery::process_message::do_process_message(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n                message_ciphertext,\n                message_context,\n            );\n        }\n    }\n}\n"
    },
    "102": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/dispatch.nr",
      "source": "use super::utils::{compute_fn_selector, size_in_fields};\nuse poseidon::poseidon2::Poseidon2Hasher;\nuse std::{collections::umap::UHashMap, hash::BuildHasherDefault, panic};\n\n/// Returns an `fn public_dispatch(...)` function for the given module that's assumed to be an Aztec contract.\npub comptime fn generate_public_dispatch(m: Module) -> Quoted {\n    let functions = m.functions();\n    let functions =\n        functions.filter(|function: FunctionDefinition| function.has_named_attribute(\"public\"));\n\n    let unit = get_type::<()>();\n\n    let seen_selectors =\n        &mut UHashMap::<Field, Quoted, BuildHasherDefault<Poseidon2Hasher>>::default();\n\n    let ifs = functions.map(|function: FunctionDefinition| {\n        let parameters = function.parameters();\n        let return_type = function.return_type();\n\n        let selector: Field = compute_fn_selector(function);\n        let fn_name = function.name();\n\n        // Since function selectors are computed as the first 4 bytes of the hash of the function signature,\n        // it's possible to have collisions. With the following check, we ensure it doesn't happen within\n        // the same contract.\n        if seen_selectors.contains_key(selector) {\n            let existing_fn = seen_selectors.get(selector).unwrap();\n            panic(\n                f\"Public function selector collision detected between functions '{fn_name}' and '{existing_fn}'\",\n            );\n        }\n        seen_selectors.insert(selector, fn_name);\n\n        let mut parameters_size = 0;\n        for param in parameters {\n            parameters_size += size_in_fields(param.1);\n        }\n\n        let initial_read = if parameters.len() == 0 {\n            quote {}\n        } else {\n            // The initial calldata_copy offset is 1 to skip the Field selector\n            // The expected calldata is the serialization of\n            // - FunctionSelector: the selector of the function intended to dispatch\n            // - Parameters: the parameters of the function intended to dispatch\n            // That is, exactly what is expected for a call to the target function,\n            // but with a selector added at the beginning.\n            quote {\n                let input_calldata: [Field; $parameters_size] = dep::aztec::context::public_context::calldata_copy(1, $parameters_size);\n                let mut reader = dep::aztec::protocol_types::utils::reader::Reader::new(input_calldata);\n            }\n        };\n\n        let parameter_index: &mut u32 = &mut 0;\n        let reads = parameters.map(|param: (Quoted, Type)| {\n            let parameter_index_value = *parameter_index;\n            let param_name = f\"arg{parameter_index_value}\".quoted_contents();\n            let param_type = param.1;\n            let read = quote {\n                let $param_name: $param_type = reader.read_struct(dep::aztec::protocol_types::traits::Deserialize::deserialize);\n            };\n            *parameter_index += 1;\n            quote { $read }\n        });\n        let read = reads.join(quote { });\n\n        let mut args = &[];\n        for parameter_index in 0..parameters.len() {\n            let param_name = f\"arg{parameter_index}\".quoted_contents();\n            args = args.push_back(quote { $param_name });\n        }\n\n        let args = args.join(quote { , });\n        // name of the function is assigned just before the call so debug metadata doesn't span most of this macro when figuring out where the call comes from.\n        let name = function.name();\n        let call = quote { $name($args) };\n\n        let return_code = if return_type == unit {\n            quote {\n                $call;\n                // Force early return.\n                dep::aztec::context::public_context::avm_return([]);\n            }\n        } else {\n            quote {\n                let return_value = dep::aztec::protocol_types::traits::Serialize::serialize($call);\n                dep::aztec::context::public_context::avm_return(return_value.as_slice());\n            }\n        };\n\n        let if_ = quote {\n            if selector == $selector {\n                $initial_read\n                $read\n                $return_code\n            }\n        };\n        if_\n    });\n\n    if ifs.len() == 0 {\n        // No dispatch function if there are no public functions\n        quote {}\n    } else {\n        let ifs = ifs.push_back(quote { panic(f\"Unknown selector {selector}\") });\n        let dispatch = ifs.join(quote {  });\n\n        let body = quote {\n            // We mark this as public because our whole system depends on public\n            // functions having this attribute. However, the public MACRO will\n            // handle the public_dispatch function specially and do nothing.\n            #[public]\n            pub unconstrained fn public_dispatch(selector: Field) {\n                $dispatch\n            }\n        };\n\n        body\n    }\n}\n\ncomptime fn get_type<T>() -> Type {\n    let t: T = std::mem::zeroed();\n    std::meta::type_of(t)\n}\n"
    },
    "106": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/call_interface_stubs.nr",
      "source": "use crate::macros::utils::{\n    add_to_field_array, AsStrQuote, compute_fn_selector, is_fn_private, is_fn_public, is_fn_view,\n};\nuse std::meta::unquote;\n\ncomptime global FROM_FIELD: TypedExpr = {\n    let from_field_trait = quote { protocol_types::traits::FromField }.as_trait_constraint();\n    let function_selector_typ =\n        quote { protocol_types::abis::function_selector::FunctionSelector }.as_type();\n    function_selector_typ.get_trait_impl(from_field_trait).unwrap().methods().filter(|m| {\n        m.name() == quote { from_field }\n    })[0]\n        .as_typed_expr()\n};\n\ncomptime global SERIALIZED_ARGS_NAME: Quoted = quote { serialized_args };\n\npub comptime fn stub_fn(f: FunctionDefinition) -> Quoted {\n    let is_static_call = is_fn_view(f);\n\n    if is_fn_private(f) {\n        if is_static_call {\n            create_private_static_stub(f)\n        } else {\n            create_private_stub(f)\n        }\n    } else if is_fn_public(f) {\n        if is_static_call {\n            create_public_static_stub(f)\n        } else {\n            create_public_stub(f)\n        }\n    } else {\n        create_utility_stub(f)\n    }\n}\n\n/// Utility function creating stubs used by all the stub functions in this file.\ncomptime fn create_stub_base(\n    f: FunctionDefinition,\n) -> (Quoted, Quoted, Quoted, Quoted, u32, Field) {\n    let fn_name = f.name();\n    let fn_parameters = f.parameters();\n    let fn_parameters_list =\n        fn_parameters.map(|(name, typ): (Quoted, Type)| quote { $name: $typ }).join(quote {,});\n    let params_num_fields =\n        fn_parameters.fold(0, |acc, (_, typ)| acc + crate::macros::utils::size_in_fields(typ));\n\n    let serialized_args_index_name = quote { serialized_args_index };\n    // Example of what the fold(...) below will generate for `target_address` and `fee_juice_limit_per_tx` function\n    // parameters:\n    // ```\n    // let mut serialized_args = [0;2];\n    // let mut serialized_args_index = 0;\n    // let target_address_serialized = aztec::protocol_types::traits::Serialize::serialize(target_address)\n    // for i in 0..target_address_serialized.len() {\n    //    serialized_args[serialized_args_index] = target_address_serialized[i];\n    //    serialized_args_index += 1;\n    // }\n    // serialized_args[serialized_args_index] = fee_juice_limit_per_tx as Field\n    // serialized_args_index += 1;\n    // ```\n    let serialized_args_array_construction = fn_parameters.fold(\n        quote {\n            let mut $SERIALIZED_ARGS_NAME = [0; $params_num_fields];\n            let mut $serialized_args_index_name: u32 = 0;\n        },\n        |args, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let arg_to_append =\n                add_to_field_array(SERIALIZED_ARGS_NAME, serialized_args_index_name, name, typ);\n            quote {\n                $args\n                $arg_to_append\n            }\n        },\n    );\n\n    let (fn_name_str, _) = fn_name.as_str_quote();\n    let fn_name_len: u32 = unquote!(quote { $fn_name_str.as_bytes().len()});\n    let fn_selector: Field = compute_fn_selector(f);\n\n    (\n        fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len,\n        fn_selector,\n    )\n}\n\ncomptime fn create_private_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_array_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_array_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_private_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PrivateStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PrivateStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_public_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n                false\n            )\n        }\n    }\n}\n\ncomptime fn create_public_static_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::PublicStaticCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::PublicStaticCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n\ncomptime fn create_utility_stub(f: FunctionDefinition) -> Quoted {\n    let (fn_name, fn_parameters_list, serialized_args_slice_construction, fn_name_str, fn_name_len, fn_selector) =\n        create_stub_base(f);\n    let fn_return_type = f.return_type();\n\n    quote {\n        pub fn $fn_name(self, $fn_parameters_list) -> dep::aztec::context::call_interfaces::UtilityCallInterface<$fn_name_len, $fn_return_type> {\n            $serialized_args_slice_construction\n            let selector = $FROM_FIELD($fn_selector);\n            dep::aztec::context::call_interfaces::UtilityCallInterface::new(\n                self.target_contract,\n                selector,\n                $fn_name_str,\n                $SERIALIZED_ARGS_NAME,\n            )\n        }\n    }\n}\n"
    },
    "107": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/initialization_utils.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress,\n    constants::GENERATOR_INDEX__CONSTRUCTOR, hash::poseidon2_hash_with_separator, traits::ToField,\n};\n\nuse crate::{\n    context::{PrivateContext, PublicContext},\n    oracle::get_contract_instance::{\n        get_contract_instance, get_contract_instance_deployer_avm,\n        get_contract_instance_initialization_hash_avm,\n    },\n};\n\npub fn mark_as_initialized_public(context: &mut PublicContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn mark_as_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier =\n        compute_unsiloed_contract_initialization_nullifier((*context).this_address());\n    context.push_nullifier(init_nullifier);\n}\n\npub fn assert_is_initialized_public(context: &mut PublicContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    assert(context.nullifier_exists(init_nullifier, context.this_address()), \"Not initialized\");\n}\n\npub fn assert_is_initialized_private(context: &mut PrivateContext) {\n    let init_nullifier = compute_unsiloed_contract_initialization_nullifier(context.this_address());\n    context.push_nullifier_read_request(init_nullifier);\n}\n\nfn compute_unsiloed_contract_initialization_nullifier(address: AztecAddress) -> Field {\n    address.to_field()\n}\n\npub fn assert_initialization_matches_address_preimage_public(context: PublicContext) {\n    let address = context.this_address();\n    let deployer = get_contract_instance_deployer_avm(address).unwrap();\n    let initialization_hash = get_contract_instance_initialization_hash_avm(address).unwrap();\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (deployer.is_zero()) | (deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\npub fn assert_initialization_matches_address_preimage_private(context: PrivateContext) {\n    let address = context.this_address();\n    let instance = get_contract_instance(address);\n    let expected_init = compute_initialization_hash(context.selector(), context.get_args_hash());\n    assert(instance.initialization_hash == expected_init, \"Initialization hash does not match\");\n    assert(\n        (instance.deployer.is_zero()) | (instance.deployer == context.msg_sender()),\n        \"Initializer address is not the contract deployer\",\n    );\n}\n\n/// This function is not only used in macros but it's also used by external people to check that an instance has been\n/// initialized with the correct constructor arguments. Don't hide this unless you implement factory functionality.\npub fn compute_initialization_hash(\n    init_selector: FunctionSelector,\n    init_args_hash: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [init_selector.to_field(), init_args_hash],\n        GENERATOR_INDEX__CONSTRUCTOR,\n    )\n}\n"
    },
    "110": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/functions/utils.nr",
      "source": "use crate::macros::{\n    functions::{\n        auth_registry::AUTHORIZE_ONCE_REGISTRY, call_interface_stubs::stub_fn, stub_registry,\n    },\n    notes::NOTES,\n    utils::{\n        add_to_hasher, fn_has_authorize_once, fn_has_noinitcheck, get_fn_visibility,\n        is_fn_contract_library_method, is_fn_initializer, is_fn_internal, is_fn_private,\n        is_fn_public, is_fn_test, is_fn_utility, is_fn_view, modify_fn_body, module_has_initializer,\n        module_has_storage,\n    },\n};\nuse std::meta::{ctstring::AsCtString, type_of};\n\npub(crate) comptime fn transform_private(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Private functions undergo a lot of transformations from their Aztec.nr form into a circuit that can be fed to the\n    // Private Kernel Circuit.\n    // First we change the function signature so that it also receives `PrivateContextInputs`, which contain information\n    // about the execution context (e.g. the caller).\n    let original_params = f.parameters();\n    f.set_parameters(&[(\n        quote { inputs },\n        quote { crate::context::inputs::private_context_inputs::PrivateContextInputs }.as_type(),\n    )]\n        .append(original_params));\n\n    let mut body = f.body().as_block().unwrap();\n\n    // The original params are hashed and passed to the `context` object, so that the kernel can verify we've received\n    // the correct values.\n    // TODO: Optimize args_hasher for small number of arguments\n    let args_hasher_name = quote { args_hasher };\n    let args_hasher = original_params.fold(\n        quote {\n            let mut $args_hasher_name = dep::aztec::hash::ArgsHasher::new();\n        },\n        |args_hasher, param: (Quoted, Type)| {\n            let (name, typ) = param;\n            let appended_arg = add_to_hasher(args_hasher_name, name, typ);\n            quote {\n                $args_hasher\n                $appended_arg\n            }\n        },\n    );\n\n    let context_creation = quote {\n        let mut context = dep::aztec::context::private_context::PrivateContext::new(inputs, dep::aztec::protocol_types::traits::Hash::hash($args_hasher_name));\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !is_fn_initializer(f) & !fn_has_noinitcheck(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // All private functions perform message discovery, since they may need to access notes. This is slightly\n    // inefficient and could be improved by only doing it once we actually attempt to read any. Note that the message\n    // discovery call syncs private events as well. We do not sync those here if there are no notes because we don't\n    // have an API that would access events from private functions.\n    let message_discovery_call = if NOTES.len() > 0 {\n        create_message_discovery_call()\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    // Finally, we need to change the return type to be `PrivateCircuitPublicInputs`, which is what the Private Kernel\n    // circuit expects.\n    let return_value_var_name = quote { macro__returned__values };\n\n    let return_value_type = f.return_type();\n    let return_value = if body.len() == 0 {\n        quote {}\n    } else if return_value_type != type_of(()) {\n        // The original return value is passed to a second args hasher which the context receives.\n        let (body_without_return, last_body_expr) = body.pop_back();\n        let return_value = last_body_expr.quoted();\n        let return_value_assignment =\n            quote { let $return_value_var_name: $return_value_type = $return_value; };\n        let return_hasher_name = quote { return_hasher };\n        let return_value_into_hasher =\n            add_to_hasher(return_hasher_name, return_value_var_name, return_value_type);\n\n        body = body_without_return;\n\n        quote {\n            let mut $return_hasher_name = dep::aztec::hash::ArgsHasher::new();\n            $return_value_assignment\n            $return_value_into_hasher\n            context.set_return_hash($return_hasher_name);\n        }\n    } else {\n        let (body_without_return, last_body_expr) = body.pop_back();\n        if !last_body_expr.has_semicolon()\n            & last_body_expr.as_for().is_none()\n            & last_body_expr.as_assert().is_none()\n            & last_body_expr.as_for_range().is_none()\n            & last_body_expr.as_assert_eq().is_none()\n            & last_body_expr.as_let().is_none() {\n            let unused_return_value_name = f\"_{return_value_var_name}\".quoted_contents();\n            body = body_without_return.push_back(\n                quote { let $unused_return_value_name = $last_body_expr; }.as_expr().unwrap(),\n            );\n        }\n        quote {}\n    };\n\n    let context_finish = quote { context.finish() };\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $args_hasher\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $message_discovery_call\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $return_value\n        $mark_as_initialized\n        $context_finish\n    };\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n    f.set_return_type(\n        quote { dep::protocol_types::abis::private_circuit_public_inputs::PrivateCircuitPublicInputs }\n            .as_type(),\n    );\n    f.set_return_data();\n}\n\npub(crate) comptime fn transform_public(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    let module_has_initializer = module_has_initializer(f.module());\n    let module_has_storage = module_has_storage(f.module());\n\n    // Public functions undergo a lot of transformations from their Aztec.nr form.\n    let original_params = f.parameters();\n\n    let args_len_quote = if original_params.len() == 0 {\n        // If the function has no parameters, we set the args_len to 0.\n        quote { 0 }\n    } else {\n        // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n        original_params\n            .map(|(_, param_type): (Quoted, Type)| {\n                quote {\n            <$param_type as $crate::protocol_types::traits::Serialize>::N\n        }\n            })\n            .join(quote {+})\n    };\n\n    // Unlike in the private case, in public the `context` does not need to receive the hash of the original params.\n    let context_creation = quote {\n        let mut context = dep::aztec::context::public_context::PublicContext::new(|| {\n        // We start from 1 because we skip the selector for the dispatch function.\n        let serialized_args : [Field; $args_len_quote] = dep::aztec::context::public_context::calldata_copy(1, $args_len_quote);\n        dep::aztec::hash::hash_args_array(serialized_args)\n        });\n    };\n\n    // Modifications introduced by the different marker attributes.\n    let internal_check = if is_fn_internal(f) {\n        create_internal_check(f)\n    } else {\n        quote {}\n    };\n\n    let view_check = if is_fn_view(f) {\n        create_view_check(f)\n    } else {\n        quote {}\n    };\n\n    let (assert_initializer, mark_as_initialized) = if is_fn_initializer(f) {\n        (create_assert_correct_initializer_args(f), create_mark_as_initialized(f))\n    } else {\n        (quote {}, quote {})\n    };\n\n    let storage_init = if module_has_storage {\n        // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n        // referenced. We instead ignore 'unused variable' warnings for it.\n        quote {\n            #[allow(unused_variables)]\n            let storage = Storage::init(&mut context);\n        }\n    } else {\n        quote {}\n    };\n\n    // Initialization checks are not included in contracts that don't have initializers.\n    let init_check = if module_has_initializer & !fn_has_noinitcheck(f) & !is_fn_initializer(f) {\n        create_init_check(f)\n    } else {\n        quote {}\n    };\n\n    // Inject the authwit check if the function is marked with #[authorize_once].\n    let authorize_once_check = if fn_has_authorize_once(f) {\n        create_authorize_once_check(f)\n    } else {\n        quote {}\n    };\n\n    let to_prepend = quote {\n        $context_creation\n        $assert_initializer\n        $init_check\n        $internal_check\n        $view_check\n        $storage_init\n        $authorize_once_check\n    };\n\n    let to_append = quote {\n        $mark_as_initialized\n    };\n\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, to_append);\n    f.set_body(modified_body);\n\n    // All public functions are automatically made unconstrained, even if they were not marked as such. This is because\n    // instead of compiling into a circuit, they will compile to bytecode that will be later transpiled into AVM\n    // bytecode.\n    f.set_unconstrained(true);\n    f.set_return_public(true);\n}\n\npub(crate) comptime fn transform_utility(f: FunctionDefinition) {\n    let fn_stub = stub_fn(f);\n    stub_registry::register(f.module(), fn_stub);\n\n    // Create utility context\n    let context_creation =\n        quote { let mut context = dep::aztec::context::utility_context::UtilityContext::new(); };\n    let module_has_storage = module_has_storage(f.module());\n\n    // Initialize Storage if module has storage\n    let storage_init = if module_has_storage {\n        quote {\n            // Some functions don't access storage, but it'd be quite difficult to only inject this variable if it is\n            // referenced. We instead ignore 'unused variable' warnings for it.\n            #[allow(unused_variables)]\n            let storage = Storage::init(context);\n        }\n    } else {\n        quote {}\n    };\n\n    // All utility functions perform message discovery, since they may need to access private notes that would be\n    // found during this process or they may be used to sync private events from TypeScript\n    // (`sync_private_state` function gets invoked by PXE::getPrivateEvents function).\n    let message_discovery_call = create_message_discovery_call();\n\n    // A quote to be injected at the beginning of the function body.\n    let to_prepend = quote {\n        dep::aztec::oracle::version::assert_compatible_oracle_version();\n        $context_creation\n        $storage_init\n        $message_discovery_call\n    };\n    let body = f.body().as_block().unwrap();\n    let modified_body = modify_fn_body(body, to_prepend, quote {});\n    f.set_body(modified_body);\n\n    f.set_return_public(true);\n}\n\ncomptime fn create_internal_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called internally\";\n    quote { assert(context.msg_sender() == context.this_address(), $assertion_message); }\n}\n\ncomptime fn create_view_check(f: FunctionDefinition) -> Quoted {\n    let name = f.name();\n    let assertion_message = f\"Function {name} can only be called statically\";\n    if is_fn_private(f) {\n        // Here `context` is of type context::PrivateContext\n        quote { assert(context.inputs.call_context.is_static_call, $assertion_message); }\n    } else {\n        // Here `context` is of type context::PublicContext\n        quote { assert(context.is_static_call(), $assertion_message); }\n    }\n}\n\ncomptime fn create_assert_correct_initializer_args(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_initialization_matches_address_preimage_{fn_visibility}(context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_mark_as_initialized(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::mark_as_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\ncomptime fn create_init_check(f: FunctionDefinition) -> Quoted {\n    let fn_visibility = get_fn_visibility(f);\n    f\"dep::aztec::macros::functions::initialization_utils::assert_is_initialized_{fn_visibility}(&mut context);\"\n        .quoted_contents()\n}\n\n/// Injects a call to `aztec::messages::discovery::discover_new_messages`, causing for new notes to be added to PXE and made\n/// available for the current execution.\npub(crate) comptime fn create_message_discovery_call() -> Quoted {\n    quote {\n        /// Safety: message discovery returns nothing and is performed solely for its side-effects. It is therefore\n        /// always safe to call.\n        unsafe {\n            dep::aztec::messages::discovery::discover_new_messages(\n                context.this_address(),\n                _compute_note_hash_and_nullifier,\n            );\n        };\n    }\n}\n\n/// Injects an authwit verification check of the form:\n/// ```\n///   if (!from.eq(context.msg_sender())) {\n///         assert_current_call_valid_authwit::<N>(&mut context, from);\n///     } else {\n///         assert(authwit_nonce, \"Invalid authwit nonce. When 'from' and 'msg_sender' are the same, authwit_nonce must be zero\");\n///     }\n/// ```\n/// where `from` and `authwit_nonce` are the names of the parameters that are expected to be present in the function definition.\n/// This check is injected by the `#[authorize_once(\"from_arg_name\", \"nonce_arg_name\")]`, which allows the user to define\n/// which parameters to use.\npub(crate) comptime fn create_authorize_once_check(f: FunctionDefinition) -> Quoted {\n    let maybe_authorize_once_args = AUTHORIZE_ONCE_REGISTRY.get(f);\n    let authorize_once_args = if maybe_authorize_once_args.is_some() {\n        maybe_authorize_once_args.unwrap()\n    } else {\n        // We need to for authorize_once to have already executed so that we can retrieve its params - this depends on\n        // the order in which the attributes are applied.\n        panic(\n            f\"Functions marked with #[authorize_once] must have the #[private] or #[public] attribute placed last\",\n        )\n    };\n\n    let (from_arg_name, nonce_arg_name) = authorize_once_args;\n    let name: Quoted = f.name();\n\n    let from_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{from_arg_name}\".quoted_contents());\n    let (from_arg_name_quoted, from_arg_type) = if from_arg_candidates.len() == 1 {\n        from_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {from_arg_name} parameter. Please specify which one to use in #[authorize_once(\\\"...\\\", \\\"authwit_nonce\\\")]\",\n        )\n    };\n    if from_arg_type\n        != quote { dep::protocol_types::address::aztec_address::AztecAddress }.as_type() {\n        panic(\n            f\"Argument {from_arg_name_quoted} in function {name} must be of type AztecAddress, but is of type {from_arg_type}\",\n        )\n    }\n\n    let nonce_arg_candidates =\n        f.parameters().filter(|(name, _)| name == f\"{nonce_arg_name}\".quoted_contents());\n    let (nonce_arg_name_quoted, nonce_arg_type) = if nonce_arg_candidates.len() == 1 {\n        nonce_arg_candidates[0]\n    } else {\n        panic(\n            f\"Function {name} does not have a {nonce_arg_name}. Please specify which one to use in #[authorize_once(\\\"from\\\", \\\"...\\\")]\",\n        )\n    };\n    if nonce_arg_type != quote { Field }.as_type() {\n        panic(\n            f\"Argument {nonce_arg_name_quoted} in function {name} must be of type Field, but is of type {nonce_arg_type}\",\n        );\n    }\n\n    let nonce_check_quote = f\"{nonce_arg_name_quoted} == 0\".quoted_contents();\n\n    let fn_call = if is_fn_private(f) {\n        // At this point, the original args of the fn have already been altered by the macro\n        // to include PrivateContextInputs, so we need to adjust the args_len accordingly.\n        let args_len = f.parameters().len() - 1;\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit::<$args_len> }\n    } else {\n        quote { dep::aztec::authwit::auth::assert_current_call_valid_authwit_public }\n    };\n    let invalid_nonce_message = f\"Invalid authwit nonce. When '{from_arg_name}' and 'msg_sender' are the same, '{nonce_arg_name}' must be zero\"\n        .as_ctstring()\n        .as_quoted_str();\n    quote {         \n        if (!$from_arg_name_quoted.eq(context.msg_sender())) {\n            $fn_call(&mut context, $from_arg_name_quoted);\n        } else {\n            assert($nonce_check_quote, $invalid_nonce_message);\n        }\n    }\n}\n\n/// Checks if each function in the module is marked with either #[private], #[public], #[utility],\n/// #[contract_library_method], or #[test]. Non-macroified functions are not allowed in contracts.\npub(crate) comptime fn check_each_fn_macroified(m: Module) {\n    for f in m.functions() {\n        let name = f.name();\n        if !is_fn_private(f)\n            & !is_fn_public(f)\n            & !is_fn_utility(f)\n            & !is_fn_contract_library_method(f)\n            & !is_fn_test(f) {\n            panic(\n                f\"Function {name} must be marked as either #[private], #[public], #[utility], #[contract_library_method], or #[test]\",\n            );\n        }\n    }\n}\n"
    },
    "112": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/macros/notes.nr",
      "source": "use crate::note::note_getter_options::PropertySelector;\nuse std::{collections::bounded_vec::BoundedVec, meta::{ctstring::AsCtString, type_of}};\n\n/// Maximum number of note types within 1 contract.\ncomptime global MAX_NOTE_TYPES: u32 = 128;\n\n/// A BoundedVec containing all the note types within this contract.\npub comptime mut global NOTES: BoundedVec<Type, MAX_NOTE_TYPES> = BoundedVec::new();\n\ncomptime mut global NOTE_TYPE_ID_COUNTER: u32 = 0;\n\n/// The note type id is set by enumerating the note types.\ncomptime fn get_next_note_type_id() -> Field {\n    // We assert that the note type id fits within 7 bits\n    assert(\n        NOTE_TYPE_ID_COUNTER < MAX_NOTE_TYPES,\n        f\"A contract can contain at most {MAX_NOTE_TYPES} different note types\",\n    );\n\n    let note_type_id = NOTE_TYPE_ID_COUNTER as Field;\n    NOTE_TYPE_ID_COUNTER += 1;\n    note_type_id\n}\n\n/// Generates default `NoteType` implementation for a given note struct `s` and returns it as a quote.\n///\n/// impl NoteType for NoteStruct {\n///     fn get_id() -> Field {\n///         ...\n///     }\n/// }\ncomptime fn generate_note_type_impl(s: TypeDefinition, note_type_id: Field) -> Quoted {\n    let name = s.name();\n    let typ = s.as_type();\n    let note_type_name: str<_> = f\"{name}\".as_ctstring().as_quoted_str!();\n    let max_note_packed_len = crate::messages::discovery::private_notes::MAX_NOTE_PACKED_LEN;\n\n    quote {\n        impl aztec::note::note_interface::NoteType for $name {\n            fn get_id() -> Field {\n                // This static assertion ensures the note's packed length doesn't exceed the maximum allowed size.\n                // While this check would ideally live in the Packable trait implementation, we place it here since\n                // this function is always generated by our macros and the Packable trait implementation is not.\n                // Note: We set the note type name and max packed length as local variables because injecting them\n                // directly into the error message doesn't work.\n                let note_type_name = $note_type_name;\n                let max_note_packed_len: u32 = $max_note_packed_len; // Casting to u32 to avoid the value to be printed in hex.\n                let note_packed_len = <$typ as Packable>::N;\n                std::static_assert(note_packed_len <= $max_note_packed_len, f\"{note_type_name} has a packed length of {note_packed_len} fields, which exceeds the maximum allowed length of {max_note_packed_len} fields\");\n\n                $note_type_id\n            }\n        }\n    }\n}\n\n/// Generates default `NoteHash` trait implementation for a given note struct `s` and returns it as a quote.\n///\n/// # Generated Implementation\n/// ```\n/// impl NoteHash for NoteStruct {\n///     fn compute_note_hash(self, storage_slot: Field) -> Field { ... }\n///\n///     fn compute_nullifier(self, context: &mut PrivateContext, note_hash_for_nullify: Field) -> Field { ... }\n///\n///     unconstrained fn compute_nullifier_unconstrained(note_hash_for_nullify: Field) -> Field { ... }\n/// }\n/// ```\ncomptime fn generate_note_hash_trait_impl(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    quote {\n        impl aztec::note::note_interface::NoteHash for $name {\n            fn compute_note_hash(self, storage_slot: Field) -> Field {\n                let inputs = aztec::protocol_types::traits::Packable::pack(self).concat( [storage_slot]);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(inputs, aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_HASH)\n            }\n\n            fn compute_nullifier(\n                self,\n                context: &mut aztec::context::PrivateContext,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = context.request_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n\n            unconstrained fn compute_nullifier_unconstrained(\n                self,\n                note_hash_for_nullify: Field,\n            ) -> Field {\n                let owner_npk_m = aztec::keys::getters::get_public_keys(self.owner).npk_m;\n                // We invoke hash as a static trait function rather than calling owner_npk_m.hash() directly\n                // in the quote to avoid \"trait not in scope\" compiler warnings.\n                let owner_npk_m_hash = aztec::protocol_types::traits::Hash::hash(owner_npk_m);\n                let secret = aztec::keys::getters::get_nsk_app(owner_npk_m_hash);\n                aztec::protocol_types::hash::poseidon2_hash_with_separator(\n                    [note_hash_for_nullify, secret],\n                    aztec::protocol_types::constants::GENERATOR_INDEX__NOTE_NULLIFIER as Field,\n                )\n            }\n        }\n    }\n}\n\n/// Generates note properties struct for a given note struct `s`.\n///\n/// Example:\n/// ```\n/// struct TokenNoteProperties {\n///     amount: aztec::note::note_getter_options::PropertySelector,\n///     npk_m_hash: aztec::note::note_getter_options::PropertySelector\n///     randomness: aztec::note::note_getter_options::PropertySelector\n/// }\n///\n/// impl aztec::note::note_interface::NoteProperties<TokenNoteProperties> for TokenNote {\n///     fn properties() -> TokenNoteProperties {\n///         Self {\n///             amount: aztec::note::note_getter_options::PropertySelector { index: 0, offset: 0, length: 32 },\n///             npk_m_hash: aztec::note::note_getter_options::PropertySelector { index: 1, offset: 0, length: 32 },\n///             randomness: aztec::note::note_getter_options::PropertySelector { index: 2, offset: 0, length: 32 }\n///         }\n///     }\n/// }\n/// ```\ncomptime fn generate_note_properties(s: TypeDefinition) -> Quoted {\n    let name = s.name();\n\n    let struct_name = f\"{name}Properties\".quoted_contents();\n\n    let property_selector_type = type_of(PropertySelector { index: 0, offset: 0, length: 0 });\n\n    let note_fields = s.fields_as_written();\n\n    let properties_types = note_fields\n        .map(|(name, _, _)| quote { pub $name: $property_selector_type })\n        .join(quote {,});\n\n    // TODO #8694: Properly handle non-field types https://github.com/AztecProtocol/aztec-packages/issues/8694\n    let mut properties_list = &[];\n    for i in 0..note_fields.len() {\n        let (name, _, _) = note_fields[i];\n        properties_list = properties_list.push_back(\n            quote { $name: aztec::note::note_getter_options::PropertySelector { index: $i, offset: 0, length: 32 } },\n        );\n    }\n\n    let properties = properties_list.join(quote {,});\n\n    quote {\n        pub struct $struct_name {\n            $properties_types\n        }\n\n        impl aztec::note::note_interface::NoteProperties<$struct_name> for $name {\n            fn properties() -> $struct_name {\n                $struct_name {\n                    $properties\n                }\n            }\n        }\n    }\n}\n\n/// Generates the core note functionality for a struct:\n///\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n/// - NoteHash trait implementation: Handles note hash and nullifier computation\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Have an `owner` field\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Generated Code\n///\n/// For detailed documentation on the generated implementations, see:\n/// - `generate_note_properties()`\n/// - `generate_note_type_impl()`\n/// - `generate_note_hash_trait_impl()`\npub comptime fn note(s: TypeDefinition) -> Quoted {\n    assert_has_owner(s);\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_properties = generate_note_properties(s);\n    let note_type_id = get_next_note_type_id();\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n    let note_hash_impl = generate_note_hash_trait_impl(s);\n\n    quote {\n        $note_properties\n        $note_type_impl\n        $note_hash_impl\n    }\n}\n\n/// Generates code for a custom note implementation that requires specialized note hash or nullifier computation.\n///\n/// # Generated Code\n/// - NoteTypeProperties: Defines the structure and properties of note fields\n/// - NoteType trait implementation: Provides the note type ID\n///\n/// # Requirements\n///\n/// The note struct must:\n/// - Implement the `Packable` trait\n/// - Not exceed `MAX_NOTE_PACKED_LEN` when packed\n///\n/// Unlike the `#[note]` macro, there is no requirement for an `owner` field.\n///\n/// # Registration\n///\n/// Registers the note in the global `NOTES` BoundedVec to enable note processing functionality.\n///\n/// # Use Cases\n/// Use this macro when implementing a note that needs custom:\n/// - Note hash computation logic\n/// - Nullifier computation logic\n///\n/// The macro omits generating default NoteHash trait implementation, allowing you to provide your own.\n///\n/// # Example\n/// ```\n/// #[custom_note]\n/// struct CustomNote {\n///     value: Field,\n///     metadata: Field\n/// }\n///\n/// impl NoteHash for CustomNote {\n///     // Custom note hash computation...\n///     fn compute_note_hash(...) -> Field { ... }\n///\n///     // Custom nullifier computation...\n///     fn compute_nullifier(...) -> Field { ... }\n///     fn compute_nullifier_unconstrained(...) -> Field { ... }\n/// }\n/// ```\npub comptime fn custom_note(s: TypeDefinition) -> Quoted {\n    assert_has_packable(s);\n\n    // We register the note in the global `NOTES` BoundedVec because we need that information inside the #[aztec] macro\n    // to generate note processing functionality.\n    NOTES.push(s.as_type());\n\n    let note_type_id = get_next_note_type_id();\n    let note_properties = generate_note_properties(s);\n    let note_type_impl = generate_note_type_impl(s, note_type_id);\n\n    quote {\n        $note_properties\n        $note_type_impl\n    }\n}\n\n/// Asserts that the given note implements the `Packable` trait.\n///\n/// We require that notes have the `Packable` trait implemented because it is used when emitting a note in a log or as\n/// an offchain message.\ncomptime fn assert_has_packable(note: TypeDefinition) {\n    let packable_constraint =\n        quote { crate::protocol_types::traits::Packable }.as_trait_constraint();\n    let note_name = note.name();\n\n    assert(\n        note.as_type().implements(packable_constraint),\n        f\"{note_name} does not implement Packable trait. Either implement it manually or place #[derive(Packable)] on the note struct before #[note] macro invocation.\",\n    );\n}\n\n/// Asserts that the note has an 'owner' field.\n///\n/// We require notes implemented with #[note] macro macro to have an 'owner' field because our\n/// auto-generated nullifier functions expect it. This requirement is most likely only temporary.\ncomptime fn assert_has_owner(note: TypeDefinition) {\n    let fields = note.fields_as_written();\n    let mut has_owner = false;\n    for i in 0..fields.len() {\n        let (field_name, _, _) = fields[i];\n        if field_name == quote { owner } {\n            has_owner = true;\n            break;\n        }\n    }\n    let note_name = note.name();\n\n    assert(\n        has_owner,\n        f\"{note_name} does not have an 'owner' field. If your notes have no owner, use #[custom_note] insteadof #[note] and implement the NoteHashing trait manually.\",\n    );\n}\n"
    },
    "115": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/mod.nr",
      "source": "use protocol_types::{address::AztecAddress, debug_log::{debug_log, debug_log_format}};\n\npub mod nonce_discovery;\npub mod partial_notes;\npub mod private_events;\npub mod private_notes;\npub mod process_message;\n\nuse crate::{\n    messages::{\n        discovery::{private_notes::MAX_NOTE_PACKED_LEN, process_message::do_process_message},\n        processing::{\n            get_private_logs, pending_tagged_log::PendingTaggedLog,\n            validate_enqueued_notes_and_events,\n        },\n    },\n    utils::array,\n};\n\npub struct NoteHashAndNullifier {\n    /// The result of NoteHash::compute_note_hash\n    pub note_hash: Field,\n    /// The result of NoteHash::compute_nullifier_unconstrained (since all of message discovery is unconstrained)\n    pub inner_nullifier: Field,\n}\n\n/// A function which takes a note's packed content, address of the emitting contract, note nonce, storage slot and note\n/// type ID and attempts to compute its note hash (not hashed by note nonce nor siloed by address) and inner nullifier\n/// (not siloed by address).\n///\n/// This function must be user-provided as its implementation requires knowledge of how note type IDs are allocated in a\n/// contract. The `#[aztec]` macro automatically creates such a contract library method called\n/// `_compute_note_hash_and_nullifier`, which looks something like this:\n///\n/// ```\n/// |packed_note, contract_address, note_nonce, storage_slot, note_type_id| {\n///     if note_type_id == MyNoteType::get_id() {\n///         assert(packed_note.len() == MY_NOTE_TYPE_SERIALIZATION_LENGTH);\n///\n///         let note = MyNoteType::unpack(aztec::utils::array::subarray(packed_note.storage(), 0));\n///\n///         let note_hash = note.compute_note_hash(storage_slot);\n///         let note_hash_for_nullify = aztec::note::utils::compute_note_hash_for_nullify(\n///             RetrievedNote{ note, contract_address, metadata: SettledNoteMetadata::new(note_nonce).into() },\n///             storage_slot\n///         );\n///\n///         let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n///\n///         Option::some(\n///             aztec::messages::discovery::NoteHashAndNullifier {\n///                 note_hash, inner_nullifier\n///             }\n///         )\n///     } else if note_type_id == MyOtherNoteType::get_id() {\n///           ... // Similar to above but calling MyOtherNoteType::unpack_content\n///     } else {\n///         Option::none() // Unknown note type ID\n///     };\n/// }\n/// ```\ntype ComputeNoteHashAndNullifier<Env> = unconstrained fn[Env](/* packed_note */BoundedVec<Field, MAX_NOTE_PACKED_LEN>, /* storage_slot */ Field, /* note_type_id */ Field, /* contract_address */ AztecAddress, /* note nonce */ Field) -> Option<NoteHashAndNullifier>;\n\n/// Performs the message discovery process, in which private are downloaded and inspected to find new private notes,\n/// partial notes and events, etc., and pending partial notes are processed to search for their completion logs.\n/// This is the mechanism via which a contract updates its knowledge of its private state.\n///\n/// Receives the address of the contract on which discovery is performed along with its\n/// `compute_note_hash_and_nullifier` function.\npub unconstrained fn discover_new_messages<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    debug_log(\"Performing message discovery\");\n\n    // First we process all private logs, which can contain different kinds of messages e.g. private notes, partial\n    // notes, private events, etc.\n    let mut logs = get_private_logs(contract_address);\n    logs.for_each(|i, pending_tagged_log: PendingTaggedLog| {\n        debug_log_format(\n            \"Processing log with tag {0}\",\n            [pending_tagged_log.log.get(0)],\n        );\n\n        // We remove the tag from the pending tagged log and process the message ciphertext contained in it.\n        let message_ciphertext = array::subbvec(pending_tagged_log.log, 1);\n\n        do_process_message(\n            contract_address,\n            compute_note_hash_and_nullifier,\n            message_ciphertext,\n            pending_tagged_log.context,\n        );\n        logs.remove(i);\n    });\n\n    // Then we process all pending partial notes, regardless of whether they were found in the current or previous\n    // executions.\n    partial_notes::fetch_and_process_partial_note_completion_logs(\n        contract_address,\n        compute_note_hash_and_nullifier,\n    );\n\n    // Finally we validate all notes and events that were found as part of the previous processes, resulting in them\n    // being added to PXE's database and retrievable via oracles (get_notes) and our TS API (PXE::getPrivateEvents).\n    validate_enqueued_notes_and_events(contract_address);\n}\n"
    },
    "116": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/nonce_discovery.nr",
      "source": "use crate::messages::discovery::{ComputeNoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN};\n\nuse dep::protocol_types::{\n    address::AztecAddress,\n    constants::MAX_NOTE_HASHES_PER_TX,\n    debug_log::debug_log_format,\n    hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n    traits::ToField,\n};\n\n/// A struct with the discovered information of a complete note, required for delivery to PXE. Note that this is *not*\n/// the complete note information, since it does not include content, storage slot, etc.\npub struct DiscoveredNoteInfo {\n    pub note_nonce: Field,\n    pub note_hash: Field,\n    pub inner_nullifier: Field,\n}\n\n/// Searches for note nonces that will result in a note that was emitted in a transaction. While rare, it is possible\n/// for multiple notes to have the exact same packed content and storage slot but different nonces, resulting in\n/// different unique note hashes. Because of this this function returns a *vector* of discovered notes, though in most\n/// cases it will contain a single element.\n///\n/// Due to how nonces are computed, this function requires knowledge of the transaction in which the note was created,\n/// more specifically the list of all unique note hashes in it plus the value of its first nullifier.\npub unconstrained fn attempt_note_nonce_discovery<Env>(\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) -> BoundedVec<DiscoveredNoteInfo, MAX_NOTE_HASHES_PER_TX> {\n    let discovered_notes = &mut BoundedVec::new();\n\n    debug_log_format(\n        \"Attempting nonce discovery on {0} potential notes on contract {1} for storage slot {2}\",\n        [unique_note_hashes_in_tx.len() as Field, contract_address.to_field(), storage_slot],\n    );\n\n    // We need to find nonces (typically just one) that result in a note hash that, once siloed into a unique note hash,\n    // is one of the note hashes created by the transaction.\n    unique_note_hashes_in_tx.for_eachi(|i, expected_unique_note_hash| {\n        // Nonces are computed by hashing the first nullifier in the transaction with the index of the note in the\n        // new note hashes array. We therefore know for each note in every transaction what its nonce is.\n        let candidate_nonce = compute_note_hash_nonce(first_nullifier_in_tx, i);\n\n        // Given note nonce, note content and metadata, we can compute the note hash and silo it to check if it matches\n        // the note hash at the array index we're currently processing.\n        // TODO(#11157): handle failed note_hash_and_nullifier computation\n        let hashes = compute_note_hash_and_nullifier(\n            packed_note,\n            storage_slot,\n            note_type_id,\n            contract_address,\n            candidate_nonce,\n        )\n            .expect(f\"Failed to compute a note hash for note type {note_type_id}\");\n\n        let siloed_note_hash = compute_siloed_note_hash(contract_address, hashes.note_hash);\n        let unique_note_hash = compute_unique_note_hash(candidate_nonce, siloed_note_hash);\n\n        if unique_note_hash == expected_unique_note_hash {\n            // Note that while we did check that the note hash is the preimage of the expected unique note hash, we\n            // perform no validations on the nullifier - we fundamentally cannot, since only the application knows\n            // how to compute nullifiers. We simply trust it to have provided the correct one: if it hasn't, then\n            // PXE may fail to realize that a given note has been nullified already, and calls to the application\n            // could result in invalid transactions (with duplicate nullifiers). This is not a concern because an\n            // application already has more direct means of making a call to it fail the transaction.\n            discovered_notes.push(\n                DiscoveredNoteInfo {\n                    note_nonce: candidate_nonce,\n                    note_hash: hashes.note_hash,\n                    inner_nullifier: hashes.inner_nullifier,\n                },\n            );\n\n            // We don't exit the loop - it is possible (though rare) for the exact same note content to be present\n            // multiple times in the same transaction with different nonces. This typically doesn't happen due to\n            // notes containing random values in order to hide their contents.\n        }\n    });\n\n    debug_log_format(\n        \"Found valid nonces for a total of {0} notes\",\n        [discovered_notes.len() as Field],\n    );\n\n    *discovered_notes\n}\n\nmod test {\n    use crate::{\n        messages::discovery::{NoteHashAndNullifier, private_notes::MAX_NOTE_PACKED_LEN},\n        note::{\n            note_interface::{NoteHash, NoteType},\n            note_metadata::SettledNoteMetadata,\n            retrieved_note::RetrievedNote,\n            utils::compute_note_hash_for_nullify,\n        },\n        oracle::random::random,\n        test::mocks::mock_note::MockNote,\n        utils::array,\n    };\n\n    use dep::protocol_types::{\n        address::AztecAddress,\n        hash::{compute_note_hash_nonce, compute_siloed_note_hash, compute_unique_note_hash},\n        traits::{FromField, Packable},\n    };\n\n    use super::attempt_note_nonce_discovery;\n\n    // This implementation could be simpler, but this serves as a nice example of the expected flow in a real\n    // implementation, and as a sanity check that the interface is sufficient.\n    unconstrained fn compute_note_hash_and_nullifier(\n        packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n        storage_slot: Field,\n        note_type_id: Field,\n        contract_address: AztecAddress,\n        note_nonce: Field,\n    ) -> Option<NoteHashAndNullifier> {\n        if note_type_id == MockNote::get_id() {\n            let note = MockNote::unpack(array::subarray(packed_note.storage(), 0));\n            let note_hash = note.compute_note_hash(storage_slot);\n\n            let note_hash_for_nullify = compute_note_hash_for_nullify(\n                RetrievedNote {\n                    note,\n                    contract_address,\n                    metadata: SettledNoteMetadata::new(note_nonce).into(),\n                },\n                storage_slot,\n            );\n\n            let inner_nullifier = note.compute_nullifier_unconstrained(note_hash_for_nullify);\n\n            Option::some(NoteHashAndNullifier { note_hash, inner_nullifier })\n        } else {\n            Option::none()\n        }\n    }\n\n    global VALUE: Field = 7;\n    global FIRST_NULLIFIER_IN_TX: Field = 47;\n    global CONTRACT_ADDRESS: AztecAddress = AztecAddress::from_field(13);\n    global STORAGE_SLOT: Field = 99;\n\n    #[test]\n    unconstrained fn no_note_hashes() {\n        let unique_note_hashes_in_tx = BoundedVec::new();\n        let packed_note = BoundedVec::new();\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    #[test(should_fail_with = \"Failed to compute a note hash\")]\n    unconstrained fn failed_hash_computation() {\n        let unique_note_hashes_in_tx = BoundedVec::from_array([random()]);\n        let packed_note = BoundedVec::new();\n        let note_type_id = 0; // This note type id is unknown to compute_note_hash_and_nullifier\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            note_type_id,\n            packed_note,\n        );\n\n        assert_eq(discovered_notes.len(), 0);\n    }\n\n    struct NoteAndData {\n        note: MockNote,\n        note_nonce: Field,\n        note_hash: Field,\n        unique_note_hash: Field,\n        inner_nullifier: Field,\n    }\n\n    unconstrained fn construct_note(value: Field, note_index_in_tx: u32) -> NoteAndData {\n        let note_nonce = compute_note_hash_nonce(FIRST_NULLIFIER_IN_TX, note_index_in_tx);\n\n        let retrieved_note = MockNote::new(value)\n            .contract_address(CONTRACT_ADDRESS)\n            .note_metadata(SettledNoteMetadata::new(note_nonce).into())\n            .build_retrieved_note();\n        let note = retrieved_note.note;\n\n        let note_hash = note.compute_note_hash(STORAGE_SLOT);\n        let unique_note_hash = compute_unique_note_hash(\n            note_nonce,\n            compute_siloed_note_hash(CONTRACT_ADDRESS, note_hash),\n        );\n        let inner_nullifier = note.compute_nullifier_unconstrained(compute_note_hash_for_nullify(\n            retrieved_note,\n            STORAGE_SLOT,\n        ));\n\n        NoteAndData { note, note_nonce, note_hash, unique_note_hash, inner_nullifier }\n    }\n\n    #[test]\n    unconstrained fn single_note() {\n        let note_index_in_tx = 2;\n        let note_and_data = construct_note(VALUE, note_index_in_tx);\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(note_index_in_tx, note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(note_and_data.note.pack()),\n        );\n\n        assert_eq(discovered_notes.len(), 1);\n        let discovered_note = discovered_notes.get(0);\n\n        assert_eq(discovered_note.note_nonce, note_and_data.note_nonce);\n        assert_eq(discovered_note.note_hash, note_and_data.note_hash);\n        assert_eq(discovered_note.inner_nullifier, note_and_data.inner_nullifier);\n    }\n\n    #[test]\n    unconstrained fn multiple_notes_same_preimage() {\n        let first_note_index_in_tx = 3;\n        let first_note_and_data = construct_note(VALUE, first_note_index_in_tx);\n\n        let second_note_index_in_tx = 5;\n        let second_note_and_data = construct_note(VALUE, second_note_index_in_tx);\n\n        // Both notes have the same preimage (and therefore packed representation), so both should be found in the same\n        // call.\n        assert_eq(first_note_and_data.note, second_note_and_data.note);\n        let packed_note = first_note_and_data.note.pack();\n\n        let mut unique_note_hashes_in_tx = BoundedVec::from_array([\n            random(), random(), random(), random(), random(), random(), random(),\n        ]);\n        unique_note_hashes_in_tx.set(first_note_index_in_tx, first_note_and_data.unique_note_hash);\n        unique_note_hashes_in_tx.set(second_note_index_in_tx, second_note_and_data.unique_note_hash);\n\n        let discovered_notes = attempt_note_nonce_discovery(\n            unique_note_hashes_in_tx,\n            FIRST_NULLIFIER_IN_TX,\n            compute_note_hash_and_nullifier,\n            CONTRACT_ADDRESS,\n            STORAGE_SLOT,\n            MockNote::get_id(),\n            BoundedVec::from_array(packed_note),\n        );\n\n        assert_eq(discovered_notes.len(), 2);\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == first_note_and_data.note_nonce)\n                & (discovered_note.note_hash == first_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == first_note_and_data.inner_nullifier)\n        }));\n\n        assert(discovered_notes.any(|discovered_note| {\n            (discovered_note.note_nonce == second_note_and_data.note_nonce)\n                & (discovered_note.note_hash == second_note_and_data.note_hash)\n                & (discovered_note.inner_nullifier == second_note_and_data.inner_nullifier)\n        }));\n    }\n}\n"
    },
    "117": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/partial_notes.nr",
      "source": "use crate::{\n    capsules::CapsuleArray,\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::{\n            enqueue_note_for_validation, get_pending_partial_notes_completion_logs,\n            log_retrieval_response::LogRetrievalResponse,\n        },\n    },\n    utils::array,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    debug_log::debug_log_format,\n    hash::sha256_to_field,\n    traits::{Deserialize, Serialize},\n};\n\nglobal PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 2;\n\n/// Partial notes have a maximum packed length of their private fields bound by extra content in their private message\n/// (e.g. the storage slot, note completion log tag, etc.).\npub global MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\n/// The slot in the PXE capsules where we store a `CapsuleArray` of `DeliveredPendingPartialNote`.\npub global DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT\".as_bytes(),\n);\n\n/// A partial note that was delivered but is still pending completion. Contains the information necessary to find the\n/// log that will complete it and lead to a note being discovered and delivered.\n#[derive(Serialize, Deserialize)]\npub(crate) struct DeliveredPendingPartialNote {\n    pub(crate) note_completion_log_tag: Field,\n    pub(crate) storage_slot: Field,\n    pub(crate) note_type_id: Field,\n    pub(crate) packed_private_note_content: BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>,\n    pub(crate) recipient: AztecAddress,\n}\n\npub unconstrained fn process_partial_note_private_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content) =\n        decode_partial_note_private_msg(msg_metadata, msg_content);\n\n    // We store the information of the partial note we found in a persistent capsule in PXE, so that we can later search\n    // for the public log that will complete it.\n    let pending = DeliveredPendingPartialNote {\n        note_completion_log_tag,\n        storage_slot,\n        note_type_id,\n        packed_private_note_content,\n        recipient,\n    };\n\n    CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    )\n        .push(pending);\n}\n\n/// Searches for logs that would result in the completion of pending partial notes, ultimately resulting in the notes\n/// being delivered to PXE if completed.\npub unconstrained fn fetch_and_process_partial_note_completion_logs<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n) {\n    let pending_partial_notes = CapsuleArray::at(\n        contract_address,\n        DELIVERED_PENDING_PARTIAL_NOTE_ARRAY_LENGTH_CAPSULES_SLOT,\n    );\n\n    debug_log_format(\n        \"{} pending partial notes\",\n        [pending_partial_notes.len() as Field],\n    );\n\n    // Each of the pending partial notes might get completed by a log containing its public values. For performance\n    // reasons, we fetch all of these logs concurrently and then process them one by one, minimizing the amount of time\n    // waiting for the node roundtrip.\n    let maybe_completion_logs =\n        get_pending_partial_notes_completion_logs(contract_address, pending_partial_notes);\n\n    // Each entry in the maybe completion logs array corresponds to the entry in the pending partial notes array at the\n    // same index. This means we can use the same index as we iterate through the responses to get both the partial note\n    // and the log that might complete it.\n    assert_eq(maybe_completion_logs.len(), pending_partial_notes.len());\n\n    maybe_completion_logs.for_each(|i, maybe_log: Option<LogRetrievalResponse>| {\n        // We clear the completion logs as we read them so that the array is empty by the time we next query it.\n        // TODO(#14943): use volatile arrays to avoid having to manually clear this.\n        maybe_completion_logs.remove(i);\n\n        let pending_partial_note = pending_partial_notes.get(i);\n\n        if maybe_log.is_none() {\n            debug_log_format(\n                \"Found no completion logs for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n\n            // Note that we're not removing the pending partial note from the capsule array, so we will continue\n            // searching for this tagged log when performing message discovery in the future until we either find it or\n            // the entry is somehow removed from the array.\n        } else {\n            debug_log_format(\n                \"Completion log found for partial note with tag {}\",\n                [pending_partial_note.note_completion_log_tag],\n            );\n            let log = maybe_log.unwrap();\n\n            // Public fields are assumed to all be placed at the end of the packed representation, so we combine the\n            // private and public packed fields (i.e. the contents of the private message and public log plaintext to get\n            // the complete packed content.\n            let complete_packed_note = array::append(\n                pending_partial_note.packed_private_note_content,\n                log.log_payload,\n            );\n\n            let discovered_notes = attempt_note_nonce_discovery(\n                log.unique_note_hashes_in_tx,\n                log.first_nullifier_in_tx,\n                compute_note_hash_and_nullifier,\n                contract_address,\n                pending_partial_note.storage_slot,\n                pending_partial_note.note_type_id,\n                complete_packed_note,\n            );\n\n            // TODO(#11627): is there anything reasonable we can do if we get a log but it doesn't result in a note\n            // being found?\n            if discovered_notes.len() == 0 {\n                panic(\n                    f\"A partial note's completion log did not result in any notes being found - this should never happen\",\n                );\n            }\n\n            debug_log_format(\n                \"Discovered {0} notes for partial note with tag {1}\",\n                [discovered_notes.len() as Field, pending_partial_note.note_completion_log_tag],\n            );\n\n            discovered_notes.for_each(|discovered_note| {\n                enqueue_note_for_validation(\n                    contract_address,\n                    pending_partial_note.storage_slot,\n                    discovered_note.note_nonce,\n                    complete_packed_note,\n                    discovered_note.note_hash,\n                    discovered_note.inner_nullifier,\n                    log.tx_hash,\n                    pending_partial_note.recipient,\n                );\n            });\n\n            // Because there is only a single log for a given tag, once we've processed the tagged log then we\n            // simply delete the pending work entry, regardless of whether it was actually completed or not.\n            pending_partial_notes.remove(i);\n        }\n    });\n}\n\nfn decode_partial_note_private_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, Field, BoundedVec<Field, MAX_PARTIAL_NOTE_PRIVATE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all partial note private messages must have at least {PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the partial note private message encoding below must be updated as well.\n    std::static_assert(\n        PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 2,\n        \"unexpected value for PARTIAL_NOTE_PRIVATE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have two fields that are not the partial note's packed representation, which are the storage slot\n    // and the note completion log tag.\n    let storage_slot = msg_content.get(0);\n    let note_completion_log_tag = msg_content.get(1);\n\n    let packed_private_note_content = array::subbvec(msg_content, 2);\n\n    (note_type_id, storage_slot, note_completion_log_tag, packed_private_note_content)\n}\n"
    },
    "118": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_events.nr",
      "source": "use crate::{\n    event::event_selector::EventSelector,\n    messages::{encoding::MAX_MESSAGE_CONTENT_LEN, processing::enqueue_event_for_validation},\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::GENERATOR_INDEX__EVENT_COMMITMENT,\n    hash::poseidon2_hash_with_separator_bounded_vec, traits::FromField,\n};\n\n/// The number of fields in a private event message content that are not the event's serialized representation\n/// (1 field for randomness).\nglobal PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of an event's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, randomness, etc.).\npub global MAX_EVENT_SERIALIZED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN;\n\npub unconstrained fn process_private_event_msg(\n    contract_address: AztecAddress,\n    recipient: AztecAddress,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n    tx_hash: Field,\n) {\n    // In the case of events, the msg metadata is the event selector.\n    let event_type_id = EventSelector::from_field(msg_metadata as Field);\n\n    assert(\n        msg_content.len() > PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n        f\"Invalid private event message: all private event messages must have at least {PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private event message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN\",\n    );\n\n    let serialized_event_with_randomness = msg_content;\n\n    let event_commitment = poseidon2_hash_with_separator_bounded_vec(\n        serialized_event_with_randomness,\n        GENERATOR_INDEX__EVENT_COMMITMENT,\n    );\n\n    // Randomness was injected into the event payload in `emit_event_in_private` but we have already used it\n    // to compute the event commitment, so we can safely discard it now.\n    let serialized_event = array::subbvec(\n        serialized_event_with_randomness,\n        PRIVATE_EVENT_MSG_CONTENT_NON_EVENT_FIELDS_LEN,\n    );\n\n    enqueue_event_for_validation(\n        contract_address,\n        event_type_id,\n        serialized_event,\n        event_commitment,\n        tx_hash,\n        recipient,\n    );\n}\n"
    },
    "119": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/private_notes.nr",
      "source": "use crate::{\n    messages::{\n        discovery::{ComputeNoteHashAndNullifier, nonce_discovery::attempt_note_nonce_discovery},\n        encoding::MAX_MESSAGE_CONTENT_LEN,\n        processing::enqueue_note_for_validation,\n    },\n    utils::array,\n};\nuse protocol_types::{\n    address::AztecAddress, constants::MAX_NOTE_HASHES_PER_TX, debug_log::debug_log_format,\n};\n\n/// The number of fields in a private note message content that are not the note's packed representation.\n// See the call to `std::static_assert` below to see what's in these fields.\nglobal PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN: u32 = 1;\n\n/// The maximum length of the packed representation of a note's contents. This is limited by private log size,\n/// encryption overhead and extra fields in the message (e.g. message type id, storage slot, etc.).\npub global MAX_NOTE_PACKED_LEN: u32 =\n    MAX_MESSAGE_CONTENT_LEN - PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN;\n\npub unconstrained fn process_private_note_msg<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) {\n    let (note_type_id, storage_slot, packed_note) =\n        decode_private_note_msg(msg_metadata, msg_content);\n\n    attempt_note_discovery(\n        contract_address,\n        tx_hash,\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        recipient,\n        compute_note_hash_and_nullifier,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n}\n\n/// Attempts discovery of a note given information about its contents and the transaction in which it is\n/// suspected the note was created.\npub unconstrained fn attempt_note_discovery<Env>(\n    contract_address: AztecAddress,\n    tx_hash: Field,\n    unique_note_hashes_in_tx: BoundedVec<Field, MAX_NOTE_HASHES_PER_TX>,\n    first_nullifier_in_tx: Field,\n    recipient: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    storage_slot: Field,\n    note_type_id: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n) {\n    let discovered_notes = attempt_note_nonce_discovery(\n        unique_note_hashes_in_tx,\n        first_nullifier_in_tx,\n        compute_note_hash_and_nullifier,\n        contract_address,\n        storage_slot,\n        note_type_id,\n        packed_note,\n    );\n\n    debug_log_format(\n        \"Discovered {0} notes from a private message\",\n        [discovered_notes.len() as Field],\n    );\n\n    discovered_notes.for_each(|discovered_note| {\n        enqueue_note_for_validation(\n            contract_address,\n            storage_slot,\n            discovered_note.note_nonce,\n            packed_note,\n            discovered_note.note_hash,\n            discovered_note.inner_nullifier,\n            tx_hash,\n            recipient,\n        );\n    });\n}\n\nfn decode_private_note_msg(\n    msg_metadata: u64,\n    msg_content: BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>,\n) -> (Field, Field, BoundedVec<Field, MAX_NOTE_PACKED_LEN>) {\n    let note_type_id = msg_metadata as Field; // TODO: make note type id not be a full field\n\n    assert(\n        msg_content.len() > PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN,\n        f\"Invalid private note message: all private note messages must have at least {PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN} fields\",\n    );\n\n    // If PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN is changed, causing the assertion below to fail, then the\n    // destructuring of the private note message encoding below must be updated as well.\n    std::static_assert(\n        PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN == 1,\n        \"unexpected value for PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN\",\n    );\n\n    // We currently have a single field that is not the note's packed representation, which is the storage slot.\n    let storage_slot = msg_content.get(0);\n    let packed_note = array::subbvec(msg_content, PRIVATE_NOTE_MSG_CONTENT_NON_NOTE_FIELDS_LEN);\n\n    (note_type_id, storage_slot, packed_note)\n}\n"
    },
    "12": {
      "path": "std/convert.nr",
      "source": "// docs:start:from-trait\npub trait From<T> {\n    fn from(input: T) -> Self;\n}\n// docs:end:from-trait\n\nimpl<T> From<T> for T {\n    fn from(input: T) -> T {\n        input\n    }\n}\n\n// docs:start:into-trait\npub trait Into<T> {\n    fn into(self) -> T;\n}\n\nimpl<T, U> Into<T> for U\nwhere\n    T: From<U>,\n{\n    fn into(self) -> T {\n        T::from(self)\n    }\n}\n// docs:end:into-trait\n\n// docs:start:from-impls\n// Unsigned integers\n\nimpl From<u8> for u16 {\n    fn from(value: u8) -> u16 {\n        value as u16\n    }\n}\n\nimpl From<u8> for u32 {\n    fn from(value: u8) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u16> for u32 {\n    fn from(value: u16) -> u32 {\n        value as u32\n    }\n}\n\nimpl From<u8> for u64 {\n    fn from(value: u8) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u16> for u64 {\n    fn from(value: u16) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u32> for u64 {\n    fn from(value: u32) -> u64 {\n        value as u64\n    }\n}\n\nimpl From<u8> for u128 {\n    fn from(value: u8) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u16> for u128 {\n    fn from(value: u16) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u32> for u128 {\n    fn from(value: u32) -> u128 {\n        value as u128\n    }\n}\nimpl From<u64> for u128 {\n    fn from(value: u64) -> u128 {\n        value as u128\n    }\n}\n\nimpl From<u8> for Field {\n    fn from(value: u8) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u16> for Field {\n    fn from(value: u16) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u32> for Field {\n    fn from(value: u32) -> Field {\n        value as Field\n    }\n}\nimpl From<u64> for Field {\n    fn from(value: u64) -> Field {\n        value as Field\n    }\n}\n\nimpl From<u128> for Field {\n    fn from(value: u128) -> Field {\n        value as Field\n    }\n}\n\n// Signed integers\n\nimpl From<i8> for i16 {\n    fn from(value: i8) -> i16 {\n        value as i16\n    }\n}\n\nimpl From<i8> for i32 {\n    fn from(value: i8) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i16> for i32 {\n    fn from(value: i16) -> i32 {\n        value as i32\n    }\n}\n\nimpl From<i8> for i64 {\n    fn from(value: i8) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i16> for i64 {\n    fn from(value: i16) -> i64 {\n        value as i64\n    }\n}\n\nimpl From<i32> for i64 {\n    fn from(value: i32) -> i64 {\n        value as i64\n    }\n}\n\n// Booleans\nimpl From<bool> for u8 {\n    fn from(value: bool) -> u8 {\n        value as u8\n    }\n}\nimpl From<bool> for u16 {\n    fn from(value: bool) -> u16 {\n        value as u16\n    }\n}\nimpl From<bool> for u32 {\n    fn from(value: bool) -> u32 {\n        value as u32\n    }\n}\nimpl From<bool> for u64 {\n    fn from(value: bool) -> u64 {\n        value as u64\n    }\n}\nimpl From<bool> for u128 {\n    fn from(value: bool) -> u128 {\n        value as u128\n    }\n}\nimpl From<bool> for i8 {\n    fn from(value: bool) -> i8 {\n        value as i8\n    }\n}\nimpl From<bool> for i16 {\n    fn from(value: bool) -> i16 {\n        value as i16\n    }\n}\nimpl From<bool> for i32 {\n    fn from(value: bool) -> i32 {\n        value as i32\n    }\n}\nimpl From<bool> for i64 {\n    fn from(value: bool) -> i64 {\n        value as i64\n    }\n}\nimpl From<bool> for Field {\n    fn from(value: bool) -> Field {\n        value as Field\n    }\n}\n// docs:end:from-impls\n\n/// A generic interface for casting between primitive types,\n/// equivalent of using the `as` keyword between values.\n///\n/// # Example\n///\n/// ```\n/// let x: Field = 1234567890;\n/// let y: u8 = x as u8;\n/// let z: u8 = x.as_();\n/// assert_eq(y, z);\n/// ```\npub trait AsPrimitive<T> {\n    /// The equivalent of doing `self as T`.\n    fn as_(self) -> T;\n}\n\n#[generate_as_primitive_impls]\ncomptime fn generate_as_primitive_impls(_: FunctionDefinition) -> Quoted {\n    let types = [\n        quote { bool },\n        quote { u8 },\n        quote { u16 },\n        quote { u32 },\n        quote { u64 },\n        quote { u128 },\n        quote { i8 },\n        quote { i16 },\n        quote { i32 },\n        quote { i64 },\n    ];\n\n    let mut impls = &[];\n    for type1 in types {\n        for type2 in types {\n            let body = if type1 == type2 {\n                quote { self }\n            } else if type1 == quote { bool } {\n                quote { self != 0 }\n            } else {\n                quote { self as $type1 }\n            };\n\n            impls = impls.push_back(\n                quote {\n                impl AsPrimitive<$type1> for $type2 {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n            );\n        }\n    }\n\n    let u_types =\n        [quote { bool }, quote { u8 }, quote { u16 }, quote { u32 }, quote { u64 }, quote { u128 }];\n\n    for type2 in u_types {\n        let body = quote { self as Field };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<Field> for $type2 {\n                    fn as_(self) -> Field {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    for type1 in u_types {\n        let body = if type1 == quote { bool } {\n            quote { self != 0 }\n        } else {\n            quote { self as $type1 }\n        };\n\n        impls = impls.push_back(\n            quote {\n                impl AsPrimitive<$type1> for Field {\n                    fn as_(self) -> $type1 {\n                        $body\n                    }\n                }\n            },\n        );\n    }\n\n    impls.join(quote {})\n}\n"
    },
    "120": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/discovery/process_message.nr",
      "source": "use crate::messages::{\n    discovery::{\n        ComputeNoteHashAndNullifier, partial_notes::process_partial_note_private_msg,\n        private_events::process_private_event_msg, private_notes::process_private_note_msg,\n    },\n    encoding::decode_message,\n    encryption::{aes128::AES128, log_encryption::LogEncryption},\n    msg_type::{\n        PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID, PRIVATE_EVENT_MSG_TYPE_ID, PRIVATE_NOTE_MSG_TYPE_ID,\n    },\n    processing::message_context::MessageContext,\n};\n\nuse protocol_types::{\n    address::AztecAddress,\n    constants::PRIVATE_LOG_CIPHERTEXT_LEN,\n    debug_log::{debug_log, debug_log_format},\n};\n\n/// Processes a message that can contain notes, partial notes, or events.\n///\n/// Notes result in nonce discovery being performed prior to delivery, which requires knowledge of the transaction hash\n/// in which the notes would've been created (typically the same transaction in which the log was emitted), along with\n/// the list of unique note hashes in said transaction and the `compute_note_hash_and_nullifier` function. Once\n/// discovered, the notes are enqueued for validation.\n///\n/// Partial notes result in a pending partial note entry being stored in a PXE capsule, which will later be retrieved to\n/// search for the note's completion public log.\n///\n/// Events are processed by computing an event commitment from the serialized event data and its randomness field, then\n/// enqueueing the event data and commitment for validation.\npub unconstrained fn do_process_message<Env>(\n    contract_address: AztecAddress,\n    compute_note_hash_and_nullifier: ComputeNoteHashAndNullifier<Env>,\n    message_ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n    message_context: MessageContext,\n) {\n    let message = AES128::decrypt_log(message_ciphertext, message_context.recipient);\n\n    // The first thing to do after decrypting the message is to determine what type of message we're processing. We\n    // have 3 message types: private notes, partial notes and events.\n\n    // We decode the message to obtain the message type id, metadata and content.\n    let (msg_type_id, msg_metadata, msg_content) = decode_message(message);\n\n    if msg_type_id == PRIVATE_NOTE_MSG_TYPE_ID {\n        debug_log(\"Processing private note msg\");\n\n        process_private_note_msg(\n            contract_address,\n            message_context.tx_hash,\n            message_context.unique_note_hashes_in_tx,\n            message_context.first_nullifier_in_tx,\n            message_context.recipient,\n            compute_note_hash_and_nullifier,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PARTIAL_NOTE_PRIVATE_MSG_TYPE_ID {\n        debug_log(\"Processing partial note private msg\");\n\n        process_partial_note_private_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n        );\n    } else if msg_type_id == PRIVATE_EVENT_MSG_TYPE_ID {\n        debug_log(\"Processing private event msg\");\n\n        process_private_event_msg(\n            contract_address,\n            message_context.recipient,\n            msg_metadata,\n            msg_content,\n            message_context.tx_hash,\n        );\n    } else {\n        debug_log_format(\"Unknown msg type id {0}\", [msg_type_id as Field]);\n    }\n}\n"
    },
    "121": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encoding.nr",
      "source": "// TODO(#12750): don't make these values assume we're using AES.\nuse crate::{\n    messages::encryption::log_encryption::PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS, utils::array,\n};\n\npub global MAX_MESSAGE_LEN: u32 = PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS;\n\nglobal MESSAGE_EXPANDED_METADATA_LEN: u32 = 1;\n\n// The standard message layout is composed of:\n//  - an initial field called the 'expanded metadata'\n//  - an arbitrary number of fields following that called the 'message content'\n//\n// ```\n// message: [ msg_expanded_metadata, ...msg_content ]\n// ```\n//\n// The expanded metadata itself is interpreted as a u128, of which:\n//  - the upper 64 bits are the message type id\n//  - the lower 64 bits are called the 'message metadata'\n//\n// ```\n// msg_expanded_metadata: [  msg_type_id    |  msg_metadata  ]\n//                        <---  64 bits --->|<--- 64 bits --->\n// ```\n//\n// The meaning of the message metadata and message content depend on the value of the message type id. Note that there\n// is nothing special about the message metadata, it _can_ be considered part of the content. It just has a different\n// name to make it distinct from the message content given that it is not a full field.\n\n/// The maximum length of a message's content, i.e. not including the expanded message metadata.\npub global MAX_MESSAGE_CONTENT_LEN: u32 = MAX_MESSAGE_LEN - MESSAGE_EXPANDED_METADATA_LEN;\n\n/// Encodes a message following aztec-nr's standard message encoding. This message can later be decoded with\n/// `decode_message` to retrieve the original values.\n///\n/// - The `msg_type` is an identifier that groups types of messages that are all processed the same way, e.g. private\n/// notes or events. Possible values are defined in `aztec::messages::msg_type`.\n/// - The `msg_metadata` and `msg_content` are the values stored in the message, whose meaning depends on the\n///  `msg_type`. The only special thing about `msg_metadata` that separates it from `msg_content` is that it is a u64\n/// instead of a full Field (due to details of how messages are encoded), allowing applications that can fit values into\n/// this smaller variable to achieve higher data efficiency.\npub fn encode_message<let N: u32>(\n    msg_type: u64,\n    msg_metadata: u64,\n    msg_content: [Field; N],\n) -> [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] {\n    std::static_assert(\n        msg_content.len() <= MAX_MESSAGE_CONTENT_LEN,\n        \"Invalid message content: it must have a length of at most MAX_MESSAGE_CONTENT_LEN\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n    let mut message: [Field; (N + MESSAGE_EXPANDED_METADATA_LEN)] = std::mem::zeroed();\n\n    message[0] = to_expanded_metadata(msg_type, msg_metadata);\n    for i in 0..msg_content.len() {\n        message[MESSAGE_EXPANDED_METADATA_LEN + i] = msg_content[i];\n    }\n\n    message\n}\n\n/// Decodes a standard aztec-nr message, i.e. one created via `encode_message`, returning the original encoded values.\n///\n/// Note that `encode_message` returns a fixed size array while this function takes a `BoundedVec`: this is because\n/// prior to decoding the message type is unknown, and consequentially not known at compile time. If working with\n/// fixed-size messages, consider using `BoundedVec::from_array` to convert them.\npub unconstrained fn decode_message(\n    message: BoundedVec<Field, MAX_MESSAGE_LEN>,\n) -> (u64, u64, BoundedVec<Field, MAX_MESSAGE_CONTENT_LEN>) {\n    assert(\n        message.len() >= MESSAGE_EXPANDED_METADATA_LEN,\n        f\"Invalid message: it must have at least {MESSAGE_EXPANDED_METADATA_LEN} fields\",\n    );\n\n    // If MESSAGE_EXPANDED_METADATA_LEN is changed, causing the assertion below to fail, then the destructuring of\n    // the message encoding below must be updated as well.\n    std::static_assert(\n        MESSAGE_EXPANDED_METADATA_LEN == 1,\n        \"unexpected value for MESSAGE_EXPANDED_METADATA_LEN\",\n    );\n\n    let msg_expanded_metadata = message.get(0);\n    let (msg_type_id, msg_metadata) = from_expanded_metadata(msg_expanded_metadata);\n    let msg_content = array::subbvec(message, MESSAGE_EXPANDED_METADATA_LEN);\n\n    (msg_type_id, msg_metadata, msg_content)\n}\n\nglobal U64_SHIFT_MULTIPLIER: Field = 2.pow_32(64);\n\nfn to_expanded_metadata(msg_type: u64, msg_metadata: u64) -> Field {\n    // We use multiplication instead of bit shifting operations to shift the type bits as bit shift operations are\n    // expensive in circuits.\n    let type_field: Field = (msg_type as Field) * U64_SHIFT_MULTIPLIER;\n    let msg_metadata_field = msg_metadata as Field;\n\n    type_field + msg_metadata_field\n}\n\nfn from_expanded_metadata(input: Field) -> (u64, u64) {\n    input.assert_max_bit_size::<128>();\n    let msg_metadata = (input as u64);\n    let msg_type = ((input - (msg_metadata as Field)) / U64_SHIFT_MULTIPLIER) as u64;\n    // Use division instead of bit shift since bit shifts are expensive in circuits\n    (msg_type, msg_metadata)\n}\n\nmod tests {\n    use crate::utils::array::subarray::subarray;\n    use super::{\n        decode_message, encode_message, from_expanded_metadata, MAX_MESSAGE_CONTENT_LEN,\n        to_expanded_metadata,\n    };\n\n    global U64_MAX: u64 = (2.pow_32(64) - 1) as u64;\n    global U128_MAX: Field = (2.pow_32(128) - 1);\n\n    #[test]\n    unconstrained fn encode_decode_empty_message(msg_type: u64, msg_metadata: u64) {\n        let encoded = encode_message(msg_type, msg_metadata, []);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), 0);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_short_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN / 2],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn encode_decode_full_message(\n        msg_type: u64,\n        msg_metadata: u64,\n        msg_content: [Field; MAX_MESSAGE_CONTENT_LEN],\n    ) {\n        let encoded = encode_message(msg_type, msg_metadata, msg_content);\n        let (decoded_msg_type, decoded_msg_metadata, decoded_msg_content) =\n            decode_message(BoundedVec::from_array(encoded));\n\n        assert_eq(decoded_msg_type, msg_type);\n        assert_eq(decoded_msg_metadata, msg_metadata);\n        assert_eq(decoded_msg_content.len(), msg_content.len());\n        assert_eq(subarray(decoded_msg_content.storage(), 0), msg_content);\n    }\n\n    #[test]\n    unconstrained fn to_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let packed = to_expanded_metadata(U64_MAX, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let packed = to_expanded_metadata(U64_MAX, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let packed = to_expanded_metadata(0, U64_MAX);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let packed = to_expanded_metadata(0, 0);\n        let (msg_type, msg_metadata) = from_expanded_metadata(packed);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn from_expanded_metadata_packing() {\n        // Test case 1: All bits set\n        let input = U128_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 2: Only log type bits set\n        let input = (U128_MAX - U64_MAX as Field);\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, U64_MAX);\n        assert_eq(msg_metadata, 0);\n\n        // Test case 3: Only msg_metadata bits set\n        let input = U64_MAX as Field;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, U64_MAX);\n\n        // Test case 4: No bits set\n        let input = 0;\n        let (msg_type, msg_metadata) = from_expanded_metadata(input);\n        assert_eq(msg_type, 0);\n        assert_eq(msg_metadata, 0);\n    }\n\n    #[test]\n    unconstrained fn to_from_expanded_metadata(original_msg_type: u64, original_msg_metadata: u64) {\n        let packed = to_expanded_metadata(original_msg_type, original_msg_metadata);\n        let (unpacked_msg_type, unpacked_msg_metadata) = from_expanded_metadata(packed);\n\n        assert_eq(original_msg_type, unpacked_msg_type);\n        assert_eq(original_msg_metadata, unpacked_msg_metadata);\n    }\n}\n"
    },
    "122": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/encryption/aes128.nr",
      "source": "use dep::protocol_types::{\n    address::AztecAddress,\n    constants::{\n        GENERATOR_INDEX__SYMMETRIC_KEY, GENERATOR_INDEX__SYMMETRIC_KEY_2,\n        PRIVATE_LOG_CIPHERTEXT_LEN,\n    },\n    hash::poseidon2_hash_with_separator,\n    point::Point,\n};\n\nuse crate::{\n    keys::{\n        ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        ephemeral::generate_ephemeral_key_pair,\n    },\n    messages::{\n        encryption::log_encryption::{\n            EPH_PK_SIGN_BYTE_SIZE_IN_BYTES, EPH_PK_X_SIZE_IN_FIELDS,\n            HEADER_CIPHERTEXT_SIZE_IN_BYTES, LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS,\n        },\n        logs::arithmetic_generics_utils::{\n            get_arr_of_size__log_bytes__from_PT, get_arr_of_size__log_bytes_padding__from_PT,\n        },\n    },\n    oracle::{aes128_decrypt::aes128_decrypt_oracle, shared_secret::get_shared_secret},\n    utils::{\n        array,\n        conversion::{\n            bytes_to_fields::{bytes_from_fields, bytes_to_fields},\n            fields_to_bytes::{fields_from_bytes, fields_to_bytes},\n        },\n        point::{get_sign_of_point, point_from_x_coord_and_sign},\n        random::get_random_bytes,\n    },\n};\n\nuse std::aes128::aes128_encrypt;\n\n/**\n * Computes N close-to-uniformly-random 256 bits from a given ECDH shared_secret.\n *\n * NEVER re-use the same iv and sym_key.\n * DO NOT call this function more than once with the same shared_secret.\n *\n * This function is only known to be safe if shared_secret is computed by combining a \n * random ephemeral key with an address point. See big comment within the body of the function.\n * See big comment within the body of the function.\n */\nfn extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [[u8; 32]; N] {\n    /*\n     * Unsafe because of https://eprint.iacr.org/2010/264.pdf Page 13, Lemma 2 (and the * two paragraphs below it).\n     *\n     * If you call this function, you need to be careful and aware of how the arg\n     * `shared_secret` has been derived.\n     *\n     * The paper says that the way you derive aes keys and IVs should be fine with poseidon2\n     * (modelled as a RO), as long as you _don't_ use Poseidon2 as a PRG to generate the * two exponents x & y which multiply to the shared secret S:\n     *\n     * S = [x*y]*G.\n     *\n     * (Otherwise, you would have to \"key\" poseidon2, i.e. generate a uniformly string K\n     * which can be public and compute Hash(x) as poseidon(K,x)).\n     * In that lemma, k would be 2*254=508, and m would be the number of points on the * grumpkin curve (which is close to r according to the Hasse bound).\n     *\n     * Our shared secret S is [esk * address_sk] * G, and the question is: * Can we compute hash(S) using poseidon2 instead of sha256?\n     *\n     * Well, esk is random and not generated with poseidon2, so that's good.\n     * What about address_sk?\n     * Well, address_sk = poseidon2(stuff) + ivsk, so there was some\n     * discussion about whether address_sk is independent of poseidon2.\n     * Given that ivsk is random and independent of poseidon2, the address_sk is also\n     * independent of poseidon2.\n     *\n     * Tl;dr: we believe it's safe to hash S = [esk * address_sk] * G using poseidon2,\n     * in order to derive a symmetric key.\n     *\n     * If you're calling this function for a differently-derived `shared_secret`, be\n     * careful.\n     *\n     */\n\n    /* The output of this function needs to be 32 random bytes.\n     * A single field won't give us 32 bytes of entropy.\n     * So we compute two \"random\" fields, by poseidon-hashing with two different\n     * generators.\n     * We then extract the last 16 (big endian) bytes of each \"random\" field.\n     * Note: we use to_be_bytes because it's slightly more efficient. But we have to\n     * be careful not to take bytes from the \"big end\", because the \"big\" byte is\n     * not uniformly random over the byte: it only has < 6 bits of randomness, because\n     * it's the big end of a 254-bit field element.\n     */\n\n    let mut all_bytes: [[u8; 32]; N] = std::mem::zeroed();\n    // We restrict N to be < 2^8, because of how we compute the domain separator\n    // from k below (where k <= N must be 8 bits). In practice, it's extremely\n    // unlikely that an app will want to compute >= 256 ciphertexts.\n    std::static_assert(N < 256, \"N too large\");\n    for k in 0..N {\n        // We augment the domain separator with the loop index, so that we can\n        // generate N lots of randomness.\n        let k_shift = (k as u16 << 8);\n        let separator_1 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY as u16;\n        let separator_2 = k_shift + GENERATOR_INDEX__SYMMETRIC_KEY_2 as u16;\n\n        let rand1: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_1);\n        let rand2: Field =\n            poseidon2_hash_with_separator([shared_secret.x, shared_secret.y], separator_2);\n\n        let rand1_bytes: [u8; 32] = rand1.to_be_bytes();\n        let rand2_bytes: [u8; 32] = rand2.to_be_bytes();\n\n        let mut bytes: [u8; 32] = [0; 32];\n        for i in 0..16 {\n            // We take bytes from the \"little end\" of the be-bytes arrays:\n            let j = 32 - i - 1;\n            bytes[i] = rand1_bytes[j];\n            bytes[16 + i] = rand2_bytes[j];\n        }\n\n        all_bytes[k] = bytes;\n    }\n\n    all_bytes\n}\n\nfn derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits<let N: u32>(\n    many_random_256_bits: [[u8; 32]; N],\n) -> [([u8; 16], [u8; 16]); N] {\n    // Many (sym_key, iv) pairs:\n    let mut many_pairs: [([u8; 16], [u8; 16]); N] = std::mem::zeroed();\n    for k in 0..N {\n        let random_256_bits = many_random_256_bits[k];\n        let mut sym_key = [0; 16];\n        let mut iv = [0; 16];\n        for i in 0..16 {\n            sym_key[i] = random_256_bits[i];\n            iv[i] = random_256_bits[i + 16];\n        }\n        many_pairs[k] = (sym_key, iv);\n    }\n\n    many_pairs\n}\n\npub fn derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe<let N: u32>(\n    shared_secret: Point,\n) -> [([u8; 16], [u8; 16]); N] {\n    let many_random_256_bits: [[u8; 32]; N] = extract_many_close_to_uniformly_random_256_bits_from_ecdh_shared_secret_using_poseidon2_unsafe(\n        shared_secret,\n    );\n\n    derive_aes_symmetric_key_and_iv_from_uniformly_random_256_bits(many_random_256_bits)\n}\n\npub struct AES128 {}\n\nimpl LogEncryption for AES128 {\n    fn encrypt_log<let PlaintextLen: u32>(\n        plaintext: [Field; PlaintextLen],\n        recipient: AztecAddress,\n    ) -> [Field; PRIVATE_LOG_CIPHERTEXT_LEN] {\n        // AES 128 operates on bytes, not fields, so we need to convert the fields to bytes.\n        // (This process is then reversed when processing the log in `do_process_log`)\n        let plaintext_bytes = fields_to_bytes(plaintext);\n\n        // *****************************************************************************\n        // Compute the shared secret\n        // *****************************************************************************\n\n        let (eph_sk, eph_pk) = generate_ephemeral_key_pair();\n\n        let eph_pk_sign_byte: u8 = get_sign_of_point(eph_pk) as u8;\n\n        // (not to be confused with the tagging shared secret)\n        let ciphertext_shared_secret =\n            derive_ecdh_shared_secret_using_aztec_address(eph_sk, recipient);\n        // TODO: also use this shared secret for deriving note randomness.\n\n        // *****************************************************************************\n        // Convert the plaintext into whatever format the encryption function expects\n        // *****************************************************************************\n\n        // Already done for this strategy: AES expects bytes.\n\n        // *****************************************************************************\n        // Encrypt the plaintext\n        // *****************************************************************************\n\n        // It is safe to call the `unsafe` function here, because we know the `shared_secret`\n        // was derived using an AztecAddress (the recipient). See the block comment\n        // at the start of this unsafe target function for more info.\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        let ciphertext_bytes = aes128_encrypt(plaintext_bytes, body_iv, body_sym_key);\n\n        // |full_pt| = |pt_length| + |pt|\n        // |pt_aes_padding| = 16 - (|full_pt| % 16)\n        // or... since a % b is the same as a - b * (a // b) (integer division), so:\n        // |pt_aes_padding| = 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        // |ct| = |full_pt| + |pt_aes_padding|\n        //      = |full_pt| + 16 - (|full_pt| - 16 * (|full_pt| // 16))\n        //      = 16 + 16 * (|full_pt| // 16)\n        //      = 16 * (1 + |full_pt| // 16)\n        assert(ciphertext_bytes.len() == 16 * (1 + (PlaintextLen * 32) / 16));\n\n        // *****************************************************************************\n        // Compute the header ciphertext\n        // *****************************************************************************\n\n        // Header contains only the length of the ciphertext stored in 2 bytes.\n        let mut header_plaintext: [u8; 2] = [0 as u8; 2];\n        let ciphertext_bytes_length = ciphertext_bytes.len();\n        header_plaintext[0] = (ciphertext_bytes_length >> 8) as u8;\n        header_plaintext[1] = ciphertext_bytes_length as u8;\n\n        // Note: the aes128_encrypt builtin fn automatically appends bytes to the\n        // input, according to pkcs#7; hence why the output `header_ciphertext_bytes` is 16\n        // bytes larger than the input in this case.\n        let header_ciphertext_bytes = aes128_encrypt(header_plaintext, header_iv, header_sym_key);\n        // I recall that converting a slice to an array incurs constraints, so I'll check the length this way instead:\n        assert(header_ciphertext_bytes.len() == HEADER_CIPHERTEXT_SIZE_IN_BYTES);\n\n        // *****************************************************************************\n        // Prepend / append more bytes of data to the ciphertext, before converting back\n        // to fields.\n        // *****************************************************************************\n\n        let mut log_bytes_padding_to_mult_31 =\n            get_arr_of_size__log_bytes_padding__from_PT::<PlaintextLen * 32>();\n        // Safety: this randomness won't be constrained to be random. It's in the\n        // interest of the executor of this fn to encrypt with random bytes.\n        log_bytes_padding_to_mult_31 = unsafe { get_random_bytes() };\n\n        let mut log_bytes = get_arr_of_size__log_bytes__from_PT::<PlaintextLen * 32>();\n\n        assert(\n            log_bytes.len() % 31 == 0,\n            \"Unexpected error: log_bytes.len() should be divisible by 31, by construction.\",\n        );\n\n        log_bytes[0] = eph_pk_sign_byte;\n        let mut offset = 1;\n        for i in 0..header_ciphertext_bytes.len() {\n            log_bytes[offset + i] = header_ciphertext_bytes[i];\n        }\n        offset += header_ciphertext_bytes.len();\n\n        for i in 0..ciphertext_bytes.len() {\n            log_bytes[offset + i] = ciphertext_bytes[i];\n        }\n        offset += ciphertext_bytes.len();\n\n        for i in 0..log_bytes_padding_to_mult_31.len() {\n            log_bytes[offset + i] = log_bytes_padding_to_mult_31[i];\n        }\n\n        assert(\n            offset + log_bytes_padding_to_mult_31.len() == log_bytes.len(),\n            \"Something has gone wrong\",\n        );\n\n        // *****************************************************************************\n        // Convert bytes back to fields\n        // *****************************************************************************\n\n        // TODO(#12749): As Mike pointed out, we need to make logs produced by different encryption schemes\n        // indistinguishable from each other and for this reason the output here and in the last for-loop of this function\n        // should cover a full field.\n        let log_bytes_as_fields = bytes_to_fields(log_bytes);\n\n        // *****************************************************************************\n        // Prepend / append fields, to create the final log\n        // *****************************************************************************\n\n        let mut ciphertext: [Field; PRIVATE_LOG_CIPHERTEXT_LEN] = [0; PRIVATE_LOG_CIPHERTEXT_LEN];\n\n        ciphertext[0] = eph_pk.x;\n\n        let mut offset = 1;\n        for i in 0..log_bytes_as_fields.len() {\n            ciphertext[offset + i] = log_bytes_as_fields[i];\n        }\n        offset += log_bytes_as_fields.len();\n\n        for i in offset..PRIVATE_LOG_CIPHERTEXT_LEN {\n            // We need to get a random value that fits in 31 bytes to not leak information about the size of the log\n            // (all the \"real\" log fields contain at most 31 bytes because of the way we convert the bytes to fields).\n            // TODO(#12749): Long term, this is not a good solution.\n\n            // Safety: we assume that the sender wants for the log to be private - a malicious one could simply reveal its\n            // contents publicly. It is therefore fine to trust the sender to provide random padding.\n            let field_bytes = unsafe { get_random_bytes::<31>() };\n            ciphertext[i] = Field::from_be_bytes::<31>(field_bytes);\n        }\n\n        ciphertext\n    }\n\n    unconstrained fn decrypt_log(\n        ciphertext: BoundedVec<Field, PRIVATE_LOG_CIPHERTEXT_LEN>,\n        recipient: AztecAddress,\n    ) -> BoundedVec<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS> {\n        let eph_pk_x = ciphertext.get(0);\n\n        let ciphertext_without_eph_pk_x_fields = array::subbvec::<Field, PRIVATE_LOG_CIPHERTEXT_LEN, PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS>(\n            ciphertext,\n            EPH_PK_X_SIZE_IN_FIELDS,\n        );\n\n        // Convert the ciphertext represented as fields to a byte representation (its original format)\n        let ciphertext_without_eph_pk_x = bytes_from_fields(ciphertext_without_eph_pk_x_fields);\n\n        // First byte of the ciphertext represents the ephemeral public key sign\n        let eph_pk_sign_bool = ciphertext_without_eph_pk_x.get(0) != 0;\n        // With the sign and the x-coordinate of the ephemeral public key, we can reconstruct the point\n        let eph_pk = point_from_x_coord_and_sign(eph_pk_x, eph_pk_sign_bool);\n\n        // Derive shared secret\n        let ciphertext_shared_secret = get_shared_secret(recipient, eph_pk);\n\n        // Derive symmetric keys:\n        let pairs = derive_aes_symmetric_key_and_iv_from_ecdh_shared_secret_using_poseidon2_unsafe::<2>(\n            ciphertext_shared_secret,\n        );\n        let (body_sym_key, body_iv) = pairs[0];\n        let (header_sym_key, header_iv) = pairs[1];\n\n        // Extract the header ciphertext\n        let header_start = EPH_PK_SIGN_BYTE_SIZE_IN_BYTES; // Skip eph_pk_sign byte\n        let header_ciphertext: [u8; HEADER_CIPHERTEXT_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), header_start);\n        // We need to convert the array to a BoundedVec because the oracle expects a BoundedVec as it's designed to work\n        // with logs with unknown length at compile time. This would not be necessary here as the header ciphertext length\n        // is fixed. But we do it anyway to not have to have duplicate oracles.\n        let header_ciphertext_bvec =\n            BoundedVec::<u8, HEADER_CIPHERTEXT_SIZE_IN_BYTES>::from_array(header_ciphertext);\n\n        // Decrypt header\n        let header_plaintext =\n            aes128_decrypt_oracle(header_ciphertext_bvec, header_iv, header_sym_key);\n\n        // Extract ciphertext length from header (2 bytes, big-endian)\n        let ciphertext_length =\n            ((header_plaintext.get(0) as u32) << 8) | (header_plaintext.get(1) as u32);\n\n        // Extract and decrypt main ciphertext\n        let ciphertext_start = header_start + HEADER_CIPHERTEXT_SIZE_IN_BYTES;\n        let ciphertext_with_padding: [u8; (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES] =\n            array::subarray(ciphertext_without_eph_pk_x.storage(), ciphertext_start);\n        let ciphertext: BoundedVec<u8, (PRIVATE_LOG_CIPHERTEXT_LEN - EPH_PK_X_SIZE_IN_FIELDS) * 31 - HEADER_CIPHERTEXT_SIZE_IN_BYTES - EPH_PK_SIGN_BYTE_SIZE_IN_BYTES> =\n            BoundedVec::from_parts(ciphertext_with_padding, ciphertext_length);\n\n        // Decrypt main ciphertext and return it\n        let plaintext_bytes = aes128_decrypt_oracle(ciphertext, body_iv, body_sym_key);\n\n        // Each field of the original note log was serialized to 32 bytes so we convert the bytes back to fields.\n        fields_from_bytes(plaintext_bytes)\n    }\n}\n\nmod test {\n    use crate::{\n        keys::ecdh_shared_secret::derive_ecdh_shared_secret_using_aztec_address,\n        messages::encryption::log_encryption::{LogEncryption, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS},\n        test::helpers::test_environment::TestEnvironment,\n    };\n    use super::AES128;\n    use protocol_types::{\n        address::AztecAddress,\n        indexed_tagging_secret::IndexedTaggingSecret,\n        traits::{Deserialize, FromField},\n    };\n    use std::{embedded_curve_ops::EmbeddedCurveScalar, test::OracleMock};\n\n    #[test]\n    unconstrained fn encrypt_decrypt_log() {\n        let env = TestEnvironment::new();\n\n        // Log decryption requires oracles that are only available during private execution\n        env.private_context(|_| {\n            let plaintext = [1, 2, 3];\n\n            let recipient = AztecAddress::from_field(\n                0x25afb798ea6d0b8c1618e50fdeafa463059415013d3b7c75d46abf5e242be70c,\n            );\n\n            // Mock random values for deterministic test\n            let eph_sk = 0x1358d15019d4639393d62b97e1588c095957ce74a1c32d6ec7d62fe6705d9538;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(eph_sk).times(1);\n\n            let randomness = 0x0101010101010101010101010101010101010101010101010101010101010101;\n            let _ = OracleMock::mock(\"utilityGetRandomField\").returns(randomness).times(1000000);\n\n            let _ = OracleMock::mock(\"utilityGetIndexedTaggingSecretAsSender\").returns(\n                IndexedTaggingSecret::deserialize([69420, 1337]),\n            );\n            let _ = OracleMock::mock(\"privateIncrementAppTaggingSecretIndexAsSender\").returns(());\n\n            // Encrypt the log\n            let encrypted_log = BoundedVec::from_array(AES128::encrypt_log(plaintext, recipient));\n\n            // Mock shared secret for deterministic test\n            let shared_secret = derive_ecdh_shared_secret_using_aztec_address(\n                EmbeddedCurveScalar::from_field(eph_sk),\n                recipient,\n            );\n            let _ = OracleMock::mock(\"utilityGetSharedSecret\").returns(shared_secret);\n\n            // Decrypt the log\n            let decrypted = AES128::decrypt_log(encrypted_log, recipient);\n\n            // The decryption function spits out a BoundedVec because it's designed to work with logs with unknown length\n            // at compile time. For this reason we need to convert the original input to a BoundedVec.\n            let plaintext_bvec =\n                BoundedVec::<Field, PRIVATE_LOG_PLAINTEXT_SIZE_IN_FIELDS>::from_array(plaintext);\n\n            // Verify decryption matches original plaintext\n            assert_eq(\n                decrypted,\n                plaintext_bvec,\n                \"Decrypted bytes should match original plaintext\",\n            );\n\n            // The following is a workaround of \"struct is never constructed\" Noir compilation error (we only ever use\n            // static methods of the struct).\n            let _ = AES128 {};\n        });\n    }\n}\n"
    },
    "138": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/messages/processing/mod.nr",
      "source": "pub(crate) mod event_validation_request;\npub mod message_context;\npub(crate) mod note_validation_request;\npub(crate) mod log_retrieval_request;\npub(crate) mod log_retrieval_response;\npub(crate) mod pending_tagged_log;\n\nuse crate::{\n    capsules::CapsuleArray,\n    event::event_selector::EventSelector,\n    messages::{\n        discovery::{\n            partial_notes::DeliveredPendingPartialNote, private_events::MAX_EVENT_SERIALIZED_LEN,\n            private_notes::MAX_NOTE_PACKED_LEN,\n        },\n        processing::{\n            log_retrieval_request::LogRetrievalRequest,\n            log_retrieval_response::LogRetrievalResponse,\n            note_validation_request::NoteValidationRequest, pending_tagged_log::PendingTaggedLog,\n        },\n    },\n    oracle,\n};\nuse event_validation_request::EventValidationRequest;\nuse protocol_types::{address::AztecAddress, hash::sha256_to_field};\n\n// Base slot for the pending tagged log array to which the fetch_tagged_logs oracle inserts found private logs.\nglobal PENDING_TAGGED_LOG_ARRAY_BASE_SLOT: Field =\n    sha256_to_field(\"AZTEC_NR::PENDING_TAGGED_LOG_ARRAY_BASE_SLOT\".as_bytes());\n\nglobal NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\nglobal LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT: Field = sha256_to_field(\n    \"AZTEC_NR::LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT\".as_bytes(),\n);\n\n/// Searches for private logs emitted by `contract_address` that might contain messages for one of the local accounts,\n/// and stores them in a `CapsuleArray` which is then returned.\npub(crate) unconstrained fn get_private_logs(\n    contract_address: AztecAddress,\n) -> CapsuleArray<PendingTaggedLog> {\n    // We will eventually perform log discovery via tagging here, but for now we simply call the `fetchTaggedLogs`\n    // oracle. This makes PXE synchronize tags, download logs and store the pending tagged logs in a capsule array.\n    oracle::message_processing::fetch_tagged_logs(PENDING_TAGGED_LOG_ARRAY_BASE_SLOT);\n\n    CapsuleArray::at(contract_address, PENDING_TAGGED_LOG_ARRAY_BASE_SLOT)\n}\n\n/// Enqueues a note for validation by PXE, so that it becomes aware of a note's existence allowing for later retrieval\n/// via `get_notes` oracle. The note will be scoped to `contract_address`, meaning other contracts will not be able to\n/// access it unless authorized.\n///\n/// In order for the note validation and insertion to occur, `validate_enqueued_notes_and_events` must be later called.\n/// For optimal performance, accumulate as many note validation requests as possible and then validate them all at the\n/// end (which results in PXE minimizing the number of network round-trips).\n///\n/// The `packed_note` is what `getNotes` will later return. PXE indexes notes by `storage_slot`, so this value\n/// is typically used to filter notes that correspond to different state variables. `note_hash` and `nullifier` are\n/// the inner hashes, i.e. the raw hashes returned by `NoteHash::compute_note_hash` and\n/// `NoteHash::compute_nullifier`. PXE will verify that the siloed unique note hash was inserted into the tree\n/// at `tx_hash`, and will store the nullifier to later check for nullification.\n///\n/// `recipient` is the account to which the note was sent to. Other accounts will not be able to access this note (e.g.\n/// other accounts will not be able to see one another's token balance notes, even in the same PXE) unless authorized.\npub(crate) unconstrained fn enqueue_note_for_validation(\n    contract_address: AztecAddress,\n    storage_slot: Field,\n    note_nonce: Field,\n    packed_note: BoundedVec<Field, MAX_NOTE_PACKED_LEN>,\n    note_hash: Field,\n    nullifier: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `NoteValidationRequest`\n    CapsuleArray::at(contract_address, NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        NoteValidationRequest {\n            contract_address,\n            storage_slot,\n            note_nonce,\n            packed_note,\n            note_hash,\n            nullifier,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Enqueues an event for validation by PXE, so that it can be efficiently validated and then inserted into the event\n/// store.\n///\n/// In order for the event validation and insertion to occur, `validate_enqueued_notes_and_events` must be later\n/// called. For optimal performance, accumulate as many event validation requests as possible and then validate them\n/// all at the end (which results in PXE minimizing the number of network round-trips).\npub(crate) unconstrained fn enqueue_event_for_validation(\n    contract_address: AztecAddress,\n    event_type_id: EventSelector,\n    serialized_event: BoundedVec<Field, MAX_EVENT_SERIALIZED_LEN>,\n    event_commitment: Field,\n    tx_hash: Field,\n    recipient: AztecAddress,\n) {\n    // We store requests in a `CapsuleArray`, which PXE will later read from and deserialize into its version of the\n    // Noir `EventValidationRequest`\n    CapsuleArray::at(contract_address, EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT).push(\n        EventValidationRequest {\n            contract_address,\n            event_type_id,\n            serialized_event,\n            event_commitment,\n            tx_hash,\n            recipient,\n        },\n    )\n}\n\n/// Validates all note and event validation requests enqueued via `enqueue_note_for_validation` and\n/// `enqueue_event_for_validation`, inserting them into the note database and event store respectively, making them\n/// queryable via `get_notes` oracle and our TS API (PXE::getPrivateEvents).\n///\n/// This automatically clears both validation request queues, so no further work needs to be done by the caller.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(contract_address: AztecAddress) {\n    oracle::message_processing::validate_enqueued_notes_and_events(\n        contract_address,\n        NOTE_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n        EVENT_VALIDATION_REQUESTS_ARRAY_BASE_SLOT,\n    );\n}\n\n/// Efficiently queries the node for logs that result in the completion of all `DeliveredPendingPartialNote`s stored in\n/// a `CapsuleArray` by performing all node communication concurrently. Returns a second `CapsuleArray` with Options for\n/// the responses that correspond to the pending partial notes at the same index.\n///\n/// For example, given an array with pending partial notes `[ p1, p2, p3 ]`, where `p1` and `p3` have corresponding\n/// completion logs but `p2` does not, the returned `CapsuleArray` will have contents\n/// `[some(p1_log), none(), some(p3_log)]`.\npub(crate) unconstrained fn get_pending_partial_notes_completion_logs(\n    contract_address: AztecAddress,\n    pending_partial_notes: CapsuleArray<DeliveredPendingPartialNote>,\n) -> CapsuleArray<Option<LogRetrievalResponse>> {\n    let log_retrieval_requests =\n        CapsuleArray::at(contract_address, LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT);\n\n    // We create a LogRetrievalRequest for each PendingPartialNote in the CapsuleArray. Because we need the indices in\n    // the request array to match the indices in the partial note array, we can't use CapsuleArray::for_each, as that\n    // function has arbitrary iteration order. Instead, we manually iterate the array from the beginning and push into\n    // the requests array, which we expect to be empty.\n    let mut i = 0;\n    let pending_partial_notes_count = pending_partial_notes.len();\n    while i < pending_partial_notes_count {\n        let pending_partial_note = pending_partial_notes.get(i);\n        log_retrieval_requests.push(\n            LogRetrievalRequest {\n                contract_address,\n                unsiloed_tag: pending_partial_note.note_completion_log_tag,\n            },\n        );\n        i += 1;\n    }\n\n    oracle::message_processing::bulk_retrieve_logs(\n        contract_address,\n        LOG_RETRIEVAL_REQUESTS_ARRAY_BASE_SLOT,\n        LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT,\n    );\n\n    CapsuleArray::at(contract_address, LOG_RETRIEVAL_RESPONSES_ARRAY_BASE_SLOT)\n}\n"
    },
    "150": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/note_metadata.nr",
      "source": "use protocol_types::traits::{Packable, Serialize};\n\n// There's temporarily quite a bit of boilerplate here because Noir does not yet support enums. This file will\n// eventually be simplified into something closer to:\n//\n// pub enum NoteMetadata {\n//   PendingSamePhase{ note_hash_counter: u32 },\n//   PendingOtherPhase{ note_hash_counter: u32, note_nonce: Field },\n//   Settled{ note_nonce: Field },\n// }\n//\n// For now, we have `NoteMetadata` acting as a sort of tagged union.\n\nstruct NoteStageEnum {\n    /// A note that was created in the transaction that is currently being executed, during the current execution phase,\n    /// i.e. non-revertible or revertible.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted unless nullified in this transaction\n    /// (becoming a transient note).\n    PENDING_SAME_PHASE: u8,\n    /// A note that was created in the transaction that is currently being executed, during the previous execution\n    /// phase. Because there are only two phases and their order is always the same (first non-revertible and then\n    /// revertible) this implies that the note was created in the non-revertible phase, and that the current phase is\n    /// the revertible phase.\n    ///\n    /// These notes are not yet in the note hash tree, though they will be inserted **even if nullified in this\n    /// transaction**. This means that they must be nullified as if they were settled (i.e. using the unique note hash)\n    /// in order to avoid double spends once they become settled.\n    PENDING_PREVIOUS_PHASE: u8,\n    /// A note that was created in a prior transaction and is therefore already in the note hash tree.\n    SETTLED: u8,\n}\n\nglobal NoteStage: NoteStageEnum =\n    NoteStageEnum { PENDING_SAME_PHASE: 1, PENDING_PREVIOUS_PHASE: 2, SETTLED: 3 };\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a note in any of the three valid stages (pending same phase, pending previous phase, or settled). In\n/// order to access the underlying fields callers must first find the appropriate stage (e.g. via `is_settled()`) and\n/// then convert this into the appropriate type (e.g. via `to_settled()`).\n#[derive(Eq, Serialize, Packable)]\npub struct NoteMetadata {\n    stage: u8,\n    maybe_note_nonce: Field,\n}\n\nimpl NoteMetadata {\n    /// Constructs a `NoteMetadata` object from optional note hash counter and nonce. Both a zero note hash counter and\n    /// a zero nonce are invalid, so those are used to signal non-existent values.\n    pub fn from_raw_data(nonzero_note_hash_counter: bool, maybe_note_nonce: Field) -> Self {\n        if nonzero_note_hash_counter {\n            if maybe_note_nonce == 0 {\n                Self { stage: NoteStage.PENDING_SAME_PHASE, maybe_note_nonce }\n            } else {\n                Self { stage: NoteStage.PENDING_PREVIOUS_PHASE, maybe_note_nonce }\n            }\n        } else if maybe_note_nonce != 0 {\n            Self { stage: NoteStage.SETTLED, maybe_note_nonce }\n        } else {\n            panic(\n                f\"Note has a zero note hash counter and no nonce - existence cannot be proven\",\n            )\n        }\n    }\n\n    /// Returns true if the note is pending **and** from the same phase, i.e. if it's been created in the current\n    /// transaction during the current execution phase (either non-revertible or revertible).\n    pub fn is_pending_same_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_SAME_PHASE\n    }\n\n    /// Returns true if the note is pending **and** from the previous phase, i.e. if it's been created in the current\n    /// transaction during an execution phase prior to the current one. Because private execution only has two phases\n    /// with strict ordering, this implies that the note was created in the non-revertible phase, and that the current\n    /// phase is the revertible phase.\n    pub fn is_pending_previous_phase(self) -> bool {\n        self.stage == NoteStage.PENDING_PREVIOUS_PHASE\n    }\n\n    /// Returns true if the note is settled, i.e. if it's been created in a prior transaction and is therefore already\n    /// in the note hash tree.\n    pub fn is_settled(self) -> bool {\n        self.stage == NoteStage.SETTLED\n    }\n\n    /// Asserts that the metadata is that of a pending note from the same phase and converts it accordingly.\n    pub fn to_pending_same_phase(self) -> PendingSamePhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_SAME_PHASE);\n        PendingSamePhaseNoteMetadata::new()\n    }\n\n    /// Asserts that the metadata is that of a pending note from a previous phase and converts it accordingly.\n    pub fn to_pending_previous_phase(self) -> PendingPreviousPhaseNoteMetadata {\n        assert_eq(self.stage, NoteStage.PENDING_PREVIOUS_PHASE);\n        PendingPreviousPhaseNoteMetadata::new(self.maybe_note_nonce)\n    }\n\n    /// Asserts that the metadata is that of a settled note and converts it accordingly.\n    pub fn to_settled(self) -> SettledNoteMetadata {\n        assert_eq(self.stage, NoteStage.SETTLED);\n        SettledNoteMetadata::new(self.maybe_note_nonce)\n    }\n}\n\nimpl From<PendingSamePhaseNoteMetadata> for NoteMetadata {\n    fn from(_value: PendingSamePhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, std::mem::zeroed())\n    }\n}\n\nimpl From<PendingPreviousPhaseNoteMetadata> for NoteMetadata {\n    fn from(value: PendingPreviousPhaseNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(true, value.note_nonce())\n    }\n}\n\nimpl From<SettledNoteMetadata> for NoteMetadata {\n    fn from(value: SettledNoteMetadata) -> Self {\n        NoteMetadata::from_raw_data(false, value.note_nonce())\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending same phase note, i.e. a note that was created in the transaction that is currently being\n/// executed during the current execution phase (either non-revertible or revertible).\npub struct PendingSamePhaseNoteMetadata {\n    // This struct contains no fields since there is no metadata associated with a pending same phase note: it has no\n    // nonce (since it may get squashed by a nullifier emitted in the same phase), and while it does have a note hash\n    // counter we cannot constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingSamePhaseNoteMetadata {\n    pub fn new() -> Self {\n        Self {}\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a pending previous phase note, i.e. a note that was created in the transaction that is currently\n/// being executed, during the previous execution phase. Because there are only two phases and their order is always the\n/// same (first non-revertible and then revertible) this implies that the note was created in the non-revertible phase,\n/// and that the current phase is the revertible phase.\npub struct PendingPreviousPhaseNoteMetadata {\n    note_nonce: Field,\n    // This struct does not contain a note hash counter, even though one exists for this note, because we cannot\n    // constrain its value (and don't need to - only that it is non-zero).\n}\n\nimpl PendingPreviousPhaseNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n\n/// The metadata required to both prove a note's existence and destroy it, by computing the correct note hash for kernel\n/// read requests, as well as the correct nullifier to avoid double-spends.\n///\n/// This represents a settled note, i.e. a note that was created in a prior transaction and is therefore already in the\n/// note hash tree.\npub struct SettledNoteMetadata {\n    note_nonce: Field,\n}\n\nimpl SettledNoteMetadata {\n    pub fn new(note_nonce: Field) -> Self {\n        Self { note_nonce }\n    }\n\n    pub fn note_nonce(self) -> Field {\n        self.note_nonce\n    }\n}\n"
    },
    "153": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/note/utils.nr",
      "source": "use crate::{\n    context::PrivateContext,\n    note::{note_interface::NoteHash, retrieved_note::RetrievedNote},\n};\n\nuse dep::protocol_types::hash::{\n    compute_siloed_note_hash, compute_siloed_nullifier, compute_unique_note_hash,\n};\n\n/// Returns the note hash that must be used to issue a private kernel read request for a note.\npub fn compute_note_hash_for_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash = retrieved_note.note.compute_note_hash(storage_slot);\n\n    if retrieved_note.metadata.is_settled() {\n        // Settled notes are read by siloing with contract address and nonce (resulting in the final unique note hash,\n        // which is already in the note hash tree).\n        let siloed_note_hash = compute_siloed_note_hash(retrieved_note.contract_address, note_hash);\n        compute_unique_note_hash(\n            retrieved_note.metadata.to_settled().note_nonce(),\n            siloed_note_hash,\n        )\n    } else {\n        // Pending notes (both same phase and previous phase ones)  re read by their non-siloed hash (not even by\n        // contract address), which is what is stored in the new note hashes array (at the position hinted by note hash\n        // counter).\n        note_hash\n    }\n}\n\n/// Returns the note hash that must be used to compute a note's nullifier when calling `NoteHash::compute_nullifier` or\n/// `NoteHash::compute_nullifier_unconstrained`.\npub fn compute_note_hash_for_nullify<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    compute_note_hash_for_nullify_from_read_request(\n        retrieved_note,\n        compute_note_hash_for_read_request(retrieved_note, storage_slot),\n    )\n}\n\n/// Same as `compute_note_hash_for_nullify`, except it takes the note hash used in a read request (i.e. what\n/// `compute_note_hash_for_read_request` would return). This is useful in scenarios where that hash has already been\n/// computed to reduce constraints by reusing this value.\npub fn compute_note_hash_for_nullify_from_read_request<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    note_hash_for_read_request: Field,\n) -> Field {\n    // There is just one instance in which the note hash for nullification does not match the note hash used for a read\n    // request, which is when dealing with pending previous phase notes. These had their existence proven using their\n    // non-siloed note hash along with the note hash counter (like all pending notes), but since they will be\n    // unconditionally inserted in the note hash tree (since they cannot be squashed) they must be nullified using the\n    // *unique* note hash.\n    // If we didn't, it'd be possible to emit a second different nullifier for the same note in a follow up transaction,\n    // once the note is settled, resulting in a double spend.\n\n    if retrieved_note.metadata.is_pending_previous_phase() {\n        let siloed_note_hash =\n            compute_siloed_note_hash(retrieved_note.contract_address, note_hash_for_read_request);\n        let note_nonce = retrieved_note.metadata.to_pending_previous_phase().note_nonce();\n\n        compute_unique_note_hash(note_nonce, siloed_note_hash)\n    } else {\n        note_hash_for_read_request\n    }\n}\n\n/// Computes a note's siloed nullifier, i.e. the one that will be inserted into the nullifier tree.\npub fn compute_siloed_note_nullifier<Note>(\n    retrieved_note: RetrievedNote<Note>,\n    storage_slot: Field,\n    context: &mut PrivateContext,\n) -> Field\nwhere\n    Note: NoteHash,\n{\n    let note_hash_for_nullify = compute_note_hash_for_nullify(retrieved_note, storage_slot);\n    let inner_nullifier = retrieved_note.note.compute_nullifier(context, note_hash_for_nullify);\n\n    compute_siloed_nullifier(retrieved_note.contract_address, inner_nullifier)\n}\n"
    },
    "157": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/call_private_function.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector, address::AztecAddress, utils::reader::Reader,\n};\n\n#[oracle(privateCallPrivateFunction)]\nunconstrained fn call_private_function_oracle(\n    _contract_address: AztecAddress,\n    _function_selector: FunctionSelector,\n    _args_hash: Field,\n    _start_side_effect_counter: u32,\n    _is_static_call: bool,\n) -> [Field; 2] {}\n\npub unconstrained fn call_private_function_internal(\n    contract_address: AztecAddress,\n    function_selector: FunctionSelector,\n    args_hash: Field,\n    start_side_effect_counter: u32,\n    is_static_call: bool,\n) -> (u32, Field) {\n    let fields = call_private_function_oracle(\n        contract_address,\n        function_selector,\n        args_hash,\n        start_side_effect_counter,\n        is_static_call,\n    );\n\n    let mut reader = Reader::new(fields);\n    let end_side_effect_counter = reader.read_u32();\n    let returns_hash = reader.read();\n\n    (end_side_effect_counter, returns_hash)\n}\n"
    },
    "158": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/capsules.nr",
      "source": "use protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// Stores arbitrary information in a per-contract non-volatile database, which can later be retrieved with `load`. If\n/// data was already stored at this slot, it is overwritten.\npub unconstrained fn store<T>(contract_address: AztecAddress, slot: Field, value: T)\nwhere\n    T: Serialize,\n{\n    let serialized = value.serialize();\n    store_oracle(contract_address, slot, serialized);\n}\n\n/// Returns data previously stored via `storeCapsule` in the per-contract non-volatile database. Returns Option::none() if\n/// nothing was stored at the given slot.\npub unconstrained fn load<T>(contract_address: AztecAddress, slot: Field) -> Option<T>\nwhere\n    T: Deserialize,\n{\n    let serialized_option = load_oracle(contract_address, slot, <T as Deserialize>::N);\n    serialized_option.map(|arr| Deserialize::deserialize(arr))\n}\n\n/// Deletes data in the per-contract non-volatile database. Does nothing if no data was present.\npub unconstrained fn delete(contract_address: AztecAddress, slot: Field) {\n    delete_oracle(contract_address, slot);\n}\n\n/// Copies a number of contiguous entries in the per-contract non-volatile database. This allows for efficient data\n/// structures by avoiding repeated calls to `loadCapsule` and `storeCapsule`.\n/// Supports overlapping source and destination regions (which will result in the overlapped source values being\n/// overwritten). All copied slots must exist in the database (i.e. have been stored and not deleted)\npub unconstrained fn copy(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {\n    copy_oracle(contract_address, src_slot, dst_slot, num_entries);\n}\n\n#[oracle(utilityStoreCapsule)]\nunconstrained fn store_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    values: [Field; N],\n) {}\n\n/// We need to pass in `array_len` (the value of N) as a parameter to tell the oracle how many fields the response must\n/// have.\n///\n/// Note that the oracle returns an Option<[Field; N]> because we cannot return an Option<T> directly. That would\n/// require for the oracle resolver to know the shape of T (e.g. if T were a struct of 3 u32 values then the expected\n/// response shape would be 3 single items, whereas it were a struct containing `u32, [Field;10], u32` then the expected\n/// shape would be single, array, single.). Instead, we return the serialization and deserialize in Noir.\n#[oracle(utilityLoadCapsule)]\nunconstrained fn load_oracle<let N: u32>(\n    contract_address: AztecAddress,\n    slot: Field,\n    array_len: u32,\n) -> Option<[Field; N]> {}\n\n#[oracle(utilityDeleteCapsule)]\nunconstrained fn delete_oracle(contract_address: AztecAddress, slot: Field) {}\n\n#[oracle(utilityCopyCapsule)]\nunconstrained fn copy_oracle(\n    contract_address: AztecAddress,\n    src_slot: Field,\n    dst_slot: Field,\n    num_entries: u32,\n) {}\n\nmod test {\n    // These tests are sort of redundant since we already test the oracle implementation directly in TypeScript, but\n    // they are cheap regardless and help ensure both that the TXE implementation works accordingly and that the Noir\n    // oracles are hooked up correctly.\n\n    use crate::{\n        oracle::capsules::{copy, delete, load, store},\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use protocol_types::{address::AztecAddress, traits::{FromField, ToField}};\n\n    global SLOT: Field = 1;\n\n    #[test]\n    unconstrained fn stores_and_loads() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn store_overwrites() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n\n            let new_value = MockStruct::new(7, 8);\n            store(contract_address, SLOT, new_value);\n\n            assert_eq(load(contract_address, SLOT).unwrap(), new_value);\n        });\n    }\n\n    #[test]\n    unconstrained fn loads_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_stored_value() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let value = MockStruct::new(5, 6);\n            store(contract_address, SLOT, value);\n            delete(contract_address, SLOT);\n\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn deletes_empty_slot() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            delete(contract_address, SLOT);\n            let loaded_value: Option<MockStruct> = load(contract_address, SLOT);\n            assert_eq(loaded_value, Option::none());\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_non_overlapping_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 5;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 10;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_src_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 1;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 2;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[1] and src[2] should have been overwritten since they are also dst[0] and dst[1]\n            assert_eq(load(contract_address, src).unwrap(), values[0]); // src[0] (unchanged)\n            assert_eq(load(contract_address, src + 1).unwrap(), values[0]); // dst[0]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[1]); // dst[1]\n        });\n    }\n\n    #[test]\n    unconstrained fn copies_overlapping_values_with_dst_ahead() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let src = 2;\n\n            let values = [MockStruct::new(5, 6), MockStruct::new(7, 8), MockStruct::new(9, 10)];\n            store(contract_address, src, values[0]);\n            store(contract_address, src + 1, values[1]);\n            store(contract_address, src + 2, values[2]);\n\n            let dst = 1;\n            copy(contract_address, src, dst, 3);\n\n            assert_eq(load(contract_address, dst).unwrap(), values[0]);\n            assert_eq(load(contract_address, dst + 1).unwrap(), values[1]);\n            assert_eq(load(contract_address, dst + 2).unwrap(), values[2]);\n\n            // src[0] and src[1] should have been overwritten since they are also dst[1] and dst[2]\n            assert_eq(load(contract_address, src).unwrap(), values[1]); // dst[1]\n            assert_eq(load(contract_address, src + 1).unwrap(), values[2]); // dst[2]\n            assert_eq(load(contract_address, src + 2).unwrap(), values[2]); // src[2] (unchanged)\n        });\n    }\n\n    #[test(should_fail_with = \"copy empty slot\")]\n    unconstrained fn cannot_copy_empty_values() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            copy(contract_address, SLOT, SLOT, 1);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_store_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let value = MockStruct::new(5, 6);\n            store(other_contract_address, SLOT, value);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_load_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            let _: Option<MockStruct> = load(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_delete_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            delete(other_contract_address, SLOT);\n        });\n    }\n\n    #[test(should_fail_with = \"not allowed to access\")]\n    unconstrained fn cannot_copy_other_contract() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let other_contract_address = AztecAddress::from_field(contract_address.to_field() + 1);\n\n            copy(other_contract_address, SLOT, SLOT, 0);\n        });\n    }\n}\n"
    },
    "159": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/enqueue_public_function_call.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(privateNotifyEnqueuedPublicFunctionCall)]\nunconstrained fn notify_enqueued_public_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_enqueued_public_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_enqueued_public_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_enqueued_public_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a public call has been enqueued, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_enqueued_public_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\n#[oracle(privateNotifySetPublicTeardownFunctionCall)]\nunconstrained fn notify_set_public_teardown_function_call_oracle(\n    _contract_address: AztecAddress,\n    _calldata_hash: Field,\n    _side_effect_counter: u32,\n    _is_static_call: bool,\n) {}\n\nunconstrained fn notify_set_public_teardown_function_call_wrapper(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    notify_set_public_teardown_function_call_oracle(\n        contract_address,\n        calldata_hash,\n        side_effect_counter,\n        is_static_call,\n    )\n}\n\npub fn notify_set_public_teardown_function_call(\n    contract_address: AztecAddress,\n    calldata_hash: Field,\n    side_effect_counter: u32,\n    is_static_call: bool,\n) {\n    // Safety: Notifies the simulator that a teardown call has been set, allowing it to prepare hints for the AVM to process this call.\n    unsafe {\n        notify_set_public_teardown_function_call_wrapper(\n            contract_address,\n            calldata_hash,\n            side_effect_counter,\n            is_static_call,\n        )\n    }\n}\n\npub fn notify_set_min_revertible_side_effect_counter(counter: u32) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter) };\n}\n\npub unconstrained fn notify_set_min_revertible_side_effect_counter_oracle_wrapper(counter: u32) {\n    notify_set_min_revertible_side_effect_counter_oracle(counter);\n}\n\n#[oracle(privateNotifySetMinRevertibleSideEffectCounter)]\nunconstrained fn notify_set_min_revertible_side_effect_counter_oracle(_counter: u32) {}\n"
    },
    "16": {
      "path": "std/embedded_curve_ops.nr",
      "source": "use crate::cmp::Eq;\nuse crate::hash::Hash;\nuse crate::ops::arith::{Add, Neg, Sub};\n\n/// A point on the embedded elliptic curve\n/// By definition, the base field of the embedded curve is the scalar field of the proof system curve, i.e the Noir Field.\n/// x and y denotes the Weierstrass coordinates of the point, if is_infinite is false.\npub struct EmbeddedCurvePoint {\n    pub x: Field,\n    pub y: Field,\n    pub is_infinite: bool,\n}\n\nimpl EmbeddedCurvePoint {\n    /// Elliptic curve point doubling operation\n    /// returns the doubled point of a point P, i.e P+P\n    pub fn double(self) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, self)\n    }\n\n    /// Returns the null element of the curve; 'the point at infinity'\n    pub fn point_at_infinity() -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: 0, y: 0, is_infinite: true }\n    }\n\n    /// Returns the curve's generator point.\n    pub fn generator() -> EmbeddedCurvePoint {\n        // Generator point for the grumpkin curve (y^2 = x^3 - 17)\n        EmbeddedCurvePoint {\n            x: 1,\n            y: 17631683881184975370165255887551781615748388533673675138860, // sqrt(-16)\n            is_infinite: false,\n        }\n    }\n}\n\nimpl Add for EmbeddedCurvePoint {\n    /// Adds two points P+Q, using the curve addition formula, and also handles point at infinity\n    fn add(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        embedded_curve_add(self, other)\n    }\n}\n\nimpl Sub for EmbeddedCurvePoint {\n    /// Points subtraction operation, using addition and negation\n    fn sub(self, other: EmbeddedCurvePoint) -> EmbeddedCurvePoint {\n        self + other.neg()\n    }\n}\n\nimpl Neg for EmbeddedCurvePoint {\n    /// Negates a point P, i.e returns -P, by negating the y coordinate.\n    /// If the point is at infinity, then the result is also at infinity.\n    fn neg(self) -> EmbeddedCurvePoint {\n        EmbeddedCurvePoint { x: self.x, y: -self.y, is_infinite: self.is_infinite }\n    }\n}\n\nimpl Eq for EmbeddedCurvePoint {\n    /// Checks whether two points are equal\n    fn eq(self: Self, b: EmbeddedCurvePoint) -> bool {\n        (self.is_infinite & b.is_infinite)\n            | ((self.is_infinite == b.is_infinite) & (self.x == b.x) & (self.y == b.y))\n    }\n}\n\nimpl Hash for EmbeddedCurvePoint {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        if self.is_infinite {\n            self.is_infinite.hash(state);\n        } else {\n            self.x.hash(state);\n            self.y.hash(state);\n        }\n    }\n}\n\n/// Scalar for the embedded curve represented as low and high limbs\n/// By definition, the scalar field of the embedded curve is base field of the proving system curve.\n/// It may not fit into a Field element, so it is represented with two Field elements; its low and high limbs.\npub struct EmbeddedCurveScalar {\n    pub lo: Field,\n    pub hi: Field,\n}\n\nimpl EmbeddedCurveScalar {\n    pub fn new(lo: Field, hi: Field) -> Self {\n        EmbeddedCurveScalar { lo, hi }\n    }\n\n    #[field(bn254)]\n    pub fn from_field(scalar: Field) -> EmbeddedCurveScalar {\n        let (a, b) = crate::field::bn254::decompose(scalar);\n        EmbeddedCurveScalar { lo: a, hi: b }\n    }\n\n    //Bytes to scalar: take the first (after the specified offset) 16 bytes of the input as the lo value, and the next 16 bytes as the hi value\n    #[field(bn254)]\n    pub(crate) fn from_bytes(bytes: [u8; 64], offset: u32) -> EmbeddedCurveScalar {\n        let mut v = 1;\n        let mut lo = 0 as Field;\n        let mut hi = 0 as Field;\n        for i in 0..16 {\n            lo = lo + (bytes[offset + 31 - i] as Field) * v;\n            hi = hi + (bytes[offset + 15 - i] as Field) * v;\n            v = v * 256;\n        }\n        let sig_s = crate::embedded_curve_ops::EmbeddedCurveScalar { lo, hi };\n        sig_s\n    }\n}\n\nimpl Eq for EmbeddedCurveScalar {\n    fn eq(self, other: Self) -> bool {\n        (other.hi == self.hi) & (other.lo == self.lo)\n    }\n}\n\nimpl Hash for EmbeddedCurveScalar {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: crate::hash::Hasher,\n    {\n        self.hi.hash(state);\n        self.lo.hash(state);\n    }\n}\n\n// Computes a multi scalar multiplication over the embedded curve.\n// For bn254, We have Grumpkin and Baby JubJub.\n// For bls12-381, we have JubJub and Bandersnatch.\n//\n// The embedded curve being used is decided by the\n// underlying proof system.\n// docs:start:multi_scalar_mul\npub fn multi_scalar_mul<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n) -> EmbeddedCurvePoint\n// docs:end:multi_scalar_mul\n{\n    multi_scalar_mul_array_return(points, scalars, true)[0]\n}\n\n#[foreign(multi_scalar_mul)]\npub(crate) fn multi_scalar_mul_array_return<let N: u32>(\n    points: [EmbeddedCurvePoint; N],\n    scalars: [EmbeddedCurveScalar; N],\n    predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n// docs:start:fixed_base_scalar_mul\npub fn fixed_base_scalar_mul(scalar: EmbeddedCurveScalar) -> EmbeddedCurvePoint\n// docs:end:fixed_base_scalar_mul\n{\n    multi_scalar_mul([EmbeddedCurvePoint::generator()], [scalar])\n}\n\n/// This function only assumes that the points are on the curve\n/// It handles corner cases around the infinity point causing some overhead compared to embedded_curve_add_not_nul and embedded_curve_add_unsafe\n// docs:start:embedded_curve_add\npub fn embedded_curve_add(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    // docs:end:embedded_curve_add\n    if crate::runtime::is_unconstrained() {\n        // `embedded_curve_add_unsafe` requires the inputs not to be the infinity point, so we check it here.\n        // This is because `embedded_curve_add_unsafe` uses the `embedded_curve_add` opcode.\n        // For efficiency, the backend does not check the inputs for the infinity point, but it assumes that they are not the infinity point\n        // so that it can apply the ec addition formula directly.\n        if point1.is_infinite {\n            point2\n        } else if point2.is_infinite {\n            point1\n        } else {\n            embedded_curve_add_unsafe(point1, point2)\n        }\n    } else {\n        // In a constrained context, we also need to check the inputs are not the infinity point because we also use `embedded_curve_add_unsafe`\n        // However we also need to identify the case where the two inputs are the same, because then\n        // the addition formula does not work and we need to use the doubling formula instead.\n        // In unconstrained context, we can check directly if the input values are the same when solving the opcode, so it is not an issue.\n\n        // x_coordinates_match is true if both abscissae are the same\n        let x_coordinates_match = point1.x == point2.x;\n        // y_coordinates_match is true if both ordinates are the same\n        let y_coordinates_match = point1.y == point2.y;\n        // double_predicate is true if both abscissae and ordinates are the same\n        let double_predicate = (x_coordinates_match & y_coordinates_match);\n        // If the abscissae are the same, but not the ordinates, then one point is the opposite of the other\n        let infinity_predicate = (x_coordinates_match & !y_coordinates_match);\n        let point1_1 = EmbeddedCurvePoint {\n            x: point1.x + (x_coordinates_match as Field),\n            y: point1.y,\n            is_infinite: false,\n        };\n        let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n        // point1_1 is guaranteed to have a different abscissa than point2:\n        // - if x_coordinates_match is 0, that means point1.x != point2.x, and point1_1.x = point1.x + 0\n        // - if x_coordinates_match is 1, that means point1.x = point2.x, but point1_1.x = point1.x + 1 in this case\n        // Because the abscissa is different, the addition formula is guaranteed to succeed, so we can safely use `embedded_curve_add_unsafe`\n        // Note that this computation may be garbage: if x_coordinates_match is 1, or if one of the input is the point at infinity.\n        let mut result = embedded_curve_add_unsafe(point1_1, point2_1);\n\n        // `embedded_curve_add_unsafe` is doing a doubling if the input is the same variable, because in this case it is guaranteed (at 'compile time') that the input is the same.\n        let double = embedded_curve_add_unsafe(point1, point1);\n        // `embedded_curve_add_unsafe` would not perform doubling, even if the inputs point1 and point2 are the same, because it cannot know this without adding some logic (and some constraints)\n        // However we did this logic when we computed `double_predicate`, so we set the result to 2*point1 if point1 and point2 are the same\n        result = if double_predicate { double } else { result };\n\n        // Same logic as above for unconstrained context, we set the proper result when one of the inputs is the infinity point\n        if point1.is_infinite {\n            result = point2;\n        }\n        if point2.is_infinite {\n            result = point1;\n        }\n\n        // Finally, we set the is_infinity flag of the result:\n        // Opposite points should sum into the infinity point, however, if one of them is point at infinity, their coordinates are not meaningful\n        // so we should not use the fact that the inputs are opposite in this case:\n        let mut result_is_infinity =\n            infinity_predicate & (!point1.is_infinite & !point2.is_infinite);\n        // However, if both of them are at infinity, then the result is also at infinity\n        result.is_infinite = result_is_infinity | (point1.is_infinite & point2.is_infinite);\n        result\n    }\n}\n\n#[foreign(embedded_curve_add)]\nfn embedded_curve_add_array_return(\n    _point1: EmbeddedCurvePoint,\n    _point2: EmbeddedCurvePoint,\n    _predicate: bool,\n) -> [EmbeddedCurvePoint; 1] {}\n\n/// This function assumes that:\n/// The points are on the curve, and\n/// The points don't share an x-coordinate, and\n/// Neither point is the infinity point.\n/// If it is used with correct input, the function ensures the correct non-zero result is returned.\n/// Except for points on the curve, the other assumptions are checked by the function. It will cause assertion failure if they are not respected.\npub fn embedded_curve_add_not_nul(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    assert(point1.x != point2.x);\n    assert(!point1.is_infinite);\n    assert(!point2.is_infinite);\n    // Ensure is_infinite is comptime\n    let point1_1 = EmbeddedCurvePoint { x: point1.x, y: point1.y, is_infinite: false };\n    let point2_1 = EmbeddedCurvePoint { x: point2.x, y: point2.y, is_infinite: false };\n    embedded_curve_add_unsafe(point1_1, point2_1)\n}\n\n/// Unsafe ec addition\n/// If the inputs are the same, it will perform a doubling, but only if point1 and point2 are the same variable.\n/// If they have the same value but are different variables, the result will be incorrect because in this case\n/// it assumes (but does not check) that the points' x-coordinates are not equal.\n/// It also assumes neither point is the infinity point.\npub fn embedded_curve_add_unsafe(\n    point1: EmbeddedCurvePoint,\n    point2: EmbeddedCurvePoint,\n) -> EmbeddedCurvePoint {\n    embedded_curve_add_array_return(point1, point2, true)[0]\n}\n"
    },
    "160": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution.nr",
      "source": "use dep::protocol_types::address::AztecAddress;\n\n#[oracle(utilityGetContractAddress)]\nunconstrained fn get_contract_address_oracle() -> AztecAddress {}\n\n#[oracle(utilityGetBlockNumber)]\nunconstrained fn get_block_number_oracle() -> u32 {}\n\n#[oracle(utilityGetTimestamp)]\nunconstrained fn get_timestamp_oracle() -> u64 {}\n\n#[oracle(utilityGetChainId)]\nunconstrained fn get_chain_id_oracle() -> Field {}\n\n#[oracle(utilityGetVersion)]\nunconstrained fn get_version_oracle() -> Field {}\n\npub unconstrained fn get_contract_address() -> AztecAddress {\n    get_contract_address_oracle()\n}\n\npub unconstrained fn get_block_number() -> u32 {\n    get_block_number_oracle()\n}\n\npub unconstrained fn get_timestamp() -> u64 {\n    get_timestamp_oracle()\n}\n\npub unconstrained fn get_chain_id() -> Field {\n    get_chain_id_oracle()\n}\n\npub unconstrained fn get_version() -> Field {\n    get_version_oracle()\n}\n"
    },
    "161": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/execution_cache.nr",
      "source": "/// Stores values represented as slice in execution cache to be later obtained by its hash.\npub fn store(values: [Field], hash: Field) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call. When loading the values, however, the caller must check that the values are indeed the preimage.\n    unsafe { store_in_execution_cache_oracle_wrapper(values, hash) };\n}\n\nunconstrained fn store_in_execution_cache_oracle_wrapper(values: [Field], hash: Field) {\n    store_in_execution_cache_oracle(values, hash);\n}\n\npub unconstrained fn load<let N: u32>(hash: Field) -> [Field; N] {\n    load_from_execution_cache_oracle(hash)\n}\n\n#[oracle(privateStoreInExecutionCache)]\nunconstrained fn store_in_execution_cache_oracle(_values: [Field], _hash: Field) {}\n\n#[oracle(privateLoadFromExecutionCache)]\nunconstrained fn load_from_execution_cache_oracle<let N: u32>(_hash: Field) -> [Field; N] {}\n"
    },
    "162": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_contract_instance.nr",
      "source": "use protocol_types::{\n    address::AztecAddress, contract_class_id::ContractClassId, contract_instance::ContractInstance,\n    traits::FromField,\n};\n\n// NOTE: this is for use in private only\n#[oracle(utilityGetContractInstance)]\nunconstrained fn get_contract_instance_oracle(_address: AztecAddress) -> ContractInstance {}\n\n// NOTE: this is for use in private only\nunconstrained fn get_contract_instance_internal(address: AztecAddress) -> ContractInstance {\n    get_contract_instance_oracle(address)\n}\n\n// NOTE: this is for use in private only\npub fn get_contract_instance(address: AztecAddress) -> ContractInstance {\n    // Safety: The to_address function combines all values in the instance object to produce an address,\n    // so by checking that we get the expected address we validate the entire struct.\n    let instance = unsafe { get_contract_instance_internal(address) };\n    assert_eq(instance.to_address(), address);\n\n    instance\n}\n\nstruct GetContractInstanceResult {\n    exists: bool,\n    member: Field,\n}\n\n// These oracles each return a ContractInstance member\n// plus a boolean indicating whether the instance was found.\n#[oracle(avmOpcodeGetContractInstanceDeployer)]\nunconstrained fn get_contract_instance_deployer_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceClassId)]\nunconstrained fn get_contract_instance_class_id_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n#[oracle(avmOpcodeGetContractInstanceInitializationHash)]\nunconstrained fn get_contract_instance_initialization_hash_oracle_avm(\n    _address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {}\n\nunconstrained fn get_contract_instance_deployer_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_deployer_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_class_id_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_class_id_oracle_avm(address)\n}\nunconstrained fn get_contract_instance_initialization_hash_internal_avm(\n    address: AztecAddress,\n) -> [GetContractInstanceResult; 1] {\n    get_contract_instance_initialization_hash_oracle_avm(address)\n}\n\npub fn get_contract_instance_deployer_avm(address: AztecAddress) -> Option<AztecAddress> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_deployer_internal_avm(address)[0] };\n    if exists {\n        Option::some(AztecAddress::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_class_id_avm(address: AztecAddress) -> Option<ContractClassId> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_class_id_internal_avm(address)[0] };\n    if exists {\n        Option::some(ContractClassId::from_field(member))\n    } else {\n        Option::none()\n    }\n}\npub fn get_contract_instance_initialization_hash_avm(address: AztecAddress) -> Option<Field> {\n    // Safety: AVM opcodes are constrained by the AVM itself\n    let GetContractInstanceResult { exists, member } =\n        unsafe { get_contract_instance_initialization_hash_internal_avm(address)[0] };\n    if exists {\n        Option::some(member)\n    } else {\n        Option::none()\n    }\n}\n"
    },
    "166": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/get_public_data_witness.nr",
      "source": "use dep::protocol_types::{constants::PUBLIC_DATA_TREE_HEIGHT, data::PublicDataTreeLeafPreimage};\n\npub struct PublicDataWitness {\n    pub index: Field,\n    pub leaf_preimage: PublicDataTreeLeafPreimage,\n    pub path: [Field; PUBLIC_DATA_TREE_HEIGHT],\n}\n\n#[oracle(utilityGetPublicDataWitness)]\nunconstrained fn get_public_data_witness_oracle(\n    _block_number: u32,\n    _public_data_tree_index: Field,\n) -> PublicDataWitness {}\n\npub unconstrained fn get_public_data_witness(\n    block_number: u32,\n    public_data_tree_index: Field,\n) -> PublicDataWitness {\n    get_public_data_witness_oracle(block_number, public_data_tree_index)\n}\n"
    },
    "167": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/key_validation_request.nr",
      "source": "use protocol_types::abis::validation_requests::KeyValidationRequest;\n\n#[oracle(utilityGetKeyValidationRequest)]\nunconstrained fn get_key_validation_request_oracle(\n    _pk_m_hash: Field,\n    _key_index: Field,\n) -> KeyValidationRequest {}\n\npub unconstrained fn get_key_validation_request(\n    pk_m_hash: Field,\n    key_index: Field,\n) -> KeyValidationRequest {\n    get_key_validation_request_oracle(pk_m_hash, key_index)\n}\n"
    },
    "168": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/keys.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, PartialAddress},\n    point::Point,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n};\n\n#[oracle(utilityGetPublicKeysAndPartialAddress)]\nunconstrained fn get_public_keys_and_partial_address_oracle(_address: AztecAddress) -> [Field; 13] {}\n\npub unconstrained fn get_public_keys_and_partial_address(\n    address: AztecAddress,\n) -> (PublicKeys, PartialAddress) {\n    let result = get_public_keys_and_partial_address_oracle(address);\n\n    let keys = PublicKeys {\n        npk_m: NpkM { inner: Point { x: result[0], y: result[1], is_infinite: result[2] != 0 } },\n        ivpk_m: IvpkM { inner: Point { x: result[3], y: result[4], is_infinite: result[5] != 0 } },\n        ovpk_m: OvpkM { inner: Point { x: result[6], y: result[7], is_infinite: result[8] != 0 } },\n        tpk_m: TpkM { inner: Point { x: result[9], y: result[10], is_infinite: result[11] != 0 } },\n    };\n\n    let partial_address = PartialAddress::from_field(result[12]);\n\n    (keys, partial_address)\n}\n"
    },
    "17": {
      "path": "std/field/bn254.nr",
      "source": "use crate::field::field_less_than;\nuse crate::runtime::is_unconstrained;\n\n// The low and high decomposition of the field modulus\nglobal PLO: Field = 53438638232309528389504892708671455233;\nglobal PHI: Field = 64323764613183177041862057485226039389;\n\npub(crate) global TWO_POW_128: Field = 0x100000000000000000000000000000000;\n\n// Decomposes a single field into two 16 byte fields.\nfn compute_decomposition(x: Field) -> (Field, Field) {\n    // Here's we're taking advantage of truncating 128 bit limbs from the input field\n    // and then subtracting them from the input such the field division is equivalent to integer division.\n    let low = (x as u128) as Field;\n    let high = (x - low) / TWO_POW_128;\n\n    (low, high)\n}\n\npub(crate) unconstrained fn decompose_hint(x: Field) -> (Field, Field) {\n    compute_decomposition(x)\n}\n\nunconstrained fn lte_hint(x: Field, y: Field) -> bool {\n    if x == y {\n        true\n    } else {\n        field_less_than(x, y)\n    }\n}\n\n// Assert that (alo > blo && ahi >= bhi) || (alo <= blo && ahi > bhi)\nfn assert_gt_limbs(a: (Field, Field), b: (Field, Field)) {\n    let (alo, ahi) = a;\n    let (blo, bhi) = b;\n    // Safety: borrow is enforced to be boolean due to its type.\n    // if borrow is 0, it asserts that (alo > blo && ahi >= bhi)\n    // if borrow is 1, it asserts that (alo <= blo && ahi > bhi)\n    unsafe {\n        let borrow = lte_hint(alo, blo);\n\n        let rlo = alo - blo - 1 + (borrow as Field) * TWO_POW_128;\n        let rhi = ahi - bhi - (borrow as Field);\n\n        rlo.assert_max_bit_size::<128>();\n        rhi.assert_max_bit_size::<128>();\n    }\n}\n\n/// Decompose a single field into two 16 byte fields.\npub fn decompose(x: Field) -> (Field, Field) {\n    if is_unconstrained() {\n        compute_decomposition(x)\n    } else {\n        // Safety: decomposition is properly checked below\n        unsafe {\n            // Take hints of the decomposition\n            let (xlo, xhi) = decompose_hint(x);\n\n            // Range check the limbs\n            xlo.assert_max_bit_size::<128>();\n            xhi.assert_max_bit_size::<128>();\n\n            // Check that the decomposition is correct\n            assert_eq(x, xlo + TWO_POW_128 * xhi);\n\n            // Assert that the decomposition of P is greater than the decomposition of x\n            assert_gt_limbs((PLO, PHI), (xlo, xhi));\n            (xlo, xhi)\n        }\n    }\n}\n\npub fn assert_gt(a: Field, b: Field) {\n    if is_unconstrained() {\n        assert(\n            // Safety: already unconstrained\n            unsafe { field_less_than(b, a) },\n        );\n    } else {\n        // Decompose a and b\n        let a_limbs = decompose(a);\n        let b_limbs = decompose(b);\n\n        // Assert that a_limbs is greater than b_limbs\n        assert_gt_limbs(a_limbs, b_limbs)\n    }\n}\n\npub fn assert_lt(a: Field, b: Field) {\n    assert_gt(b, a);\n}\n\npub fn gt(a: Field, b: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unsafe in unconstrained\n        unsafe {\n            field_less_than(b, a)\n        }\n    } else if a == b {\n        false\n    } else {\n        // Safety: Take a hint of the comparison and verify it\n        unsafe {\n            if field_less_than(a, b) {\n                assert_gt(b, a);\n                false\n            } else {\n                assert_gt(a, b);\n                true\n            }\n        }\n    }\n}\n\npub fn lt(a: Field, b: Field) -> bool {\n    gt(b, a)\n}\n\nmod tests {\n    // TODO: Allow imports from \"super\"\n    use crate::field::bn254::{assert_gt, decompose, gt, lte_hint, PHI, PLO, TWO_POW_128};\n\n    #[test]\n    fn check_decompose() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_decompose_unconstrained() {\n        assert_eq(decompose(TWO_POW_128), (0, 1));\n        assert_eq(decompose(TWO_POW_128 + 0x1234567890), (0x1234567890, 1));\n        assert_eq(decompose(0x1234567890), (0x1234567890, 0));\n    }\n\n    #[test]\n    unconstrained fn check_lte_hint() {\n        assert(lte_hint(0, 1));\n        assert(lte_hint(0, 0x100));\n        assert(lte_hint(0x100, TWO_POW_128 - 1));\n        assert(!lte_hint(0 - 1, 0));\n\n        assert(lte_hint(0, 0));\n        assert(lte_hint(0x100, 0x100));\n        assert(lte_hint(0 - 1, 0 - 1));\n    }\n\n    #[test]\n    fn check_assert_gt() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    unconstrained fn check_assert_gt_unconstrained() {\n        assert_gt(1, 0);\n        assert_gt(0x100, 0);\n        assert_gt((0 - 1), (0 - 2));\n        assert_gt(TWO_POW_128, 0);\n        assert_gt(0 - 1, 0);\n    }\n\n    #[test]\n    fn check_gt() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    unconstrained fn check_gt_unconstrained() {\n        assert(gt(1, 0));\n        assert(gt(0x100, 0));\n        assert(gt((0 - 1), (0 - 2)));\n        assert(gt(TWO_POW_128, 0));\n        assert(!gt(0, 0));\n        assert(!gt(0, 0x100));\n        assert(gt(0 - 1, 0 - 2));\n        assert(!gt(0 - 2, 0 - 1));\n    }\n\n    #[test]\n    fn check_plo_phi() {\n        assert_eq(PLO + PHI * TWO_POW_128, 0);\n        let p_bytes = crate::field::modulus_le_bytes();\n        let mut p_low: Field = 0;\n        let mut p_high: Field = 0;\n\n        let mut offset = 1;\n        for i in 0..16 {\n            p_low += (p_bytes[i] as Field) * offset;\n            p_high += (p_bytes[i + 16] as Field) * offset;\n            offset *= 256;\n        }\n        assert_eq(p_low, PLO);\n        assert_eq(p_high, PHI);\n    }\n}\n"
    },
    "170": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/message_processing.nr",
      "source": "use protocol_types::address::AztecAddress;\n\n/// Finds new private logs that may have been sent to all registered accounts in PXE in the current contract and makes\n/// them available for later processing in Noir by storing them in a capsule array.\npub unconstrained fn fetch_tagged_logs(pending_tagged_log_array_base_slot: Field) {\n    fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot);\n}\n\n#[oracle(utilityFetchTaggedLogs)]\nunconstrained fn fetch_tagged_logs_oracle(pending_tagged_log_array_base_slot: Field) {}\n\n// This must be a single oracle and not one for notes and one for events because the entire point is to validate\n// all notes and events in one go, minimizing node round-trips.\npub(crate) unconstrained fn validate_enqueued_notes_and_events(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {\n    validate_enqueued_notes_and_events_oracle(\n        contract_address,\n        note_validation_requests_array_base_slot,\n        event_validation_requests_array_base_slot,\n    );\n}\n\n#[oracle(utilityValidateEnqueuedNotesAndEvents)]\nunconstrained fn validate_enqueued_notes_and_events_oracle(\n    contract_address: AztecAddress,\n    note_validation_requests_array_base_slot: Field,\n    event_validation_requests_array_base_slot: Field,\n) {}\n\npub(crate) unconstrained fn bulk_retrieve_logs(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {\n    bulk_retrieve_logs_oracle(\n        contract_address,\n        log_retrieval_requests_array_base_slot,\n        log_retrieval_responses_array_base_slot,\n    );\n}\n\n#[oracle(utilityBulkRetrieveLogs)]\nunconstrained fn bulk_retrieve_logs_oracle(\n    contract_address: AztecAddress,\n    log_retrieval_requests_array_base_slot: Field,\n    log_retrieval_responses_array_base_slot: Field,\n) {}\n"
    },
    "175": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/shared_secret.nr",
      "source": "use protocol_types::{address::aztec_address::AztecAddress, point::Point};\n\n// TODO(#12656): return an app-siloed secret + document this\n#[oracle(utilityGetSharedSecret)]\nunconstrained fn get_shared_secret_oracle(address: AztecAddress, ephPk: Point) -> Point {}\n\n/// Returns an app-siloed shared secret between `address` and someone who knows the secret key behind an\n/// ephemeral public key `ephPk`. The app-siloing means that contracts cannot retrieve secrets that belong to\n/// other contracts, and therefore cannot e.g. decrypt their messages. This is an important security consideration\n/// given that both the `address` and `ephPk` are public information.\n///\n/// The shared secret `S` is computed as:\n/// `let S =  (ivsk + h) * ephPk`\n/// where `ivsk + h` is the 'preaddress' i.e. the preimage of the address, also called the address secret.\n/// TODO(#12656): app-silo this secret\npub unconstrained fn get_shared_secret(address: AztecAddress, ephPk: Point) -> Point {\n    get_shared_secret_oracle(address, ephPk)\n}\n"
    },
    "177": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/storage.nr",
      "source": "use dep::protocol_types::{address::AztecAddress, traits::{Packable, ToField}};\n\n#[oracle(utilityStorageRead)]\nunconstrained fn storage_read_oracle<let N: u32>(\n    address: Field,\n    storage_slot: Field,\n    block_number: u32,\n    length: u32,\n) -> [Field; N] {}\n\npub unconstrained fn raw_storage_read<let N: u32>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> [Field; N] {\n    storage_read_oracle(address.to_field(), storage_slot, block_number, N)\n}\n\npub unconstrained fn storage_read<T>(\n    address: AztecAddress,\n    storage_slot: Field,\n    block_number: u32,\n) -> T\nwhere\n    T: Packable,\n{\n    T::unpack(raw_storage_read(address, storage_slot, block_number))\n}\n\nmod tests {\n    use crate::oracle::storage::{raw_storage_read, storage_read};\n    use dep::protocol_types::{address::AztecAddress, traits::{FromField, Packable}};\n\n    use crate::test::mocks::mock_struct::MockStruct;\n    use std::test::OracleMock;\n\n    global address: AztecAddress = AztecAddress::from_field(29);\n    global slot: Field = 7;\n    global block_number: u32 = 17;\n\n    #[test]\n    unconstrained fn test_raw_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: [Field; 2] = raw_storage_read(address, slot, block_number);\n        assert_eq(read[0], 13);\n        assert_eq(read[1], 42);\n    }\n\n    #[test]\n    unconstrained fn test_storage_read() {\n        let written = MockStruct { a: 13, b: 42 };\n\n        let _ = OracleMock::mock(\"utilityStorageRead\").returns(written.pack());\n\n        let read: MockStruct = storage_read(address, slot, block_number);\n        assert_eq(read.a, 13);\n        assert_eq(read.b, 42);\n    }\n}\n"
    },
    "178": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/oracle/version.nr",
      "source": "/// The ORACLE_VERSION constant is used to check that the oracle interface is in sync between PXE and Aztec.nr. We need\n/// to version the oracle interface to ensure that developers get a reasonable error message if they use incompatible\n/// versions of Aztec.nr and PXE. The TypeScript counterpart is in `oracle_version.ts`.\n///\n/// @dev Whenever a contract function or Noir test is run, the `utilityAssertCompatibleOracleVersion` oracle is called and\n/// if the oracle version is incompatible an error is thrown.\npub global ORACLE_VERSION: Field = 1;\n\n/// Asserts that the version of the oracle is compatible with the version expected by the contract.\npub fn assert_compatible_oracle_version() {\n    // Safety: This oracle call returns nothing: we only call it to check Aztec.nr and Oracle interface versions are\n    // compatible. It is therefore always safe to call.\n    unsafe {\n        assert_compatible_oracle_version_wrapper();\n    }\n}\n\nunconstrained fn assert_compatible_oracle_version_wrapper() {\n    assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n}\n\n#[oracle(utilityAssertCompatibleOracleVersion)]\nunconstrained fn assert_compatible_oracle_version_oracle(version: Field) {}\n\nmod test {\n    use super::{assert_compatible_oracle_version_oracle, ORACLE_VERSION};\n\n    #[test]\n    unconstrained fn compatible_oracle_version() {\n        assert_compatible_oracle_version_oracle(ORACLE_VERSION);\n    }\n\n    #[test(should_fail_with = \"Incompatible oracle version. PXE is using version '1', but got a request for '318183437'.\")]\n    unconstrained fn incompatible_oracle_version() {\n        let arbitrary_incorrect_version = 318183437;\n        assert_compatible_oracle_version_oracle(arbitrary_incorrect_version);\n    }\n}\n"
    },
    "18": {
      "path": "std/field/mod.nr",
      "source": "pub mod bn254;\nuse crate::{runtime::is_unconstrained, static_assert};\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    /// Asserts that `self` can be represented in `bit_size` bits.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^{bit_size}`.\n    // docs:start:assert_max_bit_size\n    pub fn assert_max_bit_size<let BIT_SIZE: u32>(self) {\n        // docs:end:assert_max_bit_size\n        static_assert(\n            BIT_SIZE < modulus_num_bits() as u32,\n            \"BIT_SIZE must be less than modulus_num_bits\",\n        );\n        __assert_max_bit_size(self, BIT_SIZE);\n    }\n\n    /// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n    /// This slice will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_le_bits\n    pub fn to_le_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_le_bits\n        let bits = __to_le_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[N - 1 - i] != p[N - 1 - i]) {\n                        assert(p[N - 1 - i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n    /// This array will be zero padded should not all bits be necessary to represent `self`.\n    ///\n    /// # Failures\n    /// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n    /// be able to represent the original `Field`.\n    ///\n    /// # Safety\n    /// The bit decomposition returned is canonical and is guaranteed to not overflow the modulus.\n    // docs:start:to_be_bits\n    pub fn to_be_bits<let N: u32>(self: Self) -> [u1; N] {\n        // docs:end:to_be_bits\n        let bits = __to_be_bits(self);\n\n        if !is_unconstrained() {\n            // Ensure that the decomposition does not overflow the modulus\n            let p = modulus_be_bits();\n            assert(bits.len() <= p.len());\n            let mut ok = bits.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bits[i] != p[i]) {\n                        assert(p[i] == 1);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bits\n    }\n\n    /// Decomposes `self` into its little endian byte decomposition as a `[u8;N]` array\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_le_bytes\n    pub fn to_le_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_le_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_le_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_le_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[N - 1 - i] != p[N - 1 - i]) {\n                        assert(bytes[N - 1 - i] < p[N - 1 - i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    /// Decomposes `self` into its big endian byte decomposition as a `[u8;N]` array of length required to represent the field modulus\n    /// This array will be zero padded should not all bytes be necessary to represent `self`.\n    ///\n    /// # Failures\n    ///  The length N of the array must be big enough to contain all the bytes of the 'self',\n    ///  and no more than the number of bytes required to represent the field modulus\n    ///\n    /// # Safety\n    /// The result is ensured to be the canonical decomposition of the field element\n    // docs:start:to_be_bytes\n    pub fn to_be_bytes<let N: u32>(self: Self) -> [u8; N] {\n        // docs:end:to_be_bytes\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        // Compute the byte decomposition\n        let bytes = self.to_be_radix(256);\n\n        if !is_unconstrained() {\n            // Ensure that the byte decomposition does not overflow the modulus\n            let p = modulus_be_bytes();\n            assert(bytes.len() <= p.len());\n            let mut ok = bytes.len() != p.len();\n            for i in 0..N {\n                if !ok {\n                    if (bytes[i] != p[i]) {\n                        assert(bytes[i] < p[i]);\n                        ok = true;\n                    }\n                }\n            }\n            assert(ok);\n        }\n        bytes\n    }\n\n    fn to_le_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_le_radix(self, radix)\n    }\n\n    fn to_be_radix<let N: u32>(self: Self, radix: u32) -> [u8; N] {\n        // Brillig does not need an immediate radix\n        if !crate::runtime::is_unconstrained() {\n            static_assert(1 < radix, \"radix must be greater than 1\");\n            static_assert(radix <= 256, \"radix must be less than or equal to 256\");\n            static_assert(radix & (radix - 1) == 0, \"radix must be a power of 2\");\n        }\n        __to_be_radix(self, radix)\n    }\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b: [u1; 32] = exponent.to_le_bits();\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32 - i] as Field) * (r * self) + (1 - b[32 - i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x `elem` {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n\n    /// Convert a little endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_le_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        static_assert(\n            N <= modulus_le_bytes().len(),\n            \"N must be less than or equal to modulus_le_bytes().len()\",\n        );\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n\n    /// Convert a big endian byte array to a field element.\n    /// If the provided byte array overflows the field modulus then the Field will silently wrap around.\n    pub fn from_be_bytes<let N: u32>(bytes: [u8; N]) -> Field {\n        let mut v = 1;\n        let mut result = 0;\n\n        for i in 0..N {\n            result += (bytes[N - 1 - i] as Field) * v;\n            v = v * 256;\n        }\n        result\n    }\n}\n\n#[builtin(apply_range_constraint)]\nfn __assert_max_bit_size(value: Field, bit_size: u32) {}\n\n// `_radix` must be less than 256\n#[builtin(to_le_radix)]\nfn __to_le_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n// `_radix` must be less than 256\n#[builtin(to_be_radix)]\nfn __to_be_radix<let N: u32>(value: Field, radix: u32) -> [u8; N] {}\n\n/// Decomposes `self` into its little endian bit decomposition as a `[u1; N]` array.\n/// This slice will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_le_bits)]\nfn __to_le_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n/// Decomposes `self` into its big endian bit decomposition as a `[u1; N]` array.\n/// This array will be zero padded should not all bits be necessary to represent `self`.\n///\n/// # Failures\n/// Causes a constraint failure for `Field` values exceeding `2^N` as the resulting slice will not\n/// be able to represent the original `Field`.\n///\n/// # Safety\n/// Values of `N` equal to or greater than the number of bits necessary to represent the `Field` modulus\n/// (e.g. 254 for the BN254 field) allow for multiple bit decompositions. This is due to how the `Field` will\n/// wrap around due to overflow when verifying the decomposition.\n#[builtin(to_be_bits)]\nfn __to_be_bits<let N: u32>(value: Field) -> [u1; N] {}\n\n#[builtin(modulus_num_bits)]\npub comptime fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub comptime fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub comptime fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub comptime fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub comptime fn modulus_le_bytes() -> [u8] {}\n\n/// An unconstrained only built in to efficiently compare fields.\n#[builtin(field_less_than)]\nunconstrained fn __field_less_than(x: Field, y: Field) -> bool {}\n\npub(crate) unconstrained fn field_less_than(x: Field, y: Field) -> bool {\n    __field_less_than(x, y)\n}\n\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    if is_unconstrained() {\n        // Safety: unconstrained context\n        unsafe {\n            field_less_than(x, y)\n        }\n    } else {\n        let x_bytes: [u8; 32] = x.to_le_bytes();\n        let y_bytes: [u8; 32] = y.to_le_bytes();\n        let mut x_is_lt = false;\n        let mut done = false;\n        for i in 0..32 {\n            if (!done) {\n                let x_byte = x_bytes[32 - 1 - i] as u8;\n                let y_byte = y_bytes[32 - 1 - i] as u8;\n                let bytes_match = x_byte == y_byte;\n                if !bytes_match {\n                    x_is_lt = x_byte < y_byte;\n                    done = true;\n                }\n            }\n        }\n        x_is_lt\n    }\n}\n\nmod tests {\n    use crate::{panic::panic, runtime};\n    use super::field_less_than;\n\n    #[test]\n    // docs:start:to_be_bits_example\n    fn test_to_be_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_be_bits();\n        assert_eq(bits, [0, 0, 0, 0, 0, 0, 1, 0]);\n    }\n    // docs:end:to_be_bits_example\n\n    #[test]\n    // docs:start:to_le_bits_example\n    fn test_to_le_bits() {\n        let field = 2;\n        let bits: [u1; 8] = field.to_le_bits();\n        assert_eq(bits, [0, 1, 0, 0, 0, 0, 0, 0]);\n    }\n    // docs:end:to_le_bits_example\n\n    #[test]\n    // docs:start:to_be_bytes_example\n    fn test_to_be_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_be_bytes();\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 0, 2]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_bytes_example\n\n    #[test]\n    // docs:start:to_le_bytes_example\n    fn test_to_le_bytes() {\n        let field = 2;\n        let bytes: [u8; 8] = field.to_le_bytes();\n        assert_eq(bytes, [2, 0, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_bytes_example\n\n    #[test]\n    // docs:start:to_be_radix_example\n    fn test_to_be_radix() {\n        // 259, in base 256, big endian, is [1, 3].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_be_radix(256);\n        assert_eq(bytes, [0, 0, 0, 0, 0, 0, 1, 3]);\n        assert_eq(Field::from_be_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_be_radix_example\n\n    #[test]\n    // docs:start:to_le_radix_example\n    fn test_to_le_radix() {\n        // 259, in base 256, little endian, is [3, 1].\n        // i.e. 3 * 256^0 + 1 * 256^1\n        let field = 259;\n\n        // The radix (in this example, 256) must be a power of 2.\n        // The length of the returned byte array can be specified to be\n        // >= the amount of space needed.\n        let bytes: [u8; 8] = field.to_le_radix(256);\n        assert_eq(bytes, [3, 1, 0, 0, 0, 0, 0, 0]);\n        assert_eq(Field::from_le_bytes::<8>(bytes), field);\n    }\n    // docs:end:to_le_radix_example\n\n    #[test(should_fail_with = \"radix must be greater than 1\")]\n    fn test_to_le_radix_1() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(1);\n        } else {\n            panic(f\"radix must be greater than 1\");\n        }\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be greater than 2\n    //#[test]\n    //fn test_to_le_radix_brillig_1() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(1);\n    //        crate::println(out);\n    //        let expected = [0; 8];\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test(should_fail_with = \"radix must be a power of 2\")]\n    fn test_to_le_radix_3() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(3);\n        } else {\n            panic(f\"radix must be a power of 2\");\n        }\n    }\n\n    #[test]\n    fn test_to_le_radix_brillig_3() {\n        // this test should only fail in constrained mode\n        if runtime::is_unconstrained() {\n            let field = 1;\n            let out: [u8; 8] = field.to_le_radix(3);\n            let mut expected = [0; 8];\n            expected[0] = 1;\n            assert(out == expected, \"unexpected result\");\n        }\n    }\n\n    #[test(should_fail_with = \"radix must be less than or equal to 256\")]\n    fn test_to_le_radix_512() {\n        // this test should only fail in constrained mode\n        if !runtime::is_unconstrained() {\n            let field = 2;\n            let _: [u8; 8] = field.to_le_radix(512);\n        } else {\n            panic(f\"radix must be less than or equal to 256\")\n        }\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    unconstrained fn not_enough_limbs_brillig() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    #[test(should_fail_with = \"Field failed to decompose into specified 16 limbs\")]\n    fn not_enough_limbs() {\n        let _: [u8; 16] = 0x100000000000000000000000000000000.to_le_bytes();\n    }\n\n    // TODO: Update this test to account for the Brillig restriction that the radix must be less than 512\n    //#[test]\n    //fn test_to_le_radix_brillig_512() {\n    //    // this test should only fail in constrained mode\n    //    if runtime::is_unconstrained() {\n    //        let field = 1;\n    //        let out: [u8; 8] = field.to_le_radix(512);\n    //        let mut expected = [0; 8];\n    //        expected[0] = 1;\n    //        assert(out == expected, \"unexpected result\");\n    //    }\n    //}\n\n    #[test]\n    unconstrained fn test_field_less_than() {\n        assert(field_less_than(0, 1));\n        assert(field_less_than(0, 0x100));\n        assert(field_less_than(0x100, 0 - 1));\n        assert(!field_less_than(0 - 1, 0));\n    }\n}\n"
    },
    "19": {
      "path": "std/hash/mod.nr",
      "source": "// Exposed only for usage in `std::meta`\npub(crate) mod poseidon2;\n\nuse crate::default::Default;\nuse crate::embedded_curve_ops::{\n    EmbeddedCurvePoint, EmbeddedCurveScalar, multi_scalar_mul, multi_scalar_mul_array_return,\n};\nuse crate::meta::derive_via;\n\n#[foreign(sha256_compression)]\n// docs:start:sha256_compression\npub fn sha256_compression(input: [u32; 16], state: [u32; 8]) -> [u32; 8] {}\n// docs:end:sha256_compression\n\n#[foreign(keccakf1600)]\n// docs:start:keccakf1600\npub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {}\n// docs:end:keccakf1600\n\npub mod keccak {\n    #[deprecated(\"This function has been moved to std::hash::keccakf1600\")]\n    pub fn keccakf1600(input: [u64; 25]) -> [u64; 25] {\n        super::keccakf1600(input)\n    }\n}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n// docs:start:blake3\npub fn blake3<let N: u32>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{\n    if crate::runtime::is_unconstrained() {\n        // Temporary measure while Barretenberg is main proving system.\n        // Please open an issue if you're working on another proving system and running into problems due to this.\n        crate::static_assert(\n            N <= 1024,\n            \"Barretenberg cannot prove blake3 hashes with inputs larger than 1024 bytes\",\n        );\n    }\n    __blake3(input)\n}\n\n#[foreign(blake3)]\nfn __blake3<let N: u32>(input: [u8; N]) -> [u8; 32] {}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<let N: u32>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[inline_always]\npub fn pedersen_commitment_with_separator<let N: u32>(\n    input: [Field; N],\n    separator: u32,\n) -> EmbeddedCurvePoint {\n    let mut points = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N];\n    for i in 0..N {\n        // we use the unsafe version because the multi_scalar_mul will constrain the scalars.\n        points[i] = from_field_unsafe(input[i]);\n    }\n    let generators = derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n    multi_scalar_mul(generators, points)\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<let N: u32>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[no_predicates]\npub fn pedersen_hash_with_separator<let N: u32>(input: [Field; N], separator: u32) -> Field {\n    let mut scalars: [EmbeddedCurveScalar; N + 1] = [EmbeddedCurveScalar { lo: 0, hi: 0 }; N + 1];\n    let mut generators: [EmbeddedCurvePoint; N + 1] =\n        [EmbeddedCurvePoint::point_at_infinity(); N + 1];\n    let domain_generators: [EmbeddedCurvePoint; N] =\n        derive_generators(\"DEFAULT_DOMAIN_SEPARATOR\".as_bytes(), separator);\n\n    for i in 0..N {\n        scalars[i] = from_field_unsafe(input[i]);\n        generators[i] = domain_generators[i];\n    }\n    scalars[N] = EmbeddedCurveScalar { lo: N as Field, hi: 0 as Field };\n\n    let length_generator: [EmbeddedCurvePoint; 1] =\n        derive_generators(\"pedersen_hash_length\".as_bytes(), 0);\n    generators[N] = length_generator[0];\n    multi_scalar_mul_array_return(generators, scalars, true)[0].x\n}\n\n#[field(bn254)]\n#[inline_always]\npub fn derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {\n    crate::assert_constant(domain_separator_bytes);\n    // TODO(https://github.com/noir-lang/noir/issues/5672): Add back assert_constant on starting_index\n    __derive_generators(domain_separator_bytes, starting_index)\n}\n\n#[builtin(derive_pedersen_generators)]\n#[field(bn254)]\nfn __derive_generators<let N: u32, let M: u32>(\n    domain_separator_bytes: [u8; M],\n    starting_index: u32,\n) -> [EmbeddedCurvePoint; N] {}\n\n#[field(bn254)]\n// Same as from_field but:\n// does not assert the limbs are 128 bits\n// does not assert the decomposition does not overflow the EmbeddedCurveScalar\nfn from_field_unsafe(scalar: Field) -> EmbeddedCurveScalar {\n    // Safety: xlo and xhi decomposition is checked below\n    let (xlo, xhi) = unsafe { crate::field::bn254::decompose_hint(scalar) };\n    // Check that the decomposition is correct\n    assert_eq(scalar, xlo + crate::field::bn254::TWO_POW_128 * xhi);\n    EmbeddedCurveScalar { lo: xlo, hi: xhi }\n}\n\npub fn poseidon2_permutation<let N: u32>(input: [Field; N], state_len: u32) -> [Field; N] {\n    assert_eq(input.len(), state_len);\n    poseidon2_permutation_internal(input)\n}\n\n#[foreign(poseidon2_permutation)]\nfn poseidon2_permutation_internal<let N: u32>(input: [Field; N]) -> [Field; N] {}\n\n// Generic hashing support.\n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\n#[derive_via(derive_hash)]\npub trait Hash {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher;\n}\n\n// docs:start:derive_hash\ncomptime fn derive_hash(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::hash::Hash };\n    let signature = quote { fn hash<H>(_self: Self, _state: &mut H) where H: $crate::hash::Hasher };\n    let for_each_field = |name| quote { _self.$name.hash(_state); };\n    crate::meta::make_trait_impl(\n        s,\n        name,\n        signature,\n        for_each_field,\n        quote {},\n        |fields| fields,\n    )\n}\n// docs:end:derive_hash\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\npub trait Hasher {\n    fn finish(self) -> Field;\n\n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\npub trait BuildHasher {\n    type H: Hasher;\n\n    fn build_hasher(self) -> H;\n}\n\npub struct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    type H = H;\n\n    fn build_hasher(_self: Self) -> H {\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere\n    H: Hasher + Default,\n{\n    fn default() -> Self {\n        BuildHasherDefault {}\n    }\n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u1 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u128 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u8 as Field);\n    }\n}\n\nimpl Hash for i16 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u16 as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u32 as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as u64 as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H)\n    where\n        H: Hasher,\n    {}\n}\n\nimpl<T, let N: u32> Hash for [T; N]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T]\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B)\nwhere\n    A: Hash,\n    B: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E)\nwhere\n    A: Hash,\n    B: Hash,\n    C: Hash,\n    D: Hash,\n    E: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n\n// Some test vectors for Pedersen hash and Pedersen Commitment.\n// They have been generated using the same functions so the tests are for now useless\n// but they will be useful when we switch to Noir implementation.\n#[test]\nfn assert_pedersen() {\n    assert_eq(\n        pedersen_hash_with_separator([1], 1),\n        0x1b3f4b1a83092a13d8d1a59f7acb62aba15e7002f4440f2275edb99ebbc2305f,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1], 1),\n        EmbeddedCurvePoint {\n            x: 0x054aa86a73cb8a34525e5bbed6e43ba1198e860f5f3950268f71df4591bde402,\n            y: 0x209dcfbf2cfb57f9f6046f44d71ac6faf87254afc7407c04eb621a6287cac126,\n            is_infinite: false,\n        },\n    );\n\n    assert_eq(\n        pedersen_hash_with_separator([1, 2], 2),\n        0x26691c129448e9ace0c66d11f0a16d9014a9e8498ee78f4d69f0083168188255,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2], 2),\n        EmbeddedCurvePoint {\n            x: 0x2e2b3b191e49541fe468ec6877721d445dcaffe41728df0a0eafeb15e87b0753,\n            y: 0x2ff4482400ad3a6228be17a2af33e2bcdf41be04795f9782bd96efe7e24f8778,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3], 3),\n        0x0bc694b7a1f8d10d2d8987d07433f26bd616a2d351bc79a3c540d85b6206dbe4,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3], 3),\n        EmbeddedCurvePoint {\n            x: 0x1fee4e8cf8d2f527caa2684236b07c4b1bad7342c01b0f75e9a877a71827dc85,\n            y: 0x2f9fedb9a090697ab69bf04c8bc15f7385b3e4b68c849c1536e5ae15ff138fd1,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4], 4),\n        0xdae10fb32a8408521803905981a2b300d6a35e40e798743e9322b223a5eddc,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4], 4),\n        EmbeddedCurvePoint {\n            x: 0x07ae3e202811e1fca39c2d81eabe6f79183978e6f12be0d3b8eda095b79bdbc9,\n            y: 0x0afc6f892593db6fbba60f2da558517e279e0ae04f95758587760ba193145014,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5], 5),\n        0xfc375b062c4f4f0150f7100dfb8d9b72a6d28582dd9512390b0497cdad9c22,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5], 5),\n        EmbeddedCurvePoint {\n            x: 0x1754b12bd475a6984a1094b5109eeca9838f4f81ac89c5f0a41dbce53189bb29,\n            y: 0x2da030e3cfcdc7ddad80eaf2599df6692cae0717d4e9f7bfbee8d073d5d278f7,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6], 6),\n        0x1696ed13dc2730062a98ac9d8f9de0661bb98829c7582f699d0273b18c86a572,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6], 6),\n        EmbeddedCurvePoint {\n            x: 0x190f6c0e97ad83e1e28da22a98aae156da083c5a4100e929b77e750d3106a697,\n            y: 0x1f4b60f34ef91221a0b49756fa0705da93311a61af73d37a0c458877706616fb,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        0x128c0ff144fc66b6cb60eeac8a38e23da52992fc427b92397a7dffd71c45ede3,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7], 7),\n        EmbeddedCurvePoint {\n            x: 0x015441e9d29491b06563fac16fc76abf7a9534c715421d0de85d20dbe2965939,\n            y: 0x1d2575b0276f4e9087e6e07c2cb75aa1baafad127af4be5918ef8a2ef2fea8fc,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        0x2f960e117482044dfc99d12fece2ef6862fba9242be4846c7c9a3e854325a55c,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8], 8),\n        EmbeddedCurvePoint {\n            x: 0x1657737676968887fceb6dd516382ea13b3a2c557f509811cd86d5d1199bc443,\n            y: 0x1f39f0cb569040105fa1e2f156521e8b8e08261e635a2b210bdc94e8d6d65f77,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        0x0c96db0790602dcb166cc4699e2d306c479a76926b81c2cb2aaa92d249ec7be7,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9], 9),\n        EmbeddedCurvePoint {\n            x: 0x0a3ceae42d14914a432aa60ec7fded4af7dad7dd4acdbf2908452675ec67e06d,\n            y: 0xfc19761eaaf621ad4aec9a8b2e84a4eceffdba78f60f8b9391b0bd9345a2f2,\n            is_infinite: false,\n        },\n    );\n    assert_eq(\n        pedersen_hash_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        0x2cd37505871bc460a62ea1e63c7fe51149df5d0801302cf1cbc48beb8dff7e94,\n    );\n    assert_eq(\n        pedersen_commitment_with_separator([1, 2, 3, 4, 5, 6, 7, 8, 9, 10], 10),\n        EmbeddedCurvePoint {\n            x: 0x2fb3f8b3d41ddde007c8c3c62550f9a9380ee546fcc639ffbb3fd30c8d8de30c,\n            y: 0x300783be23c446b11a4c0fabf6c91af148937cea15fcf5fb054abf7f752ee245,\n            is_infinite: false,\n        },\n    );\n}\n"
    },
    "190": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/state_vars/public_immutable.nr",
      "source": "use crate::{\n    context::{PrivateContext, PublicContext, UtilityContext},\n    state_vars::storage::HasStorageSlot,\n    utils::with_hash::WithHash,\n};\nuse protocol_types::{\n    constants::GENERATOR_INDEX__INITIALIZATION_NULLIFIER, hash::poseidon2_hash_with_separator,\n    traits::Packable,\n};\n\n/// # PublicImmutable\n///\n/// PublicImmutable is a public state variable type for values that are set once\n/// during initialization and remain permanently unchanged.\n///\n/// You can declare a state variable of type PublicImmutable within your contract's\n/// #[storage] struct:\n///\n/// E.g.:\n/// `your_variable: PublicImmutable<T, Context>`\n///\n/// PublicImmutable stores an immutable value in public state which can be _read_\n/// from public, utility and even _private_ execution contexts.\n///\n/// The methods of PublicImmutable are:\n/// - `initialize`\n/// - `read`\n/// (see the methods' own doc comments for more info).\n///\n/// # Generic Parameters:\n///\n/// * `T` - The type of value stored (must implement Packable).\n/// * `Context` - The execution context (PublicContext, PrivateContext, or UtilityContext).\n///\n/// # Advanced\n///\n/// PublicImmutable leverages `WithHash<T>` to enable efficient private reads of\n/// public storage. The `WithHash` wrapper optimizes reads by hashing values that would\n/// be larger than a single field into a single field, then proving inclusion of only\n/// the hash in public storage.\n///\n/// This optimization is particularly valuable when T packs to multiple fields,\n/// as it maintains \"almost constant\" verification overhead regardless of the\n/// original data size.\n///\n/// ## Optimizing private reads in your contract\n/// Since reading T from public immutable storage in private contexts has \"almost\n/// constant\" constraint costs regardless of T's size, it's recommended to group\n/// multiple values into a single struct when they are to be read together. This is\n/// typically useful for configuration data set during contract initialization. E.g.:\n///\n/// ```noir\n/// use dep::aztec::protocol_types::{address::AztecAddress, traits::Packable};\n/// use std::meta::derive;\n///\n/// #[derive(Eq, Packable)]\n/// pub struct Config \\{\n///     pub address_1: AztecAddress,\n///     pub value_1: u128,\n///     pub value_2: u64,\n///     ...\n/// }\n/// ```\n///\n// docs:start:public_immutable_struct\npub struct PublicImmutable<T, Context> {\n    context: Context,\n    storage_slot: Field,\n}\n// docs:end:public_immutable_struct\n\n/// `PublicImmutable` stores both the packed value (using M fields) and its hash (1 field), requiring M + 1 total\n/// fields.\nimpl<T, Context, let M: u32> HasStorageSlot<M + 1> for PublicImmutable<T, Context>\nwhere\n    T: Packable<N = M>,\n{\n    fn get_storage_slot(self) -> Field {\n        self.storage_slot\n    }\n}\n\nimpl<T, Context> PublicImmutable<T, Context> {\n    /// Initializes a new PublicImmutable state variable.\n    ///\n    /// This function is usually automatically called within the #[storage] macro.\n    /// You typically don't need to call this directly when writing smart contracts.\n    ///\n    /// # Arguments\n    ///\n    /// * `context` - One of `PublicContext`/`PrivateContext`/`UtilityContext`. The\n    ///               Context determines which methods of this struct will be made\n    ///               available to the calling smart contract function.\n    /// * `storage_slot` - A unique identifier for this state variable within the\n    ///                    contract. Usually, the #[storage] macro will determine an\n    ///                    appropriate storage_slot automatically. A smart contract\n    ///                    dev shouldn't have to worry about this, as it's managed\n    ///                    behind the scenes.\n    ///\n    /// docs:start:public_immutable_struct_new\n    pub fn new(\n        // Note: Passing the contexts to new(...) just to have an interface compatible with a Map.\n        context: Context,\n        storage_slot: Field,\n    ) -> Self {\n        assert(storage_slot != 0, \"Storage slot 0 not allowed. Storage slots must start from 1.\");\n        PublicImmutable { context, storage_slot }\n    }\n    // docs:end:public_immutable_struct_new\n\n    pub fn compute_initialization_nullifier(self) -> Field {\n        poseidon2_hash_with_separator(\n            [self.storage_slot],\n            GENERATOR_INDEX__INITIALIZATION_NULLIFIER,\n        )\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PublicContext> {\n    /// Initializes a PublicImmutable state variable instance with a permanent value.\n    ///\n    /// This function sets the immutable value for this state variable. It can only\n    /// be called once per PublicImmutable. Subsequent calls will fail because the\n    /// initialization nullifier will already exist.\n    ///\n    /// # Arguments\n    /// * `value` - The permanent value to store in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is already initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Creates and emits an initialization nullifier to mark this storage slot\n    ///   as initialized. This prevents double-initialization.\n    /// - Wraps the value in `WithHash<T>` for efficient private reads.\n    /// - Stores the wrapped value in Aztec's public data tree.\n    ///\n    /// docs:start:public_immutable_struct_write\n    pub fn initialize(self, value: T)\n    where\n        T: Packable + Eq,\n    {\n        // We emit an initialization nullifier to indicate that the struct is initialized. This also prevents\n        // the value from being initialized again as a nullifier can be included only once.\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.push_nullifier(nullifier);\n\n        self.context.storage_write(self.storage_slot, WithHash::new(value));\n    }\n    // docs:end:public_immutable_struct_write\n\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// # Returns\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    /// # Panics\n    /// Panics if the value is not initialized.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs the following operations:\n    /// - Checks that the state variable has been initialized by verifying the\n    ///   initialization nullifier exists\n    /// - Reads the `WithHash<T>` wrapper from public storage\n    /// - Extracts and returns the original value T\n    ///\n    /// The function will panic if called on an uninitialized PublicImmutable.\n    ///\n    /// docs:start:public_immutable_struct_read\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        assert(self.is_initialized(), \"Trying to read from uninitialized PublicImmutable\");\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n    // docs:end:public_immutable_struct_read\n\n    /// Reads the value stored in this PublicImmutable without checking if the value\n    /// is initialized.\n    ///\n    /// This function bypasses the initialization check and directly reads from\n    /// storage.\n    /// If the PublicImmutable has not been initialized, this will return a\n    /// zeroed value.\n    /// However, if the variable is _known_ to be initialized, this is cheaper\n    /// to call than `read`.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The value stored in this PublicImmutable, or empty/default values if\n    ///         uninitialized.\n    ///\n    pub fn read_unsafe(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        WithHash::public_storage_read(*self.context, self.storage_slot)\n    }\n\n    fn is_initialized(self) -> bool {\n        let nullifier = self.compute_initialization_nullifier();\n        self.context.nullifier_exists(nullifier, self.context.this_address())\n    }\n}\n\nimpl<T> PublicImmutable<T, UtilityContext> {\n    /// Reads the permanent value stored in this PublicImmutable state variable.\n    ///\n    /// Notice that this function is executable only within a UtilityContext, which\n    /// is an unconstrained environment on the user's local device.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable.\n    ///\n    pub unconstrained fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::utility_public_storage_read(self.context, self.storage_slot)\n    }\n}\n\nimpl<T> PublicImmutable<T, &mut PrivateContext> {\n    /// Reads the permanent value stored in this PublicImmutable from the anchor\n    /// block.\n    ///\n    /// Private functions execute asynchronously and offchain. When a user begins\n    /// private execution, their view of the chain 'branches off' from the current\n    /// public state, since public state continues to advance while they execute\n    /// privately. Therefore, private functions read from a historical snapshot of\n    /// public state rather than the current state.\n    ///\n    /// # Returns\n    ///\n    /// * `T` - The permanent value stored in this PublicImmutable at the historical\n    ///         block referenced by the private context.\n    ///\n    /// # Advanced\n    ///\n    /// This function performs a historical read using the block header from the private\n    /// context. The `WithHash` optimization is particularly valuable here because it\n    /// reduces the number of required inclusion proofs by proving membership of\n    /// only the hash instead of the full packed value.\n    ///\n    /// The historical read mechanism:\n    /// - Uses an oracle to obtain the value from the historical block\n    /// - Proves inclusion of the value's hash in the public data tree\n    /// - Proves that the root of this public data tree is correct, relative to the\n    ///   historical block header that is being referenced by this private function.\n    /// - Verifies that the oracle-provided value matches the stored hash\n    ///\n    pub fn read(self) -> T\n    where\n        T: Packable + Eq,\n    {\n        // TODO(#15703): this fn should fail if the variable is not initialized\n        WithHash::historical_public_storage_read(\n            self.context.get_block_header(),\n            self.context.this_address(),\n            self.storage_slot,\n        )\n    }\n}\n"
    },
    "208": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/append.nr",
      "source": "/// Appends the elements of the second `BoundedVec` to the end of the first one. The resulting `BoundedVec` can have any arbitrary maximum length, but it must be\n/// large enough to fit all of the elements of both the first and second vectors.\npub fn append<T, let ALen: u32, let BLen: u32, let DstLen: u32>(\n    a: BoundedVec<T, ALen>,\n    b: BoundedVec<T, BLen>,\n) -> BoundedVec<T, DstLen> {\n    let mut dst = BoundedVec::new();\n\n    dst.extend_from_bounded_vec(a);\n    dst.extend_from_bounded_vec(b);\n\n    dst\n}\n\nmod test {\n    use super::append;\n\n    #[test]\n    unconstrained fn append_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::new();\n        let b: BoundedVec<_, 14> = BoundedVec::new();\n\n        let result: BoundedVec<Field, 5> = append(a, b);\n\n        assert_eq(result.len(), 0);\n        assert_eq(result.storage(), std::mem::zeroed());\n    }\n\n    #[test]\n    unconstrained fn append_non_empty_vecs() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let result: BoundedVec<Field, 8> = append(a, b);\n\n        assert_eq(result.len(), 6);\n        assert_eq(result.storage(), [1, 2, 3, 4, 5, 6, std::mem::zeroed(), std::mem::zeroed()]);\n    }\n\n    #[test(should_fail_with = \"out of bounds\")]\n    unconstrained fn append_non_empty_vecs_insufficient_max_len() {\n        let a: BoundedVec<_, 3> = BoundedVec::from_array([1, 2, 3]);\n        let b: BoundedVec<_, 14> = BoundedVec::from_array([4, 5, 6]);\n\n        let _: BoundedVec<Field, 5> = append(a, b);\n    }\n}\n"
    },
    "211": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subarray.nr",
      "source": "/// Returns `DstLen` elements from a source array, starting at `offset`. `DstLen` must not be larger than the number\n/// of elements past `offset`.\n///\n/// Examples:\n/// ```\n/// let foo: [Field; 2] = subarray([1, 2, 3, 4, 5], 2);\n/// assert_eq(foo, [3, 4]);\n///\n/// let bar: [Field; 5] = subarray([1, 2, 3, 4, 5], 2); // fails - we can't return 5 elements since only 3 remain\n/// ```\npub fn subarray<T, let SrcLen: u32, let DstLen: u32>(src: [T; SrcLen], offset: u32) -> [T; DstLen] {\n    assert(offset + DstLen <= SrcLen, \"DstLen too large for offset\");\n\n    let mut dst: [T; DstLen] = std::mem::zeroed();\n    for i in 0..DstLen {\n        dst[i] = src[i + offset];\n    }\n\n    dst\n}\n\nmod test {\n    use super::subarray;\n\n    #[test]\n    unconstrained fn subarray_into_empty() {\n        // In all of these cases we're setting DstLen to be 0, so we always get back an empty array.\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 2), []);\n    }\n\n    #[test]\n    unconstrained fn subarray_complete() {\n        assert_eq(subarray::<Field, _, _>([], 0), []);\n        assert_eq(subarray([1, 2, 3, 4, 5], 0), [1, 2, 3, 4, 5]);\n    }\n\n    #[test]\n    unconstrained fn subarray_different_end_sizes() {\n        // We implicitly select how many values to read in the size of the return array\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4, 5]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3, 4]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2, 3]);\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [2]);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subarray_offset_too_large() {\n        // With an offset of 1 we can only request up to 4 elements\n        let _: [_; 5] = subarray([1, 2, 3, 4, 5], 1);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subarray_bad_return_value() {\n        assert_eq(subarray([1, 2, 3, 4, 5], 1), [3, 3, 4, 5]);\n    }\n}\n"
    },
    "212": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/array/subbvec.nr",
      "source": "use crate::utils::array;\n\n/// Returns `DstMaxLen` elements from a source BoundedVec, starting at `offset`. `offset` must not be larger than the\n/// original length, and `DstLen` must not be larger than the total number of elements past `offset` (including the\n/// zeroed elements past `len()`).\n///\n/// Only elements at the beginning of the vector can be removed: it is not possible to also remove elements at the end\n/// of the vector by passing a value for `DstLen` that is smaller than `len() - offset`.\n///\n/// Examples:\n/// ```\n/// let foo = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n/// assert_eq(subbvec(foo, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n///\n/// let bar: BoundedVec<_, 1> = subbvec(foo, 2); // fails - we can't return just 1 element since 3 remain\n/// let baz: BoundedVec<_, 10> = subbvec(foo, 3); // fails - we can't return 10 elements since only 7 remain\n/// ```\npub fn subbvec<T, let SrcMaxLen: u32, let DstMaxLen: u32>(\n    bvec: BoundedVec<T, SrcMaxLen>,\n    offset: u32,\n) -> BoundedVec<T, DstMaxLen> {\n    // from_parts_unchecked does not verify that the elements past len are zeroed, but that is not an issue in our case\n    // because we're constructing the new storage array as a subarray of the original one (which should have zeroed\n    // storage past len), guaranteeing correctness. This is because `subarray` does not allow extending arrays past\n    // their original length.\n    BoundedVec::from_parts_unchecked(array::subarray(bvec.storage(), offset), bvec.len() - offset)\n}\n\nmod test {\n    use super::subbvec;\n\n    #[test]\n    unconstrained fn subbvec_empty() {\n        let bvec = BoundedVec::<Field, 0>::from_array([]);\n        assert_eq(subbvec(bvec, 0), bvec);\n    }\n\n    #[test]\n    unconstrained fn subbvec_complete() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), bvec);\n\n        let smaller_capacity = BoundedVec::<_, 5>::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 0), smaller_capacity);\n    }\n\n    #[test]\n    unconstrained fn subbvec_partial() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 8>::from_array([3, 4, 5]));\n        assert_eq(subbvec(bvec, 2), BoundedVec::<_, 3>::from_array([3, 4, 5]));\n    }\n\n    #[test]\n    unconstrained fn subbvec_into_empty() {\n        let bvec: BoundedVec<_, 10> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n        assert_eq(subbvec(bvec, 5), BoundedVec::<_, 5>::from_array([]));\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_offset_past_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n        let _: BoundedVec<_, 1> = subbvec(bvec, 6);\n    }\n\n    #[test(should_fail)]\n    unconstrained fn subbvec_insufficient_dst_len() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // We're not providing enough space to hold all of the items inside the original BoundedVec. subbvec can cause\n        // for the capacity to reduce, but not the length (other than by len - offset).\n        let _: BoundedVec<_, 1> = subbvec(bvec, 2);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_causes_enlarge() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // subbvec does not supprt capacity increases\n        let _: BoundedVec<_, 11> = subbvec(bvec, 0);\n    }\n\n    #[test(should_fail_with = \"DstLen too large for offset\")]\n    unconstrained fn subbvec_dst_len_too_large_for_offset() {\n        let bvec = BoundedVec::<_, 10>::from_array([1, 2, 3, 4, 5]);\n\n        // This effectively requests a capacity increase, since there'd be just one element plus the 5 empty slots,\n        // which is less than 7.\n        let _: BoundedVec<_, 7> = subbvec(bvec, 4);\n    }\n}\n"
    },
    "214": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/bytes_to_fields.nr",
      "source": "use std::static_assert;\n\n// These functions are used to facilitate the conversion of log ciphertext between byte and field representations.\n//\n// `bytes_to_fields` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `bytes_from_fields` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between bytes and fields when processing encrypted logs.\n\n/// Converts the input bytes into an array of fields. A Field is ~254 bits meaning that each field can store 31 whole\n/// bytes. Use `bytes_from_fields` to obtain the original bytes array.\n///\n/// The input bytes are chunked into chunks of 31 bytes. Each 31-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (31 bytes) is encoded as [1 * 256^30 + 10 * 256^29 + 3 * 256^28 + ... + 0]\n/// Note: N must be a multiple of 31 bytes\npub fn bytes_to_fields<let N: u32>(bytes: [u8; N]) -> [Field; N / 31] {\n    // Assert that N is a multiple of 31\n    static_assert(N % 31 == 0, \"N must be a multiple of 31\");\n\n    let mut fields = [0; N / 31];\n\n    // Since N is a multiple of 31, we can simply process all chunks fully\n    for i in 0..N / 31 {\n        let mut field = 0;\n        for j in 0..31 {\n            // Shift the existing value left by 8 bits and add the new byte\n            field = field * 256 + bytes[i * 31 + j] as Field;\n        }\n        fields[i] = field;\n    }\n\n    fields\n}\n\n/// Converts an input BoundedVec of fields into a BoundedVec of bytes in big-endian order. Arbitrary Field arrays\n/// are not allowed: this is assumed to be an array obtained via `bytes_to_fields`, i.e. one that actually represents\n/// bytes. To convert a Field array into bytes, use `fields_to_bytes`.\n///\n/// Each input field must contain at most 31 bytes (this is constrained to be so).\n/// Each field is converted into 31 big-endian bytes, and the resulting 31-byte chunks are concatenated\n/// back together in the order of the original fields.\npub fn bytes_from_fields<let N: u32>(fields: BoundedVec<Field, N>) -> BoundedVec<u8, N * 31> {\n    let mut bytes = BoundedVec::new();\n\n    for i in 0..fields.len() {\n        let field = fields.get(i);\n\n        // We expect that the field contains at most 31 bytes of information.\n        field.assert_max_bit_size::<248>();\n\n        // Now we can safely convert the field to 31 bytes.\n        let field_as_bytes: [u8; 31] = field.to_be_bytes();\n\n        for j in 0..31 {\n            bytes.push(field_as_bytes[j]);\n        }\n    }\n\n    bytes\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{bytes_from_fields, bytes_to_fields};\n\n    #[test]\n    unconstrained fn random_bytes_to_fields_and_back(input: [u8; 93]) {\n        let fields = bytes_to_fields(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `bytes_from_fields`\n        // function.\n        let fields_as_bounded_vec = BoundedVec::<_, 6>::from_array(fields);\n\n        let bytes_back = bytes_from_fields(fields_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(bytes_back.len(), input.len());\n        assert_eq(subarray(bytes_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"N must be a multiple of 31\")]\n    unconstrained fn bytes_to_fields_input_length_not_multiple_of_31() {\n        // Try to convert 32 bytes (not a multiple of 31) to fields\n        let _fields = bytes_to_fields([0; 32]);\n    }\n\n}\n"
    },
    "215": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/conversion/fields_to_bytes.nr",
      "source": "// These functions are used to facilitate the conversion of log plaintext represented as fields into bytes and back.\n//\n// `fields_to_bytes` uses fixed-size arrays since encryption contexts have compile-time size information.\n// `fields_from_bytes` uses BoundedVec for flexibility in unconstrained contexts where sizes are dynamic.\n//\n// Together they provide bidirectional conversion between fields and bytes.\n\n/// Converts an input array of fields into a single array of bytes. Use `fields_from_bytes` to obtain the original\n/// field array.\n/// Each field is converted to a 32-byte big-endian array.\n///\n/// For example, if you have a field array [123, 456], it will be converted to a 64-byte array:\n/// [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,123,  // First field (32 bytes)\n///  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,200]  // Second field (32 bytes)\n///\n/// Since a field is ~254 bits, you'll end up with a subtle 2-bit \"gap\" at the big end, every 32 bytes. Be careful\n/// that such a gap doesn't leak information! This could happen if you for example expected the output to be\n/// indistinguishable from random bytes.\npub fn fields_to_bytes<let N: u32>(fields: [Field; N]) -> [u8; 32 * N] {\n    let mut bytes = [0; 32 * N];\n\n    for i in 0..N {\n        let field_as_bytes: [u8; 32] = fields[i].to_be_bytes();\n\n        for j in 0..32 {\n            bytes[i * 32 + j] = field_as_bytes[j];\n        }\n    }\n\n    bytes\n}\n\n/// Converts an input BoundedVec of bytes into a BoundedVec of fields. Arbitrary byte arrays are not allowed: this\n/// is assumed to be an array obtained via `fields_to_bytes`, i.e. one that actually represents fields. To convert\n/// a byte array into Fields, use `bytes_to_fields`.\n///\n/// The input bytes are chunked into chunks of 32 bytes. Each 32-byte chunk is viewed as big-endian, and is converted\n/// into a Field.\n/// For example, [1, 10, 3, ..., 0] (32 bytes) is encoded as [1 * 256^31 + 10 * 256^30 + 3 * 256^29 + ... + 0]\n/// Note 1: N must be a multiple of 32 bytes\n/// Note 2: The max value check code was taken from std::field::to_be_bytes function.\npub fn fields_from_bytes<let N: u32>(bytes: BoundedVec<u8, N>) -> BoundedVec<Field, N / 32> {\n    // Assert that input length is a multiple of 32\n    assert(bytes.len() % 32 == 0, \"Input length must be a multiple of 32\");\n\n    let mut fields = BoundedVec::new();\n\n    let p = std::field::modulus_be_bytes();\n\n    // Since input length is a multiple of 32, we can simply process all chunks fully\n    for i in 0..bytes.len() / 32 {\n        let mut field = 0;\n\n        // Process each byte in the 32-byte chunk\n        let mut ok = false;\n\n        for j in 0..32 {\n            let next_byte = bytes.get(i * 32 + j);\n            field = field * 256 + next_byte as Field;\n\n            if !ok {\n                if next_byte != p[j] {\n                    assert(next_byte < p[j], \"Value does not fit in field\");\n                    ok = true;\n                }\n            }\n        }\n        assert(ok, \"Value does not fit in field\");\n\n        fields.push(field);\n    }\n\n    fields\n}\n\nmod tests {\n    use crate::utils::array::subarray;\n    use super::{fields_from_bytes, fields_to_bytes};\n\n    #[test]\n    unconstrained fn random_fields_to_bytes_and_back(input: [Field; 3]) {\n        // Convert to bytes\n        let bytes = fields_to_bytes(input);\n\n        // At this point in production, the log flies through the system and we get a BoundedVec on the other end.\n        // So we need to convert the field array to a BoundedVec to be able to feed it to the `fields_from_bytes`\n        // function.\n        // 113 is an arbitrary max length that is larger than the input length of 96.\n        let bytes_as_bounded_vec = BoundedVec::<_, 113>::from_array(bytes);\n\n        // Convert back to fields\n        let fields_back = fields_from_bytes(bytes_as_bounded_vec);\n\n        // Compare the original input with the round-tripped result\n        assert_eq(fields_back.len(), input.len());\n        assert_eq(subarray(fields_back.storage(), 0), input);\n    }\n\n    #[test(should_fail_with = \"Input length must be a multiple of 32\")]\n    unconstrained fn to_fields_assert() {\n        // 143 is an arbitrary max length that is larger than 33\n        let input = BoundedVec::<_, 143>::from_array([\n            1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n            25, 26, 27, 28, 29, 30, 31, 32, 33,\n        ]);\n\n        // This should fail since 33 is not a multiple of 32\n        let _fields = fields_from_bytes(input);\n    }\n\n    #[test]\n    unconstrained fn fields_from_bytes_max_value() {\n        let max_field_as_bytes: [u8; 32] = (-1).to_be_bytes();\n        let input = BoundedVec::<_, 32>::from_array(max_field_as_bytes);\n\n        let fields = fields_from_bytes(input);\n\n        // The result should be a largest value storable in a field (-1 since we are modulo-ing)\n        assert_eq(fields.get(0), -1);\n    }\n\n    // In this test we verify that overflow check works by taking the max allowed value, bumping a random byte\n    // and then feeding it to `fields_from_bytes` as input.\n    #[test(should_fail_with = \"Value does not fit in field\")]\n    unconstrained fn fields_from_bytes_overflow(random_value: u8) {\n        let index_of_byte_to_bump = random_value % 32;\n\n        // Obtain the byte representation of the maximum field value\n        let max_field_value_as_bytes: [u8; 32] = (-1).to_be_bytes();\n\n        let byte_to_bump = max_field_value_as_bytes[index_of_byte_to_bump as u32];\n\n        // Skip test execution if the selected byte is already at maximum value (255).\n        // This is acceptable since we are using fuzz testing to generate many test cases.\n        if byte_to_bump != 255 {\n            let mut input = BoundedVec::<_, 32>::from_array(max_field_value_as_bytes);\n\n            // Increment the selected byte to exceed the field's maximum value\n            input.set(index_of_byte_to_bump as u32, byte_to_bump + 1);\n\n            // Attempt the conversion, which should fail due to the value exceeding the field's capacity\n            let _fields = fields_from_bytes(input);\n        }\n    }\n\n}\n"
    },
    "217": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/field.nr",
      "source": "use std::option::Option;\n\nglobal KNOWN_NON_RESIDUE: Field = 5; // This is a non-residue in Noir's native Field.\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\n// Power function of two Field arguments of arbitrary size.\n// Adapted from std::field::pow_32.\npub fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Boolean indicating whether Field element is a square, i.e. whether there exists a y in Field s.t. x = y*y.\nunconstrained fn is_square(x: Field) -> bool {\n    let v = pow(x, -1 / 2);\n    v * (v - 1) == 0\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\nunconstrained fn tonelli_shanks_sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n// NB: this doesn't return an option, because in the case of there _not_ being a square root, we still want to return a field element that allows us to then assert in the _constrained_ sqrt function that there is no sqrt.\npub unconstrained fn __sqrt(x: Field) -> (bool, Field) {\n    let is_sq = is_square(x);\n    if is_sq {\n        let sqrt = tonelli_shanks_sqrt(x);\n        (true, sqrt)\n    } else {\n        // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n        // Facts:\n        // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n        // - If x is a square, LS(x) = 1\n        // - If x is not a square, LS(x) = -1\n        // - If x = 0, LS(x) = 0.\n        //\n        // Hence:\n        // sq * sq = sq // 1 * 1 = 1\n        // non-sq * non-sq = sq // -1 * -1 = 1\n        // sq * non-sq = non-sq // -1 * 1 = -1\n        //\n        // See: https://en.wikipedia.org/wiki/Legendre_symbol\n        let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n        let not_sqrt = tonelli_shanks_sqrt(demo_x_not_square);\n        (false, not_sqrt)\n    }\n}\n\n// Returns (false, 0) if there is no square root.\n// Returns (true, sqrt) if there is a square root.\npub fn sqrt(x: Field) -> Option<Field> {\n    // Safety: if the hint returns the square root of x, then we simply square it\n    // check the result equals x. If x is not square, we return a value that\n    // enables us to prove that fact (see the `else` clause below).\n    let (is_sq, maybe_sqrt) = unsafe { __sqrt(x) };\n\n    if is_sq {\n        let sqrt = maybe_sqrt;\n        validate_sqrt_hint(x, sqrt);\n        Option::some(sqrt)\n    } else {\n        let not_sqrt_hint = maybe_sqrt;\n        validate_not_sqrt_hint(x, not_sqrt_hint);\n        Option::none()\n    }\n}\n\nfn validate_sqrt_hint(x: Field, hint: Field) {\n    assert(hint * hint == x, f\"The claimed_sqrt {hint} is not the sqrt of x {x}\");\n}\n\nfn validate_not_sqrt_hint(x: Field, hint: Field) {\n    // We need this assertion, because x = 0 would pass the other assertions in this\n    // function, and we don't want people to be able to prove that 0 is not square!\n    assert(x != 0, \"0 has a square root; you cannot claim it is not square\");\n    // Demonstrate that x is not a square (a.k.a. a \"quadratic non-residue\").\n    //\n    // Facts:\n    // The Legendre symbol (\"LS\") of x, is x^((p-1)/2) (mod p).\n    // - If x is a square, LS(x) = 1\n    // - If x is not a square, LS(x) = -1\n    // - If x = 0, LS(x) = 0.\n    //\n    // Hence:\n    // 1. sq * sq = sq // 1 * 1 = 1\n    // 2. non-sq * non-sq = sq // -1 * -1 = 1\n    // 3. sq * non-sq = non-sq // -1 * 1 = -1\n    //\n    // See: https://en.wikipedia.org/wiki/Legendre_symbol\n    //\n    // We want to demonstrate that this below multiplication falls under bullet-point (2):\n    let demo_x_not_square = x * KNOWN_NON_RESIDUE;\n    // I.e. we want to demonstrate that `demo_x_not_square` has Legendre symbol 1\n    // (i.e. that it is a square), so we prove that it is square below.\n    // Why do we want to prove that it has LS 1?\n    // Well, since it was computed with a known-non-residue, its squareness implies we're\n    // in case 2 (something multiplied by a known-non-residue yielding a result which\n    // has a LS of 1), which implies that x must be a non-square. The unconstrained\n    // function gave us the sqrt of demo_x_not_square, so all we need to do is\n    // assert its squareness:\n    assert(\n        hint * hint == demo_x_not_square,\n        f\"The hint {hint} does not demonstrate that {x} is not a square\",\n    );\n}\n\n#[test]\nfn test_sqrt() {\n    let x = 9;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_some());\n    let sqrt = maybe_sqrt.unwrap_unchecked();\n    assert((sqrt == 3) | (sqrt == -3));\n}\n\n#[test]\nfn test_non_square() {\n    let x = 5;\n    let maybe_sqrt = sqrt(x);\n    assert(maybe_sqrt.is_none());\n}\n\n#[test]\nunconstrained fn test_known_non_residue_is_actually_a_non_residue_in_the_field() {\n    assert(!is_square(KNOWN_NON_RESIDUE));\n}\n\n#[test]\nfn test_sqrt_0() {\n    let x = 0;\n    let sqrt = sqrt(x).unwrap();\n    assert(sqrt == 0);\n}\n\n#[test]\nfn test_sqrt_1() {\n    let x = 1;\n    let sqrt = sqrt(x).unwrap();\n    assert((sqrt == 1) | (sqrt == -1));\n}\n\n#[test(should_fail_with = \"The claimed_sqrt 0x04 is not the sqrt of x 0x09\")]\nfn test_bad_sqrt_hint_fails() {\n    validate_sqrt_hint(9, 4);\n}\n\n#[test(should_fail_with = \"The hint 0x04 does not demonstrate that 0x0a is not a square\")]\nfn test_bad_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(10, 4);\n}\n\n#[test(should_fail_with = \"0 has a square root; you cannot claim it is not square\")]\nfn test_0_not_sqrt_hint_fails() {\n    validate_not_sqrt_hint(0, 0);\n}\n\n#[test]\nunconstrained fn test_is_square() {\n    assert(is_square(25));\n}\n\n#[test]\nunconstrained fn test_is_not_square() {\n    assert(!is_square(10));\n}\n"
    },
    "219": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/point.nr",
      "source": "use crate::utils::field::sqrt;\nuse dep::protocol_types::point::Point;\n\n// I am storing the modulus minus 1 divided by 2 here because full modulus would throw \"String literal too large\" error\n// Full modulus is 21888242871839275222246405745257275088548364400416034343698204186575808495617\nglobal BN254_FR_MODULUS_DIV_2: Field =\n    10944121435919637611123202872628637544274182200208017171849102093287904247808;\n\n/// Converts a point to a byte array.\n///\n/// We don't serialize the point at infinity flag because this function is used in situations where we do not want\n/// to waste the extra byte (encrypted log).\npub fn point_to_bytes(p: Point) -> [u8; 32] {\n    // Note that there is 1 more free bit in the 32 bytes (254 bits currently occupied by the x coordinate, 1 bit for\n    // the \"sign\") so it's possible to use that last bit as an \"is_infinite\" flag if desired in the future.\n    assert(!p.is_infinite, \"Cannot serialize point at infinity as bytes.\");\n\n    let mut result: [u8; 32] = p.x.to_be_bytes();\n\n    if get_sign_of_point(p) {\n        // y is <= (modulus - 1) / 2 so we set the sign bit to 1\n        // Here we leverage that field fits into 254 bits (log2(Fr.MODULUS) < 254) and given that we serialize Fr to 32\n        // bytes and we use big-endian the 2 most significant bits are never populated. Hence we can use one of\n        // the bits as a sign bit.\n        result[0] += 128;\n    }\n\n    result\n}\n\n/**\n * Returns: true if p.y <= MOD_DIV_2, else false.\n */\npub fn get_sign_of_point(p: Point) -> bool {\n    // We store only a \"sign\" of the y coordinate because the rest can be derived from the x coordinate. To get\n    // the sign we check if the y coordinate is less or equal than the curve's order minus 1 divided by 2.\n    // Ideally we'd do `y <= MOD_DIV_2`, but there's no `lte` function, so instead we do `!(y > MOD_DIV_2)`, which is\n    // equivalent, and then rewrite that as `!(MOD_DIV_2 < y)`, since we also have no `gt` function.\n    !BN254_FR_MODULUS_DIV_2.lt(p.y)\n}\n\npub fn point_from_x_coord(x: Field) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n    Point { x, y, is_infinite: false }\n}\n\n/// Uses the x coordinate and sign flag (+/-) to reconstruct the point.\n/// The y coordinate can be derived from the x coordinate and the \"sign\" flag by solving the grumpkin curve\n/// equation for y.\n/// @param x - The x coordinate of the point\n/// @param sign - The \"sign\" of the y coordinate - determines whether y <= (Fr.MODULUS - 1) / 2\npub fn point_from_x_coord_and_sign(x: Field, sign: bool) -> Point {\n    // y ^ 2 = x ^ 3 - 17\n    let rhs = x * x * x - 17;\n    let y = sqrt(rhs).unwrap();\n\n    // If y > MOD_DIV_2 and we want positive sign (or vice versa), negate y\n    let y_is_positive = !BN254_FR_MODULUS_DIV_2.lt(y);\n    let final_y = if y_is_positive == sign { y } else { -y };\n\n    Point { x, y: final_y, is_infinite: false }\n}\n\nmod test {\n    use crate::utils::point::{point_from_x_coord_and_sign, point_to_bytes};\n    use dep::protocol_types::point::Point;\n\n    #[test]\n    unconstrained fn test_point_to_bytes_positive_sign() {\n        let p = Point {\n            x: 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73,\n            y: 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_positive_sign = [\n            154, 244, 31, 93, 233, 100, 70, 220, 55, 118, 161, 235, 45, 152, 187, 149, 107, 122,\n            205, 153, 121, 166, 120, 84, 190, 198, 250, 124, 41, 115, 189, 115,\n        ];\n        assert_eq(expected_compressed_point_positive_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_to_bytes_negative_sign() {\n        let p = Point {\n            x: 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5,\n            y: 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0,\n            is_infinite: false,\n        };\n\n        let compressed_point = point_to_bytes(p);\n\n        let expected_compressed_point_negative_sign = [\n            36, 115, 113, 101, 46, 85, 221, 116, 201, 175, 141, 190, 159, 180, 73, 49, 186, 41, 169,\n            34, 153, 148, 56, 75, 215, 7, 119, 150, 193, 78, 226, 181,\n        ];\n\n        assert_eq(expected_compressed_point_negative_sign, compressed_point);\n    }\n\n    #[test]\n    unconstrained fn test_point_from_x_coord_and_sign() {\n        // Test positive y coordinate\n        let x = 0x1af41f5de96446dc3776a1eb2d98bb956b7acd9979a67854bec6fa7c2973bd73;\n        let sign = true;\n        let p = point_from_x_coord_and_sign(x, sign);\n\n        assert_eq(p.x, x);\n        assert_eq(p.y, 0x07fc22c7f2c7057571f137fe46ea9c95114282bc95d37d71ec4bfb88de457d4a);\n        assert_eq(p.is_infinite, false);\n\n        // Test negative y coordinate\n        let x2 = 0x247371652e55dd74c9af8dbe9fb44931ba29a9229994384bd7077796c14ee2b5;\n        let sign2 = false;\n        let p2 = point_from_x_coord_and_sign(x2, sign2);\n\n        assert_eq(p2.x, x2);\n        assert_eq(p2.y, 0x26441aec112e1ae4cee374f42556932001507ad46e255ffb27369c7e3766e5c0);\n        assert_eq(p2.is_infinite, false);\n    }\n}\n"
    },
    "224": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/utils/with_hash.nr",
      "source": "use crate::{\n    context::{PublicContext, UtilityContext},\n    history::public_storage::PublicStorageHistoricalRead,\n    oracle,\n};\nuse dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress, hash::poseidon2_hash, traits::Packable,\n};\n\n/// A struct that allows for efficient reading of value `T` from public storage in private.\n///\n/// The efficient reads are achieved by verifying large values through a single hash check\n/// and then proving inclusion only of the hash in public storage. This reduces the number\n/// of required tree inclusion proofs from `M` to 1.\n///\n/// # Type Parameters\n/// - `T`: The underlying type being wrapped, must implement `Packable<N>`\n/// - `M`: The number of field elements required to pack values of type `T`\npub struct WithHash<T, let M: u32> {\n    value: T,\n    packed: [Field; M],\n    hash: Field,\n}\n\nimpl<T, let M: u32> WithHash<T, M>\nwhere\n    T: Packable<N = M> + Eq,\n{\n    pub fn new(value: T) -> Self {\n        let packed = value.pack();\n        Self { value, packed, hash: poseidon2_hash(packed) }\n    }\n\n    pub fn get_value(self) -> T {\n        self.value\n    }\n\n    pub fn get_hash(self) -> Field {\n        self.hash\n    }\n\n    pub fn public_storage_read(context: PublicContext, storage_slot: Field) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub unconstrained fn utility_public_storage_read(\n        context: UtilityContext,\n        storage_slot: Field,\n    ) -> T {\n        context.storage_read(storage_slot)\n    }\n\n    pub fn historical_public_storage_read(\n        header: BlockHeader,\n        address: AztecAddress,\n        storage_slot: Field,\n    ) -> T {\n        let historical_block_number = header.global_variables.block_number;\n\n        // We could simply produce historical inclusion proofs for each field in `packed`, but that would require one\n        // full sibling path per storage slot (since due to kernel siloing the storage is not contiguous). Instead, we\n        // get an oracle to provide us the values, and instead we prove inclusion of their hash, which is both a much\n        // smaller proof (a single slot), and also independent of the size of T (except in that we need to pack and hash T).\n        let hint = WithHash::new(\n            // Safety: We verify that a hash of the hint/packed data matches the stored hash.\n            unsafe {\n                oracle::storage::storage_read(address, storage_slot, historical_block_number)\n            },\n        );\n\n        let hash = header.public_storage_historical_read(storage_slot + M as Field, address);\n\n        if hash != 0 {\n            assert_eq(hash, hint.get_hash(), \"Hint values do not match hash\");\n        } else {\n            // The hash slot can only hold a zero if it is uninitialized. Therefore, the hints must then be zero\n            // (i.e. the default value for public storage) as well.\n            assert_eq(\n                hint.get_value(),\n                T::unpack(std::mem::zeroed()),\n                \"Non-zero hint for zero hash\",\n            );\n        };\n\n        hint.get_value()\n    }\n}\n\n// Note: I don't derive Packable on `WithHash` because `derive_serialize` function does not support setting \"N = M\"\n// as I do here 3 lines below. This could be worked around by placing the \"where\" clause directly on the `WithHash`\n// struct, but Jake mentioned that the syntax is not expected to be supported at least until Noir 1.0.\n// Relevant discussion on Slack:\n// https://aztecprotocol.slack.com/archives/C04QF64EDNV/p1752593876160699?thread_ts=1752589887.955379&cid=C04QF64EDNV\nimpl<T, let M: u32> Packable for WithHash<T, M>\nwhere\n    T: Packable<N = M>,\n{\n    let N: u32 = M + 1;\n\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            result[i] = self.packed[i];\n        }\n        result[M] = self.hash;\n\n        result\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        let mut value_packed = [0; M];\n        for i in 0..M {\n            value_packed[i] = packed[i];\n        }\n        let hash = packed[M];\n\n        Self { value: T::unpack(value_packed), packed: value_packed, hash }\n    }\n}\n\nmod test {\n    use crate::{\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n        utils::with_hash::WithHash,\n    };\n    use dep::protocol_types::hash::poseidon2_hash;\n    use dep::protocol_types::traits::{Packable, ToField};\n    use dep::std::test::OracleMock;\n\n    global STORAGE_SLOT: Field = 47;\n\n    #[test]\n    unconstrained fn create_and_recover() {\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n        let recovered = WithHash::unpack(value_with_hash.pack());\n\n        assert_eq(recovered.value, value);\n        assert_eq(recovered.packed, value.pack());\n        assert_eq(recovered.hash, poseidon2_hash(value.pack()));\n    }\n\n    #[test]\n    unconstrained fn read_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n\n            assert_eq(result, std::mem::zeroed());\n        });\n    }\n\n    #[test]\n    unconstrained fn read_initialized_value() {\n        let env = TestEnvironment::new();\n\n        let value = MockStruct { a: 5, b: 3 };\n        let value_with_hash = WithHash::new(value);\n\n        env.public_context(|context| { context.storage_write(STORAGE_SLOT, value_with_hash); });\n\n        env.private_context(|context| {\n            let result = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n            assert_eq(result, value);\n        });\n    }\n\n    #[test(should_fail_with = \"Non-zero hint for zero hash\")]\n    unconstrained fn bad_hint_uninitialized_value() {\n        let env = TestEnvironment::new();\n\n        env.private_context(|context| {\n            let block_header = context.historical_header;\n            let address = context.this_address();\n\n            // Mock the oracle to return a non-zero hint/packed value\n            let value_packed = MockStruct { a: 1, b: 1 }.pack();\n            let _ = OracleMock::mock(\"utilityStorageRead\")\n                .with_params((\n                    address.to_field(), STORAGE_SLOT, block_header.global_variables.block_number,\n                    value_packed.len(),\n                ))\n                .returns(value_packed)\n                .times(1);\n\n            // This should fail because the hint value is non-zero and the hash is zero (default value of storage)\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                block_header,\n                address,\n                STORAGE_SLOT,\n            );\n        });\n    }\n\n    #[test(should_fail_with = \"Hint values do not match hash\")]\n    unconstrained fn bad_hint_initialized_value() {\n        let env = TestEnvironment::new();\n\n        env.public_context(|context| {\n            // Write the value and hash separately so that the hash is wrong\n            let value = MockStruct { a: 5, b: 3 };\n            context.storage_write(STORAGE_SLOT, value);\n\n            let incorrect_hash = 13;\n            let hash_storage_slot = STORAGE_SLOT + (value.pack().len() as Field);\n            context.storage_write(hash_storage_slot, [incorrect_hash]);\n        });\n\n        env.private_context(|context| {\n            let _ = WithHash::<MockStruct, _>::historical_public_storage_read(\n                context.historical_header,\n                context.this_address(),\n                STORAGE_SLOT,\n            );\n        });\n    }\n}\n"
    },
    "231": {
      "path": "/home/aztec-dev/nargo/github.com/noir-lang/poseidon/v0.1.1/src/poseidon2.nr",
      "source": "use std::default::Default;\nuse std::hash::Hasher;\n\ncomptime global RATE: u32 = 3;\n\npub struct Poseidon2 {\n    cache: [Field; 3],\n    state: [Field; 4],\n    cache_size: u32,\n    squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2 {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2 {\n        let mut result =\n            Poseidon2 { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = crate::poseidon2_permutation(self.state, 4);\n    }\n\n    fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let two_pow_64 = 18446744073709551616;\n        let iv: Field = (in_len as Field) * two_pow_64;\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n\npub struct Poseidon2Hasher {\n    _state: [Field],\n}\n\nimpl Hasher for Poseidon2Hasher {\n    fn finish(self) -> Field {\n        let iv: Field = (self._state.len() as Field) * 18446744073709551616; // iv = (self._state.len() << 64)\n        let mut sponge = Poseidon2::new(iv);\n        for i in 0..self._state.len() {\n            sponge.absorb(self._state[i]);\n        }\n        sponge.squeeze()\n    }\n\n    fn write(&mut self, input: Field) {\n        self._state = self._state.push_back(input);\n    }\n}\n\nimpl Default for Poseidon2Hasher {\n    fn default() -> Self {\n        Poseidon2Hasher { _state: &[] }\n    }\n}\n"
    },
    "25": {
      "path": "std/meta/expr.nr",
      "source": "//! Contains methods on the built-in `Expr` type for quoted, syntactically valid expressions.\n\nuse crate::meta::op::BinaryOp;\nuse crate::meta::op::UnaryOp;\nuse crate::option::Option;\n\nimpl Expr {\n    /// If this expression is an array literal `[elem1, ..., elemN]`, this returns a slice of each element in the array.\n    #[builtin(expr_as_array)]\n    // docs:start:as_array\n    pub comptime fn as_array(self) -> Option<[Expr]> {}\n    // docs:end:as_array\n\n    /// If this expression is an assert, this returns the assert expression and the optional message.\n    #[builtin(expr_as_assert)]\n    // docs:start:as_assert\n    pub comptime fn as_assert(self) -> Option<(Expr, Option<Expr>)> {}\n    // docs:end:as_assert\n\n    /// If this expression is an assert_eq, this returns the left-hand-side and right-hand-side\n    /// expressions, together with the optional message.\n    #[builtin(expr_as_assert_eq)]\n    // docs:start:as_assert_eq\n    pub comptime fn as_assert_eq(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_assert_eq\n\n    /// If this expression is an assignment, this returns a tuple with the left hand side\n    /// and right hand side in order.\n    #[builtin(expr_as_assign)]\n    // docs:start:as_assign\n    pub comptime fn as_assign(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_assign\n\n    /// If this expression is a binary operator operation `<lhs> <op> <rhs>`,\n    /// return the left-hand side, operator, and the right-hand side of the operation.\n    #[builtin(expr_as_binary_op)]\n    // docs:start:as_binary_op\n    pub comptime fn as_binary_op(self) -> Option<(Expr, BinaryOp, Expr)> {}\n    // docs:end:as_binary_op\n\n    /// If this expression is a block `{ stmt1; stmt2; ...; stmtN }`, return\n    /// a slice containing each statement.\n    #[builtin(expr_as_block)]\n    // docs:start:as_block\n    pub comptime fn as_block(self) -> Option<[Expr]> {}\n    // docs:end:as_block\n\n    /// If this expression is a boolean literal, return that literal.\n    #[builtin(expr_as_bool)]\n    // docs:start:as_bool\n    pub comptime fn as_bool(self) -> Option<bool> {}\n    // docs:end:as_bool\n\n    /// If this expression is a cast expression `expr as type`, returns the casted\n    /// expression and the type to cast to.\n    // docs:start:as_cast\n    #[builtin(expr_as_cast)]\n    pub comptime fn as_cast(self) -> Option<(Expr, UnresolvedType)> {}\n    // docs:end:as_cast\n\n    /// If this expression is a `comptime { stmt1; stmt2; ...; stmtN }` block,\n    /// return each statement in the block.\n    #[builtin(expr_as_comptime)]\n    // docs:start:as_comptime\n    pub comptime fn as_comptime(self) -> Option<[Expr]> {}\n    // docs:end:as_comptime\n\n    /// If this expression is a constructor `Type { field1: expr1, ..., fieldN: exprN }`,\n    /// return the type and the fields.\n    #[builtin(expr_as_constructor)]\n    // docs:start:as_constructor\n    pub comptime fn as_constructor(self) -> Option<(UnresolvedType, [(Quoted, Expr)])> {}\n    // docs:end:as_constructor\n\n    /// If this expression is a for statement over a single expression, return the identifier,\n    /// the expression and the for loop body.\n    #[builtin(expr_as_for)]\n    // docs:start:as_for\n    pub comptime fn as_for(self) -> Option<(Quoted, Expr, Expr)> {}\n    // docs:end:as_for\n\n    /// If this expression is a for statement over a range, return the identifier,\n    /// the range start, the range end and the for loop body.\n    #[builtin(expr_as_for_range)]\n    // docs:start:as_for_range\n    pub comptime fn as_for_range(self) -> Option<(Quoted, Expr, Expr, Expr)> {}\n    // docs:end:as_for_range\n\n    /// If this expression is a function call `foo(arg1, ..., argN)`, return\n    /// the function and a slice of each argument.\n    #[builtin(expr_as_function_call)]\n    // docs:start:as_function_call\n    pub comptime fn as_function_call(self) -> Option<(Expr, [Expr])> {}\n    // docs:end:as_function_call\n\n    /// If this expression is an `if condition { then_branch } else { else_branch }`,\n    /// return the condition, then branch, and else branch. If there is no else branch,\n    /// `None` is returned for that branch instead.\n    #[builtin(expr_as_if)]\n    // docs:start:as_if\n    pub comptime fn as_if(self) -> Option<(Expr, Expr, Option<Expr>)> {}\n    // docs:end:as_if\n\n    /// If this expression is an index into an array `array[index]`, return the\n    /// array and the index.\n    #[builtin(expr_as_index)]\n    // docs:start:as_index\n    pub comptime fn as_index(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_index\n\n    /// If this expression is an integer literal, return the integer as a field\n    /// as well as whether the integer is negative (true) or not (false).\n    #[builtin(expr_as_integer)]\n    // docs:start:as_integer\n    pub comptime fn as_integer(self) -> Option<(Field, bool)> {}\n    // docs:end:as_integer\n\n    /// If this expression is a lambda, returns the parameters, return type and body.\n    #[builtin(expr_as_lambda)]\n    // docs:start:as_lambda\n    pub comptime fn as_lambda(\n        self,\n    ) -> Option<([(Expr, Option<UnresolvedType>)], Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_lambda\n\n    /// If this expression is a let statement, returns the let pattern as an `Expr`,\n    /// the optional type annotation, and the assigned expression.\n    #[builtin(expr_as_let)]\n    // docs:start:as_let\n    pub comptime fn as_let(self) -> Option<(Expr, Option<UnresolvedType>, Expr)> {}\n    // docs:end:as_let\n\n    /// If this expression is a member access `foo.bar`, return the struct/tuple\n    /// expression and the field. The field will be represented as a quoted value.\n    #[builtin(expr_as_member_access)]\n    // docs:start:as_member_access\n    pub comptime fn as_member_access(self) -> Option<(Expr, Quoted)> {}\n    // docs:end:as_member_access\n\n    /// If this expression is a method call `foo.bar::<generic1, ..., genericM>(arg1, ..., argN)`, return\n    /// the receiver, method name, a slice of each generic argument, and a slice of each argument.\n    #[builtin(expr_as_method_call)]\n    // docs:start:as_method_call\n    pub comptime fn as_method_call(self) -> Option<(Expr, Quoted, [UnresolvedType], [Expr])> {}\n    // docs:end:as_method_call\n\n    /// If this expression is a repeated element array `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_array)]\n    // docs:start:as_repeated_element_array\n    pub comptime fn as_repeated_element_array(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_array\n\n    /// If this expression is a repeated element slice `[elem; length]`, return\n    /// the repeated element and the length expressions.\n    #[builtin(expr_as_repeated_element_slice)]\n    // docs:start:as_repeated_element_slice\n    pub comptime fn as_repeated_element_slice(self) -> Option<(Expr, Expr)> {}\n    // docs:end:as_repeated_element_slice\n\n    /// If this expression is a slice literal `&[elem1, ..., elemN]`,\n    /// return each element of the slice.\n    #[builtin(expr_as_slice)]\n    // docs:start:as_slice\n    pub comptime fn as_slice(self) -> Option<[Expr]> {}\n    // docs:end:as_slice\n\n    /// If this expression is a tuple `(field1, ..., fieldN)`,\n    /// return each element of the tuple.\n    #[builtin(expr_as_tuple)]\n    // docs:start:as_tuple\n    pub comptime fn as_tuple(self) -> Option<[Expr]> {}\n    // docs:end:as_tuple\n\n    /// If this expression is a unary operation `<op> <rhs>`,\n    /// return the unary operator as well as the right-hand side expression.\n    #[builtin(expr_as_unary_op)]\n    // docs:start:as_unary_op\n    pub comptime fn as_unary_op(self) -> Option<(UnaryOp, Expr)> {}\n    // docs:end:as_unary_op\n\n    /// If this expression is an `unsafe { stmt1; ...; stmtN }` block,\n    /// return each statement inside in a slice.\n    #[builtin(expr_as_unsafe)]\n    // docs:start:as_unsafe\n    pub comptime fn as_unsafe(self) -> Option<[Expr]> {}\n    // docs:end:as_unsafe\n\n    /// Returns `true` if this expression is trailed by a semicolon.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// comptime {\n    ///     let expr1 = quote { 1 + 2 }.as_expr().unwrap();\n    ///     let expr2 = quote { 1 + 2; }.as_expr().unwrap();\n    ///\n    ///     assert(expr1.as_binary_op().is_some());\n    ///     assert(expr2.as_binary_op().is_some());\n    ///\n    ///     assert(!expr1.has_semicolon());\n    ///     assert(expr2.has_semicolon());\n    /// }\n    /// ```\n    #[builtin(expr_has_semicolon)]\n    // docs:start:has_semicolon\n    pub comptime fn has_semicolon(self) -> bool {}\n    // docs:end:has_semicolon\n\n    /// Returns `true` if this expression is `break`.\n    #[builtin(expr_is_break)]\n    // docs:start:is_break\n    pub comptime fn is_break(self) -> bool {}\n    // docs:end:is_break\n\n    /// Returns `true` if this expression is `continue`.\n    #[builtin(expr_is_continue)]\n    // docs:start:is_continue\n    pub comptime fn is_continue(self) -> bool {}\n    // docs:end:is_continue\n\n    /// Applies a mapping function to this expression and to all of its sub-expressions.\n    /// `f` will be applied to each sub-expression first, then applied to the expression itself.\n    ///\n    /// This happens recursively for every expression within `self`.\n    ///\n    /// For example, calling `modify` on `(&[1], &[2, 3])` with an `f` that returns `Option::some`\n    /// for expressions that are integers, doubling them, would return `(&[2], &[4, 6])`.\n    // docs:start:modify\n    pub comptime fn modify<Env>(self, f: fn[Env](Expr) -> Option<Expr>) -> Expr {\n        // docs:end:modify\n        let result = modify_array(self, f);\n        let result = result.or_else(|| modify_assert(self, f));\n        let result = result.or_else(|| modify_assert_eq(self, f));\n        let result = result.or_else(|| modify_assign(self, f));\n        let result = result.or_else(|| modify_binary_op(self, f));\n        let result = result.or_else(|| modify_block(self, f));\n        let result = result.or_else(|| modify_cast(self, f));\n        let result = result.or_else(|| modify_comptime(self, f));\n        let result = result.or_else(|| modify_constructor(self, f));\n        let result = result.or_else(|| modify_if(self, f));\n        let result = result.or_else(|| modify_index(self, f));\n        let result = result.or_else(|| modify_for(self, f));\n        let result = result.or_else(|| modify_for_range(self, f));\n        let result = result.or_else(|| modify_lambda(self, f));\n        let result = result.or_else(|| modify_let(self, f));\n        let result = result.or_else(|| modify_function_call(self, f));\n        let result = result.or_else(|| modify_member_access(self, f));\n        let result = result.or_else(|| modify_method_call(self, f));\n        let result = result.or_else(|| modify_repeated_element_array(self, f));\n        let result = result.or_else(|| modify_repeated_element_slice(self, f));\n        let result = result.or_else(|| modify_slice(self, f));\n        let result = result.or_else(|| modify_tuple(self, f));\n        let result = result.or_else(|| modify_unary_op(self, f));\n        let result = result.or_else(|| modify_unsafe(self, f));\n        if result.is_some() {\n            let result = result.unwrap_unchecked();\n            let modified = f(result);\n            modified.unwrap_or(result)\n        } else {\n            f(self).unwrap_or(self)\n        }\n    }\n\n    /// Returns this expression as a `Quoted` value. It's the same as `quote { $self }`.\n    // docs:start:quoted\n    pub comptime fn quoted(self) -> Quoted {\n        // docs:end:quoted\n        quote { $self }\n    }\n\n    /// Resolves and type-checks this expression and returns the result as a `TypedExpr`.\n    ///\n    /// The `in_function` argument specifies where the expression is resolved:\n    /// - If it's `none`, the expression is resolved in the function where `resolve` was called\n    /// - If it's `some`, the expression is resolved in the given function\n    ///\n    /// If any names used by this expression are not in scope or if there are any type errors,\n    /// this will give compiler errors as if the expression was written directly into\n    /// the current `comptime` function.\n    #[builtin(expr_resolve)]\n    // docs:start:resolve\n    pub comptime fn resolve(self, in_function: Option<FunctionDefinition>) -> TypedExpr {}\n    // docs:end:resolve\n}\n\ncomptime fn modify_array<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_array().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_array(exprs)\n    })\n}\n\ncomptime fn modify_assert<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert().map(|(predicate, msg)| {\n        let predicate = predicate.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert(predicate, msg)\n    })\n}\n\ncomptime fn modify_assert_eq<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assert_eq().map(|(lhs, rhs, msg)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        let msg = msg.map(|msg| msg.modify(f));\n        new_assert_eq(lhs, rhs, msg)\n    })\n}\n\ncomptime fn modify_assign<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_assign().map(|expr| {\n        let (lhs, rhs) = expr;\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_assign(lhs, rhs)\n    })\n}\n\ncomptime fn modify_binary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_binary_op().map(|(lhs, op, rhs)| {\n        let lhs = lhs.modify(f);\n        let rhs = rhs.modify(f);\n        new_binary_op(lhs, op, rhs)\n    })\n}\n\ncomptime fn modify_block<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_block().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_block(exprs)\n    })\n}\n\ncomptime fn modify_cast<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_cast().map(|(expr, typ)| {\n        let expr = expr.modify(f);\n        new_cast(expr, typ)\n    })\n}\n\ncomptime fn modify_comptime<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_comptime().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_comptime(exprs)\n    })\n}\n\ncomptime fn modify_constructor<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_constructor().map(|(typ, fields)| {\n        let fields = fields.map(|(name, value)| (name, value.modify(f)));\n        new_constructor(typ, fields)\n    })\n}\n\ncomptime fn modify_function_call<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_function_call().map(|(function, arguments)| {\n        let function = function.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_function_call(function, arguments)\n    })\n}\n\ncomptime fn modify_if<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_if().map(|(condition, consequence, alternative)| {\n        let condition = condition.modify(f);\n        let consequence = consequence.modify(f);\n        let alternative = alternative.map(|alternative| alternative.modify(f));\n        new_if(condition, consequence, alternative)\n    })\n}\n\ncomptime fn modify_index<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_index().map(|(object, index)| {\n        let object = object.modify(f);\n        let index = index.modify(f);\n        new_index(object, index)\n    })\n}\n\ncomptime fn modify_for<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for().map(|(identifier, array, body)| {\n        let array = array.modify(f);\n        let body = body.modify(f);\n        new_for(identifier, array, body)\n    })\n}\n\ncomptime fn modify_for_range<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_for_range().map(|(identifier, from, to, body)| {\n        let from = from.modify(f);\n        let to = to.modify(f);\n        let body = body.modify(f);\n        new_for_range(identifier, from, to, body)\n    })\n}\n\ncomptime fn modify_lambda<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_lambda().map(|(params, return_type, body)| {\n        let params = params.map(|(name, typ)| (name.modify(f), typ));\n        let body = body.modify(f);\n        new_lambda(params, return_type, body)\n    })\n}\n\ncomptime fn modify_let<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_let().map(|(pattern, typ, expr)| {\n        let pattern = pattern.modify(f);\n        let expr = expr.modify(f);\n        new_let(pattern, typ, expr)\n    })\n}\n\ncomptime fn modify_member_access<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_member_access().map(|(object, name)| {\n        let object = object.modify(f);\n        new_member_access(object, name)\n    })\n}\n\ncomptime fn modify_method_call<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_method_call().map(|(object, name, generics, arguments)| {\n        let object = object.modify(f);\n        let arguments = arguments.map(|arg| arg.modify(f));\n        new_method_call(object, name, generics, arguments)\n    })\n}\n\ncomptime fn modify_repeated_element_array<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_array().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_array(expr, length)\n    })\n}\n\ncomptime fn modify_repeated_element_slice<Env>(\n    expr: Expr,\n    f: fn[Env](Expr) -> Option<Expr>,\n) -> Option<Expr> {\n    expr.as_repeated_element_slice().map(|(expr, length)| {\n        let expr = expr.modify(f);\n        let length = length.modify(f);\n        new_repeated_element_slice(expr, length)\n    })\n}\n\ncomptime fn modify_slice<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_slice().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_slice(exprs)\n    })\n}\n\ncomptime fn modify_tuple<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_tuple().map(|exprs| {\n        let exprs = modify_expressions(exprs, f);\n        new_tuple(exprs)\n    })\n}\n\ncomptime fn modify_unary_op<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unary_op().map(|(op, rhs)| {\n        let rhs = rhs.modify(f);\n        new_unary_op(op, rhs)\n    })\n}\n\ncomptime fn modify_unsafe<Env>(expr: Expr, f: fn[Env](Expr) -> Option<Expr>) -> Option<Expr> {\n    expr.as_unsafe().map(|exprs| {\n        let exprs = exprs.map(|expr| expr.modify(f));\n        new_unsafe(exprs)\n    })\n}\n\ncomptime fn modify_expressions<Env>(exprs: [Expr], f: fn[Env](Expr) -> Option<Expr>) -> [Expr] {\n    exprs.map(|expr| expr.modify(f))\n}\n\ncomptime fn new_array(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { [$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_assert(predicate: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert($predicate, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert($predicate) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assert_eq(lhs: Expr, rhs: Expr, msg: Option<Expr>) -> Expr {\n    if msg.is_some() {\n        let msg = msg.unwrap();\n        quote { assert_eq($lhs, $rhs, $msg) }.as_expr().unwrap()\n    } else {\n        quote { assert_eq($lhs, $rhs) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_assign(lhs: Expr, rhs: Expr) -> Expr {\n    quote { $lhs = $rhs }.as_expr().unwrap()\n}\n\ncomptime fn new_binary_op(lhs: Expr, op: BinaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { ($lhs) $op ($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_block(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_cast(expr: Expr, typ: UnresolvedType) -> Expr {\n    quote { ($expr) as $typ }.as_expr().unwrap()\n}\n\ncomptime fn new_comptime(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { comptime { $exprs }}.as_expr().unwrap()\n}\n\ncomptime fn new_constructor(typ: UnresolvedType, fields: [(Quoted, Expr)]) -> Expr {\n    let fields = fields.map(|(name, value)| quote { $name: $value }).join(quote { , });\n    quote { $typ { $fields }}.as_expr().unwrap()\n}\n\ncomptime fn new_if(condition: Expr, consequence: Expr, alternative: Option<Expr>) -> Expr {\n    if alternative.is_some() {\n        let alternative = alternative.unwrap();\n        quote { if $condition { $consequence } else { $alternative }}.as_expr().unwrap()\n    } else {\n        quote { if $condition { $consequence } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_for(identifier: Quoted, array: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $array { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_for_range(identifier: Quoted, from: Expr, to: Expr, body: Expr) -> Expr {\n    quote { for $identifier in $from .. $to { $body } }.as_expr().unwrap()\n}\n\ncomptime fn new_index(object: Expr, index: Expr) -> Expr {\n    quote { $object[$index] }.as_expr().unwrap()\n}\n\ncomptime fn new_lambda(\n    params: [(Expr, Option<UnresolvedType>)],\n    return_type: Option<UnresolvedType>,\n    body: Expr,\n) -> Expr {\n    let params = params\n        .map(|(name, typ)| {\n            if typ.is_some() {\n                let typ = typ.unwrap();\n                quote { $name: $typ }\n            } else {\n                quote { $name }\n            }\n        })\n        .join(quote { , });\n\n    if return_type.is_some() {\n        let return_type = return_type.unwrap();\n        quote { |$params| -> $return_type { $body } }.as_expr().unwrap()\n    } else {\n        quote { |$params| { $body } }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_let(pattern: Expr, typ: Option<UnresolvedType>, expr: Expr) -> Expr {\n    if typ.is_some() {\n        let typ = typ.unwrap();\n        quote { let $pattern : $typ = $expr; }.as_expr().unwrap()\n    } else {\n        quote { let $pattern = $expr; }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_member_access(object: Expr, name: Quoted) -> Expr {\n    quote { $object.$name }.as_expr().unwrap()\n}\n\ncomptime fn new_function_call(function: Expr, arguments: [Expr]) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    quote { $function($arguments) }.as_expr().unwrap()\n}\n\ncomptime fn new_method_call(\n    object: Expr,\n    name: Quoted,\n    generics: [UnresolvedType],\n    arguments: [Expr],\n) -> Expr {\n    let arguments = join_expressions(arguments, quote { , });\n\n    if generics.len() == 0 {\n        quote { $object.$name($arguments) }.as_expr().unwrap()\n    } else {\n        let generics = generics.map(|generic| quote { $generic }).join(quote { , });\n        quote { $object.$name::<$generics>($arguments) }.as_expr().unwrap()\n    }\n}\n\ncomptime fn new_repeated_element_array(expr: Expr, length: Expr) -> Expr {\n    quote { [$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_repeated_element_slice(expr: Expr, length: Expr) -> Expr {\n    quote { &[$expr; $length] }.as_expr().unwrap()\n}\n\ncomptime fn new_slice(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { &[$exprs]}.as_expr().unwrap()\n}\n\ncomptime fn new_tuple(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { , });\n    quote { ($exprs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unary_op(op: UnaryOp, rhs: Expr) -> Expr {\n    let op = op.quoted();\n    quote { $op($rhs) }.as_expr().unwrap()\n}\n\ncomptime fn new_unsafe(exprs: [Expr]) -> Expr {\n    let exprs = join_expressions(exprs, quote { ; });\n    quote { \n        // Safety: generated by macro\n        unsafe { $exprs }\n    }\n        .as_expr()\n        .unwrap()\n}\n\ncomptime fn join_expressions(exprs: [Expr], separator: Quoted) -> Quoted {\n    exprs.map(|expr| expr.quoted()).join(separator)\n}\n"
    },
    "250": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/abis/function_selector.nr",
      "source": "use crate::traits::{Deserialize, Empty, FromField, Serialize, ToField};\nuse std::meta::derive;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct FunctionSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    pub inner: u32,\n}\n\nimpl FromField for FunctionSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for FunctionSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for FunctionSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl FunctionSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = crate::hash::poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        FunctionSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n\n#[test]\nfn test_is_valid_selector() {\n    let selector = FunctionSelector::from_signature(\"IS_VALID()\");\n    assert_eq(selector.to_field(), 0x73cdda47);\n}\n\n#[test]\nfn test_long_selector() {\n    let selector =\n        FunctionSelector::from_signature(\"foo_and_bar_and_baz_and_foo_bar_baz_and_bar_foo\");\n    assert_eq(selector.to_field(), 0x7590a997);\n}\n"
    },
    "296": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/address/aztec_address.nr",
      "source": "use crate::{\n    address::{\n        partial_address::PartialAddress, salted_initialization_hash::SaltedInitializationHash,\n    },\n    constants::{\n        AZTEC_ADDRESS_LENGTH, GENERATOR_INDEX__CONTRACT_ADDRESS_V1, MAX_FIELD_VALUE,\n        MAX_PROTOCOL_CONTRACTS,\n    },\n    contract_class_id::ContractClassId,\n    hash::poseidon2_hash_with_separator,\n    public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, ToPoint, TpkM},\n    traits::{Deserialize, Empty, FromField, Packable, Serialize, ToField},\n    utils::field::{pow, sqrt},\n};\n\n// We do below because `use crate::point::Point;` does not work\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\nuse crate::public_keys::AddressPoint;\nuse std::{\n    embedded_curve_ops::{EmbeddedCurveScalar, fixed_base_scalar_mul as derive_public_key},\n    ops::Add,\n};\nuse std::meta::derive;\n\n// Aztec address\n#[derive(Deserialize, Eq, Packable, Serialize)]\npub struct AztecAddress {\n    pub inner: Field,\n}\n\nimpl Empty for AztecAddress {\n    fn empty() -> Self {\n        Self { inner: 0 }\n    }\n}\n\nimpl ToField for AztecAddress {\n    fn to_field(self) -> Field {\n        self.inner\n    }\n}\n\nimpl FromField for AztecAddress {\n    fn from_field(value: Field) -> AztecAddress {\n        AztecAddress { inner: value }\n    }\n}\n\nimpl AztecAddress {\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n\n    pub fn to_address_point(self) -> AddressPoint {\n        // We compute the address point by taking our address, setting it to x, and then solving for y in the\n        // equation which defines our bn curve:\n        // y^2 = x^3 - 17; x = address\n        let x = self.inner;\n        let y_squared = pow(x, 3) - 17;\n\n        // TODO (#8970): Handle cases where we cannot recover a point from an address\n        let mut y = sqrt(y_squared);\n\n        // If we get a negative y coordinate (any y where y > MAX_FIELD_VALUE / 2), we pin it to the\n        // positive one (any value where y <= MAX_FIELD_VALUE / 2) by subtracting it from the Field modulus\n        // note: The field modulus is MAX_FIELD_VALUE + 1\n        if (!(y.lt(MAX_FIELD_VALUE / 2) | y.eq(MAX_FIELD_VALUE / 2))) {\n            y = (MAX_FIELD_VALUE + 1) - y;\n        }\n\n        AddressPoint { inner: Point { x: self.inner, y, is_infinite: false } }\n    }\n\n    pub fn compute(public_keys: PublicKeys, partial_address: PartialAddress) -> AztecAddress {\n        let public_keys_hash = public_keys.hash();\n\n        let pre_address = poseidon2_hash_with_separator(\n            [public_keys_hash.to_field(), partial_address.to_field()],\n            GENERATOR_INDEX__CONTRACT_ADDRESS_V1,\n        );\n\n        let address_point = derive_public_key(EmbeddedCurveScalar::from_field(pre_address)).add(\n            public_keys.ivpk_m.to_point(),\n        );\n\n        // Note that our address is only the x-coordinate of the full address_point. This is okay because when people want to encrypt something and send it to us\n        // they can recover our full point using the x-coordinate (our address itself). To do this, they recompute the y-coordinate according to the equation y^2 = x^3 - 17.\n        // When they do this, they may get a positive y-coordinate (a value that is less than or equal to MAX_FIELD_VALUE / 2) or\n        // a negative y-coordinate (a value that is more than MAX_FIELD_VALUE), and we cannot dictate which one they get and hence the recovered point may sometimes be different than the one\n        // our secret can decrypt. Regardless though, they should and will always encrypt using point with the positive y-coordinate by convention.\n        // This ensures that everyone encrypts to the same point given an arbitrary x-coordinate (address). This is allowed because even though our original point may not have a positive y-coordinate,\n        // with our original secret, we will be able to derive the secret to the point with the flipped (and now positive) y-coordinate that everyone encrypts to.\n        AztecAddress::from_field(address_point.x)\n    }\n\n    pub fn compute_from_class_id(\n        contract_class_id: ContractClassId,\n        salted_initialization_hash: SaltedInitializationHash,\n        public_keys: PublicKeys,\n    ) -> Self {\n        let partial_address = PartialAddress::compute_from_salted_initialization_hash(\n            contract_class_id,\n            salted_initialization_hash,\n        );\n\n        AztecAddress::compute(public_keys, partial_address)\n    }\n\n    pub fn is_protocol_contract(self) -> bool {\n        self.inner.lt(MAX_PROTOCOL_CONTRACTS as Field)\n    }\n\n    pub fn is_zero(self) -> bool {\n        self.inner == 0\n    }\n\n    pub fn assert_is_zero(self) {\n        assert(self.to_field() == 0);\n    }\n}\n\n#[test]\nfn compute_address_from_partial_and_pub_keys() {\n    let public_keys = PublicKeys {\n        npk_m: NpkM {\n            inner: Point {\n                x: 0x22f7fcddfa3ce3e8f0cc8e82d7b94cdd740afa3e77f8e4a63ea78a239432dcab,\n                y: 0x0471657de2b6216ade6c506d28fbc22ba8b8ed95c871ad9f3e3984e90d9723a7,\n                is_infinite: false,\n            },\n        },\n        ivpk_m: IvpkM {\n            inner: Point {\n                x: 0x111223493147f6785514b1c195bb37a2589f22a6596d30bb2bb145fdc9ca8f1e,\n                y: 0x273bbffd678edce8fe30e0deafc4f66d58357c06fd4a820285294b9746c3be95,\n                is_infinite: false,\n            },\n        },\n        ovpk_m: OvpkM {\n            inner: Point {\n                x: 0x09115c96e962322ffed6522f57194627136b8d03ac7469109707f5e44190c484,\n                y: 0x0c49773308a13d740a7f0d4f0e6163b02c5a408b6f965856b6a491002d073d5b,\n                is_infinite: false,\n            },\n        },\n        tpk_m: TpkM {\n            inner: Point {\n                x: 0x00d3d81beb009873eb7116327cf47c612d5758ef083d4fda78e9b63980b2a762,\n                y: 0x2f567d22d2b02fe1f4ad42db9d58a36afd1983e7e2909d1cab61cafedad6193a,\n                is_infinite: false,\n            },\n        },\n    };\n\n    let partial_address = PartialAddress::from_field(\n        0x0a7c585381b10f4666044266a02405bf6e01fa564c8517d4ad5823493abd31de,\n    );\n\n    let address = AztecAddress::compute(public_keys, partial_address);\n\n    // The following value was generated by `derivation.test.ts`.\n    // --> Run the test with AZTEC_GENERATE_TEST_DATA=1 flag to update test data.\n    let expected_computed_address_from_partial_and_pubkeys =\n        0x24e4646f58b9fbe7d38e317db8d5636c423fbbdfbe119fc190fe9c64747e0c62;\n    assert(address.to_field() == expected_computed_address_from_partial_and_pubkeys);\n}\n\n#[test]\nfn compute_preaddress_from_partial_and_pub_keys() {\n    let pre_address = poseidon2_hash_with_separator([1, 2], GENERATOR_INDEX__CONTRACT_ADDRESS_V1);\n    let expected_computed_preaddress_from_partial_and_pubkey =\n        0x23ce9be3fa3c846b0f9245cc796902e731d04f086e8a42473bb29e405fc98075;\n    assert(pre_address == expected_computed_preaddress_from_partial_and_pubkey);\n}\n\n#[test]\nfn from_field_to_field() {\n    let address = AztecAddress { inner: 37 };\n    assert_eq(FromField::from_field(address.to_field()), address);\n}\n\n#[test]\nfn serde() {\n    let address = AztecAddress { inner: 37 };\n    // We use the AZTEC_ADDRESS_LENGTH constant to ensure that there is a match between the derived trait\n    // implementation and the constant.\n    let serialized: [Field; AZTEC_ADDRESS_LENGTH] = address.serialize();\n    let deserialized = AztecAddress::deserialize(serialized);\n    assert_eq(address, deserialized);\n}\n"
    },
    "3": {
      "path": "std/array/mod.nr",
      "source": "use crate::cmp::{Eq, Ord};\nuse crate::convert::From;\nuse crate::runtime::is_unconstrained;\n\nmod check_shuffle;\nmod quicksort;\n\nimpl<T, let N: u32> [T; N] {\n    /// Returns the length of this array.\n    ///\n    /// ```noir\n    /// fn len(self) -> Field\n    /// ```\n    ///\n    /// example\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let array = [42, 42];\n    ///     assert(array.len() == 2);\n    /// }\n    /// ```\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Returns this array as a slice.\n    ///\n    /// ```noir\n    /// let array = [1, 2];\n    /// let slice = array.as_slice();\n    /// assert_eq(slice, &[1, 2]);\n    /// ```\n    #[builtin(as_slice)]\n    pub fn as_slice(self) -> [T] {}\n\n    /// Applies a function to each element of this array, returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.map(|a| a * 2);\n    /// assert_eq(b, [2, 4, 6]);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array along with its index,\n    /// returning a new array containing the mapped elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let b = a.mapi(|i, a| i + a * 2);\n    /// assert_eq(b, [2, 5, 8]);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U; N] {\n        let uninitialized = crate::mem::zeroed();\n        let mut ret = [uninitialized; N];\n\n        for i in 0..self.len() {\n            ret[i] = f(i, self[i]);\n        }\n\n        ret\n    }\n\n    /// Applies a function to each element of this array.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// let mut i = 0;\n    /// a.for_each(|x| {\n    ///     b[i] = x;\n    ///     i += 1;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for i in 0..self.len() {\n            f(self[i]);\n        }\n    }\n\n    /// Applies a function to each element of this array along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// let a = [1, 2, 3];\n    /// let mut b = [0; 3];\n    /// a.for_eachi(|i, x| {\n    ///     b[i] = x;\n    /// });\n    /// assert_eq(a, b);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        for i in 0..self.len() {\n            f(i, self[i]);\n        }\n    }\n\n    /// Applies a function to each element of the array, returning the final accumulated value. The first\n    /// parameter is the initial value.\n    ///\n    /// This is a left fold, so the given function will be applied to the accumulator and first element of\n    /// the array, then the second, and so on. For a given call the expected result would be equivalent to:\n    ///\n    /// ```rust\n    /// let a1 = [1];\n    /// let a2 = [1, 2];\n    /// let a3 = [1, 2, 3];\n    ///\n    /// let f = |a, b| a - b;\n    /// a1.fold(10, f); //=> f(10, 1)\n    /// a2.fold(10, f); //=> f(f(10, 1), 2)\n    /// a3.fold(10, f); //=> f(f(f(10, 1), 2), 3)\n    ///\n    /// assert_eq(a3.fold(10, f), 10 - 1 - 2 - 3);\n    /// ```\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    /// Same as fold, but uses the first element as the starting element.\n    ///\n    /// Requires the input array to be non-empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [1, 2, 3, 4];\n    ///     let reduced = arr.reduce(|a, b| a + b);\n    ///     assert(reduced == 10);\n    /// }\n    /// ```\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    /// Returns true if all the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 2];\n    ///     let all = arr.all(|a| a == 2);\n    ///     assert(all);\n    /// }\n    /// ```\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    /// Returns true if any of the elements in this array satisfy the given predicate.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr = [2, 2, 2, 2, 5];\n    ///     let any = arr.any(|a| a == 5);\n    ///     assert(any);\n    /// }\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n\n    /// Concatenates this array with another array.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn main() {\n    ///     let arr1 = [1, 2, 3, 4];\n    ///     let arr2 = [6, 7, 8, 9, 10, 11];\n    ///     let concatenated_arr = arr1.concat(arr2);\n    ///     assert(concatenated_arr == [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    /// }\n    /// ```\n    pub fn concat<let M: u32>(self, array2: [T; M]) -> [T; N + M] {\n        let mut result = [crate::mem::zeroed(); N + M];\n        for i in 0..N {\n            result[i] = self[i];\n        }\n        for i in 0..M {\n            result[i + N] = array2[i];\n        }\n        result\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Ord + Eq,\n{\n    /// Returns a new sorted array. The original array remains untouched. Notice that this function will\n    /// only work for arrays of fields or integers, not for any arbitrary type. This is because the sorting\n    /// logic it uses internally is optimized specifically for these values. If you need a sort function to\n    /// sort any type, you should use the `sort_via` function.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32];\n    ///     let sorted = arr.sort();\n    ///     assert(sorted == [32, 42]);\n    /// }\n    /// ```\n    pub fn sort(self) -> Self {\n        self.sort_via(|a, b| a <= b)\n    }\n}\n\nimpl<T, let N: u32> [T; N]\nwhere\n    T: Eq,\n{\n    /// Returns a new sorted array by sorting it with a custom comparison function.\n    /// The original array remains untouched.\n    /// The ordering function must return true if the first argument should be sorted to be before the second argument or is equal to the second argument.\n    ///\n    /// Using this method with an operator like `<` that does not return `true` for equal values will result in an assertion failure for arrays with equal elements.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let arr = [42, 32]\n    ///     let sorted_ascending = arr.sort_via(|a, b| a <= b);\n    ///     assert(sorted_ascending == [32, 42]); // verifies\n    ///\n    ///     let sorted_descending = arr.sort_via(|a, b| a >= b);\n    ///     assert(sorted_descending == [32, 42]); // does not verify\n    /// }\n    /// ```\n    pub fn sort_via<Env>(self, ordering: fn[Env](T, T) -> bool) -> Self {\n        // Safety: `sorted` array is checked to be:\n        // a. a permutation of `input`'s elements\n        // b. satisfying the predicate `ordering`\n        let sorted = unsafe { quicksort::quicksort(self, ordering) };\n\n        if !is_unconstrained() {\n            for i in 0..N - 1 {\n                assert(\n                    ordering(sorted[i], sorted[i + 1]),\n                    \"Array has not been sorted correctly according to `ordering`.\",\n                );\n            }\n            check_shuffle::check_shuffle(self, sorted);\n        }\n        sorted\n    }\n}\n\nimpl<let N: u32> [u8; N] {\n    /// Converts a byte array of type `[u8; N]` to a string. Note that this performs no UTF-8 validation -\n    /// the given array is interpreted as-is as a string.\n    ///\n    /// Example:\n    ///\n    /// ```rust\n    /// fn main() {\n    ///     let hi = [104, 105].as_str_unchecked();\n    ///     assert_eq(hi, \"hi\");\n    /// }\n    /// ```\n    #[builtin(array_as_str_unchecked)]\n    pub fn as_str_unchecked(self) -> str<N> {}\n}\n\nimpl<let N: u32> From<str<N>> for [u8; N] {\n    /// Returns an array of the string bytes.\n    fn from(s: str<N>) -> Self {\n        s.as_bytes()\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq([].map(|x| x + 1), []);\n    }\n\n    global arr_with_100_values: [u32; 100] = [\n        42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2, 54,\n        89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41, 19, 98,\n        53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21, 43, 86, 35,\n        21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15, 127, 81, 30, 8,\n        125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n    ];\n    global expected_with_100_values: [u32; 100] = [\n        0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30, 32,\n        32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58, 61, 62,\n        62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82, 84, 84, 86,\n        86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114, 114, 116, 118,\n        119, 120, 121, 123, 123, 123, 125, 126, 127,\n    ];\n    fn sort_u32(a: u32, b: u32) -> bool {\n        a <= b\n    }\n\n    #[test]\n    fn test_sort() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort();\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_100_values_comptime() {\n        let sorted = arr_with_100_values.sort();\n        assert(sorted == expected_with_100_values);\n    }\n\n    #[test]\n    fn test_sort_via() {\n        let mut arr: [u32; 7] = [3, 6, 8, 10, 1, 2, 1];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 7] = [1, 1, 2, 3, 6, 8, 10];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn test_sort_via_100_values() {\n        let mut arr: [u32; 100] = [\n            42, 123, 87, 93, 48, 80, 50, 5, 104, 84, 70, 47, 119, 66, 71, 121, 3, 29, 42, 118, 2,\n            54, 89, 44, 81, 0, 26, 106, 68, 96, 84, 48, 95, 54, 45, 32, 89, 100, 109, 19, 37, 41,\n            19, 98, 53, 114, 107, 66, 6, 74, 13, 19, 105, 64, 123, 28, 44, 50, 89, 58, 123, 126, 21,\n            43, 86, 35, 21, 62, 82, 0, 108, 120, 72, 72, 62, 80, 12, 71, 70, 86, 116, 73, 38, 15,\n            127, 81, 30, 8, 125, 28, 26, 69, 114, 63, 27, 28, 61, 42, 13, 32,\n        ];\n\n        let sorted = arr.sort_via(sort_u32);\n\n        let expected: [u32; 100] = [\n            0, 0, 2, 3, 5, 6, 8, 12, 13, 13, 15, 19, 19, 19, 21, 21, 26, 26, 27, 28, 28, 28, 29, 30,\n            32, 32, 35, 37, 38, 41, 42, 42, 42, 43, 44, 44, 45, 47, 48, 48, 50, 50, 53, 54, 54, 58,\n            61, 62, 62, 63, 64, 66, 66, 68, 69, 70, 70, 71, 71, 72, 72, 73, 74, 80, 80, 81, 81, 82,\n            84, 84, 86, 86, 87, 89, 89, 89, 93, 95, 96, 98, 100, 104, 105, 106, 107, 108, 109, 114,\n            114, 116, 118, 119, 120, 121, 123, 123, 123, 125, 126, 127,\n        ];\n        assert(sorted == expected);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq([].mapi(|i, x| i * x + 1), []);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_array: [Field; 0] = [];\n        empty_array.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = [1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, [2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = [1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        let mut i = 0;\n        let i_ref = &mut i;\n        a.for_each(|x| {\n            b_ref[*i_ref] = x * 2;\n            *i_ref += 1;\n        });\n        assert_eq(b, [2, 4, 6]);\n        assert_eq(i, 3);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = [1, 2, 3];\n        let mut b = [0, 0, 0];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { b_ref[i] = i + a * 2; });\n        assert_eq(b, [2, 5, 8]);\n    }\n\n    #[test]\n    fn concat() {\n        let arr1 = [1, 2, 3, 4];\n        let arr2 = [6, 7, 8, 9, 10, 11];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1, 2, 3, 4, 6, 7, 8, 9, 10, 11]);\n    }\n\n    #[test]\n    fn concat_zero_length_with_something() {\n        let arr1 = [];\n        let arr2 = [1];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_something_with_zero_length() {\n        let arr1 = [1];\n        let arr2 = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, [1]);\n    }\n\n    #[test]\n    fn concat_zero_lengths() {\n        let arr1: [Field; 0] = [];\n        let arr2: [Field; 0] = [];\n        let concatenated_arr = arr1.concat(arr2);\n        assert_eq(concatenated_arr, []);\n    }\n}\n"
    },
    "310": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/data/public_data_tree_leaf_preimage.nr",
      "source": "use crate::{\n    data::public_data_tree_leaf::PublicDataTreeLeaf,\n    merkle_tree::leaf_preimage::{IndexedTreeLeafPreimage, LeafPreimage},\n    traits::{Empty, Hash},\n};\n\npub struct PublicDataTreeLeafPreimage {\n    pub slot: Field,\n    pub value: Field,\n    pub next_slot: Field,\n    pub next_index: u32,\n}\n\nimpl Empty for PublicDataTreeLeafPreimage {\n    fn empty() -> Self {\n        Self { slot: 0, value: 0, next_slot: 0, next_index: 0 }\n    }\n}\n\nimpl Eq for PublicDataTreeLeafPreimage {\n    fn eq(self, other: Self) -> bool {\n        (self.slot == other.slot)\n            & (self.value == other.value)\n            & (self.next_slot == other.next_slot)\n            & (self.next_index == other.next_index)\n    }\n}\n\nimpl Hash for PublicDataTreeLeafPreimage {\n    fn hash(self) -> Field {\n        if self.is_empty() {\n            0\n        } else {\n            crate::hash::poseidon2_hash([\n                self.slot,\n                self.value,\n                (self.next_index as Field),\n                self.next_slot,\n            ])\n        }\n    }\n}\n\nimpl LeafPreimage for PublicDataTreeLeafPreimage {\n    fn get_key(self) -> Field {\n        self.slot\n    }\n\n    fn as_leaf(self) -> Field {\n        self.hash()\n    }\n}\n\nimpl IndexedTreeLeafPreimage<PublicDataTreeLeaf> for PublicDataTreeLeafPreimage {\n    fn get_next_key(self) -> Field {\n        self.next_slot\n    }\n\n    fn points_to_infinity(self) -> bool {\n        (self.next_slot == 0) & (self.next_index == 0)\n    }\n\n    fn update_pointers(self, next_slot: Field, next_index: u32) -> Self {\n        Self { slot: self.slot, value: self.value, next_slot, next_index }\n    }\n\n    fn update_value(self, write: PublicDataTreeLeaf) -> Self {\n        Self {\n            slot: self.slot,\n            value: write.value,\n            next_slot: self.next_slot,\n            next_index: self.next_index,\n        }\n    }\n\n    fn build_insertion_leaf(write: PublicDataTreeLeaf, low_leaf: Self) -> Self {\n        Self {\n            slot: write.slot,\n            value: write.value,\n            next_slot: low_leaf.next_slot,\n            next_index: low_leaf.next_index,\n        }\n    }\n}\n\nimpl PublicDataTreeLeafPreimage {\n    pub fn is_empty(self) -> bool {\n        (self.slot == 0) & (self.value == 0) & (self.next_slot == 0) & (self.next_index == 0)\n    }\n}\n"
    },
    "312": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/debug_log.nr",
      "source": "/// Utility function to console.log data in the acir simulator.\n/// Example:\n///   debug_log(\"blah blah this is a debug string\");\npub fn debug_log<let N: u32>(msg: str<N>) {\n    debug_log_format(msg, []);\n}\n\n/// Utility function to console.log data in the acir simulator. This variant receives a format string in which the\n/// `${k}` tokens will be replaced with the k-eth value in the `args` array.\n/// Examples:\n///   debug_log_format(\"get_2(slot:{0}) =>\\n\\t0:{1}\\n\\t1:{2}\", [storage_slot, note0_hash, note1_hash]);\n///   debug_log_format(\"whole array: {}\", [e1, e2, e3, e4]);\npub fn debug_log_format<let M: u32, let N: u32>(msg: str<M>, args: [Field; N]) {\n    // Safety: This oracle call returns nothing: we only call it for its side effects. It is therefore always safe\n    // to call.\n    unsafe { debug_log_oracle_wrapper(msg, args) };\n}\n\npub unconstrained fn debug_log_oracle_wrapper<let M: u32, let N: u32>(\n    msg: str<M>,\n    args: [Field; N],\n) {\n    debug_log_oracle(msg, args.as_slice());\n}\n\n// WARNING: sometimes when using debug logs the ACVM errors with: `thrown: \"solver opcode resolution error: cannot solve opcode: expression has too many unknowns x155\"`\n#[oracle(utilityDebugLog)]\nunconstrained fn debug_log_oracle<let M: u32>(_msg: str<M>, args: [Field]) {}\n"
    },
    "321": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/hash.nr",
      "source": "use crate::{\n    abis::{\n        contract_class_function_leaf_preimage::ContractClassFunctionLeafPreimage,\n        function_selector::FunctionSelector,\n        note_hash::ScopedNoteHash,\n        nullifier::ScopedNullifier,\n        private_log::{PrivateLog, PrivateLogData},\n        side_effect::{OrderedValue, scoped::Scoped},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, FUNCTION_TREE_HEIGHT, GENERATOR_INDEX__NOTE_HASH_NONCE,\n        GENERATOR_INDEX__OUTER_NULLIFIER, GENERATOR_INDEX__SILOED_NOTE_HASH,\n        GENERATOR_INDEX__UNIQUE_NOTE_HASH, TWO_POW_64,\n    },\n    merkle_tree::root::root_from_sibling_path,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    poseidon2::Poseidon2Sponge,\n    traits::{FromField, Hash, ToField},\n    utils::field::{field_from_bytes, field_from_bytes_32_trunc},\n};\nuse std::embedded_curve_ops::EmbeddedCurveScalar;\n\npub fn sha256_to_field<let N: u32>(bytes_to_hash: [u8; N]) -> Field {\n    let sha256_hashed = sha256::digest(bytes_to_hash);\n    let hash_in_a_field = field_from_bytes_32_trunc(sha256_hashed);\n\n    hash_in_a_field\n}\n\npub fn private_functions_root_from_siblings(\n    selector: FunctionSelector,\n    vk_hash: Field,\n    function_leaf_index: Field,\n    function_leaf_sibling_path: [Field; FUNCTION_TREE_HEIGHT],\n) -> Field {\n    let function_leaf_preimage = ContractClassFunctionLeafPreimage { selector, vk_hash };\n    let function_leaf = function_leaf_preimage.hash();\n    root_from_sibling_path(\n        function_leaf,\n        function_leaf_index,\n        function_leaf_sibling_path,\n    )\n}\n\npub fn compute_note_hash_nonce(first_nullifier_in_tx: Field, note_index_in_tx: u32) -> Field {\n    // Hashing the first nullifier with note index in tx is guaranteed to be unique (because all nullifiers are also\n    // unique).\n    poseidon2_hash_with_separator(\n        [first_nullifier_in_tx, note_index_in_tx as Field],\n        GENERATOR_INDEX__NOTE_HASH_NONCE,\n    )\n}\n\npub fn compute_unique_note_hash(note_nonce: Field, siloed_note_hash: Field) -> Field {\n    let inputs = [note_nonce, siloed_note_hash];\n    poseidon2_hash_with_separator(inputs, GENERATOR_INDEX__UNIQUE_NOTE_HASH)\n}\n\npub fn compute_nonce_and_unique_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    let note_nonce = compute_note_hash_nonce(first_nullifier, note_index_in_tx);\n    compute_unique_note_hash(note_nonce, siloed_note_hash)\n}\n\npub fn compute_siloed_note_hash(app: AztecAddress, note_hash: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), note_hash],\n        GENERATOR_INDEX__SILOED_NOTE_HASH,\n    )\n}\n\n/// Computes unique note hashes from siloed note hashes\npub fn compute_unique_siloed_note_hash(\n    siloed_note_hash: Field,\n    first_nullifier: Field,\n    note_index_in_tx: u32,\n) -> Field {\n    if siloed_note_hash == 0 {\n        0\n    } else {\n        compute_nonce_and_unique_note_hash(siloed_note_hash, first_nullifier, note_index_in_tx)\n    }\n}\n\n/// Siloing in the context of Aztec refers to the process of hashing a note hash with a contract address (this way\n/// the note hash is scoped to a specific contract). This is used to prevent intermingling of notes between contracts.\npub fn silo_note_hash(note_hash: ScopedNoteHash) -> Field {\n    if note_hash.contract_address.is_zero() {\n        0\n    } else {\n        compute_siloed_note_hash(note_hash.contract_address, note_hash.value())\n    }\n}\n\npub fn compute_siloed_nullifier(app: AztecAddress, nullifier: Field) -> Field {\n    poseidon2_hash_with_separator(\n        [app.to_field(), nullifier],\n        GENERATOR_INDEX__OUTER_NULLIFIER,\n    )\n}\n\npub fn silo_nullifier(nullifier: ScopedNullifier) -> Field {\n    // Q: shouldn't we be checking whether the _whole_ nullifier is empty?\n    // A: We don't have to. The init and inner circuits add contract address to non-empty nullifiers.\n    // So we know we should silo it if the contract address is not empty.\n    if nullifier.contract_address.is_zero() {\n        // Q: I don't understand this comment. We could still compute a siloed nullifier from a zero contract address.\n        nullifier.value() // Return value instead of 0 because the first nullifier's contract address is zero.\n    } else {\n        compute_siloed_nullifier(nullifier.contract_address, nullifier.value())\n    }\n}\n\npub fn compute_siloed_private_log_field(contract_address: AztecAddress, field: Field) -> Field {\n    poseidon2_hash([contract_address.to_field(), field])\n}\n\npub fn silo_private_log(private_log: Scoped<PrivateLogData>) -> PrivateLog {\n    if private_log.contract_address.is_zero() {\n        private_log.inner.log\n    } else {\n        let mut fields = private_log.inner.log.fields;\n        fields[0] = compute_siloed_private_log_field(private_log.contract_address, fields[0]);\n        PrivateLog::new(fields, private_log.inner.log.length)\n    }\n}\n\npub fn compute_contract_class_log_hash(log: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS]) -> Field {\n    poseidon2_hash(log)\n}\n\npub fn compute_app_secret_key(\n    master_secret_key: EmbeddedCurveScalar,\n    app_address: AztecAddress,\n    app_secret_generator: Field,\n) -> Field {\n    poseidon2_hash_with_separator(\n        [master_secret_key.hi, master_secret_key.lo, app_address.to_field()],\n        app_secret_generator,\n    )\n}\n\npub fn merkle_hash(left: Field, right: Field) -> Field {\n    poseidon2_hash([left, right])\n}\n\npub fn compute_l2_to_l1_hash(\n    contract_address: AztecAddress,\n    recipient: EthAddress,\n    content: Field,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    let contract_address_bytes: [u8; 32] = contract_address.to_field().to_be_bytes();\n    let recipient_bytes: [u8; 20] = recipient.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let rollup_version_id_bytes: [u8; 32] = rollup_version_id.to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n\n    let mut bytes: [u8; 148] = std::mem::zeroed();\n    for i in 0..32 {\n        bytes[i] = contract_address_bytes[i];\n        bytes[i + 32] = rollup_version_id_bytes[i];\n        // 64 - 84 are for recipient.\n        bytes[i + 84] = chain_id_bytes[i];\n        bytes[i + 116] = content_bytes[i];\n    }\n\n    for i in 0..20 {\n        bytes[64 + i] = recipient_bytes[i];\n    }\n\n    sha256_to_field(bytes)\n}\n\npub fn silo_l2_to_l1_message(\n    msg: Scoped<L2ToL1Message>,\n    rollup_version_id: Field,\n    chain_id: Field,\n) -> Field {\n    if msg.contract_address.is_zero() {\n        0\n    } else {\n        compute_l2_to_l1_hash(\n            msg.contract_address,\n            msg.inner.recipient,\n            msg.inner.content,\n            rollup_version_id,\n            chain_id,\n        )\n    }\n}\n\n/// Computes sha256 hash of 2 input fields.\n///\n/// @returns A truncated field (i.e., the first byte is always 0).\npub fn accumulate_sha256(v0: Field, v1: Field) -> Field {\n    // Concatenate two fields into 32 x 2 = 64 bytes\n    let v0_as_bytes: [u8; 32] = v0.to_be_bytes();\n    let v1_as_bytes: [u8; 32] = v1.to_be_bytes();\n    let hash_input_flattened = v0_as_bytes.concat(v1_as_bytes);\n\n    sha256_to_field(hash_input_flattened)\n}\n\n#[inline_always]\npub fn pedersen_hash<let N: u32>(inputs: [Field; N], hash_index: u32) -> Field {\n    std::hash::pedersen_hash_with_separator(inputs, hash_index)\n}\n\npub fn poseidon2_hash<let N: u32>(inputs: [Field; N]) -> Field {\n    poseidon::poseidon2::Poseidon2::hash(inputs, N)\n}\n\n#[no_predicates]\npub fn poseidon2_hash_with_separator<let N: u32, T>(inputs: [Field; N], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let inputs_with_separator = [separator.to_field()].concat(inputs);\n    poseidon2_hash(inputs_with_separator)\n}\n\n// Performs a fixed length hash with a subarray of the given input.\n// Useful for SpongeBlob in which we aborb M things and want to check it vs a hash of M elts of an N-len array.\n// Using stdlib poseidon, this will always absorb an extra 1 as a 'variable' hash, and not match spongeblob.squeeze()\n// or any ts implementation. Also checks that any remaining elts not hashed are empty.\n#[no_predicates]\npub fn poseidon2_hash_subarray<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, false);\n    sponge.squeeze()\n}\n\n// NB the below is the same as poseidon::poseidon2::Poseidon2::hash(), but replacing a range check with a bit check,\n// and absorbing in chunks of 3 below.\n#[no_predicates]\npub fn poseidon2_cheaper_variable_hash<let N: u32>(input: [Field; N], in_len: u32) -> Field {\n    let mut sponge = poseidon2_absorb_chunks(input, in_len, true);\n    // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n    // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n    // fixed-length and variable-length hashes do not collide)\n    if in_len != N {\n        sponge.absorb(1);\n    }\n    sponge.squeeze()\n}\n\n// The below fn reduces gates of a conditional poseidon2 hash by approx 3x (thank you ~* Giant Brain Dev @IlyasRidhuan *~ for the idea)\n// Why? Because when we call stdlib poseidon, we call absorb for each item. When absorbing is conditional, it seems the compiler does not know\n// what cache_size will be when calling absorb, so it assigns the permutation gates for /each i/ rather than /every 3rd i/, which is actually required.\n// The below code forces the compiler to:\n//  - absorb normally up to 2 times to set cache_size to 1\n//  - absorb in chunks of 3 to ensure perm. only happens every 3rd absorb\n//  - absorb normally up to 2 times to add any remaining values to the hash\n// In fixed len hashes, the compiler is able to tell that it will only need to perform the permutation every 3 absorbs.\n// NB: it also replaces unnecessary range checks (i < thing) with a bit check (&= i != thing), which alone reduces the gates of a var. hash by half.\n\n#[no_predicates]\nfn poseidon2_absorb_chunks<let N: u32>(\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n) -> Poseidon2Sponge {\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    // Even though shift is always 1 here, if we input in_len = 0 we get an underflow\n    // since we cannot isolate computation branches. The below is just to avoid that.\n    let shift = if in_len == 0 { 0 } else { 1 };\n    if in_len != 0 {\n        // cache_size = 0, init absorb\n        sponge.cache[0] = input[0];\n        sponge.cache_size = 1;\n        // shift = num elts already added to make cache_size 1 = 1 for a fresh sponge\n        // M = max_chunks = (N - 1 - (N - 1) % 3) / 3: (must be written as a fn of N to compile)\n        // max_remainder = (N - 1) % 3;\n        // max_chunks = (N - 1 - max_remainder) / 3;\n        sponge = poseidon2_absorb_chunks_loop::<N, (N - 1 - (N - 1) % 3) / 3>(\n            sponge,\n            input,\n            in_len,\n            variable,\n            shift,\n        );\n    }\n    sponge\n}\n\n// NB: If it's not required to check that the non-absorbed elts of 'input' are 0s, set skip_0_check=true\n#[no_predicates]\npub fn poseidon2_absorb_chunks_existing_sponge<let N: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    skip_0_check: bool,\n) -> Poseidon2Sponge {\n    let mut sponge = in_sponge;\n    // 'shift' is to account for already added inputs\n    let mut shift = 0;\n    // 'stop' is to avoid an underflow when inputting in_len = 0\n    let mut stop = false;\n    for i in 0..3 {\n        if shift == in_len {\n            stop = true;\n        }\n        if (sponge.cache_size != 1) & (!stop) {\n            sponge.absorb(input[i]);\n            shift += 1;\n        }\n    }\n    sponge = if stop {\n        sponge\n    } else {\n        // max_chunks = (N - (N % 3)) / 3;\n        poseidon2_absorb_chunks_loop::<N, (N - (N % 3)) / 3>(\n            sponge,\n            input,\n            in_len,\n            skip_0_check,\n            shift,\n        )\n    };\n    sponge\n}\n\n// The below is the loop to absorb elts into a poseidon sponge in chunks of 3\n// shift - the num of elts already absorbed to ensure the sponge's cache_size = 1\n// M - the max number of chunks required to absorb N things (must be comptime to compile)\n// NB: The 0 checks ('Found non-zero field...') are messy, but having a separate loop over N to check\n// for 0s costs 3N gates. Current approach is approx 2N gates.\n#[no_predicates]\nfn poseidon2_absorb_chunks_loop<let N: u32, let M: u32>(\n    in_sponge: Poseidon2Sponge,\n    input: [Field; N],\n    in_len: u32,\n    variable: bool,\n    shift: u32,\n) -> Poseidon2Sponge {\n    assert(in_len <= N, \"Given in_len to absorb is larger than the input array len\");\n    // When we have an existing sponge, we may have a shift of 0, and the final 'k+2' below = N\n    // The below avoids an overflow\n    let skip_last = 3 * M == N;\n    // Writing in_sponge: &mut does not compile\n    let mut sponge = in_sponge;\n    let mut should_add = true;\n    // The num of things left over after absorbing in 3s\n    let remainder = (in_len - shift) % 3;\n    // The num of chunks of 3 to absorb (maximum M)\n    let chunks = (in_len - shift - remainder) / 3;\n    for i in 0..M {\n        // Now we loop through cache size = 1 -> 3\n        should_add &= i != chunks;\n        // This is the index at the start of the chunk (for readability)\n        let k = 3 * i + shift;\n        if should_add {\n            // cache_size = 1, 2 => just assign\n            sponge.cache[1] = input[k];\n            sponge.cache[2] = input[k + 1];\n            // cache_size = 3 => duplex + perm\n            for j in 0..3 {\n                sponge.state[j] += sponge.cache[j];\n            }\n            sponge.state = std::hash::poseidon2_permutation(sponge.state, 4);\n            sponge.cache[0] = input[k + 2];\n            // cache_size is now 1 again, repeat loop\n        } else if (!variable) & (i != chunks) {\n            // if we are hashing a fixed len array which is a subarray, we check the remaining elts are 0\n            // NB: we don't check at i == chunks, because that chunk contains elts to be absorbed or checked below\n            let last_0 = if (i == M - 1) & (skip_last) {\n                0\n            } else {\n                input[k + 2]\n            };\n            let all_0 = (input[k] == 0) & (input[k + 1] == 0) & (last_0 == 0);\n            assert(all_0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    // we have 'remainder' num of items left to absorb\n    should_add = true;\n    // below is to avoid overflows (i.e. if inlen is close to N)\n    let mut should_check = !variable;\n    for i in 0..3 {\n        should_add &= i != remainder;\n        should_check &= in_len - remainder + i != N;\n        if should_add {\n            // we want to absorb the final 'remainder' items\n            sponge.absorb(input[in_len - remainder + i]);\n        } else if should_check {\n            assert_eq(input[in_len - remainder + i], 0, \"Found non-zero field after breakpoint\");\n        }\n    }\n    sponge\n}\n\npub fn poseidon2_hash_with_separator_slice<T>(inputs: [Field], separator: T) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs[i]);\n    }\n\n    sponge.squeeze()\n}\n\n// This function is  unconstrained because it is intended to be used in unconstrained context only as\n// in constrained contexts it would be too inefficient.\npub unconstrained fn poseidon2_hash_with_separator_bounded_vec<let N: u32, T>(\n    inputs: BoundedVec<Field, N>,\n    separator: T,\n) -> Field\nwhere\n    T: ToField,\n{\n    let in_len = inputs.len() + 1;\n    let iv: Field = (in_len as Field) * TWO_POW_64;\n    let mut sponge = Poseidon2Sponge::new(iv);\n    sponge.absorb(separator.to_field());\n\n    for i in 0..inputs.len() {\n        sponge.absorb(inputs.get(i));\n    }\n\n    sponge.squeeze()\n}\n\n#[no_predicates]\npub fn poseidon2_hash_bytes<let N: u32>(inputs: [u8; N]) -> Field {\n    let mut fields = [0; (N + 30) / 31];\n    let mut field_index = 0;\n    let mut current_field = [0; 31];\n    for i in 0..inputs.len() {\n        let index = i % 31;\n        current_field[index] = inputs[i];\n        if index == 30 {\n            fields[field_index] = field_from_bytes(current_field, false);\n            current_field = [0; 31];\n            field_index += 1;\n        }\n    }\n    if field_index != fields.len() {\n        fields[field_index] = field_from_bytes(current_field, false);\n    }\n    poseidon2_hash(fields)\n}\n\n#[test]\nfn poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let sub_chunk_hash = poseidon2_hash_subarray(input, in_len);\n    let fixed_len_hash = poseidon::poseidon2::Poseidon2::hash(fixed_input, fixed_input.len());\n    assert(sub_chunk_hash == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_matches_variable() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    let variable_chunk_hash = poseidon2_cheaper_variable_hash(input, in_len);\n    let variable_len_hash = poseidon::poseidon2::Poseidon2::hash(input, in_len);\n    assert(variable_chunk_hash == variable_len_hash);\n}\n\n#[test]\nfn existing_sponge_poseidon_chunks_matches_fixed() {\n    let in_len = 501;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut fixed_input = [3; 501];\n    assert(in_len == fixed_input.len()); // sanity check\n    for i in 0..in_len {\n        input[i] = 3;\n    }\n    // absorb 250 of the 501 things\n    let empty_sponge = Poseidon2Sponge::new((in_len as Field) * TWO_POW_64);\n    let first_sponge = poseidon2_absorb_chunks_existing_sponge(empty_sponge, input, 250, true);\n    // now absorb the final 251 (since they are all 3s, im being lazy and not making a new array)\n    let mut final_sponge = poseidon2_absorb_chunks_existing_sponge(first_sponge, input, 251, true);\n    let fixed_len_hash = Poseidon2Sponge::hash(fixed_input, fixed_input.len());\n    assert(final_sponge.squeeze() == fixed_len_hash);\n}\n\n#[test]\nfn poseidon_chunks_empty_inputs() {\n    let in_len = 0;\n    let mut input: [Field; 4096] = [0; 4096];\n    let mut constructed_empty_sponge = poseidon2_absorb_chunks(input, in_len, true);\n    let mut first_sponge =\n        poseidon2_absorb_chunks_existing_sponge(constructed_empty_sponge, input, in_len, true);\n    assert(first_sponge.squeeze() == constructed_empty_sponge.squeeze());\n}\n\n#[test]\nfn smoke_sha256_to_field() {\n    let full_buffer = [\n        0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24,\n        25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47,\n        48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70,\n        71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93,\n        94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112,\n        113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130,\n        131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148,\n        149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159,\n    ];\n    let result = sha256_to_field(full_buffer);\n\n    assert(result == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184c7);\n\n    // to show correctness of the current ver (truncate one byte) vs old ver (mod full bytes):\n    let result_bytes = sha256::digest(full_buffer);\n    let truncated_field = crate::utils::field::field_from_bytes_32_trunc(result_bytes);\n    assert(truncated_field == result);\n    let mod_res = result + (result_bytes[31] as Field);\n    assert(mod_res == 0x448ebbc9e1a31220a2f3830c18eef61b9bd070e5084b7fa2a359fe729184e0);\n}\n\n#[test]\nfn compute_l2_l1_hash() {\n    // All zeroes\n    let hash_result =\n        compute_l2_to_l1_hash(AztecAddress::from_field(0), EthAddress::zero(), 0, 0, 0);\n    assert(hash_result == 0x3b18c58c739716e76429634a61375c45b3b5cd470c22ab6d3e14cee23dd992);\n\n    // Non-zero case\n    let hash_result = compute_l2_to_l1_hash(\n        AztecAddress::from_field(1),\n        EthAddress::from_field(3),\n        5,\n        2,\n        4,\n    );\n    assert(hash_result == 0xaab2a5828156782b12a1dc6f336e2bc627eb1b9514b02d511f66296990c050);\n}\n\n#[test]\nfn silo_l2_to_l1_message_matches_typescript() {\n    let version = 4;\n    let chainId = 5;\n\n    let hash = silo_l2_to_l1_message(\n        L2ToL1Message { recipient: EthAddress::from_field(1), content: 2 }.scope(\n            AztecAddress::from_field(3),\n        ),\n        version,\n        chainId,\n    );\n\n    // The following value was generated by `yarn-project/stdlib/src/hash/hash.test.ts`\n    let hash_from_typescript = 0x0081edf209e087ad31b3fd24263698723d57190bd1d6e9fe056fc0c0a68ee661;\n\n    assert_eq(hash, hash_from_typescript);\n}\n\n#[test]\nunconstrained fn poseidon2_hash_with_separator_bounded_vec_matches_non_bounded_vec_version() {\n    let inputs = BoundedVec::<Field, 4>::from_array([1, 2, 3]);\n    let separator = 42;\n\n    // Hash using bounded vec version\n    let bounded_result = poseidon2_hash_with_separator_bounded_vec(inputs, separator);\n\n    // Hash using regular version\n    let regular_result = poseidon2_hash_with_separator([1, 2, 3], separator);\n\n    // Results should match\n    assert_eq(bounded_result, regular_result);\n}\n"
    },
    "331": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/merkle_tree/root.nr",
      "source": "use crate::{hash::merkle_hash, merkle_tree::merkle_tree::MerkleTree};\n\n// Calculate the Merkle tree root from the sibling path and leaf.\n//\n// The leaf is hashed with its sibling, and then the result is hashed\n// with the next sibling etc in the path. The last hash is the root.\n//\n// TODO(David/Someone): The cpp code is using a uint256, whereas its\n// TODO a bit simpler in Noir to just have a bit array.\n// TODO: I'd generally like to avoid u256 for algorithms like\n// this because it means we never even need to consider cases where\n// the index is greater than p.\npub fn root_from_sibling_path<let N: u32>(\n    leaf: Field,\n    leaf_index: Field,\n    sibling_path: [Field; N],\n) -> Field {\n    let mut node = leaf;\n    let indices: [u1; N] = leaf_index.to_le_bits();\n\n    for i in 0..N {\n        let (hash_left, hash_right) = if indices[i] == 1 {\n            (sibling_path[i], node)\n        } else {\n            (node, sibling_path[i])\n        };\n        node = merkle_hash(hash_left, hash_right);\n    }\n    node\n}\n\npub fn calculate_subtree_root<let N: u32>(leaves: [Field; N]) -> Field {\n    MerkleTree::new(leaves).get_root()\n}\n\n// These values are precomputed and we run tests to ensure that they\n// are correct. The values themselves were computed from the cpp code.\n//\n// Would be good if we could use width since the compute_subtree\n// algorithm uses depth.\npub fn calculate_empty_tree_root(depth: u32) -> Field {\n    if depth == 0 {\n        0\n    } else if depth == 1 {\n        0x0b63a53787021a4a962a452c2921b3663aff1ffd8d5510540f8e659e782956f1\n    } else if depth == 2 {\n        0x0e34ac2c09f45a503d2908bcb12f1cbae5fa4065759c88d501c097506a8b2290\n    } else if depth == 3 {\n        0x21f9172d72fdcdafc312eee05cf5092980dda821da5b760a9fb8dbdf607c8a20\n    } else if depth == 4 {\n        0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e\n    } else if depth == 5 {\n        0x120157cfaaa49ce3da30f8b47879114977c24b266d58b0ac18b325d878aafddf\n    } else if depth == 6 {\n        0x01c28fe1059ae0237b72334700697bdf465e03df03986fe05200cadeda66bd76\n    } else if depth == 7 {\n        0x2d78ed82f93b61ba718b17c2dfe5b52375b4d37cbbed6f1fc98b47614b0cf21b\n    } else if depth == 8 {\n        0x067243231eddf4222f3911defbba7705aff06ed45960b27f6f91319196ef97e1\n    } else if depth == 9 {\n        0x1849b85f3c693693e732dfc4577217acc18295193bede09ce8b97ad910310972\n    } else if depth == 10 {\n        0x2a775ea761d20435b31fa2c33ff07663e24542ffb9e7b293dfce3042eb104686\n    } else {\n        panic(f\"depth should be between 0 and 10\")\n    }\n}\n\n#[test]\nfn test_merkle_root_interop_test() {\n    // This is a test to ensure that we match the cpp implementation.\n    // You can grep for `TEST_F(root_rollup_tests, noir_interop_test)`\n    // to find the test that matches this.\n    let root = calculate_subtree_root([1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4, 1, 2, 3, 4]);\n    assert(0x1a09d935ae110b4c861fcec8f9099ec30b4485022aeb3d3cf9d7168e38fdc231 == root);\n\n    let empty_root = calculate_subtree_root([0; 16]);\n    assert(0x2373ea368857ec7af97e7b470d705848e2bf93ed7bef142a490f2119bcf82d8e == empty_root);\n}\n\n#[test]\nfn test_empty_subroot() {\n    assert(calculate_empty_tree_root(0) == 0);\n\n    let expected_empty_root_2 = calculate_subtree_root([0; 2]);\n    assert(calculate_empty_tree_root(1) == expected_empty_root_2);\n\n    let expected_empty_root_4 = calculate_subtree_root([0; 4]);\n    assert(calculate_empty_tree_root(2) == expected_empty_root_4);\n\n    let expected_empty_root_8 = calculate_subtree_root([0; 8]);\n    assert(calculate_empty_tree_root(3) == expected_empty_root_8);\n\n    let expected_empty_root_16 = calculate_subtree_root([0; 16]);\n    assert(calculate_empty_tree_root(4) == expected_empty_root_16);\n\n    let expected_empty_root_32 = calculate_subtree_root([0; 32]);\n    assert(calculate_empty_tree_root(5) == expected_empty_root_32);\n\n    let expected_empty_root_64 = calculate_subtree_root([0; 64]);\n    assert(calculate_empty_tree_root(6) == expected_empty_root_64);\n\n    let expected_empty_root_128 = calculate_subtree_root([0; 128]);\n    assert(calculate_empty_tree_root(7) == expected_empty_root_128);\n\n    let expected_empty_root_256 = calculate_subtree_root([0; 256]);\n    assert(calculate_empty_tree_root(8) == expected_empty_root_256);\n\n    let expected_empty_root_512 = calculate_subtree_root([0; 512]);\n    assert(calculate_empty_tree_root(9) == expected_empty_root_512);\n\n    let expected_empty_root_1024 = calculate_subtree_root([0; 1024]);\n    assert(calculate_empty_tree_root(10) == expected_empty_root_1024);\n}\n"
    },
    "335": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/meta/mod.nr",
      "source": "/// Generates the generic parameter declarations for a struct's trait implementation.\n///\n/// This function takes a struct type definition and generates the generic parameter declarations\n/// that go after the `impl` keyword. For example, given a struct with generics `N: u32` and `T`,\n/// it generates `<let N: u32, T>`.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate generic declarations for\n///\n/// # Returns\n/// A quoted code block containing the generic parameter declarations, or an empty quote if the struct\n/// has no generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// This function generates:\n/// ```\n/// <let N: u32, T>\n/// ```\ncomptime fn get_generics_declarations(s: TypeDefinition) -> Quoted {\n    let generics = s.generics();\n\n    if generics.len() > 0 {\n        let generics_declarations_items = generics\n            .map(|(name, maybe_integer_typ)| {\n                // The second item in the generics tuple is an Option of an integer type that is Some only if\n                // the generic is numeric.\n                if maybe_integer_typ.is_some() {\n                    // The generic is numeric, so we return a quote defined as e.g. \"let N: u32\"\n                    let integer_type = maybe_integer_typ.unwrap();\n                    quote {let $name: $integer_type}\n                } else {\n                    // The generic is not numeric, so we return a quote containing the name of the generic (e.g. \"T\")\n                    quote {$name}\n                }\n            })\n            .join(quote {,});\n        quote {<$generics_declarations_items>}\n    } else {\n        // The struct doesn't have any generics defined, so we just return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates the `where` clause for a trait implementation that constrains non-numeric generic type parameters.\n///\n/// This function takes a struct type definition and a trait name, and generates a `where` clause that\n/// requires all non-numeric generic type parameters to implement the specified trait.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the where clause for\n/// - `trait_name`: The name of the trait that non-numeric generic parameters must implement\n///\n/// # Returns\n/// A quoted code block containing the where clause, or an empty quote if the struct has no non-numeric\n/// generic parameters\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Container<T, let N: u32> {\n///     items: [T; N],\n///     count: u32\n/// }\n/// ```\n///\n/// And trait name \"Serialize\", this function generates:\n/// ```\n/// where T: Serialize\n/// ```\ncomptime fn get_where_trait_clause(s: TypeDefinition, trait_name: Quoted) -> Quoted {\n    let generics = s.generics();\n\n    // The second item in the generics tuple is an Option of an integer type that is Some only if the generic is\n    // numeric.\n    let non_numeric_generics =\n        generics.filter(|(_, maybe_integer_typ)| maybe_integer_typ.is_none());\n\n    if non_numeric_generics.len() > 0 {\n        let non_numeric_generics_declarations =\n            non_numeric_generics.map(|(name, _)| quote {$name: $trait_name}).join(quote {,});\n        quote {where $non_numeric_generics_declarations}\n    } else {\n        // There are no non-numeric generics, so we return an empty quote.\n        quote {}\n    }\n}\n\n/// Generates a `Serialize` trait implementation for a struct type.\n///\n/// # Parameters\n/// - `s`: The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A quoted code block containing the trait implementation\n///\n/// # Example\n/// For a struct defined as:\n/// ```\n/// struct Log<N> {\n///     fields: [Field; N],\n///     length: u32\n/// }\n/// ```\n///\n/// This function generates code equivalent to:\n/// ```\n/// impl<let N: u32> Serialize for Log<N> {\n///     let N: u32 = <[Field; N] as Serialize>::N + <u32 as Serialize>::N;\n///\n///     #[inline_always]\n///     fn serialize(self) -> [Field; Self::N] {\n///         let mut result = [0; _];\n///         let mut offset = 0;\n///\n///         let serialized_member = Serialize::serialize(self.fields);\n///         let serialized_member_len = <[Field; N] as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         let serialized_member = Serialize::serialize(self.length);\n///         let serialized_member_len = <u32 as Serialize>::N;\n///         for i in 0..serialized_member_len {\n///             result[i + offset] = serialized_member[i];\n///         }\n///         offset += serialized_member_len;\n///\n///         result\n///     }\n/// }\n/// ```\npub comptime fn derive_serialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Serialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_serialize_clause = get_where_trait_clause(s, quote {Serialize});\n\n    // The following will give us <type_of_struct_member_1 as Serialize>::N + <type_of_struct_member_2 as Serialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Serialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the serialized member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // For multiple struct members, generate serialization code that:\n        // 1. Serializes each member\n        // 2. Copies the serialized fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let serialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                let serialized_member = $crate::traits::Serialize::serialize(self.$param_name);\n                let serialized_member_len = <$param_type as $crate::traits::Serialize>::N;\n                for i in 0..serialized_member_len {\n                    result[i + offset] = serialized_member[i];\n                }\n                offset += serialized_member_len;\n            }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; _];\n            let mut offset = 0;\n\n            $serialization_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Serialize::serialize(self.$param_name)\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Serialize for $typ\n            $where_serialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn serialize(self) -> [Field; Self::N] {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Deserialize` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Deserialize` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Deserialize for MyStruct {\n///     let N: u32 = <AztecAddress as Deserialize>::N + <Field as Deserialize>::N;\n///\n///     fn deserialize(serialized: [Field; Self::N]) -> Self {\n///         let mut offset = 0;\n///         let mut member_fields = [0; <AztecAddress as Deserialize>::N];\n///         for i in 0..<AztecAddress as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let x = <AztecAddress as Deserialize>::deserialize(member_fields);\n///         offset += <AztecAddress as Deserialize>::N;\n///\n///         let mut member_fields = [0; <Field as Deserialize>::N];\n///         for i in 0..<Field as Deserialize>::N {\n///             member_fields[i] = serialized[i + offset];\n///         }\n///         let y = <Field as Deserialize>::deserialize(member_fields);\n///         offset += <Field as Deserialize>::N;\n///\n///         Self { x, y }\n///     }\n/// }\n/// ```\npub(crate) comptime fn derive_deserialize(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Deserialize` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_deserialize_clause = get_where_trait_clause(s, quote {Deserialize});\n\n    // The following will give us <type_of_struct_member_1 as Deserialize>::N + <type_of_struct_member_2 as Deserialize>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Deserialize>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly deserializing the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let function_body = if params.len() > 1 {\n        // This generates deserialization code for each struct member and concatenates them together.\n        let deserialization_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as Deserialize>::N];\n                    for i in 0..<$param_type as Deserialize>::N {\n                        member_fields[i] = serialized[i + offset];\n                    }\n                    let $param_name = <$param_type as Deserialize>::deserialize(member_fields);\n                    offset += <$param_type as Deserialize>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        // This will give us e.g. `a, b, c` for a struct with three fields named `a`, `b`, and `c`.\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n\n            $deserialization_of_struct_members\n\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Deserialize::deserialize(serialized) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Deserialize for $typ\n            $where_deserialize_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn deserialize(serialized: [Field; Self::N]) -> Self {\n                $function_body\n            }\n        }\n    }\n}\n\n/// Generates a `Packable` trait implementation for a given struct `s`.\n///\n/// # Arguments\n/// * `s` - The struct type definition to generate the implementation for\n///\n/// # Returns\n/// A `Quoted` block containing the generated trait implementation\n///\n/// # Requirements\n/// Each struct member type must implement the `Packable` trait (it gets used in the generated code).\n///\n/// # Example\n/// For a struct like:\n/// ```\n/// struct MyStruct {\n///     x: AztecAddress,\n///     y: Field,\n/// }\n/// ```\n///\n/// This generates:\n/// ```\n/// impl Packable for MyStruct {\n///     let N: u32 = 2;\n///\n///     fn pack(self) -> [Field; 2] {\n///         let mut result: [Field; 2] = [0_Field; 2];\n///         let mut offset: u32 = 0_u32;\n///         let packed_member: [Field; 1] = self.x.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         let packed_member: [Field; 1] = self.y.pack();\n///         let packed_member_len: u32 = <Field as Packable>::N;\n///         for i in 0_u32..packed_member_len {\n///             {\n///                 result[i + offset] = packed_member[i];\n///             }\n///         }\n///         offset = offset + packed_member_len;\n///         result\n///     }\n///\n///     fn unpack(packed: [Field; 2]) -> Self {\n///         let mut offset: u32 = 0_u32;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<AztecAddress as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let x: AztecAddress = <AztecAddress as Packable>::unpack(member_fields);\n///         offset = offset + <AztecAddress as Packable>::N;\n///         let mut member_fields: [Field; 1] = [0_Field; 1];\n///         for i in 0_u32..<Field as Packable>::N {\n///             member_fields[i] = packed[i + offset];\n///         }\n///         let y: Field = <Field as Packable>::unpack(member_fields);\n///         offset = offset + <Field as Packable>::N;\n///         Self { x: x, y: y }\n///     }\n/// }\n/// ```\npub comptime fn derive_packable(s: TypeDefinition) -> Quoted {\n    let typ = s.as_type();\n    let nested_struct = typ.as_data_type().unwrap();\n    let params = nested_struct.0.fields(nested_struct.1);\n\n    // Generates the generic parameter declarations (to be placed after the `impl` keyword) and the `where` clause\n    // for the `Packable` trait.\n    let generics_declarations = get_generics_declarations(s);\n    let where_packable_clause = get_where_trait_clause(s, quote {Packable});\n\n    // The following will give us <type_of_struct_member_1 as Packable>::N + <type_of_struct_member_2 as Packable>::N + ...\n    let right_hand_side_of_definition_of_n = params\n        .map(|(_, param_type, _): (Quoted, Type, Quoted)| {\n            quote {\n            <$param_type as $crate::traits::Packable>::N\n        }\n        })\n        .join(quote {+});\n\n    // For structs containing a single member, we can enhance performance by directly returning the packed member,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let pack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate packing code that:\n        // 1. Packs each member\n        // 2. Copies the packed fields into the result array at the correct offset\n        // 3. Updates the offset for the next member\n        let packing_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let packed_member = $crate::traits::Packable::pack(self.$param_name);\n                    let packed_member_len = <$param_type as $crate::traits::Packable>::N;\n                    for i in 0..packed_member_len {\n                        result[i + offset] = packed_member[i];\n                    }\n                    offset += packed_member_len;\n                }\n            })\n            .join(quote {});\n\n        quote {\n            let mut result = [0; Self::N];\n            let mut offset = 0;\n\n            $packing_of_struct_members\n\n            result\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            $crate::traits::Packable::pack(self.$param_name)\n        }\n    };\n\n    // For structs containing a single member, we can enhance performance by directly unpacking the input array,\n    // bypassing the need for loop-based array construction. While this optimization yields significant benefits in\n    // Brillig where the loops are expected to not be optimized, it is not relevant in ACIR where the loops are\n    // expected to be optimized away.\n    let unpack_function_body = if params.len() > 1 {\n        // For multiple struct members, generate unpacking code that:\n        // 1. Unpacks each member\n        // 2. Copies packed fields into member array at correct offset\n        // 3. Updates offset for next member\n        let unpacking_of_struct_members = params\n            .map(|(param_name, param_type, _): (Quoted, Type, Quoted)| {\n                quote {\n                    let mut member_fields = [0; <$param_type as $crate::traits::Packable>::N];\n                    for i in 0..<$param_type as $crate::traits::Packable>::N {\n                        member_fields[i] = packed[i + offset];\n                    }\n                    let $param_name = <$param_type as $crate::traits::Packable>::unpack(member_fields);\n                    offset += <$param_type as $crate::traits::Packable>::N;\n                }\n            })\n            .join(quote {});\n\n        // We join the struct member names with a comma to be used in the `Self { ... }` syntax\n        let struct_members = params\n            .map(|(param_name, _, _): (Quoted, Type, Quoted)| quote { $param_name })\n            .join(quote {,});\n\n        quote {\n            let mut offset = 0;\n            $unpacking_of_struct_members\n            Self { $struct_members }\n        }\n    } else {\n        let param_name = params[0].0;\n        quote {\n            Self { $param_name: $crate::traits::Packable::unpack(packed) }\n        }\n    };\n\n    quote {\n        impl$generics_declarations $crate::traits::Packable for $typ\n            $where_packable_clause\n        {\n            let N: u32 = $right_hand_side_of_definition_of_n;\n\n            #[inline_always]\n            fn pack(self) -> [Field; Self::N] {\n                $pack_function_body\n            }\n\n            #[inline_always]\n            fn unpack(packed: [Field; Self::N]) -> Self {\n                $unpack_function_body\n            }\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Packable, Serialize};\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct Smol {\n        a: Field,\n        b: Field,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct HasArray {\n        a: [Field; 2],\n        b: bool,\n    }\n\n    #[derive(Deserialize, Eq, Serialize)]\n    pub struct Fancier {\n        a: Smol,\n        b: [Field; 2],\n        c: [u8; 3],\n        d: str<16>,\n    }\n\n    #[derive(Deserialize, Eq, Packable, Serialize)]\n    pub struct HasArrayWithGenerics<T, let N: u32> {\n        pub fields: [T; N],\n        pub length: u32,\n    }\n\n    #[test]\n    fn serde_on_smol() {\n        let smol = Smol { a: 1, b: 2 };\n        let serialized = smol.serialize();\n        assert(serialized == [1, 2], serialized);\n        let deserialized = Smol::deserialize(serialized);\n        assert(deserialized == smol);\n\n        // None of the struct members implements the `Packable` trait so the packed and serialized data should be the same\n        let packed = smol.pack();\n        assert_eq(packed, serialized, \"Packed does not match serialized\");\n    }\n\n    #[test]\n    fn serde_on_has_array() {\n        let has_array = HasArray { a: [1, 2], b: true };\n        let serialized = has_array.serialize();\n        assert(serialized == [1, 2, 1], serialized);\n        let deserialized = HasArray::deserialize(serialized);\n        assert(deserialized == has_array);\n    }\n\n    #[test]\n    fn serde_on_fancier() {\n        let fancier =\n            Fancier { a: Smol { a: 1, b: 2 }, b: [0, 1], c: [1, 2, 3], d: \"metaprogramming!\" };\n        let serialized = fancier.serialize();\n        assert(\n            serialized\n                == [\n                    1, 2, 0, 1, 1, 2, 3, 0x6d, 0x65, 0x74, 0x61, 0x70, 0x72, 0x6f, 0x67, 0x72, 0x61,\n                    0x6d, 0x6d, 0x69, 0x6e, 0x67, 0x21,\n                ],\n            serialized,\n        );\n        let deserialized = Fancier::deserialize(serialized);\n        assert(deserialized == fancier);\n    }\n\n    #[test]\n    fn serde_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let serialized = struct_with_array_of_generics.serialize();\n        assert(serialized == [1, 2, 3, 3], serialized);\n        let deserialized = HasArrayWithGenerics::deserialize(serialized);\n        assert(deserialized == struct_with_array_of_generics);\n    }\n\n    #[test]\n    fn packable_on_contains_array_with_generics() {\n        let struct_with_array_of_generics = HasArrayWithGenerics { fields: [1, 2, 3], length: 3 };\n        let packed = struct_with_array_of_generics.pack();\n        assert(packed == [1, 2, 3, 3], packed);\n\n        let unpacked = HasArrayWithGenerics::unpack(packed);\n        assert(unpacked == struct_with_array_of_generics);\n    }\n\n}\n"
    },
    "336": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/point.nr",
      "source": "pub use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse crate::{hash::poseidon2_hash, traits::{Deserialize, Empty, Hash, Packable, Serialize}};\n\npub global POINT_LENGTH: u32 = 3;\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl Serialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn serialize(self: Self) -> [Field; Self::N] {\n        [self.x, self.y, self.is_infinite as Field]\n    }\n}\n\nimpl Hash for Point {\n    fn hash(self) -> Field {\n        poseidon2_hash(self.serialize())\n    }\n}\n\nimpl Empty for Point {\n    /// Note: Does not return a valid point on curve - instead represents an empty/\"unpopulated\" point struct (e.g.\n    /// empty/unpopulated value in an array of points).\n    fn empty() -> Self {\n        Point { x: 0, y: 0, is_infinite: false }\n    }\n}\n\nimpl Deserialize for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn deserialize(serialized: [Field; Self::N]) -> Self {\n        Point { x: serialized[0], y: serialized[1], is_infinite: serialized[2] != 0 }\n    }\n}\n\n// TODO(#11356): use compact representation here.\nimpl Packable for Point {\n    let N: u32 = POINT_LENGTH;\n\n    fn pack(self) -> [Field; Self::N] {\n        self.serialize()\n    }\n\n    fn unpack(packed: [Field; Self::N]) -> Self {\n        Self::deserialize(packed)\n    }\n}\n"
    },
    "337": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/poseidon2.nr",
      "source": "use crate::constants::TWO_POW_64;\nuse crate::traits::{Deserialize, Serialize};\nuse std::meta::derive;\n// NB: This is a clone of noir/noir-repo/noir_stdlib/src/hash/poseidon2.nr\n// It exists as we sometimes need to perform custom absorption, but the stdlib version\n// has a private absorb() method (it's also designed to just be a hasher)\n// Can be removed when standalone noir poseidon lib exists: See noir#6679\n\ncomptime global RATE: u32 = 3;\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct Poseidon2Sponge {\n    pub cache: [Field; 3],\n    pub state: [Field; 4],\n    pub cache_size: u32,\n    pub squeeze_mode: bool, // 0 => absorb, 1 => squeeze\n}\n\nimpl Poseidon2Sponge {\n    #[no_predicates]\n    pub fn hash<let N: u32>(input: [Field; N], message_size: u32) -> Field {\n        Poseidon2Sponge::hash_internal(input, message_size, message_size != N)\n    }\n\n    pub(crate) fn new(iv: Field) -> Poseidon2Sponge {\n        let mut result =\n            Poseidon2Sponge { cache: [0; 3], state: [0; 4], cache_size: 0, squeeze_mode: false };\n        result.state[RATE] = iv;\n        result\n    }\n\n    fn perform_duplex(&mut self) {\n        // add the cache into sponge state\n        for i in 0..RATE {\n            // We effectively zero-pad the cache by only adding to the state\n            // cache that is less than the specified `cache_size`\n            if i < self.cache_size {\n                self.state[i] += self.cache[i];\n            }\n        }\n        self.state = std::hash::poseidon2_permutation(self.state, 4);\n    }\n\n    pub fn absorb(&mut self, input: Field) {\n        assert(!self.squeeze_mode);\n        if self.cache_size == RATE {\n            // If we're absorbing, and the cache is full, apply the sponge permutation to compress the cache\n            self.perform_duplex();\n            self.cache[0] = input;\n            self.cache_size = 1;\n        } else {\n            // If we're absorbing, and the cache is not full, add the input into the cache\n            self.cache[self.cache_size] = input;\n            self.cache_size += 1;\n        }\n    }\n\n    pub fn squeeze(&mut self) -> Field {\n        assert(!self.squeeze_mode);\n        // If we're in absorb mode, apply sponge permutation to compress the cache.\n        self.perform_duplex();\n        self.squeeze_mode = true;\n\n        // Pop one item off the top of the permutation and return it.\n        self.state[0]\n    }\n\n    fn hash_internal<let N: u32>(\n        input: [Field; N],\n        in_len: u32,\n        is_variable_length: bool,\n    ) -> Field {\n        let iv: Field = (in_len as Field) * TWO_POW_64;\n        let mut sponge = Poseidon2Sponge::new(iv);\n        for i in 0..input.len() {\n            if i < in_len {\n                sponge.absorb(input[i]);\n            }\n        }\n\n        // In the case where the hash preimage is variable-length, we append `1` to the end of the input, to distinguish\n        // from fixed-length hashes. (the combination of this additional field element + the hash IV ensures\n        // fixed-length and variable-length hashes do not collide)\n        if is_variable_length {\n            sponge.absorb(1);\n        }\n        sponge.squeeze()\n    }\n}\n"
    },
    "347": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/public_keys.nr",
      "source": "use crate::{\n    address::public_keys_hash::PublicKeysHash,\n    constants::{\n        DEFAULT_IVPK_M_X, DEFAULT_IVPK_M_Y, DEFAULT_NPK_M_X, DEFAULT_NPK_M_Y, DEFAULT_OVPK_M_X,\n        DEFAULT_OVPK_M_Y, DEFAULT_TPK_M_X, DEFAULT_TPK_M_Y, GENERATOR_INDEX__PUBLIC_KEYS_HASH,\n    },\n    hash::poseidon2_hash_with_separator,\n    traits::{Deserialize, Hash, Serialize},\n};\n\nuse dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\nuse std::{default::Default, meta::derive};\n\npub trait ToPoint {\n    fn to_point(self) -> Point;\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct NpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for NpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n// Note: If we store npk_m_hash directly we can remove this trait implementation. See #8091\nimpl Hash for NpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct IvpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for IvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct OvpkM {\n    pub inner: Point,\n}\n\nimpl Hash for OvpkM {\n    fn hash(self) -> Field {\n        self.inner.hash()\n    }\n}\n\nimpl ToPoint for OvpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct TpkM {\n    pub inner: Point,\n}\n\nimpl ToPoint for TpkM {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct PublicKeys {\n    pub npk_m: NpkM,\n    pub ivpk_m: IvpkM,\n    pub ovpk_m: OvpkM,\n    pub tpk_m: TpkM,\n}\n\nimpl Default for PublicKeys {\n    fn default() -> Self {\n        PublicKeys {\n            npk_m: NpkM {\n                inner: Point { x: DEFAULT_NPK_M_X, y: DEFAULT_NPK_M_Y, is_infinite: false },\n            },\n            ivpk_m: IvpkM {\n                inner: Point { x: DEFAULT_IVPK_M_X, y: DEFAULT_IVPK_M_Y, is_infinite: false },\n            },\n            ovpk_m: OvpkM {\n                inner: Point { x: DEFAULT_OVPK_M_X, y: DEFAULT_OVPK_M_Y, is_infinite: false },\n            },\n            tpk_m: TpkM {\n                inner: Point { x: DEFAULT_TPK_M_X, y: DEFAULT_TPK_M_Y, is_infinite: false },\n            },\n        }\n    }\n}\n\nimpl PublicKeys {\n    pub fn hash(self) -> PublicKeysHash {\n        PublicKeysHash::from_field(poseidon2_hash_with_separator(\n            self.serialize(),\n            GENERATOR_INDEX__PUBLIC_KEYS_HASH as Field,\n        ))\n    }\n}\n\npub struct AddressPoint {\n    pub inner: Point,\n}\n\nimpl ToPoint for AddressPoint {\n    fn to_point(self) -> Point {\n        self.inner\n    }\n}\n\nmod test {\n    use crate::{\n        point::POINT_LENGTH,\n        public_keys::{IvpkM, NpkM, OvpkM, PublicKeys, TpkM},\n        traits::{Deserialize, Serialize},\n    };\n    use dep::std::embedded_curve_ops::EmbeddedCurvePoint as Point;\n\n    #[test]\n    unconstrained fn compute_public_keys_hash() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        let actual = keys.hash();\n        let expected_public_keys_hash =\n            0x0fecd9a32db731fec1fded1b9ff957a1625c069245a3613a2538bd527068b0ad;\n\n        assert(actual.to_field() == expected_public_keys_hash);\n    }\n\n    #[test]\n    unconstrained fn compute_default_hash() {\n        let keys = PublicKeys::default();\n\n        let actual = keys.hash();\n        let test_data_default_hash =\n            0x1d3bf1fb93ae0e9cda83b203dd91c3bfb492a9aecf30ec90e1057eced0f0e62d;\n\n        assert(actual.to_field() == test_data_default_hash);\n    }\n\n    #[test]\n    unconstrained fn serde() {\n        let keys = PublicKeys {\n            npk_m: NpkM { inner: Point { x: 1, y: 2, is_infinite: false } },\n            ivpk_m: IvpkM { inner: Point { x: 3, y: 4, is_infinite: false } },\n            ovpk_m: OvpkM { inner: Point { x: 5, y: 6, is_infinite: false } },\n            tpk_m: TpkM { inner: Point { x: 7, y: 8, is_infinite: false } },\n        };\n\n        // We use the PUBLIC_KEYS_LENGTH constant to ensure that there is a match between the derived trait\n        let serialized: [Field; POINT_LENGTH * 4] = keys.serialize();\n        let deserialized = PublicKeys::deserialize(serialized);\n\n        assert_eq(keys, deserialized);\n    }\n}\n"
    },
    "362": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/traits.nr",
      "source": "use crate::meta::{derive_deserialize, derive_packable, derive_serialize};\nuse crate::utils::field::field_from_bytes;\n\n// Trait: is_empty\n//\n// The general is_empty trait checks if a data type is is empty,\n// and it defines empty for the basic data types as 0.\n//\n// If a Field is equal to zero, then it is regarded as zero.\n// We will go with this definition for now, however it can be problematic\n// if a value can actually be zero. In a future refactor, we can\n// use the optional type for safety. Doing it now would lead to a worse devex\n// and would make it harder to sync up with the cpp code.\n// Preferred over Default trait to convey intent, as default doesn't necessarily mean empty.\npub trait Empty: Eq {\n    fn empty() -> Self;\n\n    fn is_empty(self) -> bool {\n        self.eq(Self::empty())\n    }\n\n    // Requires this Noir fix: https://github.com/noir-lang/noir/issues/9002\n    // fn assert_not_empty<let U: u32>(self, msg: str<U>) { // This msg version was failing with weird compiler errors.\n    //     // We provide a default impl but it's likely inefficient.\n    //     // The reason we include this function is because there's a lot of\n    //     // opportunity for optimisation on a per-struct basis.\n    //     // You only need to show one element is not empty to know that the whole thing\n    //     // is not empty.\n    //     // If you know an element of your struct which should always be nonempty,\n    //     // you can write an impl that solely checks that that element is nonempty.\n    //     assert(!self.is_empty(), msg);\n    // }\n\n    // This default impl is overwritten by types like arrays, because there's a much\n    // more efficient approach.\n    fn assert_empty<let S: u32>(self, msg: str<S>) {\n        assert(self.is_empty(), msg);\n    }\n}\n\nimpl Empty for Field {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl Empty for u1 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u8 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u16 {\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u32 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u64 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\nimpl Empty for u128 {\n    #[inline_always]\n    fn empty() -> Self {\n        0\n    }\n}\n\nimpl<T, let N: u32> Empty for [T; N]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty(); N]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\n\nimpl<T> Empty for [T]\nwhere\n    T: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        [T::empty()]\n    }\n\n    fn is_empty(self) -> bool {\n        self.all(|elem| elem.is_empty())\n    }\n\n    fn assert_empty<let S: u32>(self, msg: str<S>) -> () {\n        self.for_each(|elem| elem.assert_empty(msg))\n    }\n}\nimpl<A, B> Empty for (A, B)\nwhere\n    A: Empty,\n    B: Empty,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        (A::empty(), B::empty())\n    }\n}\n\nimpl<T> Empty for Option<T>\nwhere\n    T: Eq,\n{\n    #[inline_always]\n    fn empty() -> Self {\n        Option::none()\n    }\n}\n\n// pub fn is_empty<T>(item: T) -> bool\n// where\n//     T: Empty,\n// {\n//     item.eq(T::empty())\n// }\n\n// pub fn is_empty_array<T, let N: u32>(array: [T; N]) -> bool\n// where\n//     T: Empty,\n// {\n//     array.all(|elem| is_empty(elem))\n// }\n\n// pub fn assert_empty<T>(item: T) -> ()\n// where\n//     T: Empty,\n// {\n//     assert(item.eq(T::empty()))\n// }\n\n// pub fn assert_empty_array<T, let N: u32>(array: [T; N]) -> ()\n// where\n//     T: Empty,\n// {\n//     // A cheaper option than `is_empty_array` for if you don't need to gracefully\n//     // handle a bool result.\n//     // Avoids the `&` operator of `is_empty_array`'s `.all()` call.\n//     for i in 0..N {\n//         assert(is_empty(array[i]));\n//     }\n// }\n\npub trait Hash {\n    fn hash(self) -> Field;\n}\n\npub trait ToField {\n    fn to_field(self) -> Field;\n}\n\nimpl ToField for Field {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self\n    }\n}\n\nimpl ToField for bool {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u1 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u8 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u16 {\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u32 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u64 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl ToField for u128 {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        self as Field\n    }\n}\nimpl<let N: u32> ToField for str<N> {\n    #[inline_always]\n    fn to_field(self) -> Field {\n        assert(N < 32, \"String doesn't fit in a field, consider using Serialize instead\");\n        field_from_bytes(self.as_bytes(), true)\n    }\n}\n\npub trait FromField {\n    fn from_field(value: Field) -> Self;\n}\n\nimpl FromField for Field {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value\n    }\n}\n\nimpl FromField for bool {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value != 0\n    }\n}\nimpl FromField for u1 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u1\n    }\n}\nimpl FromField for u8 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u8\n    }\n}\nimpl FromField for u16 {\n    fn from_field(value: Field) -> Self {\n        value as u16\n    }\n}\nimpl FromField for u32 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u32\n    }\n}\nimpl FromField for u64 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u64\n    }\n}\nimpl FromField for u128 {\n    #[inline_always]\n    fn from_field(value: Field) -> Self {\n        value as u128\n    }\n}\n\n// docs:start:serialize\n/// Trait for serializing Noir types into arrays of Fields.\n///\n/// An implementation of the Serialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait (and Deserialize) are\n/// typically used to communicate between Noir and TypeScript (via oracles and function arguments).\n///\n/// # On Following Noir's Intrinsic Serialization\n/// When calling a Noir function from TypeScript (TS), first the function arguments are serialized into an array\n/// of fields. This array is then included in the initial witness. Noir's intrinsic serialization is then used\n/// to deserialize the arguments from the witness. When the same Noir function is called from Noir this Serialize trait\n/// is used instead of the serialization in TS. For this reason we need to have a match between TS serialization,\n/// Noir's intrinsic serialization and the implementation of this trait. If there is a mismatch, the function calls\n/// fail with an arguments hash mismatch error message.\n///\n/// # Associated Constants\n/// * `N` - The length of the output Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let N: u32> Serialize for str<N> {\n///     let N: u32 = N;\n///\n///     fn serialize(self) -> [Field; Self::N] {\n///         let bytes = self.as_bytes();\n///         let mut fields = [0; Self::N];\n///         for i in 0..bytes.len() {\n///             fields[i] = bytes[i] as Field;  // Each byte gets its own Field\n///         }\n///         fields\n///     }\n/// }\n/// ```\n#[derive_via(derive_serialize)]\npub trait Serialize {\n    let N: u32;\n\n    fn serialize(self) -> [Field; N];\n}\n// docs:end:serialize\n\nimpl<let M: u32> Serialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let bytes = self.as_bytes();\n        let mut fields = [0; Self::N];\n        for i in 0..bytes.len() {\n            fields[i] = bytes[i] as Field;\n        }\n        fields\n    }\n}\n\n/// Implementation of Deserialize for BoundedVec.\n///\n/// This implementation deserializes a BoundedVec from an array of Fields. The array contains:\n/// 1. The serialized items, each taking up T::N Fields\n/// 2. The length of the BoundedVec as the last Field\n///\n/// # Type Parameters\n/// * `T` - The type of items stored in the BoundedVec, must implement Deserialize\n/// * `M` - The maximum length of the BoundedVec\n///\n/// # Fields Array Layout\n/// [item1_field1, item1_field2, ..., item2_field1, item2_field2, ..., length]\n/// Where:\n/// - itemN_fieldM: The M-th Field of the N-th item (T::N Fields per item)\n/// - length: The number of items in the BoundedVec (1 Field)\n///\n/// Total length N = T::N * M + 1, where:\n/// - T::N is the number of Fields needed to deserialize one item\n/// - M is the maximum length of the BoundedVec\n/// - +1 is for storing the length\n///\n/// # Note\n/// Not deriving this because it's not supported to call derive_deserialize on a \"remote\" struct (and it will never\n/// be supported).\nimpl<T, let M: u32> Deserialize for BoundedVec<T, M>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut new_bounded_vec: BoundedVec<T, M> = BoundedVec::new();\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        let len = fields[<T as Deserialize>::N * M] as u32;\n\n        for i in 0..len {\n            let mut nested_fields = [0; <T as Deserialize>::N];\n            for j in 0..<T as Deserialize>::N {\n                nested_fields[j] = fields[i * <T as Deserialize>::N + j];\n            }\n\n            let item = T::deserialize(nested_fields);\n            new_bounded_vec.push(item);\n        }\n\n        new_bounded_vec\n    }\n}\n\n// This may cause issues if used as program input, because noir disallows empty arrays for program input.\n// I think this is okay because I don't foresee a unit type being used as input. But leaving this comment as a hint\n// if someone does run into this in the future.\nimpl Deserialize for () {\n    let N: u32 = 0;\n\n    fn deserialize(_fields: [Field; Self::N]) -> Self {\n        ()\n    }\n}\n\n// Note: Not deriving this because it's not supported to call derive_serialize on a \"remote\" struct (and it will never\n// be supported).\nimpl<T, let M: u32> Serialize for BoundedVec<T, M>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M + 1; // +1 for the length of the BoundedVec\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut fields = [0; Self::N];\n\n        let storage = self.storage();\n\n        for i in 0..M {\n            let serialized_item = storage[i].serialize();\n\n            for j in 0..<T as Serialize>::N {\n                fields[i * <T as Serialize>::N + j] = serialized_item[j];\n            }\n        }\n\n        // Length is stored in the last field as we need to match intrinsic Noir serialization and the `len` struct\n        // field is after `storage` struct field (see `bounded_vec.nr` in noir-stdlib)\n        fields[<T as Serialize>::N * M] = self.len() as Field;\n\n        fields\n    }\n}\n\n// docs:start:deserialize\n/// Trait for deserializing Noir types from arrays of Fields.\n///\n/// An implementation of the Deserialize trait has to follow Noir's intrinsic serialization (each member of a struct\n/// converted directly into one or more Fields without any packing or compression). This trait is typically used when\n/// deserializing return values from function calls in Noir. Since the same function could be called from TypeScript\n/// (TS), in which case the TS deserialization would get used, we need to have a match between the 2.\n///\n/// # Associated Constants\n/// * `N` - The length of the input Field array, known at compile time\n///\n/// # Example\n/// ```\n/// impl<let M: u32> Deserialize for str<M> {\n///     let N: u32 = M;\n///\n///     #[inline_always]\n///     fn deserialize(fields: [Field; Self::N]) -> Self {\n///         str::<Self::N>::from(fields.map(|value| value as u8))\n///     }\n/// }\n/// ```\n#[derive_via(derive_deserialize)]\npub trait Deserialize {\n    let N: u32;\n\n    fn deserialize(fields: [Field; N]) -> Self;\n}\n// docs:end:deserialize\n\nimpl<let M: u32> Deserialize for str<M> {\n    let N: u32 = M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        str::<Self::N>::from(fields.map(|value| value as u8))\n    }\n}\n\n/// Trait for efficiently packing and unpacking Noir types into and from arrays of Fields.\n///\n/// The `Packable` trait allows types to be serialized and deserialized with a focus on minimizing the size of\n/// the resulting Field array. This trait is used when storage efficiency is critical (e.g. when storing data\n/// in the contract's public storage).\n///\n/// # Associated Constants\n/// * `N` - The length of the Field array, known at compile time\n#[derive_via(derive_packable)]\npub trait Packable {\n    let N: u32;\n\n    /// Packs the current value into a compact array of `Field` elements.\n    fn pack(self) -> [Field; N];\n\n    /// Unpacks a compact array of `Field` elements into the original value.\n    fn unpack(fields: [Field; N]) -> Self;\n}\n\n#[test]\nunconstrained fn bounded_vec_serialization() {\n    // Test empty BoundedVec\n    let empty_vec: BoundedVec<Field, 3> = BoundedVec::from_array([]);\n    let serialized = empty_vec.serialize();\n    let deserialized = BoundedVec::<Field, 3>::deserialize(serialized);\n    assert_eq(empty_vec, deserialized);\n    assert_eq(deserialized.len(), 0);\n\n    // Test partially filled BoundedVec\n    let partial_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2]]);\n    let serialized = partial_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(partial_vec, deserialized);\n    assert_eq(deserialized.len(), 1);\n    assert_eq(deserialized.get(0), [1, 2]);\n\n    // Test full BoundedVec\n    let full_vec: BoundedVec<[u32; 2], 3> = BoundedVec::from_array([[1, 2], [3, 4], [5, 6]]);\n    let serialized = full_vec.serialize();\n    let deserialized = BoundedVec::<[u32; 2], 3>::deserialize(serialized);\n    assert_eq(full_vec, deserialized);\n    assert_eq(deserialized.len(), 3);\n    assert_eq(deserialized.get(0), [1, 2]);\n    assert_eq(deserialized.get(1), [3, 4]);\n    assert_eq(deserialized.get(2), [5, 6]);\n}\n"
    },
    "364": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_packing.nr",
      "source": "use crate::traits::Packable;\n\nglobal BOOL_PACKED_LEN: u32 = 1;\nglobal U8_PACKED_LEN: u32 = 1;\nglobal U16_PACKED_LEN: u32 = 1;\nglobal U32_PACKED_LEN: u32 = 1;\nglobal U64_PACKED_LEN: u32 = 1;\nglobal U128_PACKED_LEN: u32 = 1;\nglobal FIELD_PACKED_LEN: u32 = 1;\nglobal I8_PACKED_LEN: u32 = 1;\nglobal I16_PACKED_LEN: u32 = 1;\nglobal I32_PACKED_LEN: u32 = 1;\nglobal I64_PACKED_LEN: u32 = 1;\n\nimpl Packable for bool {\n    let N: u32 = BOOL_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> bool {\n        (fields[0] as u1) != 0\n    }\n}\n\nimpl Packable for u8 {\n    let N: u32 = U8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Packable for u16 {\n    let N: u32 = U16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Packable for u32 {\n    let N: u32 = U32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Packable for u64 {\n    let N: u32 = U64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Packable for u128 {\n    let N: u32 = U128_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Packable for Field {\n    let N: u32 = FIELD_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Packable for i8 {\n    let N: u32 = I8_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Packable for i16 {\n    let N: u32 = I16_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Packable for i32 {\n    let N: u32 = I32_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Packable for i64 {\n    let N: u32 = I64_PACKED_LEN;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Packable for [T; M]\nwhere\n    T: Packable,\n{\n    let N: u32 = M * <T as Packable>::N;\n\n    #[inline_always]\n    fn pack(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized = self[i].pack();\n            for j in 0..<T as Packable>::N {\n                result[i * <T as Packable>::N + j] = serialized[j];\n            }\n        }\n        result\n    }\n\n    #[inline_always]\n    fn unpack(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Packable>::N, M>(Packable::unpack, result)\n    }\n}\n\n#[test]\nfn test_u16_packing() {\n    let a: u16 = 10;\n    assert_eq(a, u16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i8_packing() {\n    let a: i8 = -10;\n    assert_eq(a, i8::unpack(a.pack()));\n}\n\n#[test]\nfn test_i16_packing() {\n    let a: i16 = -10;\n    assert_eq(a, i16::unpack(a.pack()));\n}\n\n#[test]\nfn test_i32_packing() {\n    let a: i32 = -10;\n    assert_eq(a, i32::unpack(a.pack()));\n}\n\n#[test]\nfn test_i64_packing() {\n    let a: i64 = -10;\n    assert_eq(a, i64::unpack(a.pack()));\n}\n"
    },
    "365": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/type_serialization.nr",
      "source": "use crate::traits::{Deserialize, Serialize};\n\nglobal BOOL_SERIALIZED_LEN: u32 = 1;\nglobal U8_SERIALIZED_LEN: u32 = 1;\nglobal U16_SERIALIZED_LEN: u32 = 1;\nglobal U32_SERIALIZED_LEN: u32 = 1;\nglobal U64_SERIALIZED_LEN: u32 = 1;\nglobal U128_SERIALIZED_LEN: u32 = 1;\nglobal FIELD_SERIALIZED_LEN: u32 = 1;\nglobal I8_SERIALIZED_LEN: u32 = 1;\nglobal I16_SERIALIZED_LEN: u32 = 1;\nglobal I32_SERIALIZED_LEN: u32 = 1;\nglobal I64_SERIALIZED_LEN: u32 = 1;\n\nimpl Serialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for bool {\n    let N: u32 = BOOL_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> bool {\n        fields[0] != 0\n    }\n}\n\nimpl Serialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u8 {\n    let N: u32 = U8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8\n    }\n}\n\nimpl Serialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u16 {\n    let N: u32 = U16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16\n    }\n}\n\nimpl Serialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u32 {\n    let N: u32 = U32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32\n    }\n}\n\nimpl Serialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u64 {\n    let N: u32 = U64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64\n    }\n}\n\nimpl Serialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as Field]\n    }\n}\n\nimpl Deserialize for u128 {\n    let N: u32 = U128_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u128\n    }\n}\n\nimpl Serialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self]\n    }\n}\n\nimpl Deserialize for Field {\n    let N: u32 = FIELD_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0]\n    }\n}\n\nimpl Serialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u8 as Field]\n    }\n}\n\nimpl Deserialize for i8 {\n    let N: u32 = I8_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u8 as i8\n    }\n}\n\nimpl Serialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u16 as Field]\n    }\n}\n\nimpl Deserialize for i16 {\n    let N: u32 = I16_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u16 as i16\n    }\n}\n\nimpl Serialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u32 as Field]\n    }\n}\n\nimpl Deserialize for i32 {\n    let N: u32 = I32_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u32 as i32\n    }\n}\n\nimpl Serialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        [self as u64 as Field]\n    }\n}\n\nimpl Deserialize for i64 {\n    let N: u32 = I64_SERIALIZED_LEN;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        fields[0] as u64 as i64\n    }\n}\n\nimpl<T, let M: u32> Serialize for [T; M]\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N * M;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; _] = std::mem::zeroed();\n        for i in 0..M {\n            let serialized_t = self[i].serialize();\n            for j in 0..<T as Serialize>::N {\n                result[i * <T as Serialize>::N + j] = serialized_t[j];\n            }\n        }\n        result\n    }\n}\n\nimpl<T, let M: u32> Deserialize for [T; M]\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N * M;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        let mut reader = crate::utils::reader::Reader::new(fields);\n        let mut result: [T; M] = std::mem::zeroed();\n        reader.read_struct_array::<T, <T as Deserialize>::N, M>(Deserialize::deserialize, result)\n    }\n}\n\nimpl<T> Serialize for Option<T>\nwhere\n    T: Serialize,\n{\n    let N: u32 = <T as Serialize>::N + 1;\n\n    #[inline_always]\n    fn serialize(self) -> [Field; Self::N] {\n        let mut result: [Field; Self::N] = std::mem::zeroed();\n\n        result[0] = if self.is_some() { 1 } else { 0 };\n\n        let value_serialized = self.unwrap_unchecked().serialize();\n        for i in 0..<T as Serialize>::N {\n            result[1 + i] = value_serialized[i];\n        }\n\n        result\n    }\n}\n\nimpl<T> Deserialize for Option<T>\nwhere\n    T: Deserialize,\n{\n    let N: u32 = <T as Deserialize>::N + 1;\n\n    #[inline_always]\n    fn deserialize(fields: [Field; Self::N]) -> Self {\n        if fields[0] == 1 {\n            let mut value_fields = [0; <T as Deserialize>::N];\n            for i in 0..<T as Deserialize>::N {\n                value_fields[i] = fields[1 + i];\n            }\n\n            Option::some(T::deserialize(value_fields))\n        } else {\n            Option::none()\n        }\n    }\n}\n\nmod test {\n    use crate::traits::{Deserialize, Serialize};\n\n    #[test]\n    fn u16_serialization() {\n        let a: u16 = 10;\n        assert_eq(a, u16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i8_serialization() {\n        let a: i8 = -10;\n        assert_eq(a, i8::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i16_serialization() {\n        let a: i16 = -10;\n        assert_eq(a, i16::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i32_serialization() {\n        let a: i32 = -10;\n        assert_eq(a, i32::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn i64_serialization() {\n        let a: i64 = -10;\n        assert_eq(a, i64::deserialize(a.serialize()));\n    }\n\n    #[test]\n    fn option_field_serialization() {\n        let opt_some = Option::some(5);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n\n    #[test]\n    fn option_array_serialization() {\n        let opt_some = Option::some([2, 5]);\n        assert_eq(Option::<_>::deserialize(opt_some.serialize()), opt_some);\n\n        let opt_none = Option::none();\n        assert_eq(Option::<Field>::deserialize(opt_none.serialize()), opt_none);\n    }\n}\n"
    },
    "382": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/field.nr",
      "source": "pub fn field_from_bytes<let N: u32>(bytes: [u8; N], big_endian: bool) -> Field {\n    assert(bytes.len() < 32, \"field_from_bytes: N must be less than 32\");\n    let mut as_field = 0;\n    let mut offset = 1;\n    for i in 0..N {\n        let mut index = i;\n        if big_endian {\n            index = N - i - 1;\n        }\n        as_field += (bytes[index] as Field) * offset;\n        offset *= 256;\n    }\n\n    as_field\n}\n\n// Convert a 32 byte array to a field element by truncating the final byte\npub fn field_from_bytes_32_trunc(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..15 {\n        // covers bytes 16..30 (31 is truncated and ignored)\n        low = low + (bytes32[15 + 15 - i] as Field) * v;\n        v = v * 256;\n        // covers bytes 0..14\n        high = high + (bytes32[14 - i] as Field) * v;\n    }\n    // covers byte 15\n    low = low + (bytes32[15] as Field) * v;\n\n    low + high * v\n}\n\n// TODO: This currently only exists to aid point compression in compress_to_blob_commitment().\n// Once compression is part of BigCurve it can either be removed or optimized to be used elsewhere.\npub fn byte_to_bits_be(byte: u8) -> [u1; 8] {\n    let mut mut_byte = byte;\n    let mut bits: [u1; 8] = [0; 8];\n    for i in 0..8 {\n        bits[7 - i] = (mut_byte & 1) as u1;\n        mut_byte >>= 1;\n    }\n    bits\n}\n\n// TODO to radix returns u8, so we cannot use bigger radixes. It'd be ideal to use a radix of the maximum range-constrained integer noir supports\npub fn full_field_less_than(lhs: Field, rhs: Field) -> bool {\n    lhs.lt(rhs)\n}\n\npub fn full_field_greater_than(lhs: Field, rhs: Field) -> bool {\n    rhs.lt(lhs)\n}\n\npub fn min(f1: Field, f2: Field) -> Field {\n    if f1.lt(f2) {\n        f1\n    } else {\n        f2\n    }\n}\n\nglobal C1: u32 = 28;\nglobal C3: Field = 40770029410420498293352137776570907027550720424234931066070132305055;\nglobal C5: Field = 19103219067921713944291392827692070036145651957329286315305642004821462161904;\n\npub(crate) fn pow(x: Field, y: Field) -> Field {\n    let mut r = 1 as Field;\n    let b: [u1; 254] = y.to_le_bits();\n\n    for i in 0..254 {\n        r *= r;\n        r *= (b[254 - 1 - i] as Field) * x + (1 - b[254 - 1 - i] as Field);\n    }\n\n    r\n}\n\n// Tonelli-Shanks algorithm for computing the square root of a Field element.\n// Requires C1 = max{c: 2^c divides (p-1)}, where p is the order of Field\n// as well as C3 = (C2 - 1)/2, where C2 = (p-1)/(2^c1),\n// and C5 = ZETA^C2, where ZETA is a non-square element of Field.\n// These are pre-computed above as globals.\npub(crate) fn sqrt(x: Field) -> Field {\n    let mut z = pow(x, C3);\n    let mut t = z * z * x;\n    z *= x;\n    let mut b = t;\n    let mut c = C5;\n\n    for i in 0..(C1 - 1) {\n        for _j in 1..(C1 - i - 1) {\n            b *= b;\n        }\n\n        z *= if b == 1 { 1 } else { c };\n\n        c *= c;\n\n        t *= if b == 1 { 1 } else { c };\n\n        b = t;\n    }\n\n    z\n}\n\n#[test]\nunconstrained fn bytes_field_test() {\n    // Tests correctness of field_from_bytes_32_trunc against existing methods\n    // Bytes representing 0x543e0a6642ffeb8039296861765a53407bba62bd1c97ca43374de950bbe0a7\n    let inputs = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167,\n    ];\n    let field = field_from_bytes(inputs, true);\n    let return_bytes: [u8; 31] = field.to_be_bytes();\n    assert_eq(inputs, return_bytes);\n    // 32 bytes - we remove the final byte, and check it matches the field\n    let inputs2 = [\n        84, 62, 10, 102, 66, 255, 235, 128, 57, 41, 104, 97, 118, 90, 83, 64, 123, 186, 98, 189, 28,\n        151, 202, 67, 55, 77, 233, 80, 187, 224, 167, 158,\n    ];\n    let field2 = field_from_bytes_32_trunc(inputs2);\n    let return_bytes2: [u8; 31] = field.to_be_bytes();\n\n    assert_eq(return_bytes2, return_bytes);\n    assert_eq(field2, field);\n}\n\n#[test]\nunconstrained fn max_field_test() {\n    // Tests the hardcoded value in constants.nr vs underlying modulus\n    // NB: We can't use 0-1 in constants.nr as it will be transpiled incorrectly to ts and sol constants files\n    let max_value = crate::constants::MAX_FIELD_VALUE;\n    assert_eq(max_value, 0 - 1);\n    // modulus == 0 is tested elsewhere, so below is more of a sanity check\n    let max_bytes: [u8; 32] = max_value.to_be_bytes();\n    let mod_bytes = std::field::modulus_be_bytes();\n    for i in 0..31 {\n        assert_eq(max_bytes[i], mod_bytes[i]);\n    }\n    assert_eq(max_bytes[31], mod_bytes[31] - 1);\n}\n"
    },
    "385": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-protocol-circuits/crates/types/src/utils/reader.nr",
      "source": "pub struct Reader<let N: u32> {\n    data: [Field; N],\n    offset: u32,\n}\n\nimpl<let N: u32> Reader<N> {\n    pub fn new(data: [Field; N]) -> Self {\n        Self { data, offset: 0 }\n    }\n\n    pub fn read(&mut self) -> Field {\n        let result = self.data[self.offset];\n        self.offset += 1;\n        result\n    }\n\n    pub fn read_u32(&mut self) -> u32 {\n        self.read() as u32\n    }\n\n    pub fn read_u64(&mut self) -> u64 {\n        self.read() as u64\n    }\n\n    pub fn read_bool(&mut self) -> bool {\n        self.read() != 0\n    }\n\n    pub fn read_array<let K: u32>(&mut self) -> [Field; K] {\n        let mut result = [0; K];\n        for i in 0..K {\n            result[i] = self.data[self.offset + i];\n        }\n        self.offset += K;\n        result\n    }\n\n    pub fn read_struct<T, let K: u32>(&mut self, deserialise: fn([Field; K]) -> T) -> T {\n        let result = deserialise(self.read_array());\n        result\n    }\n\n    pub fn read_struct_array<T, let K: u32, let C: u32>(\n        &mut self,\n        deserialise: fn([Field; K]) -> T,\n        mut result: [T; C],\n    ) -> [T; C] {\n        for i in 0..C {\n            result[i] = self.read_struct(deserialise);\n        }\n        result\n    }\n\n    pub fn finish(self) {\n        assert_eq(self.offset, self.data.len(), \"Reader did not read all data\");\n    }\n}\n"
    },
    "415": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/uint-note/src/uint_note.nr",
      "source": "use dep::aztec::{\n    context::{PrivateContext, PublicContext},\n    history::nullifier_inclusion::ProveNullifierInclusion,\n    keys::getters::{get_nsk_app, get_public_keys},\n    macros::notes::custom_note,\n    messages::logs::note,\n    note::note_interface::{NoteHash, NoteType},\n    oracle::random::random,\n    protocol_types::{\n        address::AztecAddress,\n        constants::{\n            GENERATOR_INDEX__NOTE_HASH, GENERATOR_INDEX__NOTE_NULLIFIER,\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT, PRIVATE_LOG_SIZE_IN_FIELDS,\n        },\n        hash::{compute_siloed_nullifier, poseidon2_hash_with_separator},\n        traits::{Deserialize, FromField, Hash, Packable, Serialize, ToField},\n    },\n};\n\n// UintNote supports partial notes, i.e. the ability to create an incomplete note in private, hiding certain values (the\n// owner, storage slot and randomness), and then completing the note in public with the ones missing (the amount).\n// Partial notes are being actively developed and are not currently fully supported via macros, and so we rely on the\n// #[custom_note] macro to implement it manually, resulting in some boilerplate. This is expected to be unnecessary once\n// macro support is expanded.\n\n/// A private note representing a numeric value associated to an account (e.g. a token balance).\n#[derive(Eq, Serialize, Packable)]\n#[custom_note]\npub struct UintNote {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintPartialNotePrivateContent, and\n    //   b) have the public field at the end\n    // Correct ordering is checked by the tests in this module.\n\n    /// The owner of the note, i.e. the account whose nullifier secret key is required to compute the nullifier.\n    owner: AztecAddress,\n    /// Random value, protects against note hash preimage attacks.\n    randomness: Field,\n    /// The number stored in the note.\n    value: u128,\n}\n\nimpl NoteHash for UintNote {\n    fn compute_note_hash(self, storage_slot: Field) -> Field {\n        // Partial notes can be implemented by having the note hash be either the result of multiscalar multiplication\n        // (MSM), or two rounds of poseidon. MSM results in more constraints and is only required when multiple variants\n        // of partial notes are supported. Because UintNote has just one variant (where the value is public), we use\n        // poseidon instead.\n\n        // We must compute the same note hash as would be produced by a partial note created and completed with the same\n        // values, so that notes all behave the same way regardless of how they were created. To achieve this, we\n        // perform both steps of the partial note computation.\n\n        // First we create the partial note from a commitment to the private content (including storage slot).\n        let private_content =\n            UintPartialNotePrivateContent { owner: self.owner, randomness: self.randomness };\n        let partial_note = PartialUintNote {\n            commitment: private_content.compute_partial_commitment(storage_slot),\n        };\n\n        // Then compute the completion note hash. In a real partial note this step would be performed in public.\n        partial_note.compute_complete_note_hash(self.value)\n    }\n\n    // The nullifiers are nothing special - this is just the canonical implementation that would be injected by the\n    // #[note] macro.\n\n    fn compute_nullifier(\n        self,\n        context: &mut PrivateContext,\n        note_hash_for_nullify: Field,\n    ) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = context.request_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n\n    unconstrained fn compute_nullifier_unconstrained(self, note_hash_for_nullify: Field) -> Field {\n        let owner_npk_m = get_public_keys(self.owner).npk_m;\n        let owner_npk_m_hash = owner_npk_m.hash();\n        let secret = get_nsk_app(owner_npk_m_hash);\n        poseidon2_hash_with_separator(\n            [note_hash_for_nullify, secret],\n            GENERATOR_INDEX__NOTE_NULLIFIER,\n        )\n    }\n}\n\nimpl UintNote {\n    pub fn new(value: u128, owner: AztecAddress) -> Self {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n        Self { value, owner, randomness }\n    }\n\n    pub fn get_value(self) -> u128 {\n        self.value\n    }\n\n    pub fn get_owner(self) -> AztecAddress {\n        self.owner\n    }\n\n    /// Creates a partial note that will hide the owner and storage slot but not the value, since the note will be later\n    /// completed in public. This is a powerful technique for scenarios in which the value cannot be known in private\n    /// (e.g. because it depends on some public state, such as a DEX).\n    ///\n    /// This function inserts a partial note validity commitment into the nullifier tree to be later on able to verify\n    /// that the partial note and completer are legitimate. See function docs of `compute_validity_commitment` for more\n    /// details.\n    ///\n    /// Each partial note should only be used once, since otherwise multiple notes would be linked together and known to\n    /// belong to the same owner.\n    ///\n    /// As part of the partial note creation process, a log will be sent to `recipient` so that they can discover the\n    /// note. `recipient` will typically be the same as `owner`.\n    pub fn partial(\n        owner: AztecAddress,\n        storage_slot: Field,\n        context: &mut PrivateContext,\n        recipient: AztecAddress,\n        completer: AztecAddress,\n    ) -> PartialUintNote {\n        // Safety: We use the randomness to preserve the privacy of the note recipient by preventing brute-forcing,\n        // so a malicious sender could use non-random values to make the note less private. But they already know\n        // the full note pre-image anyway, and so the recipient already trusts them to not disclose this\n        // information. We can therefore assume that the sender will cooperate in the random value generation.\n        let randomness = unsafe { random() };\n\n        // We create a commitment to the private data, which we then use to construct the log we send to the recipient.\n        let commitment = UintPartialNotePrivateContent { owner, randomness }\n            .compute_partial_commitment(storage_slot);\n\n        // Our partial note log encoding scheme includes a field with the tag of the public completion log, and we use\n        // the commitment as the tag. This is good for multiple reasons:\n        //  - the commitment is uniquely tied to this partial note\n        //  - the commitment is already public information, so we're not revealing anything else\n        //  - we don't need to create any additional information, private or public, for the tag\n        //  - other contracts cannot impersonate us and emit logs with the same tag due to public log siloing\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n\n        let encrypted_log =\n            note::compute_partial_note_log(private_log_content, storage_slot, recipient);\n        // Regardless of the original content size, the log is padded with random bytes up to\n        // `PRIVATE_LOG_SIZE_IN_FIELDS` to prevent leaking information about the actual size.\n        let length = encrypted_log.len();\n        context.emit_private_log(encrypted_log, length);\n\n        let partial_note = PartialUintNote { commitment };\n\n        // Now we compute the validity commitment and push it to the nullifier tree. It can be safely pushed to\n        // the nullifier tree since it uses its own separator, making collisions with actual note nullifiers\n        // practically impossible.\n        let validity_commitment = partial_note.compute_validity_commitment(completer);\n        context.push_nullifier(validity_commitment);\n\n        partial_note\n    }\n}\n\n/// The private content of a partial UintNote, i.e. the fields that will remain private. All other note fields will be\n/// made public.\n#[derive(Packable)]\nstruct UintPartialNotePrivateContent {\n    // The ordering of these fields is important given that it must match that of UintNote.\n    // Correct ordering is checked by the tests in this module.\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl UintPartialNotePrivateContent {\n    fn compute_partial_commitment(self, storage_slot: Field) -> Field {\n        // Here we commit to all private values, including the storage slot.\n        poseidon2_hash_with_separator(\n            self.pack().concat([storage_slot]),\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\n#[derive(Packable)]\nstruct PrivateUintPartialNotePrivateLogContent {\n    // The ordering of these fields is important given that it must:\n    //   a) match that of UintNote, and\n    //   b) have the public log tag at the beginning\n    // Correct ordering is checked by the tests in this module.\n    public_log_tag: Field,\n    owner: AztecAddress,\n    randomness: Field,\n}\n\nimpl NoteType for PrivateUintPartialNotePrivateLogContent {\n    fn get_id() -> Field {\n        UintNote::get_id()\n    }\n}\n\n/// A partial instance of a UintNote. This value represents a private commitment to the owner, randomness and storage\n/// slot, but the value field has not yet been set. A partial note can be completed in public with the `complete`\n/// function (revealing the value to the public), resulting in a UintNote that can be used like any other one (except\n/// of course that its value is known).\n#[derive(Packable, Serialize, Deserialize, Eq)]\npub struct PartialUintNote {\n    commitment: Field,\n}\n\nglobal NOTE_COMPLETION_LOG_LENGTH: u32 = 2;\n\nimpl PartialUintNote {\n    /// Completes the partial note, creating a new note that can be used like any other UintNote.\n    pub fn complete(self, context: &mut PublicContext, completer: AztecAddress, value: u128) {\n        // A note with a value of zero is valid, but we cannot currently complete a partial note with such a value\n        // because this will result in the completion log having its last field set to 0. Public logs currently do not\n        // track their length, and so trailing zeros are simply trimmed. This results in the completion log missing its\n        // last field (the value), and note discovery failing.\n        // TODO(#11636): remove this\n        assert(value != 0, \"Cannot complete a PartialUintNote with a value of 0\");\n\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        assert(\n            context.nullifier_exists(validity_commitment, context.this_address()),\n            \"Invalid partial note or completer\",\n        );\n\n        // We need to do two things:\n        //  - emit a public log containing the public fields (the value). The contract will later find it by searching\n        //  for the expected tag (which is simply the partial note commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_public_log(self.compute_note_completion_log(value));\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Completes the partial note, creating a new note that can be used like any other UintNote. Same as `complete`\n    /// function but works from private context.\n    pub fn complete_from_private(\n        self,\n        context: &mut PrivateContext,\n        completer: AztecAddress,\n        value: u128,\n    ) {\n        // We verify that the partial note we're completing is valid (i.e. completer is correct, it uses the correct\n        // state variable's storage slot, and it is internally consistent).\n        let validity_commitment = self.compute_validity_commitment(completer);\n        // `prove_nullifier_inclusion` function expects the nullifier to be siloed (hashed with the address of\n        // the contract that emitted the nullifier) as it checks the value directly against the nullifier tree and all\n        // the nullifiers in the tree are siloed by the protocol.\n        let siloed_validity_commitment =\n            compute_siloed_nullifier(context.this_address(), validity_commitment);\n        context.get_block_header().prove_nullifier_inclusion(siloed_validity_commitment);\n\n        // We need to do two things:\n        //  - emit an unencrypted log containing the public fields (the value) via the private log channel. The\n        //  contract will later find it by searching for the expected tag (which is simply the partial note\n        //  commitment).\n        //  - insert the completion note hash (i.e. the hash of the note) into the note hash tree. This is typically\n        //  only done in private to hide the preimage of the hash that is inserted, but completed partial notes are\n        //  inserted in public as the public values are provided and the note hash computed.\n        context.emit_private_log(\n            self.compute_note_completion_log_padded_for_private_log(value),\n            NOTE_COMPLETION_LOG_LENGTH,\n        );\n        context.push_note_hash(self.compute_complete_note_hash(value));\n    }\n\n    /// Computes a validity commitment for this partial note. The commitment cryptographically binds the note's private\n    /// data with the designated completer address. When the note is later completed in public execution, we can load\n    /// this commitment from the nullifier tree and verify that both the partial note (e.g. that the storage slot\n    /// corresponds to the correct owner, and that we're using the correct state variable) and completer are\n    /// legitimate.\n    pub fn compute_validity_commitment(self, completer: AztecAddress) -> Field {\n        poseidon2_hash_with_separator(\n            [self.commitment, completer.to_field()],\n            GENERATOR_INDEX__PARTIAL_NOTE_VALIDITY_COMMITMENT,\n        )\n    }\n\n    fn compute_note_completion_log(self, value: u128) -> [Field; NOTE_COMPLETION_LOG_LENGTH] {\n        // The first field of this log must be the tag that the recipient of the partial note private field logs\n        // expects, which is equal to the partial note commitment.\n        [self.commitment, value.to_field()]\n    }\n\n    fn compute_note_completion_log_padded_for_private_log(\n        self,\n        value: u128,\n    ) -> [Field; PRIVATE_LOG_SIZE_IN_FIELDS] {\n        let note_completion_log = self.compute_note_completion_log(value);\n        let padding = [0; PRIVATE_LOG_SIZE_IN_FIELDS - NOTE_COMPLETION_LOG_LENGTH];\n        note_completion_log.concat(padding)\n    }\n\n    fn compute_complete_note_hash(self, value: u128) -> Field {\n        // Here we finalize the note hash by including the (public) value into the partial note commitment. Note that we\n        // use the same generator index as we used for the first round of poseidon - this is not an issue.\n        poseidon2_hash_with_separator(\n            [self.commitment, value.to_field()],\n            GENERATOR_INDEX__NOTE_HASH,\n        )\n    }\n}\n\nimpl ToField for PartialUintNote {\n    fn to_field(self) -> Field {\n        self.commitment\n    }\n}\n\nimpl FromField for PartialUintNote {\n    fn from_field(field: Field) -> Self {\n        Self { commitment: field }\n    }\n}\n\nmod test {\n    use super::{\n        PartialUintNote, PrivateUintPartialNotePrivateLogContent, UintNote,\n        UintPartialNotePrivateContent,\n    };\n    use dep::aztec::{\n        note::note_interface::NoteHash,\n        protocol_types::{address::AztecAddress, traits::{Deserialize, FromField, Packable}},\n        utils::array::subarray,\n    };\n\n    global value: u128 = 17;\n    global randomness: Field = 42;\n    global owner: AztecAddress = AztecAddress::from_field(50);\n    global storage_slot: Field = 13;\n\n    #[test]\n    fn note_hash_matches_completed_partial_note_hash() {\n        // Tests that a UintNote has the same note hash as a PartialUintNote created and then completed with the same\n        // private values. This requires for the same hash function to be used in both flows, with the fields in the\n        // same order.\n\n        let note = UintNote { value, randomness, owner };\n        let note_hash = note.compute_note_hash(storage_slot);\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n\n        let partial_note = PartialUintNote {\n            commitment: partial_note_private_content.compute_partial_commitment(storage_slot),\n        };\n        let completed_partial_note_hash = partial_note.compute_complete_note_hash(value);\n\n        assert_eq(note_hash, completed_partial_note_hash);\n    }\n\n    #[test]\n    fn unpack_from_partial_note_encoding() {\n        // Tests that the packed representation of a regular UintNote can be reconstructed given the partial note\n        // private fields log and the public completion log, ensuring the recipient will be able to compute the\n        // completed note as if it were a regular UintNote.\n\n        let note = UintNote { value, randomness, owner };\n\n        let partial_note_private_content = UintPartialNotePrivateContent { owner, randomness };\n        let commitment = partial_note_private_content.compute_partial_commitment(storage_slot);\n\n        let private_log_content = PrivateUintPartialNotePrivateLogContent {\n            owner,\n            randomness,\n            public_log_tag: commitment,\n        };\n        // The following is a misuse of the `deserialize` function, but this is just a test and it's better than\n        // letting devs manually construct it when they shouldn't be able to.\n        let partial_note = PartialUintNote::deserialize([commitment]);\n\n        // The first field of the partial note private content is the public completion log tag, so it should match the\n        // first field of the public log.\n        assert_eq(\n            private_log_content.pack()[0],\n            partial_note.compute_note_completion_log(value)[0],\n        );\n\n        // Then we extract all fields except the first of both logs (i.e. the public log tag), and combine them to\n        // produce the note's packed representation. This requires that the members of the intermediate structs are in\n        // the same order as in UintNote.\n        let private_log_without_public_tag: [_; 2] = subarray(private_log_content.pack(), 1);\n        let public_log_without_tag: [_; 1] =\n            subarray(partial_note.compute_note_completion_log(value), 1);\n\n        assert_eq(private_log_without_public_tag.concat(public_log_without_tag), note.pack());\n    }\n}\n"
    },
    "42": {
      "path": "std/option.nr",
      "source": "use crate::cmp::{Eq, Ord, Ordering};\nuse crate::default::Default;\nuse crate::hash::{Hash, Hasher};\n\npub struct Option<T> {\n    _is_some: bool,\n    _value: T,\n}\n\nimpl<T> Option<T> {\n    /// Constructs a None value\n    pub fn none() -> Self {\n        Self { _is_some: false, _value: crate::mem::zeroed() }\n    }\n\n    /// Constructs a Some wrapper around the given value\n    pub fn some(_value: T) -> Self {\n        Self { _is_some: true, _value }\n    }\n\n    /// True if this Option is None\n    pub fn is_none(self) -> bool {\n        !self._is_some\n    }\n\n    /// True if this Option is Some\n    pub fn is_some(self) -> bool {\n        self._is_some\n    }\n\n    /// Asserts `self.is_some()` and returns the wrapped value.\n    pub fn unwrap(self) -> T {\n        assert(self._is_some);\n        self._value\n    }\n\n    /// Returns the inner value without asserting `self.is_some()`\n    /// Note that if `self` is `None`, there is no guarantee what value will be returned,\n    /// only that it will be of type `T`.\n    pub fn unwrap_unchecked(self) -> T {\n        self._value\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, returns the given default value.\n    pub fn unwrap_or(self, default: T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default\n        }\n    }\n\n    /// Returns the wrapped value if `self.is_some()`. Otherwise, calls the given function to return\n    /// a default value.\n    pub fn unwrap_or_else<Env>(self, default: fn[Env]() -> T) -> T {\n        if self._is_some {\n            self._value\n        } else {\n            default()\n        }\n    }\n\n    /// Asserts `self.is_some()` with a provided custom message and returns the contained `Some` value\n    pub fn expect<let N: u32, MessageTypes>(self, message: fmtstr<N, MessageTypes>) -> T {\n        assert(self.is_some(), message);\n        self._value\n    }\n\n    /// If self is `Some(x)`, this returns `Some(f(x))`. Otherwise, this returns `None`.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> Option<U> {\n        if self._is_some {\n            Option::some(f(self._value))\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns the given default value.\n    pub fn map_or<U, Env>(self, default: U, f: fn[Env](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default\n        }\n    }\n\n    /// If self is `Some(x)`, this returns `f(x)`. Otherwise, this returns `default()`.\n    pub fn map_or_else<U, Env1, Env2>(self, default: fn[Env1]() -> U, f: fn[Env2](T) -> U) -> U {\n        if self._is_some {\n            f(self._value)\n        } else {\n            default()\n        }\n    }\n\n    /// Returns None if self is None. Otherwise, this returns `other`.\n    pub fn and(self, other: Self) -> Self {\n        if self.is_none() {\n            Option::none()\n        } else {\n            other\n        }\n    }\n\n    /// If self is None, this returns None. Otherwise, this calls the given function\n    /// with the Some value contained within self, and returns the result of that call.\n    ///\n    /// In some languages this function is called `flat_map` or `bind`.\n    pub fn and_then<U, Env>(self, f: fn[Env](T) -> Option<U>) -> Option<U> {\n        if self._is_some {\n            f(self._value)\n        } else {\n            Option::none()\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `other`.\n    pub fn or(self, other: Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            other\n        }\n    }\n\n    /// If self is Some, return self. Otherwise, return `default()`.\n    pub fn or_else<Env>(self, default: fn[Env]() -> Self) -> Self {\n        if self._is_some {\n            self\n        } else {\n            default()\n        }\n    }\n\n    // If only one of the two Options is Some, return that option.\n    // Otherwise, if both options are Some or both are None, None is returned.\n    pub fn xor(self, other: Self) -> Self {\n        if self._is_some {\n            if other._is_some {\n                Option::none()\n            } else {\n                self\n            }\n        } else if other._is_some {\n            other\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Returns `Some(x)` if self is `Some(x)` and `predicate(x)` is true.\n    /// Otherwise, this returns `None`\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        if self._is_some {\n            if predicate(self._value) {\n                self\n            } else {\n                Option::none()\n            }\n        } else {\n            Option::none()\n        }\n    }\n\n    /// Flattens an Option<Option<T>> into a Option<T>.\n    /// This returns None if the outer Option is None. Otherwise, this returns the inner Option.\n    pub fn flatten(option: Option<Option<T>>) -> Option<T> {\n        if option._is_some {\n            option._value\n        } else {\n            Option::none()\n        }\n    }\n}\n\nimpl<T> Default for Option<T> {\n    fn default() -> Self {\n        Option::none()\n    }\n}\n\nimpl<T> Eq for Option<T>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: Self) -> bool {\n        if self._is_some == other._is_some {\n            if self._is_some {\n                self._value == other._value\n            } else {\n                true\n            }\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T> Hash for Option<T>\nwhere\n    T: Hash,\n{\n    fn hash<H>(self, state: &mut H)\n    where\n        H: Hasher,\n    {\n        self._is_some.hash(state);\n        if self._is_some {\n            self._value.hash(state);\n        }\n    }\n}\n\n// For this impl we're declaring Option::none < Option::some\nimpl<T> Ord for Option<T>\nwhere\n    T: Ord,\n{\n    fn cmp(self, other: Self) -> Ordering {\n        if self._is_some {\n            if other._is_some {\n                self._value.cmp(other._value)\n            } else {\n                Ordering::greater()\n            }\n        } else if other._is_some {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n"
    },
    "43": {
      "path": "std/panic.nr",
      "source": "pub fn panic<T, U, let N: u32>(message: fmtstr<N, T>) -> U {\n    assert(false, message);\n    crate::mem::zeroed()\n}\n"
    },
    "46": {
      "path": "std/slice.nr",
      "source": "use crate::append::Append;\n\nimpl<T> [T] {\n    /// Returns the length of the slice.\n    #[builtin(array_len)]\n    pub fn len(self) -> u32 {}\n\n    /// Push a new element to the end of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_back)]\n    pub fn push_back(self, elem: T) -> Self {}\n\n    /// Push a new element to the front of the slice, returning a\n    /// new slice with a length one greater than the\n    /// original unmodified slice.\n    #[builtin(slice_push_front)]\n    pub fn push_front(self, elem: T) -> Self {}\n\n    /// Remove the last element of the slice, returning the\n    /// popped slice and the element in a tuple\n    #[builtin(slice_pop_back)]\n    pub fn pop_back(self) -> (Self, T) {}\n\n    /// Remove the first element of the slice, returning the\n    /// element and the popped slice in a tuple\n    #[builtin(slice_pop_front)]\n    pub fn pop_front(self) -> (T, Self) {}\n\n    /// Insert an element at a specified index, shifting all elements\n    /// after it to the right\n    #[builtin(slice_insert)]\n    pub fn insert(self, index: u32, elem: T) -> Self {}\n\n    /// Remove an element at a specified index, shifting all elements\n    /// after it to the left, returning the altered slice and\n    /// the removed element\n    #[builtin(slice_remove)]\n    pub fn remove(self, index: u32) -> (Self, T) {}\n\n    /// Append each element of the `other` slice to the end of `self`.\n    /// This returns a new slice and leaves both input slices unchanged.\n    pub fn append(mut self, other: Self) -> Self {\n        for elem in other {\n            self = self.push_back(elem);\n        }\n        self\n    }\n\n    pub fn as_array<let N: u32>(self) -> [T; N] {\n        assert(self.len() == N);\n\n        let mut array = [crate::mem::zeroed(); N];\n        for i in 0..N {\n            array[i] = self[i];\n        }\n        array\n    }\n\n    // Apply a function to each element of the slice, returning a new slice\n    // containing the mapped elements.\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> [U] {\n        let mut ret = &[];\n        for elem in self {\n            ret = ret.push_back(f(elem));\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice with its index, returning a\n    // new slice containing the mapped elements.\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> [U] {\n        let mut ret = &[];\n        let mut index = 0;\n        for elem in self {\n            ret = ret.push_back(f(index, elem));\n            index += 1;\n        }\n        ret\n    }\n\n    // Apply a function to each element of the slice\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        for elem in self {\n            f(elem);\n        }\n    }\n\n    // Apply a function to each element of the slice with its index\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        let mut index = 0;\n        for elem in self {\n            f(index, elem);\n            index += 1;\n        }\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. This function is also sometimes\n    // called `foldl`, `fold_left`, `reduce`, or `inject`.\n    pub fn fold<U, Env>(self, mut accumulator: U, f: fn[Env](U, T) -> U) -> U {\n        for elem in self {\n            accumulator = f(accumulator, elem);\n        }\n        accumulator\n    }\n\n    // Apply a function to each element of the slice and an accumulator value,\n    // returning the final accumulated value. Unlike fold, reduce uses the first\n    // element of the given slice as its starting accumulator value.\n    pub fn reduce<Env>(self, f: fn[Env](T, T) -> T) -> T {\n        let mut accumulator = self[0];\n        for i in 1..self.len() {\n            accumulator = f(accumulator, self[i]);\n        }\n        accumulator\n    }\n\n    // Returns a new slice containing only elements for which the given predicate\n    // returns true.\n    pub fn filter<Env>(self, predicate: fn[Env](T) -> bool) -> Self {\n        let mut ret = &[];\n        for elem in self {\n            if predicate(elem) {\n                ret = ret.push_back(elem);\n            }\n        }\n        ret\n    }\n\n    // Flatten each element in the slice into one value, separated by `separator`.\n    pub fn join(self, separator: T) -> T\n    where\n        T: Append,\n    {\n        let mut ret = T::empty();\n\n        if self.len() != 0 {\n            ret = self[0];\n\n            for i in 1..self.len() {\n                ret = ret.append(separator).append(self[i]);\n            }\n        }\n\n        ret\n    }\n\n    // Returns true if all elements in the slice satisfy the predicate\n    pub fn all<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = true;\n        for elem in self {\n            ret &= predicate(elem);\n        }\n        ret\n    }\n\n    // Returns true if any element in the slice satisfies the predicate\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        for elem in self {\n            ret |= predicate(elem);\n        }\n        ret\n    }\n}\n\nmod test {\n    #[test]\n    fn map_empty() {\n        assert_eq(&[].map(|x| x + 1), &[]);\n    }\n\n    #[test]\n    fn mapi_empty() {\n        assert_eq(&[].mapi(|i, x| i * x + 1), &[]);\n    }\n\n    #[test]\n    fn for_each_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_each(|_x| assert(false));\n    }\n\n    #[test]\n    fn for_eachi_empty() {\n        let empty_slice: [Field] = &[];\n        empty_slice.for_eachi(|_i, _x| assert(false));\n    }\n\n    #[test]\n    fn map_example() {\n        let a = &[1, 2, 3];\n        let b = a.map(|a| a * 2);\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn mapi_example() {\n        let a = &[1, 2, 3];\n        let b = a.mapi(|i, a| i + a * 2);\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n    #[test]\n    fn for_each_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_each(|a| { *b_ref = b_ref.push_back(a * 2); });\n        assert_eq(b, &[2, 4, 6]);\n    }\n\n    #[test]\n    fn for_eachi_example() {\n        let a = &[1, 2, 3];\n        let mut b = &[];\n        let b_ref = &mut b;\n        a.for_eachi(|i, a| { *b_ref = b_ref.push_back(i + a * 2); });\n        assert_eq(b, &[2, 5, 8]);\n    }\n\n}\n"
    },
    "5": {
      "path": "std/cmp.nr",
      "source": "use crate::meta::derive_via;\n\n#[derive_via(derive_eq)]\n// docs:start:eq-trait\npub trait Eq {\n    fn eq(self, other: Self) -> bool;\n}\n// docs:end:eq-trait\n\n// docs:start:derive_eq\ncomptime fn derive_eq(s: TypeDefinition) -> Quoted {\n    let signature = quote { fn eq(_self: Self, _other: Self) -> bool };\n    let for_each_field = |name| quote { (_self.$name == _other.$name) };\n    let body = |fields| {\n        if s.fields_as_written().len() == 0 {\n            quote { true }\n        } else {\n            fields\n        }\n    };\n    crate::meta::make_trait_impl(\n        s,\n        quote { $crate::cmp::Eq },\n        signature,\n        for_each_field,\n        quote { & },\n        body,\n    )\n}\n// docs:end:derive_eq\n\nimpl Eq for Field {\n    fn eq(self, other: Field) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for u128 {\n    fn eq(self, other: u128) -> bool {\n        self == other\n    }\n}\nimpl Eq for u64 {\n    fn eq(self, other: u64) -> bool {\n        self == other\n    }\n}\nimpl Eq for u32 {\n    fn eq(self, other: u32) -> bool {\n        self == other\n    }\n}\nimpl Eq for u16 {\n    fn eq(self, other: u16) -> bool {\n        self == other\n    }\n}\nimpl Eq for u8 {\n    fn eq(self, other: u8) -> bool {\n        self == other\n    }\n}\nimpl Eq for u1 {\n    fn eq(self, other: u1) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for i8 {\n    fn eq(self, other: i8) -> bool {\n        self == other\n    }\n}\nimpl Eq for i16 {\n    fn eq(self, other: i16) -> bool {\n        self == other\n    }\n}\nimpl Eq for i32 {\n    fn eq(self, other: i32) -> bool {\n        self == other\n    }\n}\nimpl Eq for i64 {\n    fn eq(self, other: i64) -> bool {\n        self == other\n    }\n}\n\nimpl Eq for () {\n    fn eq(_self: Self, _other: ()) -> bool {\n        true\n    }\n}\nimpl Eq for bool {\n    fn eq(self, other: bool) -> bool {\n        self == other\n    }\n}\n\nimpl<T, let N: u32> Eq for [T; N]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T; N]) -> bool {\n        let mut result = true;\n        for i in 0..self.len() {\n            result &= self[i].eq(other[i]);\n        }\n        result\n    }\n}\n\nimpl<T> Eq for [T]\nwhere\n    T: Eq,\n{\n    fn eq(self, other: [T]) -> bool {\n        let mut result = self.len() == other.len();\n        if result {\n            for i in 0..self.len() {\n                result &= self[i].eq(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<let N: u32> Eq for str<N> {\n    fn eq(self, other: str<N>) -> bool {\n        let self_bytes = self.as_bytes();\n        let other_bytes = other.as_bytes();\n        self_bytes == other_bytes\n    }\n}\n\nimpl<A, B> Eq for (A, B)\nwhere\n    A: Eq,\n    B: Eq,\n{\n    fn eq(self, other: (A, B)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1)\n    }\n}\n\nimpl<A, B, C> Eq for (A, B, C)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n{\n    fn eq(self, other: (A, B, C)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2)\n    }\n}\n\nimpl<A, B, C, D> Eq for (A, B, C, D)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n{\n    fn eq(self, other: (A, B, C, D)) -> bool {\n        self.0.eq(other.0) & self.1.eq(other.1) & self.2.eq(other.2) & self.3.eq(other.3)\n    }\n}\n\nimpl<A, B, C, D, E> Eq for (A, B, C, D, E)\nwhere\n    A: Eq,\n    B: Eq,\n    C: Eq,\n    D: Eq,\n    E: Eq,\n{\n    fn eq(self, other: (A, B, C, D, E)) -> bool {\n        self.0.eq(other.0)\n            & self.1.eq(other.1)\n            & self.2.eq(other.2)\n            & self.3.eq(other.3)\n            & self.4.eq(other.4)\n    }\n}\n\nimpl Eq for Ordering {\n    fn eq(self, other: Ordering) -> bool {\n        self.result == other.result\n    }\n}\n\n// Noir doesn't have enums yet so we emulate (Lt | Eq | Gt) with a struct\n// that has 3 public functions for constructing the struct.\npub struct Ordering {\n    result: Field,\n}\n\nimpl Ordering {\n    // Implementation note: 0, 1, and 2 for Lt, Eq, and Gt are built\n    // into the compiler, do not change these without also updating\n    // the compiler itself!\n    pub fn less() -> Ordering {\n        Ordering { result: 0 }\n    }\n\n    pub fn equal() -> Ordering {\n        Ordering { result: 1 }\n    }\n\n    pub fn greater() -> Ordering {\n        Ordering { result: 2 }\n    }\n}\n\n#[derive_via(derive_ord)]\n// docs:start:ord-trait\npub trait Ord {\n    fn cmp(self, other: Self) -> Ordering;\n}\n// docs:end:ord-trait\n\n// docs:start:derive_ord\ncomptime fn derive_ord(s: TypeDefinition) -> Quoted {\n    let name = quote { $crate::cmp::Ord };\n    let signature = quote { fn cmp(_self: Self, _other: Self) -> $crate::cmp::Ordering };\n    let for_each_field = |name| quote {\n        if result == $crate::cmp::Ordering::equal() {\n            result = _self.$name.cmp(_other.$name);\n        }\n    };\n    let body = |fields| quote {\n        let mut result = $crate::cmp::Ordering::equal();\n        $fields\n        result\n    };\n    crate::meta::make_trait_impl(s, name, signature, for_each_field, quote {}, body)\n}\n// docs:end:derive_ord\n\n// Note: Field deliberately does not implement Ord\n\nimpl Ord for u128 {\n    fn cmp(self, other: u128) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\nimpl Ord for u64 {\n    fn cmp(self, other: u64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u32 {\n    fn cmp(self, other: u32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u16 {\n    fn cmp(self, other: u16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for u8 {\n    fn cmp(self, other: u8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i8 {\n    fn cmp(self, other: i8) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i16 {\n    fn cmp(self, other: i16) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i32 {\n    fn cmp(self, other: i32) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for i64 {\n    fn cmp(self, other: i64) -> Ordering {\n        if self < other {\n            Ordering::less()\n        } else if self > other {\n            Ordering::greater()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl Ord for () {\n    fn cmp(_self: Self, _other: ()) -> Ordering {\n        Ordering::equal()\n    }\n}\n\nimpl Ord for bool {\n    fn cmp(self, other: bool) -> Ordering {\n        if self {\n            if other {\n                Ordering::equal()\n            } else {\n                Ordering::greater()\n            }\n        } else if other {\n            Ordering::less()\n        } else {\n            Ordering::equal()\n        }\n    }\n}\n\nimpl<T, let N: u32> Ord for [T; N]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T; N]) -> Ordering {\n        let mut result = Ordering::equal();\n        for i in 0..self.len() {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n        result\n    }\n}\n\nimpl<T> Ord for [T]\nwhere\n    T: Ord,\n{\n    // The first non-equal element of both arrays determines\n    // the ordering for the whole array.\n    fn cmp(self, other: [T]) -> Ordering {\n        let self_len = self.len();\n        let other_len = other.len();\n        let min_len = if self_len < other_len {\n            self_len\n        } else {\n            other_len\n        };\n\n        let mut result = Ordering::equal();\n        for i in 0..min_len {\n            if result == Ordering::equal() {\n                result = self[i].cmp(other[i]);\n            }\n        }\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self_len.cmp(other_len)\n        }\n    }\n}\n\nimpl<A, B> Ord for (A, B)\nwhere\n    A: Ord,\n    B: Ord,\n{\n    fn cmp(self, other: (A, B)) -> Ordering {\n        let result = self.0.cmp(other.0);\n\n        if result != Ordering::equal() {\n            result\n        } else {\n            self.1.cmp(other.1)\n        }\n    }\n}\n\nimpl<A, B, C> Ord for (A, B, C)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n{\n    fn cmp(self, other: (A, B, C)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D> Ord for (A, B, C, D)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n{\n    fn cmp(self, other: (A, B, C, D)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        result\n    }\n}\n\nimpl<A, B, C, D, E> Ord for (A, B, C, D, E)\nwhere\n    A: Ord,\n    B: Ord,\n    C: Ord,\n    D: Ord,\n    E: Ord,\n{\n    fn cmp(self, other: (A, B, C, D, E)) -> Ordering {\n        let mut result = self.0.cmp(other.0);\n\n        if result == Ordering::equal() {\n            result = self.1.cmp(other.1);\n        }\n\n        if result == Ordering::equal() {\n            result = self.2.cmp(other.2);\n        }\n\n        if result == Ordering::equal() {\n            result = self.3.cmp(other.3);\n        }\n\n        if result == Ordering::equal() {\n            result = self.4.cmp(other.4);\n        }\n\n        result\n    }\n}\n\n// Compares and returns the maximum of two values.\n//\n// Returns the second argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::max(1, 2), 2);\n// assert_eq(cmp::max(2, 2), 2);\n// ```\npub fn max<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v1\n    } else {\n        v2\n    }\n}\n\n// Compares and returns the minimum of two values.\n//\n// Returns the first argument if the comparison determines them to be equal.\n//\n// # Examples\n//\n// ```\n// use std::cmp;\n//\n// assert_eq(cmp::min(1, 2), 1);\n// assert_eq(cmp::min(2, 2), 2);\n// ```\npub fn min<T>(v1: T, v2: T) -> T\nwhere\n    T: Ord,\n{\n    if v1 > v2 {\n        v2\n    } else {\n        v1\n    }\n}\n\nmod cmp_tests {\n    use super::{Eq, max, min, Ord};\n\n    #[test]\n    fn sanity_check_min() {\n        assert_eq(min(0_u64, 1), 0);\n        assert_eq(min(0_u64, 0), 0);\n        assert_eq(min(1_u64, 1), 1);\n        assert_eq(min(255_u8, 0), 0);\n    }\n\n    #[test]\n    fn sanity_check_max() {\n        assert_eq(max(0_u64, 1), 1);\n        assert_eq(max(0_u64, 0), 0);\n        assert_eq(max(1_u64, 1), 1);\n        assert_eq(max(255_u8, 0), 255);\n    }\n\n    #[test]\n    fn correctly_handles_unequal_length_slices() {\n        let slice_1 = &[0, 1, 2, 3];\n        let slice_2 = &[0, 1, 2];\n        assert(!slice_1.eq(slice_2));\n    }\n\n    #[test]\n    fn lexicographic_ordering_for_slices() {\n        assert(&[2_u32].cmp(&[1_u32, 1_u32, 1_u32]) == super::Ordering::greater());\n        assert(&[1_u32, 2_u32].cmp(&[1_u32, 2_u32, 3_u32]) == super::Ordering::less());\n    }\n}\n"
    },
    "51": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/amm_contract/src/lib.nr",
      "source": "/// Given an input amount of an asset and pair balances, returns the maximum output amount of the other asset.\npub fn get_amount_out(amount_in: u128, balance_in: u128, balance_out: u128) -> u128 {\n    assert(amount_in > 0 as u128, \"INSUFFICIENT_INPUT_AMOUNT\");\n    assert((balance_in > 0 as u128) & (balance_out > 0 as u128), \"INSUFFICIENT_LIQUIDITY\");\n\n    // The expression below is:\n    //    (amount_in * 997 * balance_out) / (balance_in * 10000 + amount_in * 997)\n    // which is equivalent to:\n    //    balance_out * ((amount_in * 0.997) / (balance_in + amount_in * 0.997))\n    // resulting in an implicit 0.3% fee on the amount in, as the fee tokens are not taken into consideration.\n\n    let amount_in_with_fee = amount_in * 997 as u128;\n    let numerator = amount_in_with_fee * balance_out;\n    let denominator = balance_in * 1000 as u128 + amount_in_with_fee;\n    numerator / denominator\n}\n\n/// Given an output amount of an asset and pair balances, returns a required input amount of the other asset.\npub fn get_amount_in(amount_out: u128, balance_in: u128, balance_out: u128) -> u128 {\n    assert(amount_out > 0 as u128, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n    assert((balance_in > 0 as u128) & (balance_out > 0 as u128), \"INSUFFICIENT_LIQUIDITY\");\n\n    // The expression below is:\n    //    (balance_in * amount_out * 1000) / (balance_out - amount_out * 997) + 1\n    // which is equivalent to:\n    //    balance_in * (amount_out / (balance_in + amount_in)) *  1/0.997 + 1\n    // resulting in an implicit 0.3% fee on the amount in, as the fee tokens are not taken into consideration. The +1\n    // at the end ensures the rounding error favors the pool.\n\n    let numerator = balance_in * amount_out * 1000 as u128;\n    let denominator = (balance_out - amount_out) * 997 as u128;\n    (numerator / denominator) + 1 as u128\n}\n\n/// Given the desired amounts and balances of token0 and token1 returns the optimal amount of token0 and token1 to be added to the pool.\npub fn get_amounts_to_add(\n    amount0_max: u128,\n    amount1_max: u128,\n    amount0_min: u128,\n    amount1_min: u128,\n    balance0: u128,\n    balance1: u128,\n) -> (u128, u128) {\n    // When adding tokens, both balances must grow by the same ratio, which means that their spot price is unchanged.\n    // Since any swaps would affect these ratios, liquidity providers supply a range of minimum and maximum balances\n    // they are willing to supply for each token (which translates to minimum and maximum relative prices of the\n    // tokens, preventing loss of value outside of this range due to e.g. front-running).\n\n    if (balance0 == 0 as u128) | (balance1 == 0 as u128) {\n        // The token balances should only be zero when initializing the pool. In this scenario there is no prior ratio\n        // to follow so we simply transfer the full maximum balance - it is up to the caller to make sure that the ratio\n        // they've chosen results in a a reasonable spot price.\n        (amount0_max, amount1_max)\n    } else {\n        // There is a huge number of amount combinations that respect the minimum and maximum for each token, but we'll\n        // only consider the two scenarios in which one of the amounts is the maximum amount.\n\n        // First we calculate the token1 amount that'd need to be supplied if we used the maximum amount for token0.\n        let amount1_equivalent = get_equivalent_amount(amount0_max, balance0, balance1);\n        if (amount1_equivalent <= amount1_max) {\n            assert(amount1_equivalent >= amount1_min, \"AMOUNT_1_BELOW_MINIMUM\");\n            (amount0_max, amount1_equivalent)\n        } else {\n            // If the max amount for token0 results in a token1 amount larger than the maximum, then we try with the\n            // maximum token1 amount, hoping that it'll result in a token0 amount larger than the minimum.\n            let amount0_equivalent = get_equivalent_amount(amount1_max, balance1, balance0);\n            // This should never happen, as it'd imply that the maximum is lower than the minimum.\n            assert(amount0_equivalent <= amount0_max);\n\n            assert(amount0_equivalent >= amount0_min, \"AMOUNT_0_BELOW_MINIMUM\");\n            (amount0_equivalent, amount1_max)\n        }\n    }\n}\n\n/// Returns the amount of tokens to return to a liquidity provider when they remove liquidity from the pool.\npub fn get_amounts_on_remove(\n    to_burn: u128,\n    total_supply: u128,\n    balance0: u128,\n    balance1: u128,\n) -> (u128, u128) {\n    // Since the liquidity token tracks ownership of the pool, the liquidity provider gets a proportional share of each\n    // token.\n    (to_burn * balance0 / total_supply, to_burn * balance1 / total_supply)\n}\n\n/// Given some amount of an asset and pair balances, returns an equivalent amount of the other asset. Tokens should be\n/// added and removed from the Pool respecting this ratio.\nfn get_equivalent_amount(amount0: u128, balance0: u128, balance1: u128) -> u128 {\n    assert((balance0 > 0 as u128) & (balance1 > 0 as u128), \"INSUFFICIENT_LIQUIDITY\");\n\n    // This is essentially the Rule of Three, since we're computing proportional ratios. Note we divide at the end to\n    // avoid introducing too much error due to truncation.\n    (amount0 * balance1) / balance0\n}\n"
    },
    "52": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/noir-contracts/contracts/app/amm_contract/src/main.nr",
      "source": "mod lib;\nmod config;\nmod test;\n\nuse dep::aztec::macros::aztec;\n\n/// ## Overview\n/// This contract demonstrates how to implement an **Automated Market Maker (AMM)** that maintains **public state**\n/// while still achieving **identity privacy**. However, it does **not provide function privacy**:\n/// - Anyone can observe **what actions** were performed.\n/// - All amounts involved are visible, but **who** performed the action remains private.\n///\n/// Unlike most Ethereum AMMs, the AMM contract is not itself the token that tracks participation of liquidity\n/// providers, mostly due to Noir lacking inheritance as a feature. Instead, the AMM is expected to have mint and burn\n/// permission over an external token contract.\n///\n/// **Note:**\n/// This is purely a demonstration. The **Aztec team** does not consider this the optimal design for building a DEX.\n///\n/// ## Reentrancy Guard Considerations\n///\n/// ### 1. Private Functions:\n/// Reentrancy protection is typically necessary if entering an intermediate state that is only valid when\n/// the action completes uninterrupted. This follows the **Checks-Effects-Interactions** pattern.\n///\n/// - In this contract, **private functions** do not introduce intermediate states.\n/// - All operations will be fully executed in **public** without needing intermediate checks.\n///\n/// ### 2. Public Functions:\n/// No **reentrancy guard** is required for public functions because:\n/// - All public functions are marked as **internal** with a **single callsite** - from a private function.\n/// - Public functions **cannot call private functions**, eliminating the risk of reentering into them from private.\n/// - Since public functions are internal-only, **external contracts cannot access them**, ensuring no external\n///   contract can trigger a reentrant call. This eliminates the following attack vector:\n///   `AMM.private_fn --> AMM.public_fn --> ExternalContract.fn --> AMM.public_fn`.\n#[aztec]\npub contract AMM {\n    use crate::{\n        config::Config,\n        lib::{get_amount_in, get_amount_out, get_amounts_on_remove, get_amounts_to_add},\n    };\n    use dep::aztec::{\n        macros::{functions::{initializer, internal, private, public, utility}, storage::storage},\n        protocol_types::address::AztecAddress,\n        state_vars::PublicImmutable,\n    };\n\n    use dep::token::Token;\n    use dep::uint_note::uint_note::PartialUintNote;\n\n    #[storage]\n    struct Storage<Context> {\n        config: PublicImmutable<Config, Context>,\n    }\n\n    /// Amount of liquidity which gets locked when liquidity is provided for the first time. Its purpose is to prevent\n    /// the pool from ever emptying which could lead to undefined behavior.\n    pub global MINIMUM_LIQUIDITY: u128 = 1000;\n    /// We set it to 99 times the minimum liquidity. That way the first LP gets 99% of the value of their deposit.\n    pub global INITIAL_LIQUIDITY: u128 = 99000;\n\n    // TODO(#9480): Either deploy the liquidity contract in the constructor or verify it that it corresponds to what\n    // this contract expects (i.e. that the AMM has permission to mint and burn).\n    #[public]\n    #[initializer]\n    fn constructor(token0: AztecAddress, token1: AztecAddress, liquidity_token: AztecAddress) {\n        storage.config.initialize(Config { token0, token1, liquidity_token });\n    }\n\n    /// Privately adds liquidity to the pool. This function receives the minimum and maximum number of tokens the caller\n    /// is willing to add, in order to account for changing market conditions, and will try to add as many tokens as\n    /// possible.\n    ///\n    /// `authwit_nonce` can be any non-zero value, as it's only used to isolate token transfer authwits to this\n    /// specific call.\n    ///\n    /// The identity of the liquidity provider is not revealed, but the action and amounts are.\n    #[private]\n    fn add_liquidity(\n        amount0_max: u128,\n        amount1_max: u128,\n        amount0_min: u128,\n        amount1_min: u128,\n        authwit_nonce: Field,\n    ) {\n        assert(\n            (amount0_min < amount0_max) | (amount0_min == amount0_max),\n            \"INCORRECT_TOKEN0_LIMITS\",\n        );\n        assert(\n            (amount1_min < amount1_max) | (amount1_min == amount1_max),\n            \"INCORRECT_TOKEN1_LIMITS\",\n        );\n        assert((0 as u128 < amount0_max) & (0 as u128 < amount1_max), \"INSUFFICIENT_INPUT_AMOUNTS\");\n\n        let config = storage.config.read();\n\n        let token0 = Token::at(config.token0);\n        let token1 = Token::at(config.token1);\n        let liquidity_token = Token::at(config.liquidity_token);\n\n        let sender = context.msg_sender();\n\n        // We don't yet know how many tokens the sender will actually supply - that can only be computed during public\n        // execution since the amounts supplied must have the same ratio as the live balances. We therefore transfer the\n        // maximum amounts here, and prepare partial notes that return the change to the sender (if any).\n        let refund_token0_partial_note = token0\n            .transfer_to_public_and_prepare_private_balance_increase(\n                sender,\n                context.this_address(),\n                amount0_max,\n                authwit_nonce,\n            )\n            .call(&mut context);\n\n        let refund_token1_partial_note = token1\n            .transfer_to_public_and_prepare_private_balance_increase(\n                sender,\n                context.this_address(),\n                amount1_max,\n                authwit_nonce,\n            )\n            .call(&mut context);\n\n        // The number of liquidity tokens to mint for the caller depends on both the live balances and the amount\n        // supplied, both of which can only be known during public execution. We therefore prepare a partial note that\n        // will get completed via minting.\n        let liquidity_partial_note =\n            liquidity_token.prepare_private_balance_increase(sender).call(&mut context);\n\n        // We then complete the flow in public. Note that the type of operation and amounts will all be publicly known,\n        // but the identity of the caller is not revealed despite us being able to send tokens to them by completing the\n        // partial notes.\n        AMM::at(context.this_address())\n            ._add_liquidity(\n                config,\n                refund_token0_partial_note,\n                refund_token1_partial_note,\n                liquidity_partial_note,\n                amount0_max,\n                amount1_max,\n                amount0_min,\n                amount1_min,\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _add_liquidity(\n        config: Config, // We could read this in public, but it's cheaper to receive from private\n        refund_token0_partial_note: PartialUintNote,\n        refund_token1_partial_note: PartialUintNote,\n        liquidity_partial_note: PartialUintNote,\n        amount0_max: u128,\n        amount1_max: u128,\n        amount0_min: u128,\n        amount1_min: u128,\n    ) {\n        let token0 = Token::at(config.token0);\n        let token1 = Token::at(config.token1);\n        let liquidity_token = Token::at(config.liquidity_token);\n\n        // We read the current AMM balance of both tokens. Note that by the time this function is called the token\n        // transfers have already been completed (since those calls were enqueued before this call), and so we need to\n        // subtract the transfer amount to get the pre-deposit balance.\n        let balance0_plus_amount0_max =\n            token0.balance_of_public(context.this_address()).view(&mut context);\n        let balance0 = balance0_plus_amount0_max - amount0_max;\n\n        let balance1_plus_amount1_max =\n            token1.balance_of_public(context.this_address()).view(&mut context);\n        let balance1 = balance1_plus_amount1_max - amount1_max;\n\n        // With the current balances known, we can calculate the token amounts to the pool, respecting the user's\n        // minimum deposit preferences.\n        let (amount0, amount1) = get_amounts_to_add(\n            amount0_max,\n            amount1_max,\n            amount0_min,\n            amount1_min,\n            balance0,\n            balance1,\n        );\n\n        // Return any excess from the original token deposits.\n        let refund_amount_token0 = amount0_max - amount0;\n        let refund_amount_token1 = amount1_max - amount1;\n\n        // We can simply skip the refund if the amount to return is 0 in order to save gas: the partial note will\n        // simply stay in public storage and not be completed, but this is not an issue.\n        if (refund_amount_token0 > 0 as u128) {\n            token0\n                .finalize_transfer_to_private(refund_amount_token0, refund_token0_partial_note)\n                .call(&mut context);\n        }\n        if (refund_amount_token1 > 0 as u128) {\n            token1\n                .finalize_transfer_to_private(refund_amount_token1, refund_token1_partial_note)\n                .call(&mut context);\n        }\n\n        // With the deposit amounts known, we can compute the number of liquidity tokens to mint and finalize the\n        // depositor's partial note.\n        let total_supply = liquidity_token.total_supply().view(&mut context);\n        let liquidity_amount = if total_supply != 0 as u128 {\n            // The liquidity token supply increases by the same ratio as the balances. In case one of the token balances\n            // increased with a ratio different from the other one, we simply take the smallest value.\n            std::cmp::min(\n                (amount0 * total_supply) / balance0,\n                (amount1 * total_supply) / balance1,\n            )\n        } else {\n            // The zero total supply case (i.e. pool initialization) is special as we can't increase the supply\n            // proportionally. We instead set the initial liquidity to an arbitrary amount.\n            // We could set the initial liquidity to be equal to the pool invariant (i.e. sqrt(amount0 * amount1)) if\n            // we wanted to collect protocol fees over swap fees (in the style of Uniswap v2), but we choose not to in\n            // order to keep things simple.\n\n            // As part of initialization, we mint some tokens to the zero address to 'lock' them (i.e. make them\n            // impossible to redeem), guaranteeing total supply will never be zero again.\n            liquidity_token.mint_to_public(AztecAddress::zero(), MINIMUM_LIQUIDITY).call(\n                &mut context,\n            );\n\n            INITIAL_LIQUIDITY\n        };\n\n        assert(liquidity_amount > 0 as u128, \"INSUFFICIENT_LIQUIDITY_MINTED\");\n        liquidity_token.finalize_mint_to_private(liquidity_amount, liquidity_partial_note).call(\n            &mut context,\n        );\n    }\n\n    /// Privately removes liquidity from the pool. This function receives how many liquidity tokens to burn, and the\n    /// minimum number of tokens the caller is willing to receive, in order to account for changing market conditions.\n    ///\n    /// `authwit_nonce` can be any non-zero value, as it's only used to isolate token transfer authwits to this\n    /// specific call.\n    ///\n    /// The identity of the liquidity provider is not revealed, but the action and amounts are.\n    #[private]\n    fn remove_liquidity(\n        liquidity: u128,\n        amount0_min: u128,\n        amount1_min: u128,\n        authwit_nonce: Field,\n    ) {\n        let config = storage.config.read();\n\n        let liquidity_token = Token::at(config.liquidity_token);\n        let token0 = Token::at(config.token0);\n        let token1 = Token::at(config.token1);\n\n        let sender = context.msg_sender();\n\n        // Liquidity tokens are burned when liquidity is removed in order to reduce the total supply. However, we lack\n        // a function to privately burn, so we instead transfer the tokens into the AMM's public balance, and then have\n        // the AMM publicly burn its own tokens.\n        // TODO(#10287): consider adding a private burn\n        liquidity_token\n            .transfer_to_public(sender, context.this_address(), liquidity, authwit_nonce)\n            .call(&mut context);\n\n        // We don't yet know how many tokens the sender will get - that can only be computed during public execution\n        // since the it depends on the live balances. We therefore simply prepare partial notes to the sender.\n        let token0_partial_note =\n            token0.prepare_private_balance_increase(sender).call(&mut context);\n        let token1_partial_note =\n            token1.prepare_private_balance_increase(sender).call(&mut context);\n\n        // We then complete the flow in public. Note that the type of operation and amounts will all be publicly known,\n        // but the identity of the caller is not revealed despite us being able to send tokens to them by completing the\n        // partial notes.\n        AMM::at(context.this_address())\n            ._remove_liquidity(\n                config,\n                liquidity,\n                token0_partial_note,\n                token1_partial_note,\n                amount0_min,\n                amount1_min,\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _remove_liquidity(\n        config: Config, // We could read this in public, but it's cheaper to receive from private\n        liquidity: u128,\n        token0_partial_note: PartialUintNote,\n        token1_partial_note: PartialUintNote,\n        amount0_min: u128,\n        amount1_min: u128,\n    ) {\n        let token0 = Token::at(config.token0);\n        let token1 = Token::at(config.token1);\n        let liquidity_token = Token::at(config.liquidity_token);\n\n        // We need the current balance of both tokens as well as the liquidity token total supply in order to compute\n        // the amounts to send the user.\n        let balance0 = token0.balance_of_public(context.this_address()).view(&mut context);\n        let balance1 = token1.balance_of_public(context.this_address()).view(&mut context);\n        let total_supply = liquidity_token.total_supply().view(&mut context);\n\n        // We calculate the amounts of token0 and token1 the user is entitled to based on the amount of liquidity they\n        // are removing, and check that they are above the minimum amounts they requested.\n        let (amount0, amount1) = get_amounts_on_remove(liquidity, total_supply, balance0, balance1);\n        assert(amount0 >= amount0_min, \"INSUFFICIENT_0_AMOUNT\");\n        assert(amount1 >= amount1_min, \"INSUFFICIENT_1_AMOUNT\");\n\n        // We can now burn the liquidity tokens that had been privately transferred into the AMM, as well as complete\n        // both partial notes.\n        liquidity_token.burn_public(context.this_address(), liquidity, 0).call(&mut context);\n        token0.finalize_transfer_to_private(amount0, token0_partial_note).call(&mut context);\n        token1.finalize_transfer_to_private(amount1, token1_partial_note).call(&mut context);\n    }\n\n    /// Privately swaps `amount_in` `token_in` tokens for at least `amount_out_mint` `token_out` tokens with the pool.\n    ///\n    /// `authwit_nonce` can be any non-zero value, as it's only used to isolate token transfer authwits to this\n    /// specific call.\n    ///\n    /// The identity of the swapper is not revealed, but the action and amounts are.\n    #[private]\n    fn swap_exact_tokens_for_tokens(\n        token_in: AztecAddress,\n        token_out: AztecAddress,\n        amount_in: u128,\n        amount_out_min: u128,\n        authwit_nonce: Field,\n    ) {\n        let config = storage.config.read();\n\n        assert((token_in == config.token0) | (token_in == config.token1), \"TOKEN_IN_IS_INVALID\");\n        assert((token_out == config.token0) | (token_out == config.token1), \"TOKEN_OUT_IS_INVALID\");\n        assert(token_in != token_out, \"SAME_TOKEN_SWAP\");\n\n        let sender = context.msg_sender();\n\n        // We transfer the full amount in, since it is an exact amount, and prepare a partial note for the amount out,\n        // which will only be known during public execution as it depends on the live balances.\n        Token::at(token_in)\n            .transfer_to_public(sender, context.this_address(), amount_in, authwit_nonce)\n            .call(&mut context);\n        let token_out_partial_note =\n            Token::at(token_out).prepare_private_balance_increase(sender).call(&mut context);\n\n        AMM::at(context.this_address())\n            ._swap_exact_tokens_for_tokens(\n                token_in,\n                token_out,\n                amount_in,\n                amount_out_min,\n                token_out_partial_note,\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _swap_exact_tokens_for_tokens(\n        token_in: AztecAddress,\n        token_out: AztecAddress,\n        amount_in: u128,\n        amount_out_min: u128,\n        token_out_partial_note: PartialUintNote,\n    ) {\n        // In order to compute the amount to swap we need the live token balances. Note that at this state the token in\n        // transfer has already been completed as that function call was enqueued before this one. We therefore need to\n        // subtract the amount in to get the pre-swap balances.\n        let balance_in_plus_amount_in =\n            Token::at(token_in).balance_of_public(context.this_address()).view(&mut context);\n        let balance_in = balance_in_plus_amount_in - amount_in;\n\n        let balance_out =\n            Token::at(token_out).balance_of_public(context.this_address()).view(&mut context);\n\n        // We can now compute the number of tokens to transfer and complete the partial note.\n        let amount_out = get_amount_out(amount_in, balance_in, balance_out);\n        assert(amount_out >= amount_out_min, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n\n        Token::at(token_out).finalize_transfer_to_private(amount_out, token_out_partial_note).call(\n            &mut context,\n        );\n    }\n\n    /// Privately swaps at most `amount_in_max` `token_in` tokens for `amount_out` `token_out` tokens with the pool.\n    ///\n    /// `authwit_nonce` can be any non-zero value, as it's only used to isolate token transfer authwits to this\n    /// specific call.\n    ///\n    /// The identity of the swapper is not revealed, but the action and amounts are.\n    #[private]\n    fn swap_tokens_for_exact_tokens(\n        token_in: AztecAddress,\n        token_out: AztecAddress,\n        amount_out: u128,\n        amount_in_max: u128,\n        authwit_nonce: Field,\n    ) {\n        let config = storage.config.read();\n\n        assert((token_in == config.token0) | (token_in == config.token1), \"TOKEN_IN_IS_INVALID\");\n        assert((token_out == config.token0) | (token_out == config.token1), \"TOKEN_OUT_IS_INVALID\");\n        assert(token_in != token_out, \"SAME_TOKEN_SWAP\");\n\n        let sender = context.msg_sender();\n\n        // We don't know how many tokens we'll receive from the user, since the swap amount will only be known during\n        // public execution as it depends on the live balances. We therefore transfer the full maximum amount and\n        // prepare partial notes both for the token out and the refund.\n        // Technically the token out note does not need to be partial, since we do know the amount out, but we do want\n        // to wait until the swap has been completed before committing the note to the tree to avoid it being spent too\n        // early.\n        let change_token_in_partial_note = Token::at(token_in)\n            .transfer_to_public_and_prepare_private_balance_increase(\n                sender,\n                context.this_address(),\n                amount_in_max,\n                authwit_nonce,\n            )\n            .call(&mut context);\n\n        let token_out_partial_note =\n            Token::at(token_out).prepare_private_balance_increase(sender).call(&mut context);\n\n        AMM::at(context.this_address())\n            ._swap_tokens_for_exact_tokens(\n                token_in,\n                token_out,\n                amount_in_max,\n                amount_out,\n                change_token_in_partial_note,\n                token_out_partial_note,\n            )\n            .enqueue(&mut context);\n    }\n\n    #[public]\n    #[internal]\n    fn _swap_tokens_for_exact_tokens(\n        token_in: AztecAddress,\n        token_out: AztecAddress,\n        amount_in_max: u128,\n        amount_out: u128,\n        change_token_in_partial_note: PartialUintNote,\n        token_out_partial_note: PartialUintNote,\n    ) {\n        // In order to compute the amount to swap we need the live token balances. Note that at this state the token in\n        // transfer has already been completed as that function call was enqueued before this one. We therefore need to\n        // subtract the amount in to get the pre-swap balances.\n        let balance_in_plus_amount_in_max =\n            Token::at(token_in).balance_of_public(context.this_address()).view(&mut context);\n        let balance_in = balance_in_plus_amount_in_max - amount_in_max;\n\n        let balance_out =\n            Token::at(token_out).balance_of_public(context.this_address()).view(&mut context);\n\n        // We can now compute the number of tokens we need to receive and complete the partial note with the change.\n        let amount_in = get_amount_in(amount_out, balance_in, balance_out);\n        assert(amount_in <= amount_in_max, \"INSUFFICIENT_OUTPUT_AMOUNT\");\n\n        let change = amount_in_max - amount_in;\n        if (change > 0 as u128) {\n            Token::at(token_in)\n                .finalize_transfer_to_private(change, change_token_in_partial_note)\n                .call(&mut context);\n        }\n\n        // Note again that we already knew the amount out, but for consistency we want to only commit this note once\n        // all other steps have been performed.\n        Token::at(token_out).finalize_transfer_to_private(amount_out, token_out_partial_note).call(\n            &mut context,\n        );\n    }\n\n    #[utility]\n    unconstrained fn get_amount_out_for_exact_in(\n        balance_in: u128,\n        balance_out: u128,\n        amount_in: u128,\n    ) -> u128 {\n        // Ideally we'd call the token contract in order to read the current balance, but we can't due to #7524.\n        get_amount_out(amount_in, balance_in, balance_out)\n    }\n\n    #[utility]\n    unconstrained fn get_amount_in_for_exact_out(\n        balance_in: u128,\n        balance_out: u128,\n        amount_out: u128,\n    ) -> u128 {\n        // Ideally we'd call the token contract in order to read the current balance, but we can't due to #7524.\n        get_amount_in(amount_out, balance_in, balance_out)\n    }\n}\n"
    },
    "6": {
      "path": "std/collections/bounded_vec.nr",
      "source": "use crate::{cmp::Eq, convert::From, runtime::is_unconstrained, static_assert};\n\n/// A `BoundedVec<T, MaxLen>` is a growable storage similar to a `Vec<T>` except that it\n/// is bounded with a maximum possible length. Unlike `Vec`, `BoundedVec` is not implemented\n/// via slices and thus is not subject to the same restrictions slices are (notably, nested\n/// slices - and thus nested vectors as well - are disallowed).\n///\n/// Since a BoundedVec is backed by a normal array under the hood, growing the BoundedVec by\n/// pushing an additional element is also more efficient - the length only needs to be increased\n/// by one.\n///\n/// For these reasons `BoundedVec<T, N>` should generally be preferred over `Vec<T>` when there\n/// is a reasonable maximum bound that can be placed on the vector.\n///\n/// Example:\n///\n/// ```noir\n/// let mut vector: BoundedVec<Field, 10> = BoundedVec::new();\n/// for i in 0..5 {\n///     vector.push(i);\n/// }\n/// assert(vector.len() == 5);\n/// assert(vector.max_len() == 10);\n/// ```\npub struct BoundedVec<T, let MaxLen: u32> {\n    storage: [T; MaxLen],\n    len: u32,\n}\n\nimpl<T, let MaxLen: u32> BoundedVec<T, MaxLen> {\n    /// Creates a new, empty vector of length zero.\n    ///\n    /// Since this container is backed by an array internally, it still needs an initial value\n    /// to give each element. To resolve this, each element is zeroed internally. This value\n    /// is guaranteed to be inaccessible unless `get_unchecked` is used.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let empty_vector: BoundedVec<Field, 10> = BoundedVec::new();\n    /// assert(empty_vector.len() == 0);\n    /// ```\n    ///\n    /// Note that whenever calling `new` the maximum length of the vector should always be specified\n    /// via a type signature:\n    ///\n    /// ```noir\n    /// fn good() -> BoundedVec<Field, 10> {\n    ///     // Ok! MaxLen is specified with a type annotation\n    ///     let v1: BoundedVec<Field, 3> = BoundedVec::new();\n    ///     let v2 = BoundedVec::new();\n    ///\n    ///     // Ok! MaxLen is known from the type of `good`'s return value\n    ///     v2\n    /// }\n    ///\n    /// fn bad() {\n    ///     // Error: Type annotation needed\n    ///     // The compiler can't infer `MaxLen` from the following code:\n    ///     let mut v3 = BoundedVec::new();\n    ///     v3.push(5);\n    /// }\n    /// ```\n    ///\n    /// This defaulting of `MaxLen` (and numeric generics in general) to zero may change in future noir versions\n    /// but for now make sure to use type annotations when using bounded vectors. Otherwise, you will receive a\n    /// constraint failure at runtime when the vec is pushed to.\n    pub fn new() -> Self {\n        let zeroed = crate::mem::zeroed();\n        BoundedVec { storage: [zeroed; MaxLen], len: 0 }\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this\n    /// will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     let last = v.get(v.len() - 1);\n    ///     assert(first != last);\n    /// }\n    /// ```\n    pub fn get(self, index: u32) -> T {\n        assert(index < self.len, \"Attempted to read past end of BoundedVec\");\n        self.get_unchecked(index)\n    }\n\n    /// Retrieves an element from the vector at the given index, starting from zero, without\n    /// performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element,\n    /// it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn sum_of_first_three<let N: u32>(v: BoundedVec<u32, N>) -> u32 {\n    ///     // Always ensure the length is larger than the largest\n    ///     // index passed to get_unchecked\n    ///     assert(v.len() > 2);\n    ///     let first = v.get_unchecked(0);\n    ///     let second = v.get_unchecked(1);\n    ///     let third = v.get_unchecked(2);\n    ///     first + second + third\n    /// }\n    /// ```\n    pub fn get_unchecked(self, index: u32) -> T {\n        self.storage[index]\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero.\n    ///\n    /// If the given index is equal to or greater than the length of the vector, this will issue a constraint failure.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn foo<let N: u32>(v: BoundedVec<u32, N>) {\n    ///     let first = v.get(0);\n    ///     assert(first != 42);\n    ///     v.set(0, 42);\n    ///     let new_first = v.get(0);\n    ///     assert(new_first == 42);\n    /// }\n    /// ```\n    pub fn set(&mut self, index: u32, value: T) {\n        assert(index < self.len, \"Attempted to write past end of BoundedVec\");\n        self.set_unchecked(index, value)\n    }\n\n    /// Writes an element to the vector at the given index, starting from zero, without performing a bounds check.\n    ///\n    /// Since this function does not perform a bounds check on length before accessing the element, it is unsafe! Use at your own risk!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// fn set_unchecked_example() {\n    ///     let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n    ///     vec.extend_from_array([1, 2]);\n    ///\n    ///     // Here we're safely writing within the valid range of `vec`\n    ///     // `vec` now has the value [42, 2]\n    ///     vec.set_unchecked(0, 42);\n    ///\n    ///     // We can then safely read this value back out of `vec`.\n    ///     // Notice that we use the checked version of `get` which would prevent reading unsafe values.\n    ///     assert_eq(vec.get(0), 42);\n    ///\n    ///     // We've now written past the end of `vec`.\n    ///     // As this index is still within the maximum potential length of `v`,\n    ///     // it won't cause a constraint failure.\n    ///     vec.set_unchecked(2, 42);\n    ///     println(vec);\n    ///\n    ///     // This will write past the end of the maximum potential length of `vec`,\n    ///     // it will then trigger a constraint failure.\n    ///     vec.set_unchecked(5, 42);\n    ///     println(vec);\n    /// }\n    /// ```\n    pub fn set_unchecked(&mut self, index: u32, value: T) {\n        self.storage[index] = value;\n    }\n\n    /// Pushes an element to the end of the vector. This increases the length\n    /// of the vector by one.\n    ///\n    /// Panics if the new length of the vector will be greater than the max length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    ///\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// // Panics with failed assertion \"push out of bounds\"\n    /// v.push(3);\n    /// ```\n    pub fn push(&mut self, elem: T) {\n        assert(self.len < MaxLen, \"push out of bounds\");\n\n        self.storage[self.len] = elem;\n        self.len += 1;\n    }\n\n    /// Returns the current length of this vector\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 4> = BoundedVec::new();\n    /// assert(v.len() == 0);\n    ///\n    /// v.push(100);\n    /// assert(v.len() == 1);\n    ///\n    /// v.push(200);\n    /// v.push(300);\n    /// v.push(400);\n    /// assert(v.len() == 4);\n    ///\n    /// let _ = v.pop();\n    /// let _ = v.pop();\n    /// assert(v.len() == 2);\n    /// ```\n    pub fn len(self) -> u32 {\n        self.len\n    }\n\n    /// Returns the maximum length of this vector. This is always\n    /// equal to the `MaxLen` parameter this vector was initialized with.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.max_len() == 5);\n    /// v.push(10);\n    /// assert(v.max_len() == 5);\n    /// ```\n    pub fn max_len(_self: BoundedVec<T, MaxLen>) -> u32 {\n        MaxLen\n    }\n\n    /// Returns the internal array within this vector.\n    ///\n    /// Since arrays in Noir are immutable, mutating the returned storage array will not mutate\n    /// the storage held internally by this vector.\n    ///\n    /// Note that uninitialized elements may be zeroed out!\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 5> = BoundedVec::new();\n    ///\n    /// assert(v.storage() == [0, 0, 0, 0, 0]);\n    ///\n    /// v.push(57);\n    /// assert(v.storage() == [57, 0, 0, 0, 0]);\n    /// ```\n    pub fn storage(self) -> [T; MaxLen] {\n        self.storage\n    }\n\n    /// Pushes each element from the given array to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_array([2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_array<let Len: u32>(&mut self, array: [T; Len]) {\n        let new_len = self.len + array.len();\n        assert(new_len <= MaxLen, \"extend_from_array out of bounds\");\n        for i in 0..array.len() {\n            self.storage[self.len + i] = array[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the given slice to this vector.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut vec: BoundedVec<Field, 3> = BoundedVec::new();\n    /// vec.extend_from_slice(&[2, 4]);\n    ///\n    /// assert(vec.len == 2);\n    /// assert(vec.get(0) == 2);\n    /// assert(vec.get(1) == 4);\n    /// ```\n    pub fn extend_from_slice(&mut self, slice: [T]) {\n        let new_len = self.len + slice.len();\n        assert(new_len <= MaxLen, \"extend_from_slice out of bounds\");\n        for i in 0..slice.len() {\n            self.storage[self.len + i] = slice[i];\n        }\n        self.len = new_len;\n    }\n\n    /// Pushes each element from the other vector to this vector. The length of\n    /// the other vector is left unchanged.\n    ///\n    /// Panics if pushing each element would cause the length of this vector\n    /// to exceed the maximum length.\n    ///\n    /// ```noir\n    /// let mut v1: BoundedVec<Field, 5> = BoundedVec::new();\n    /// let mut v2: BoundedVec<Field, 7> = BoundedVec::new();\n    ///\n    /// v2.extend_from_array([1, 2, 3]);\n    /// v1.extend_from_bounded_vec(v2);\n    ///\n    /// assert(v1.storage() == [1, 2, 3, 0, 0]);\n    /// assert(v2.storage() == [1, 2, 3, 0, 0, 0, 0]);\n    /// ```\n    pub fn extend_from_bounded_vec<let Len: u32>(&mut self, vec: BoundedVec<T, Len>) {\n        let append_len = vec.len();\n        let new_len = self.len + append_len;\n        assert(new_len <= MaxLen, \"extend_from_bounded_vec out of bounds\");\n\n        if is_unconstrained() {\n            for i in 0..append_len {\n                self.storage[self.len + i] = vec.get_unchecked(i);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..Len {\n                exceeded_len |= i == append_len;\n                if !exceeded_len {\n                    self.storage[self.len + i] = vec.get_unchecked(i);\n                }\n            }\n        }\n        self.len = new_len;\n    }\n\n    /// Creates a new vector, populating it with values derived from an array input.\n    /// The maximum length of the vector is determined based on the type signature.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array([1, 2, 3])\n    /// ```\n    pub fn from_array<let Len: u32>(array: [T; Len]) -> Self {\n        static_assert(Len <= MaxLen, \"from array out of bounds\");\n        let mut vec: BoundedVec<T, MaxLen> = BoundedVec::new();\n        vec.extend_from_array(array);\n        vec\n    }\n\n    /// Pops the element at the end of the vector. This will decrease the length\n    /// of the vector by one.\n    ///\n    /// Panics if the vector is empty.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<Field, 2> = BoundedVec::new();\n    /// v.push(1);\n    /// v.push(2);\n    ///\n    /// let two = v.pop();\n    /// let one = v.pop();\n    ///\n    /// assert(two == 2);\n    /// assert(one == 1);\n    ///\n    /// // error: cannot pop from an empty vector\n    /// let _ = v.pop();\n    /// ```\n    pub fn pop(&mut self) -> T {\n        assert(self.len > 0, \"cannot pop from an empty vector\");\n        self.len -= 1;\n\n        let elem = self.storage[self.len];\n        self.storage[self.len] = crate::mem::zeroed();\n        elem\n    }\n\n    /// Returns true if the given predicate returns true for any element\n    /// in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let mut v: BoundedVec<u32, 3> = BoundedVec::new();\n    /// v.extend_from_array([2, 4, 6]);\n    ///\n    /// let all_even = !v.any(|elem: u32| elem % 2 != 0);\n    /// assert(all_even);\n    /// ```\n    pub fn any<Env>(self, predicate: fn[Env](T) -> bool) -> bool {\n        let mut ret = false;\n        if is_unconstrained() {\n            for i in 0..self.len {\n                ret |= predicate(self.storage[i]);\n            }\n        } else {\n            let mut exceeded_len = false;\n            for i in 0..MaxLen {\n                exceeded_len |= i == self.len;\n                if !exceeded_len {\n                    ret |= predicate(self.storage[i]);\n                }\n            }\n        }\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.map(|value| value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn map<U, Env>(self, f: fn[Env](T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Creates a new vector of equal size by calling a closure on each element\n    /// in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let result = vec.mapi(|i, value| i + value * 2);\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn mapi<U, Env>(self, f: fn[Env](u32, T) -> U) -> BoundedVec<U, MaxLen> {\n        let mut ret = BoundedVec::new();\n        ret.len = self.len();\n\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                ret.storage[i] = f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    ret.storage[i] = f(i, self.get_unchecked(i));\n                }\n            }\n        }\n\n        ret\n    }\n\n    /// Calls a closure on each element in this vector.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_each(|value| result.push(value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 4, 6, 8]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_each<Env>(self, f: fn[Env](T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Calls a closure on each element in this vector, along with its index.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n    /// let mut result = BoundedVec::<u32, 4>::new();\n    /// vec.for_eachi(|i, value| result.push(i + value * 2));\n    ///\n    /// let expected = BoundedVec::from_array([2, 5, 8, 11]);\n    /// assert_eq(result, expected);\n    /// ```\n    pub fn for_eachi<Env>(self, f: fn[Env](u32, T) -> ()) {\n        if is_unconstrained() {\n            for i in 0..self.len() {\n                f(i, self.get_unchecked(i));\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i < self.len() {\n                    f(i, self.get_unchecked(i));\n                }\n            }\n        }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function will zero out any elements at or past index `len` of `array`.\n    /// This incurs an extra runtime cost of O(MaxLen). If you are sure your array is\n    /// zeroed after that index, you can use `from_parts_unchecked` to remove the extra loop.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    /// ```\n    pub fn from_parts(mut array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        let zeroed = crate::mem::zeroed();\n\n        if is_unconstrained() {\n            for i in len..MaxLen {\n                array[i] = zeroed;\n            }\n        } else {\n            for i in 0..MaxLen {\n                if i >= len {\n                    array[i] = zeroed;\n                }\n            }\n        }\n\n        BoundedVec { storage: array, len }\n    }\n\n    /// Creates a new BoundedVec from the given array and length.\n    /// The given length must be less than or equal to the length of the array.\n    ///\n    /// This function is unsafe because it expects all elements past the `len` index\n    /// of `array` to be zeroed, but does not check for this internally. Use `from_parts`\n    /// for a safe version of this function which does zero out any indices past the\n    /// given length. Invalidating this assumption can notably cause `BoundedVec::eq`\n    /// to give incorrect results since it will check even elements past `len`.\n    ///\n    /// Example:\n    ///\n    /// ```noir\n    /// let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n    /// assert_eq(vec.len(), 3);\n    ///\n    /// // invalid use!\n    /// let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n    /// let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n    ///\n    /// // both vecs have length 3 so we'd expect them to be equal, but this\n    /// // fails because elements past the length are still checked in eq\n    /// assert_eq(vec1, vec2); // fails\n    /// ```\n    pub fn from_parts_unchecked(array: [T; MaxLen], len: u32) -> Self {\n        assert(len <= MaxLen);\n        BoundedVec { storage: array, len }\n    }\n}\n\nimpl<T, let MaxLen: u32> Eq for BoundedVec<T, MaxLen>\nwhere\n    T: Eq,\n{\n    fn eq(self, other: BoundedVec<T, MaxLen>) -> bool {\n        // TODO: https://github.com/noir-lang/noir/issues/4837\n        //\n        // We make the assumption that the user has used the proper interface for working with `BoundedVec`s\n        // rather than directly manipulating the internal fields as this can result in an inconsistent internal state.\n        if self.len == other.len {\n            self.storage == other.storage\n        } else {\n            false\n        }\n    }\n}\n\nimpl<T, let MaxLen: u32, let Len: u32> From<[T; Len]> for BoundedVec<T, MaxLen> {\n    fn from(array: [T; Len]) -> BoundedVec<T, MaxLen> {\n        BoundedVec::from_array(array)\n    }\n}\n\nmod bounded_vec_tests {\n\n    mod get {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_elements_past_end_of_vec() {\n            let vec: BoundedVec<Field, 5> = BoundedVec::new();\n\n            let _ = vec.get(0);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn panics_when_reading_beyond_length() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            let _ = vec.get(3);\n        }\n\n        #[test]\n        fn get_works_within_bounds() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(2), 3);\n            assert_eq(vec.get(4), 5);\n        }\n\n        #[test]\n        fn get_unchecked_works() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(0), 1);\n            assert_eq(vec.get_unchecked(2), 3);\n        }\n\n        #[test]\n        fn get_unchecked_works_past_len() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            assert_eq(vec.get_unchecked(4), 0);\n        }\n    }\n\n    mod set {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn set_updates_values_properly() {\n            let mut vec = BoundedVec::from_array([0, 0, 0, 0, 0]);\n\n            vec.set(0, 42);\n            assert_eq(vec.storage, [42, 0, 0, 0, 0]);\n\n            vec.set(1, 43);\n            assert_eq(vec.storage, [42, 43, 0, 0, 0]);\n\n            vec.set(2, 44);\n            assert_eq(vec.storage, [42, 43, 44, 0, 0]);\n\n            vec.set(1, 10);\n            assert_eq(vec.storage, [42, 10, 44, 0, 0]);\n\n            vec.set(0, 0);\n            assert_eq(vec.storage, [0, 10, 44, 0, 0]);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_writing_elements_past_end_of_vec() {\n            let mut vec: BoundedVec<Field, 5> = BoundedVec::new();\n            vec.set(0, 42);\n        }\n\n        #[test(should_fail_with = \"Attempted to write past end of BoundedVec\")]\n        fn panics_when_setting_beyond_length() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3]);\n            vec.set(3, 4);\n        }\n\n        #[test]\n        fn set_unchecked_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(0, 10);\n            assert_eq(vec.get(0), 10);\n        }\n\n        #[test(should_fail_with = \"Attempted to read past end of BoundedVec\")]\n        fn set_unchecked_operations_past_len() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            vec.set_unchecked(3, 40);\n            assert_eq(vec.get(3), 40);\n        }\n\n        #[test]\n        fn set_preserves_other_elements() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            vec.set(2, 30);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 30);\n            assert_eq(vec.get(3), 4);\n            assert_eq(vec.get(4), 5);\n        }\n    }\n\n    mod any {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn returns_false_if_predicate_not_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, false, false]);\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn returns_true_if_predicate_satisfied() {\n            let vec: BoundedVec<bool, 4> = BoundedVec::from_array([false, false, true, true]);\n            let result = vec.any(|value| value);\n\n            assert(result);\n        }\n\n        #[test]\n        fn returns_false_on_empty_boundedvec() {\n            let vec: BoundedVec<bool, 0> = BoundedVec::new();\n            let result = vec.any(|value| value);\n\n            assert(!result);\n        }\n\n        #[test]\n        fn any_with_complex_predicates() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n\n            assert(vec.any(|x| x > 3));\n            assert(!vec.any(|x| x > 10));\n            assert(vec.any(|x| x % 2 == 0)); // has a even number\n            assert(vec.any(|x| x == 3)); // has a specific value\n        }\n\n        #[test]\n        fn any_with_partial_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n\n            assert(vec.any(|x| x == 1));\n            assert(vec.any(|x| x == 2));\n            assert(!vec.any(|x| x == 3));\n        }\n    }\n\n    mod map {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-map-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| value * 2);\n            // docs:end:bounded-vec-map-example\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.map(|value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn map_with_conditional_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.map(|x| if x % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([1, 4, 3, 8]);\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn map_preserves_length() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.map(|x| x * 2);\n\n            assert_eq(result.len(), vec.len());\n            assert_eq(result.max_len(), vec.max_len());\n        }\n\n        #[test]\n        fn map_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let result = vec.map(|x| x * 2);\n            assert_eq(result, vec);\n            assert_eq(result.len(), 0);\n            assert_eq(result.max_len(), 5);\n        }\n    }\n\n    mod mapi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn applies_function_correctly() {\n            // docs:start:bounded-vec-mapi-example\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| i + value * 2);\n            // docs:end:bounded-vec-mapi-example\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = vec.mapi(|i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = vec.mapi(|_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn mapi_with_index_branching_logic() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n\n            let result = vec.mapi(|i, x| if i % 2 == 0 { x * 2 } else { x });\n            let expected = BoundedVec::from_array([2, 2, 6, 4]);\n            assert_eq(result, expected);\n        }\n    }\n\n    mod for_each {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // map in terms of for_each\n        fn for_each_map<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_each(|x| output_ref.push(f(x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-each-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_each(|value| { *acc_ref += value; });\n            // docs:end:bounded-vec-for-each-example\n            assert_eq(acc, 6);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| value * 2);\n            let expected = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_each_map(vec, |value| (value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 4, 6, 8]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_each_map(vec, |value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_each_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_each(|_| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_each_with_side_effects() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let mut seen = BoundedVec::<u32, 3>::new();\n            let seen_ref = &mut seen;\n            vec.for_each(|x| seen_ref.push(x));\n            assert_eq(seen, vec);\n        }\n    }\n\n    mod for_eachi {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        // mapi in terms of for_eachi\n        fn for_eachi_mapi<T, U, Env, let MaxLen: u32>(\n            input: BoundedVec<T, MaxLen>,\n            f: fn[Env](u32, T) -> U,\n        ) -> BoundedVec<U, MaxLen> {\n            let mut output = BoundedVec::<U, MaxLen>::new();\n            let output_ref = &mut output;\n            input.for_eachi(|i, x| output_ref.push(f(i, x)));\n            output\n        }\n\n        #[test]\n        fn smoke_test() {\n            let mut acc = 0;\n            let acc_ref = &mut acc;\n            // docs:start:bounded-vec-for-eachi-example\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            vec.for_eachi(|i, value| { *acc_ref += i * value; });\n            // docs:end:bounded-vec-for-eachi-example\n\n            // 0 * 1 + 1 * 2 + 2 * 3\n            assert_eq(acc, 8);\n        }\n\n        #[test]\n        fn applies_function_correctly() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| i + value * 2);\n            let expected = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn applies_function_that_changes_return_type() {\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_array([1, 2, 3, 4]);\n            let result = for_eachi_mapi(vec, |i, value| (i + value * 2) as Field);\n            let expected: BoundedVec<Field, 4> = BoundedVec::from_array([2, 5, 8, 11]);\n\n            assert_eq(result, expected);\n        }\n\n        #[test]\n        fn does_not_apply_function_past_len() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([0, 1]);\n            let result = for_eachi_mapi(vec, |_, value| if value == 0 { 5 } else { value });\n            let expected = BoundedVec::from_array([5, 1]);\n\n            assert_eq(result, expected);\n            assert_eq(result.get_unchecked(2), 0);\n        }\n\n        #[test]\n        fn for_eachi_on_empty_vector() {\n            let vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut count = 0;\n            let count_ref = &mut count;\n            vec.for_eachi(|_, _| { *count_ref += 1; });\n            assert_eq(count, 0);\n        }\n\n        #[test]\n        fn for_eachi_with_index_tracking() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([10, 20, 30]);\n            let mut indices = BoundedVec::<u32, 3>::new();\n            let indices_ref = &mut indices;\n            vec.for_eachi(|i, _| indices_ref.push(i));\n\n            let expected = BoundedVec::from_array([0, 1, 2]);\n            assert_eq(indices, expected);\n        }\n\n    }\n\n    mod from_array {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty() {\n            let empty_array: [Field; 0] = [];\n            let bounded_vec = BoundedVec::from_array([]);\n\n            assert_eq(bounded_vec.max_len(), 0);\n            assert_eq(bounded_vec.len(), 0);\n            assert_eq(bounded_vec.storage(), empty_array);\n        }\n\n        #[test]\n        fn equal_len() {\n            let array = [1, 2, 3];\n            let bounded_vec = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 3);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.storage(), array);\n        }\n\n        #[test]\n        fn max_len_greater_then_array_len() {\n            let array = [1, 2, 3];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from_array(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 3);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n            assert_eq(bounded_vec.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"from array out of bounds\")]\n        fn max_len_lower_then_array_len() {\n            let _: BoundedVec<Field, 2> = BoundedVec::from_array([0; 3]);\n        }\n\n        #[test]\n        fn from_array_preserves_order() {\n            let array = [5, 3, 1, 4, 2];\n            let vec: BoundedVec<u32, 5> = BoundedVec::from_array(array);\n            for i in 0..array.len() {\n                assert_eq(vec.get(i), array[i]);\n            }\n        }\n\n        #[test]\n        fn from_array_with_different_types() {\n            let bool_array = [true, false, true];\n            let bool_vec: BoundedVec<bool, 3> = BoundedVec::from_array(bool_array);\n            assert_eq(bool_vec.len(), 3);\n            assert_eq(bool_vec.get(0), true);\n            assert_eq(bool_vec.get(1), false);\n        }\n    }\n\n    mod trait_from {\n        use crate::collections::bounded_vec::BoundedVec;\n        use crate::convert::From;\n\n        #[test]\n        fn simple() {\n            let array = [1, 2];\n            let bounded_vec: BoundedVec<Field, 10> = BoundedVec::from(array);\n\n            assert_eq(bounded_vec.max_len(), 10);\n            assert_eq(bounded_vec.len(), 2);\n            assert_eq(bounded_vec.get(0), 1);\n            assert_eq(bounded_vec.get(1), 2);\n        }\n    }\n\n    mod trait_eq {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn empty_equality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n\n            assert_eq(bounded_vec1, bounded_vec2);\n        }\n\n        #[test]\n        fn inequality() {\n            let mut bounded_vec1: BoundedVec<Field, 3> = BoundedVec::new();\n            let mut bounded_vec2: BoundedVec<Field, 3> = BoundedVec::new();\n            bounded_vec1.push(1);\n            bounded_vec2.push(2);\n\n            assert(bounded_vec1 != bounded_vec2);\n        }\n    }\n\n    mod from_parts {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn from_parts() {\n            // docs:start:from-parts\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // Any elements past the given length are zeroed out, so these\n            // two BoundedVecs will be completely equal\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts([1, 2, 3, 2], 3);\n            assert_eq(vec1, vec2);\n            // docs:end:from-parts\n        }\n\n        #[test]\n        fn from_parts_unchecked() {\n            // docs:start:from-parts-unchecked\n            let vec: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 0], 3);\n            assert_eq(vec.len(), 3);\n\n            // invalid use!\n            let vec1: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 1], 3);\n            let vec2: BoundedVec<u32, 4> = BoundedVec::from_parts_unchecked([1, 2, 3, 2], 3);\n\n            // both vecs have length 3 so we'd expect them to be equal, but this\n            // fails because elements past the length are still checked in eq\n            assert(vec1 != vec2);\n            // docs:end:from-parts-unchecked\n        }\n    }\n\n    mod push_pop {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn push_and_pop_operations() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            assert_eq(vec.len(), 0);\n\n            vec.push(1);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 1);\n\n            vec.push(2);\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.get(1), 2);\n\n            let popped = vec.pop();\n            assert_eq(popped, 2);\n            assert_eq(vec.len(), 1);\n\n            let popped2 = vec.pop();\n            assert_eq(popped2, 1);\n            assert_eq(vec.len(), 0);\n        }\n\n        #[test(should_fail_with = \"push out of bounds\")]\n        fn push_to_full_vector() {\n            let mut vec: BoundedVec<u32, 2> = BoundedVec::new();\n            vec.push(1);\n            vec.push(2);\n            vec.push(3); // should panic\n        }\n\n        #[test(should_fail_with = \"cannot pop from an empty vector\")]\n        fn pop_from_empty_vector() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let _ = vec.pop(); // should panic\n        }\n\n        #[test]\n        fn push_pop_cycle() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n\n            // push to full\n            vec.push(1);\n            vec.push(2);\n            vec.push(3);\n            assert_eq(vec.len(), 3);\n\n            // pop all\n            assert_eq(vec.pop(), 3);\n            assert_eq(vec.pop(), 2);\n            assert_eq(vec.pop(), 1);\n            assert_eq(vec.len(), 0);\n\n            // push again\n            vec.push(4);\n            assert_eq(vec.len(), 1);\n            assert_eq(vec.get(0), 4);\n        }\n    }\n\n    mod extend {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn extend_from_array() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_slice() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3]);\n\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n\n        #[test]\n        fn extend_from_bounded_vec() {\n            let mut vec1: BoundedVec<u32, 5> = BoundedVec::new();\n            let mut vec2: BoundedVec<u32, 3> = BoundedVec::new();\n\n            vec1.push(1);\n            vec2.push(2);\n            vec2.push(3);\n\n            vec1.extend_from_bounded_vec(vec2);\n\n            assert_eq(vec1.len(), 3);\n            assert_eq(vec1.get(0), 1);\n            assert_eq(vec1.get(1), 2);\n            assert_eq(vec1.get(2), 3);\n        }\n\n        #[test(should_fail_with = \"extend_from_array out of bounds\")]\n        fn extend_array_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_array([2, 3, 4]); // should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_slice out of bounds\")]\n        fn extend_slice_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.push(1);\n            vec.extend_from_slice(&[2, 3, 4]); // S]should panic\n        }\n\n        #[test(should_fail_with = \"extend_from_bounded_vec out of bounds\")]\n        fn extend_bounded_vec_beyond_max_len() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::new();\n            let other: BoundedVec<u32, 5> = BoundedVec::from_array([1, 2, 3, 4, 5]);\n            vec.extend_from_bounded_vec(other); // should panic\n        }\n\n        #[test]\n        fn extend_with_empty_collections() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n            let original_len = vec.len();\n\n            vec.extend_from_array([]);\n            assert_eq(vec.len(), original_len);\n\n            vec.extend_from_slice(&[]);\n            assert_eq(vec.len(), original_len);\n\n            let empty: BoundedVec<u32, 3> = BoundedVec::new();\n            vec.extend_from_bounded_vec(empty);\n            assert_eq(vec.len(), original_len);\n        }\n    }\n\n    mod storage {\n        use crate::collections::bounded_vec::BoundedVec;\n\n        #[test]\n        fn storage_consistency() {\n            let mut vec: BoundedVec<u32, 5> = BoundedVec::new();\n\n            // test initial storage state\n            assert_eq(vec.storage(), [0, 0, 0, 0, 0]);\n\n            vec.push(1);\n            vec.push(2);\n\n            // test storage after modifications\n            assert_eq(vec.storage(), [1, 2, 0, 0, 0]);\n\n            // storage doesn't change length\n            assert_eq(vec.len(), 2);\n            assert_eq(vec.max_len(), 5);\n        }\n\n        #[test]\n        fn storage_after_pop() {\n            let mut vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n\n            let _ = vec.pop();\n            // after pop, the last element should be zeroed\n            assert_eq(vec.storage(), [1, 2, 0]);\n            assert_eq(vec.len(), 2);\n        }\n\n        #[test]\n        fn vector_immutable() {\n            let vec: BoundedVec<u32, 3> = BoundedVec::from_array([1, 2, 3]);\n            let storage = vec.storage();\n\n            assert_eq(storage, [1, 2, 3]);\n\n            // Verify that the original vector is unchanged\n            assert_eq(vec.len(), 3);\n            assert_eq(vec.get(0), 1);\n            assert_eq(vec.get(1), 2);\n            assert_eq(vec.get(2), 3);\n        }\n    }\n}\n"
    },
    "65": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/capsules/mod.nr",
      "source": "use crate::oracle::capsules;\nuse protocol_types::{address::AztecAddress, traits::{Deserialize, Serialize}};\n\n/// A dynamically sized array backed by PXE's non-volatile database (called capsules). Values are persisted until\n/// deleted, so they can be e.g. stored during simulation of a transaction and later retrieved during witness\n/// generation. All values are scoped per contract address, so external contracts cannot access them.\npub struct CapsuleArray<T> {\n    contract_address: AztecAddress,\n    /// The base slot is where the array length is stored in capsules. Array elements are stored in consecutive slots\n    /// after the base slot. For example, with base slot 5: the length is at slot 5, the first element (index 0) is at\n    /// slot 6, the second element (index 1) is at slot 7, and so on.\n    base_slot: Field,\n}\n\nimpl<T> CapsuleArray<T> {\n    /// Returns a CapsuleArray connected to a contract's capsules at a base slot. Array elements are stored in\n    /// contiguous slots following the base slot, so there should be sufficient space between array base slots to\n    /// accommodate elements. A reasonable strategy is to make the base slot a hash of a unique value.\n    pub unconstrained fn at(contract_address: AztecAddress, base_slot: Field) -> Self {\n        Self { contract_address, base_slot }\n    }\n\n    /// Returns the number of elements stored in the array.\n    pub unconstrained fn len(self) -> u32 {\n        // An uninitialized array defaults to a length of 0.\n        capsules::load(self.contract_address, self.base_slot).unwrap_or(0) as u32\n    }\n\n    /// Stores a value at the end of the array.\n    pub unconstrained fn push(self, value: T)\n    where\n        T: Serialize,\n    {\n        let current_length = self.len();\n\n        // The slot corresponding to the index `current_length` is the first slot immediately after the end of the\n        // array, which is where we want to place the new value.\n        capsules::store(self.contract_address, self.slot_at(current_length), value);\n\n        // Then we simply update the length.\n        let new_length = current_length + 1;\n        capsules::store(self.contract_address, self.base_slot, new_length);\n    }\n\n    /// Retrieves the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn get(self, index: u32) -> T\n    where\n        T: Deserialize,\n    {\n        assert(index < self.len(), \"Attempted to read past the length of a CapsuleArray\");\n\n        capsules::load(self.contract_address, self.slot_at(index)).unwrap()\n    }\n\n    /// Deletes the value stored in the array at `index`. Throws if the index is out of bounds.\n    pub unconstrained fn remove(self, index: u32) {\n        let current_length = self.len();\n        assert(index < current_length, \"Attempted to delete past the length of a CapsuleArray\");\n\n        // In order to be able to remove elements at arbitrary indices, we need to shift the entire contents of the\n        // array past the removed element one slot backward so that we don't end up with a gap and preserve the\n        // contiguous slots. We can skip this when deleting the last element however.\n        if index != current_length - 1 {\n            // The source and destination regions overlap, but `copy` supports this.\n            capsules::copy(\n                self.contract_address,\n                self.slot_at(index + 1),\n                self.slot_at(index),\n                current_length - index - 1,\n            );\n        }\n\n        // We can now delete the last element (which has either been copied to the slot immediately before it, or was\n        // the element we meant to delete in the first place) and update the length.\n        capsules::delete(self.contract_address, self.slot_at(current_length - 1));\n        capsules::store(self.contract_address, self.base_slot, current_length - 1);\n    }\n\n    /// Iterates over the entire array, calling the callback with all values and their array index. The order in which\n    /// values are processed is arbitrary.\n    ///\n    /// It is safe to delete the current element (and only the current element) from inside the callback via `remove`:\n    /// ```noir\n    /// array.for_each(|index, value| {\n    ///   if some_condition(value) {\n    ///     array.remove(index); // safe only for this index\n    ///   }\n    /// }\n    /// ```\n    ///\n    /// If all elements in the array need to iterated over and then removed, then using `for_each` results in optimal\n    /// efficiency.\n    ///\n    /// It is **not** safe to push new elements into the array from inside the callback.\n    pub unconstrained fn for_each<Env>(self, f: unconstrained fn[Env](u32, T) -> ())\n    where\n        T: Deserialize,\n    {\n        // Iterating over all elements is simple, but we want to do it in such a way that a) deleting the current\n        // element is safe to do, and b) deleting *all* elements is optimally efficient. This is because CapsuleArrays\n        // are typically used to hold pending tasks, so iterating them while clearing completed tasks (sometimes\n        // unconditionally, resulting in a full clear) is a very common access pattern.\n        //\n        // The way we achieve this is by iterating backwards: each element can always be deleted since it won't change\n        // any preceding (lower) indices, and if every element is deleted then every element will (in turn) be the last\n        // element. This results in an optimal full clear since `remove` will be able to skip the `capsules::copy` call\n        // to shift any elements past the deleted one (because there will be none).\n        let mut i = self.len();\n        while i > 0 {\n            i -= 1;\n            f(i, self.get(i));\n        }\n    }\n\n    unconstrained fn slot_at(self, index: u32) -> Field {\n        // Elements are stored immediately after the base slot, so we add 1 to it to compute the slot for the first\n        // element.\n        self.base_slot + 1 + index as Field\n    }\n}\n\nmod test {\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use super::CapsuleArray;\n\n    global SLOT: Field = 1230;\n\n    #[test]\n    unconstrained fn empty_array() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array: CapsuleArray<Field> = CapsuleArray::at(contract_address, SLOT);\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn empty_array_read() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            let _: Field = array.get(0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_push() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            assert_eq(array.len(), 1);\n            assert_eq(array.get(0), 5);\n        });\n    }\n\n    #[test(should_fail_with = \"Attempted to read past the length of a CapsuleArray\")]\n    unconstrained fn read_past_len() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n            array.push(5);\n\n            let _ = array.get(1);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_last() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(5);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            assert_eq(array.len(), 3);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 8);\n            assert_eq(array.get(2), 9);\n\n            array.remove(1);\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 7);\n            assert_eq(array.get(1), 9);\n        });\n    }\n\n    #[test]\n    unconstrained fn array_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(7);\n            array.push(8);\n            array.push(9);\n\n            array.remove(1);\n            array.remove(1);\n            array.remove(0);\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_called_with_all_elements() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We store all values that we were called with and check that all (value, index) tuples are present. Note that\n            // we do not care about the order in which each tuple was passed to the closure.\n            let called_with = &mut BoundedVec::<(u32, Field), 3>::new();\n            array.for_each(|index, value| { called_with.push((index, value)); });\n\n            assert_eq(called_with.len(), 3);\n            assert(called_with.any(|(index, value)| (index == 0) & (value == 4)));\n            assert(called_with.any(|(index, value)| (index == 1) & (value == 5)));\n            assert(called_with.any(|(index, value)| (index == 2) & (value == 6)));\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_some() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| {\n                if index == 1 {\n                    array.remove(index);\n                }\n            });\n\n            assert_eq(array.len(), 2);\n            assert_eq(array.get(0), 4);\n            assert_eq(array.get(1), 6);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(array.len(), 0);\n        });\n    }\n\n    #[test]\n    unconstrained fn for_each_remove_all_no_copy() {\n        let env = TestEnvironment::new();\n        env.private_context(|context| {\n            let contract_address = context.this_address();\n            let array = CapsuleArray::at(contract_address, SLOT);\n\n            array.push(4);\n            array.push(5);\n            array.push(6);\n\n            // We test that the utilityCopyCapsule was never called, which is the expensive operation we want to avoid.\n            let mock = std::test::OracleMock::mock(\"utilityCopyCapsule\");\n\n            array.for_each(|index, _| { array.remove(index); });\n\n            assert_eq(mock.times_called(), 0);\n        });\n    }\n}\n"
    },
    "66": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/call_interfaces.nr",
      "source": "use dep::protocol_types::{\n    abis::function_selector::FunctionSelector,\n    address::AztecAddress,\n    traits::{Deserialize, ToField},\n};\n\nuse crate::context::{gas::GasOpts, private_context::PrivateContext, public_context::PublicContext};\nuse crate::hash::{hash_args, hash_calldata};\nuse crate::oracle::execution_cache;\n\npub trait CallInterface<let N: u32> {\n    fn get_args(self) -> [Field];\n    fn get_selector(self) -> FunctionSelector;\n    fn get_name(self) -> str<N>;\n    fn get_contract_address(self) -> AztecAddress;\n    fn get_is_static(self) -> bool;\n}\n\n// PrivateCallInterface\n\npub struct PrivateCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    /// Makes the call to this private function.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (see https://github.com/AztecProtocol/aztec-packages/pull/16433)\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn call(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            false,\n        );\n\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n\n    /// Makes a _read-only_ call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// See `call` for more general info on private function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T {\n        execution_cache::store(self.args, self.args_hash);\n        let returns_hash = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        // If T is () (i.e. if the function does not return anything) then `get_preimage` will constrain that the\n        // returns hash is empty as per the protocol rules.\n        returns_hash.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PrivateStaticCallInterface\n\npub struct PrivateStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PrivateStaticCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self {\n            target_contract,\n            selector,\n            name,\n            args_hash,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n        }\n    }\n\n    /// Makes a read-only call to this private function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn view(self, context: &mut PrivateContext) -> T\n    where\n        T: Deserialize,\n    {\n        execution_cache::store(self.args, self.args_hash);\n        let returns = context.call_private_function_with_args_hash(\n            self.target_contract,\n            self.selector,\n            self.args_hash,\n            true,\n        );\n        returns.get_preimage()\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PrivateStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicCallInterface\n\npub struct PublicCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    gas_opts: GasOpts,\n    return_type: T,\n    is_static: bool,\n}\n\nimpl<let M: u32, T> PublicCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n        is_static: bool,\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            gas_opts: GasOpts::default(),\n            return_type: std::mem::zeroed(),\n            is_static,\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the call to this public function.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn call(self, context: &mut PublicContext) -> T {\n        let returns = context.call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Makes a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        // If T is () (i.e. if the function does not return anything) then `as_array` will constrain that `returns` has\n        // a length of 0 (since that is ()'s deserialization length).\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a call to this public function, to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            false,\n        )\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n\n    /// Enqueues a call to this public function, and designates it to be the\n    /// teardown function for this tx. Only one teardown function call can be\n    /// made by a tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a hefty function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    /// See `enqueue` for more information about enqueuing public function calls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn set_as_teardown(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.set_public_teardown_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            false,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// PublicStaticCallInterface\n\npub struct PublicStaticCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args: [Field],\n    return_type: T,\n    is_static: bool,\n    gas_opts: GasOpts,\n}\n\nimpl<let M: u32, T> PublicStaticCallInterface<M, T>\nwhere\n    T: Deserialize,\n{\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        Self {\n            target_contract,\n            selector,\n            name,\n            args,\n            return_type: std::mem::zeroed(),\n            is_static: true,\n            gas_opts: GasOpts::default(),\n        }\n    }\n\n    pub fn with_gas(self: &mut Self, gas_opts: GasOpts) -> &mut Self {\n        self.gas_opts = gas_opts;\n        self\n    }\n\n    /// Makes the read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `context` - The PublicContext -- made magically available to the body\n    ///               of every #[public] function as `context`, through the\n    ///               #[public] annotation's macro.\n    ///\n    /// # Returns\n    /// * `T` - Whatever data the called function has returned.\n    ///\n    pub unconstrained fn view(self, context: &mut PublicContext) -> T {\n        let returns = context.static_call_public_function(\n            self.target_contract,\n            self.selector,\n            self.args,\n            self.gas_opts,\n        );\n        Deserialize::deserialize(returns.as_array())\n    }\n\n    /// Enqueues a read-only call to this public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state, emit L2->L1 messages, nor emit events. Any nested\n    /// calls are constrained to also be staticcalls.\n    ///\n    /// # Arguments\n    /// * `context` - The PrivateContext -- made magically available to the body\n    ///               of every #[private] function as `context`, through the\n    ///               #[private] annotation's macro.\n    ///\n    pub fn enqueue_view(self, context: &mut PrivateContext) {\n        let calldata = self.args.push_front(self.selector.to_field());\n        let calldata_hash = hash_calldata(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        context.call_public_function_with_calldata_hash(\n            self.target_contract,\n            calldata_hash,\n            /*static=*/\n            true,\n        )\n    }\n}\n\nimpl<let M: u32, T> CallInterface<M> for PublicStaticCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        self.is_static\n    }\n}\n\n// UtilityCallInterface\n\npub struct UtilityCallInterface<let M: u32, T> {\n    target_contract: AztecAddress,\n    selector: FunctionSelector,\n    name: str<M>,\n    args_hash: Field,\n    args: [Field],\n    return_type: T,\n}\n\nimpl<let M: u32, T> CallInterface<M> for UtilityCallInterface<M, T> {\n    fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n\n    fn get_is_static(self) -> bool {\n        false\n    }\n}\n\nimpl<let M: u32, T> UtilityCallInterface<M, T> {\n    pub fn new(\n        target_contract: AztecAddress,\n        selector: FunctionSelector,\n        name: str<M>,\n        args: [Field],\n    ) -> Self {\n        let args_hash = hash_args(args);\n        Self { target_contract, selector, name, args_hash, args, return_type: std::mem::zeroed() }\n    }\n\n    pub fn get_args(self) -> [Field] {\n        self.args\n    }\n\n    pub fn get_selector(self) -> FunctionSelector {\n        self.selector\n    }\n\n    pub fn get_name(self) -> str<M> {\n        self.name\n    }\n\n    pub fn get_contract_address(self) -> AztecAddress {\n        self.target_contract\n    }\n}\n"
    },
    "73": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/private_context.nr",
      "source": "use crate::{\n    context::{inputs::PrivateContextInputs, returns_hash::ReturnsHash},\n    hash::{ArgsHasher, hash_args_array, hash_calldata_array},\n    keys::constants::{NULLIFIER_INDEX, NUM_KEY_TYPES, OUTGOING_INDEX, sk_generators},\n    messaging::process_l1_to_l2_message,\n    oracle::{\n        block_header::get_block_header_at,\n        call_private_function::call_private_function_internal,\n        enqueue_public_function_call::{\n            notify_enqueued_public_function_call, notify_set_min_revertible_side_effect_counter,\n            notify_set_public_teardown_function_call,\n        },\n        execution_cache,\n        key_validation_request::get_key_validation_request,\n        logs::notify_created_contract_class_log,\n        notes::{notify_created_nullifier, notify_nullified_note},\n    },\n};\nuse dep::protocol_types::{\n    abis::{\n        block_header::BlockHeader,\n        call_context::CallContext,\n        function_selector::FunctionSelector,\n        gas_settings::GasSettings,\n        log_hash::LogHash,\n        note_hash::NoteHash,\n        nullifier::Nullifier,\n        private_call_request::PrivateCallRequest,\n        private_circuit_public_inputs::PrivateCircuitPublicInputs,\n        private_log::{PrivateLog, PrivateLogData},\n        public_call_request::PublicCallRequest,\n        read_request::ReadRequest,\n        side_effect::Counted,\n        validation_requests::{KeyValidationRequest, KeyValidationRequestAndGenerator},\n    },\n    address::{AztecAddress, EthAddress},\n    constants::{\n        CONTRACT_CLASS_LOG_SIZE_IN_FIELDS, MAX_CONTRACT_CLASS_LOGS_PER_CALL,\n        MAX_ENQUEUED_CALLS_PER_CALL, MAX_INCLUDE_BY_TIMESTAMP_DURATION,\n        MAX_KEY_VALIDATION_REQUESTS_PER_CALL, MAX_L2_TO_L1_MSGS_PER_CALL,\n        MAX_NOTE_HASH_READ_REQUESTS_PER_CALL, MAX_NOTE_HASHES_PER_CALL,\n        MAX_NULLIFIER_READ_REQUESTS_PER_CALL, MAX_NULLIFIERS_PER_CALL,\n        MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL, MAX_PRIVATE_LOGS_PER_CALL,\n        PRIVATE_LOG_SIZE_IN_FIELDS,\n    },\n    hash::poseidon2_hash,\n    messaging::l2_to_l1_message::L2ToL1Message,\n    traits::{Empty, Hash, ToField},\n    utils::arrays::{ClaimedLengthArray, trimmed_array_length_hint},\n};\n\n/// # PrivateContext\n///\n/// The **main interface** between a #[private] function and the Aztec blockchain.\n///\n/// An instance of the PrivateContext is initialized automatically at the outset\n/// of every private function, within the #[private] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it is always be available within\n/// the body of every #[private] function in your smart contract.\n///\n/// > For those used to \"vanilla\" Noir, it might be jarring to have access to\n/// > `context` without seeing a declaration `let context = PrivateContext::new(...)`\n/// > within the body of your function. This is just a consequence of using\n/// > macros to tidy-up verbose boilerplate. You can use `nargo expand` to\n/// > expand all macros, if you dare.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PrivateContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// > Advanced users might occasionally wish to push data to the context\n/// > directly for lower-level control. If you find yourself doing this, please\n/// > open an issue on GitHub to describe your use case: it might be that\n/// > new functionality should be added to aztec-nr.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a private function:\n///   - Data relating to how this private function was called.\n///     - msg_sender\n///     - this_address - (the contract address of the private function being\n///                      executed)\n///     - See `CallContext` for more data.\n///   - Data relating to the transaction in which this private function is\n///     being executed.\n///     - chain_id\n///     - version\n///     - gas_settings\n/// - Provides state access:\n///   - Access to the \"Anchor block\" header.\n///     Recall, a private function cannot read from the \"current\" block header,\n///     but must read from some historical block header, because as soon as\n///     private function execution begins (asynchronously, on a user's device),\n///     the public state of the chain (the \"current state\") will have progressed\n///     forward. We call this reference the \"Anchor block\".\n///     See `BlockHeader`.\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to functions of other smart contracts:\n///   - Private function calls\n///   - Enqueueing of public function call requests\n///     (Since public functions are executed at a later time, by a block\n///     proposer, we say they are \"enqueued\").\n/// - Writes data to the blockchain:\n///   - New notes\n///   - New nullifiers\n///   - Private logs (for sending encrypted note contents or encrypted events)\n///   - New L2->L1 messages.\n/// - Provides args to the private function (handled by the #[private] macro).\n/// - Returns the return values of this private function (handled by the\n///   #[private] macro).\n/// - Makes Key Validation Requests.\n///   - Private functions are not allowed to see master secret keys, because we\n///     do not trust them. They are instead given \"app-siloed\" secret keys with\n///     a claim that they relate to a master public key. They can then request\n///     validation of this claim, by making a \"key validation request\" to the\n///     protocol's kernel circuits (which _are_ allowed to see certain master\n///     secret keys).\n///\n/// ## Advanced Responsibilities\n///\n/// - Ultimately, the PrivateContext is responsible for constructing the\n///   PrivateCircuitPublicInputs of the private function being executed.\n///   All private functions on Aztec must have public inputs which adhere\n///   to the rigid layout of the PrivateCircuitPublicInputs, in order to be\n///   compatible with the protocol's kernel circuits.\n///   A well-known misnomer:\n///   - \"public inputs\" contain both inputs and outputs of this function.\n///     - By \"outputs\" we mean a lot more side-effects than just the\n///       \"return values\" of the function.\n///   - Most of the so-called \"public inputs\" are kept _private_, and never leak\n///     to the outside world, because they are 'swallowed' by the protocol's\n///     kernel circuits before the tx is sent to the network. Only the\n///     following are exposed to the outside world:\n///     - New note_hashes\n///     - New nullifiers\n///     - New private logs\n///     - New L2->L1 messages\n///     - New enqueued public function call requests\n///     All the above-listed arrays of side-effects can be padded by the\n///     user's wallet (through instructions to the kernel circuits, via the\n///     PXE) to obscure their true lengths.\n///\n/// ## Syntax Justification\n///\n/// Both user-defined functions _and_ most functions in aztec-nr need access to\n/// the PrivateContext instance to read/write data. This is why you'll see the\n/// arguably-ugly pervasiveness of the \"context\" throughout your smart contract\n/// and the aztec-nr library.\n/// For example, `&mut context` is prevalent. In some languages, you can access\n/// and mutate a global variable (such as a PrivateContext instance) from a\n/// function without polluting the function's parameters. With Noir, a function\n/// must explicitly pass control of a mutable variable to another function, by\n/// reference. Since many functions in aztec-nr need to be able to push new data\n/// to the PrivateContext, they need to be handed a mutable reference _to_ the\n/// context as a parameter.\n/// For example, `Context` is prevalent as a generic parameter, to give better\n/// type safety at compile time. Many `aztec-nr` functions don't make sense if\n/// they're called in a particular runtime (private, public or utility), and so\n/// are intentionally only implemented over certain\n/// [Private|Public|Utility]Context structs. This gives smart contract\n/// developers a much faster feedback loop if they're making a mistake, as an\n/// error will be thrown by the LSP or when they compile their contract.\n///\n#[derive(Eq)]\npub struct PrivateContext {\n    // docs:start:private-context\n    pub inputs: PrivateContextInputs,\n    pub side_effect_counter: u32,\n\n    pub min_revertible_side_effect_counter: u32,\n    pub is_fee_payer: bool,\n\n    pub args_hash: Field,\n    pub return_hash: Field,\n\n    pub include_by_timestamp: u64,\n\n    pub note_hash_read_requests: BoundedVec<ReadRequest, MAX_NOTE_HASH_READ_REQUESTS_PER_CALL>,\n    pub nullifier_read_requests: BoundedVec<ReadRequest, MAX_NULLIFIER_READ_REQUESTS_PER_CALL>,\n    key_validation_requests_and_generators: BoundedVec<KeyValidationRequestAndGenerator, MAX_KEY_VALIDATION_REQUESTS_PER_CALL>,\n\n    pub note_hashes: BoundedVec<NoteHash, MAX_NOTE_HASHES_PER_CALL>,\n    pub nullifiers: BoundedVec<Nullifier, MAX_NULLIFIERS_PER_CALL>,\n\n    pub private_call_requests: BoundedVec<PrivateCallRequest, MAX_PRIVATE_CALL_STACK_LENGTH_PER_CALL>,\n    pub public_call_requests: BoundedVec<Counted<PublicCallRequest>, MAX_ENQUEUED_CALLS_PER_CALL>,\n    pub public_teardown_call_request: PublicCallRequest,\n    pub l2_to_l1_msgs: BoundedVec<Counted<L2ToL1Message>, MAX_L2_TO_L1_MSGS_PER_CALL>,\n    // docs:end:private-context\n\n    // Header of a block whose state is used during private execution (not the block the transaction is included in).\n    pub historical_header: BlockHeader,\n\n    pub private_logs: BoundedVec<PrivateLogData, MAX_PRIVATE_LOGS_PER_CALL>,\n    pub contract_class_logs_hashes: BoundedVec<Counted<LogHash>, MAX_CONTRACT_CLASS_LOGS_PER_CALL>,\n\n    // Contains the last key validation request for each key type. This is used to cache the last request and avoid\n    // fetching the same request multiple times.\n    // The index of the array corresponds to the key type (0 nullifier, 1 incoming, 2 outgoing, 3 tagging).\n    pub last_key_validation_requests: [Option<KeyValidationRequest>; NUM_KEY_TYPES],\n}\n\nimpl PrivateContext {\n    pub fn new(inputs: PrivateContextInputs, args_hash: Field) -> PrivateContext {\n        let max_allowed_include_by_timestamp =\n            inputs.historical_header.global_variables.timestamp + MAX_INCLUDE_BY_TIMESTAMP_DURATION;\n        PrivateContext {\n            inputs,\n            side_effect_counter: inputs.start_side_effect_counter + 1,\n            min_revertible_side_effect_counter: 0,\n            is_fee_payer: false,\n            args_hash,\n            return_hash: 0,\n            include_by_timestamp: max_allowed_include_by_timestamp,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            historical_header: inputs.historical_header,\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// TODO(https://github.com/AztecProtocol/aztec-packages/issues/14025) - we\n    /// are considering making msg_sender: Option<AztecAddress>, since\n    /// a returned value of `Option:none` will be clearer to developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the smart contract that called\n    ///   this function (be it an app contract or a user's account contract).\n    ///   Returns `-1` for the first function call of the tx.\n    ///\n    pub fn msg_sender(self) -> AztecAddress {\n        self.inputs.call_context.msg_sender\n    }\n\n    /// Returns the contract address of the current function being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(self) -> AztecAddress {\n        self.inputs.call_context.contract_address\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(self) -> Field {\n        self.inputs.tx_context.chain_id\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(self) -> Field {\n        self.inputs.tx_context.version\n    }\n\n    /// Returns the gas settings for the current transaction.\n    ///\n    /// This provides information about gas limits and pricing for the\n    /// transaction, similar to `tx.gasprice` and gas limits in Ethereum.\n    /// However, Aztec has a more sophisticated gas model with separate\n    /// accounting for L2 computation and data availability (DA) costs.\n    ///\n    /// # Returns\n    /// * `GasSettings` - Struct containing gas limits and fee information\n    ///\n    pub fn gas_settings(self) -> GasSettings {\n        self.inputs.tx_context.gas_settings\n    }\n\n    /// Returns the function selector of the currently executing function.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to access this.\n    ///\n    /// This is similar to `msg.sig` in Solidity, which returns the first 4\n    /// bytes of the function signature. In Aztec, the selector uniquely\n    /// identifies which function within the contract is being called.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// Only #[private] functions have a function selector as a protocol-\n    /// enshrined concept. The function selectors of private functions are\n    /// baked into the preimage of the contract address, and are used by the\n    /// protocol's kernel circuits to identify each private function and ensure\n    /// the correct one is being executed.\n    ///\n    /// Used internally for function dispatch and call verification.\n    ///\n    pub fn selector(self) -> FunctionSelector {\n        self.inputs.call_context.function_selector\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: You shouldn't need to call this. The #[private]\n    /// macro calls this, and it makes the arguments neatly available to the\n    /// body of your private function.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    /// # Advanced\n    /// * Arguments are hashed to reduce proof size and verification time\n    /// * Enables efficient argument passing in recursive function calls\n    /// * The hash can be used to retrieve the original arguments from the PXE.\n    ///\n    pub fn get_args_hash(self) -> Field {\n        self.args_hash\n    }\n\n    /// Pushes a new note_hash to the Aztec blockchain's global Note Hash Tree\n    /// (a state tree).\n    ///\n    /// A note_hash is a commitment to a piece of private state.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note hashes.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The new note_hash.\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// note_hash into the protocol's \"note hash tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `note_hash` with the contract address of this function,\n    ///   to yield a `siloed_note_hash`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure uniqueness of the `siloed_note_hash`, to prevent Faerie-Gold\n    ///   attacks, by hashing the `siloed_note_hash` with a unique value, to\n    ///   yield a `unique_siloed_note_hash` (see the protocol spec for more).\n    ///\n    /// In addition to calling this function, aztec-nr provides the contents\n    /// of the newly-created note to the PXE, via the `notify_created_note`\n    /// oracle.\n    ///\n    /// > Advanced users might occasionally wish to push data to the context\n    /// > directly for lower-level control. If you find yourself doing this,\n    /// > please open an issue on GitHub to describe your use case: it might be\n    /// > that new functionality should be added to aztec-nr.\n    ///\n    pub fn push_note_hash(&mut self, note_hash: Field) {\n        self.note_hashes.push(NoteHash { value: note_hash, counter: self.next_counter() });\n    }\n\n    /// Pushes a new nullifier to the Aztec blockchain's global Nullifier Tree\n    /// (a state tree).\n    ///\n    /// See also: `push_nullifier_for_note_hash`.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// A nullifier can only be emitted once. Duplicate nullifier insertions are\n    /// rejected by the protocol.\n    ///\n    /// Generally, a nullifier is emitted to prevent an action from happening\n    /// more than once, in such a way that the action cannot be linked (by an\n    /// observer of the blockchain) to any earlier transactions.\n    ///\n    /// I.e. a nullifier is a random-looking, but deterministic record of a\n    /// private, one-time action, which does not leak what action has been\n    /// taken, and which preserves the property of \"tx unlinkability\".\n    ///\n    /// Usually, a nullifier will be emitted to \"spend\" a note (a piece of\n    /// private state), without revealing which specific note is being spent.\n    ///\n    /// (Important: in such cases, use the below `push_nullifier_for_note_hash`).\n    ///\n    /// Sometimes, a nullifier might be emitted completely unrelated to any\n    /// notes. Examples include initialization of a new contract; initialization\n    /// of a PrivateMutable, or signalling in Semaphore-like applications.\n    /// This `push_nullifier` function serves such use cases.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    ///\n    /// # Advanced\n    /// From here, the protocol's kernel circuits will take over and insert the\n    /// nullifier into the protocol's \"nullifier tree\" (in the Base Rollup\n    /// circuit).\n    /// Before insertion, the protocol will:\n    /// - \"Silo\" the `nullifier` with the contract address of this function,\n    ///   to yield a `siloed_nullifier`. This prevents state collisions\n    ///   between different smart contracts.\n    /// - Ensure the `siloed_nullifier` is unique (the nullifier tree is an\n    ///   indexed merkle tree which supports efficient non-membership proofs).\n    ///\n    pub fn push_nullifier(&mut self, nullifier: Field) {\n        notify_created_nullifier(nullifier);\n        self.nullifiers.push(\n            Nullifier { value: nullifier, note_hash: 0, counter: self.next_counter() },\n        );\n    }\n\n    /// Pushes a nullifier that corresponds to a specific note hash.\n    ///\n    /// Low-level function: Ordinarily, smart contract developers will not need\n    /// to manually call this. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifiers.\n    ///\n    /// This is a specialized version of `push_nullifier` that links a nullifier\n    /// to the specific note hash it's nullifying. This is the most common\n    /// usage pattern for nullifiers.\n    /// See `push_nullifier` for more explanation on nullifiers.\n    ///\n    /// # Arguments\n    /// * `nullifier`\n    /// * `nullified_note_hash` - The note hash of the note being nullified\n    ///\n    /// # Advanced\n    /// Important: usage of this function doesn't mean that the world will _see_\n    /// that this nullifier relates to the given nullified_note_hash (as that\n    /// would violate \"tx unlinkability\"); it simply informs the user's PXE\n    /// about the relationship (via `notify_nullified_note`). The PXE can then\n    /// use this information to feed hints to the kernel circuits for\n    /// \"squashing\" purposes: If a note is nullified during the same tx which\n    /// created it, we can \"squash\" (delete) the note and nullifier (and any\n    /// private logs associated with the note), to save on data emission costs.\n    ///\n    pub fn push_nullifier_for_note_hash(&mut self, nullifier: Field, nullified_note_hash: Field) {\n        let nullifier_counter = self.next_counter();\n        notify_nullified_note(nullifier, nullified_note_hash, nullifier_counter);\n        self.nullifiers.push(\n            Nullifier {\n                value: nullifier,\n                note_hash: nullified_note_hash,\n                counter: nullifier_counter,\n            },\n        );\n    }\n\n    /// Returns the anchor block header - the historical block header that this\n    /// private function is reading from.\n    ///\n    /// A private function CANNOT read from the \"current\" block header,\n    /// but must read from some historical block header, because as soon as\n    /// private function execution begins (asynchronously, on a user's device),\n    /// the public state of the chain (the \"current state\") will have progressed\n    /// forward.\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The anchor block header.\n    ///\n    /// # Advanced\n    /// * All private functions of a tx read from the same anchor block header.\n    /// * The protocol asserts that the `include_by_timestamp` of every tx\n    ///   is at most 24 hours beyond the timestamp of the tx's chosen anchor\n    ///   block header. This enables the network's nodes to safely prune old txs\n    ///   from the mempool. Therefore, the chosen block header _must_ be one\n    ///   from within the last 24 hours.\n    ///\n    pub fn get_block_header(self) -> BlockHeader {\n        self.historical_header\n    }\n\n    /// Returns the header of any historical block at or before the anchor\n    /// block.\n    ///\n    /// This enables private contracts to access information from even older\n    /// blocks than the anchor block header.\n    ///\n    /// Useful for time-based contract logic that needs to compare against\n    /// multiple historical points.\n    ///\n    /// # Arguments\n    /// * `block_number` - The block number to retrieve (must be <= anchor\n    ///                    block number)\n    ///\n    /// # Returns\n    /// * `BlockHeader` - The header of the requested historical block\n    ///\n    /// # Advanced\n    /// This function uses an oracle to fetch block header data from the user's\n    /// PXE. Depending on how much blockchain data the user's PXE has been set\n    /// up to store, this might require a query from the PXE to another Aztec\n    /// node to get the data.\n    /// > This is generally true of all oracle getters (see `../oracle`).\n    ///\n    /// Each block header gets hashed and stored as a leaf in the protocol's\n    /// Archive Tree. In fact, the i-th block header gets stored at the i-th\n    /// leaf index of the Archive Tree. Behind the scenes, this\n    /// `get_block_header_at` function will add Archive Tree merkle-membership\n    /// constraints (~3k) to your smart contract function's circuit, to prove\n    /// existence of the block header in the Archive Tree.\n    ///\n    /// Note: we don't do any caching, so avoid making duplicate calls for the\n    /// same block header, because each call will add duplicate constraints.\n    ///\n    /// Calling this function is more expensive (constraint-wise) than getting\n    /// the anchor block header (via `get_block_header`). This is because the\n    /// anchor block's merkle membership proof is handled by Aztec's protocol\n    /// circuits, and is only performed once for the entire tx because all\n    /// private functions of a tx share a common anchor block header. Therefore,\n    /// the cost (constraint-wise) of calling `get_block_header` is effectively\n    /// free.\n    ///\n    pub fn get_block_header_at(self, block_number: u32) -> BlockHeader {\n        get_block_header_at(block_number, self)\n    }\n\n    /// Sets the hash of the return values for this private function.\n    ///\n    /// Very low-level function: this is called by the #[private] macro.\n    ///\n    /// # Arguments\n    /// * `returns_hasher` - A hasher containing the return values to hash\n    ///\n    pub fn set_return_hash(&mut self, returns_hasher: ArgsHasher) {\n        self.return_hash = returns_hasher.hash();\n        execution_cache::store(returns_hasher.fields, self.return_hash);\n    }\n\n    /// Builds the PrivateCircuitPublicInputs for this private function, to\n    /// ensure compatibility with the protocol's kernel circuits.\n    ///\n    /// Very low-level function: This function is automatically called by the\n    /// #[private] macro.\n    pub fn finish(self) -> PrivateCircuitPublicInputs {\n        PrivateCircuitPublicInputs {\n            call_context: self.inputs.call_context,\n            args_hash: self.args_hash,\n            returns_hash: self.return_hash,\n            min_revertible_side_effect_counter: self.min_revertible_side_effect_counter,\n            is_fee_payer: self.is_fee_payer,\n            include_by_timestamp: self.include_by_timestamp,\n            note_hash_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.note_hash_read_requests,\n            ),\n            nullifier_read_requests: ClaimedLengthArray::from_bounded_vec(\n                self.nullifier_read_requests,\n            ),\n            key_validation_requests_and_generators: ClaimedLengthArray::from_bounded_vec(\n                self.key_validation_requests_and_generators,\n            ),\n            note_hashes: ClaimedLengthArray::from_bounded_vec(self.note_hashes),\n            nullifiers: ClaimedLengthArray::from_bounded_vec(self.nullifiers),\n            private_call_requests: ClaimedLengthArray::from_bounded_vec(self.private_call_requests),\n            public_call_requests: ClaimedLengthArray::from_bounded_vec(self.public_call_requests),\n            public_teardown_call_request: self.public_teardown_call_request,\n            l2_to_l1_msgs: ClaimedLengthArray::from_bounded_vec(self.l2_to_l1_msgs),\n            start_side_effect_counter: self.inputs.start_side_effect_counter,\n            end_side_effect_counter: self.side_effect_counter,\n            private_logs: ClaimedLengthArray::from_bounded_vec(self.private_logs),\n            contract_class_logs_hashes: ClaimedLengthArray::from_bounded_vec(\n                self.contract_class_logs_hashes,\n            ),\n            historical_header: self.historical_header,\n            tx_context: self.inputs.tx_context,\n        }\n    }\n\n    /// Designates this contract as the fee payer for the transaction.\n    ///\n    /// Unlike Ethereum, where the transaction sender always pays fees, Aztec\n    /// allows any contract to voluntarily pay transaction fees. This enables\n    /// patterns like sponsored transactions or fee abstraction where users\n    /// don't need to hold fee-juice themselves. (Fee juice is a fee-paying\n    /// asset for Aztec).\n    ///\n    /// Only one contract per transaction can declare itself as the fee payer,\n    /// and it must have sufficient fee-juice balance (>= the gas limits\n    /// specified in the TxContext) by the time we reach the public setup phase\n    /// of the tx.\n    ///\n    pub fn set_as_fee_payer(&mut self) {\n        dep::protocol_types::debug_log::debug_log_format(\n            \"Setting {0} as fee payer\",\n            [self.this_address().to_field()],\n        );\n        self.is_fee_payer = true;\n    }\n\n    /// Declares the end of the \"setup phase\" of this tx.\n    ///\n    /// Only one function per tx can declare the end of the setup phase.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase enables such a payment to\n    /// be made, because the setup phase _cannot revert_: a reverting function\n    /// within the setup phase would result in an invalid block which cannot\n    /// be proven. Any side-effects generated during that phase are guaranteed\n    /// to be inserted into Aztec's state trees (except for squashed notes &\n    /// nullifiers, of course).\n    ///\n    /// Even though the end of the setup phase is declared within a private\n    /// function, you might have noticed that _public_ functions can also\n    /// execute within the setup phase. This is because any public function\n    /// calls which were enqueued _within the setup phase_ by a private\n    /// function are considered part of the setup phase.\n    ///\n    /// # Advanced\n    /// * Sets the minimum revertible side effect counter of this tx to be the\n    /// PrivateContext's _current_ side effect counter.\n    ///\n    pub fn end_setup(&mut self) {\n        // dep::protocol_types::debug_log::debug_log_format(\n        //     \"Ending setup at counter {0}\",\n        //     [self.side_effect_counter as Field]\n        // );\n        self.min_revertible_side_effect_counter = self.side_effect_counter;\n        notify_set_min_revertible_side_effect_counter(self.min_revertible_side_effect_counter);\n    }\n\n    /// Sets a deadline (an \"include-by timestamp\") for when this transaction\n    /// must be included in a block.\n    ///\n    /// Other functions in this tx might call this setter with differing\n    /// values for the include-by timestamp. To ensure that all functions'\n    /// deadlines are met, the _minimum_ of all these include-by timestamps will\n    /// be exposed when this tx is submitted to the network.\n    ///\n    /// If the transaction is not included in a block by its include-by\n    /// timestamp, it becomes invalid and it will never be included.\n    ///\n    /// This expiry timestamp is publicly visible. See the \"Advanced\" section\n    /// for privacy concerns.\n    ///\n    /// # Arguments\n    /// * `include_by_timestamp` - Unix timestamp (seconds) deadline for inclusion.\n    ///                            The include-by timestamp of this tx will be\n    ///                            _at most_ the timestamp specified.\n    ///\n    /// # Advanced\n    /// * If multiple functions set differing `include_by_timestamp`s, the\n    ///   kernel circuits will set it to be the _minimum_ of the two. This\n    ///   ensures the tx expiry requirements of all functions in the tx are met.\n    /// * Rollup circuits will reject expired txs.\n    /// * The protocol enforces that all transactions must be included within\n    ///   24 hours of their chosen anchor block's timestamp, to enable safe\n    ///   mempool pruning.\n    /// * The DelayedPublicMutable design makes heavy use of this functionality,\n    ///   to enable private functions to read public state.\n    /// * A sophisticated Wallet should cleverly set an include-by timestamp\n    ///   to improve the privacy of the user and the network as a whole.\n    ///   For example, if a contract interaction sets include-by to some\n    ///   publicly-known value (e.g. the time when a contract upgrades), then\n    ///   the wallet might wish to set an even lower one to avoid revealing that\n    ///   this tx is interacting with said contract.\n    ///   Ideally, all wallets should standardise on an approach in order to\n    ///   provide users with a large anonymity set -- although the exact apprach\n    ///   will need to be discussed. Wallets that deviate from a standard might\n    ///   accidentally reveal which wallet each transaction originates from.\n    ///\n    // docs:start:include-by-timestamp\n    pub fn set_include_by_timestamp(&mut self, include_by_timestamp: u64) {\n        // docs:end:include-by-timestamp\n        self.include_by_timestamp = std::cmp::min(self.include_by_timestamp, include_by_timestamp);\n    }\n\n    /// Makes a request to the protocol's kernel circuit to ensure a note_hash\n    /// actually exists.\n    ///\n    /// \"Read requests\" are used to prove that a note hash exists without\n    /// revealing which specific note was read.\n    ///\n    /// This can be used to prove existence of both settled notes (created in\n    /// prior transactions) and transient notes (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled note _at a specific block\n    /// number_, use `note_inclusion::prove_note_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new note_hash read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to read and verify\n    ///\n    /// # Advanced\n    /// In \"traditional\" circuits for non-Aztec privacy applications, the merkle\n    /// membership proofs to check existence of a note are performed _within_\n    /// the application circuit.\n    ///\n    /// All Aztec private functions have access to the following constraint\n    /// optimisation:\n    /// In cases where the note being read was created earlier in the same tx,\n    /// the note wouldn't yet exist in the Note Hash Tree, so a hard-coded\n    /// merkle membership check which then gets ignored would be a waste of\n    /// constraints.\n    /// Instead, we can send read requests for all notes to the protocol's\n    /// kernel circuits, where we can conditionally assess which notes actually\n    /// need merkle membership proofs, and select an appropriately-sized\n    /// kernel circuit.\n    ///\n    /// For \"settled notes\" (which already existed in the Note Hash Tree of the\n    /// anchor block (i.e. before the tx began)), the kernel does a merkle\n    /// membership check.\n    ///\n    /// For \"pending notes\" (which were created earlier in _this_ tx), the\n    /// kernel will check that the note existed _before_ this read request was\n    /// made, by checking the side-effect counters of the note_hash and this\n    /// read request.\n    ///\n    /// This approach improves latency between writes and reads:\n    /// a function can read a note which was created earlier in the tx (rather\n    /// than performing the read in a later tx, after waiting for the earlier tx\n    /// to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_note_hash_read_request(&mut self, note_hash: Field) {\n        let side_effect = ReadRequest { value: note_hash, counter: self.next_counter() };\n        self.note_hash_read_requests.push(side_effect);\n    }\n\n    /// Requests to read a specific nullifier from the nullifier tree.\n    ///\n    /// Nullifier read requests are used to prove that a nullifier exists without\n    /// revealing which specific nullifier preimage was read.\n    ///\n    /// This can be used to prove existence of both settled nullifiers (created in\n    /// prior transactions) and transient nullifiers (created in the current\n    /// transaction).\n    /// If you need to prove existence of a settled nullifier _at a specific block\n    /// number_, use `nullifier_inclusion::prove_nullifier_inclusion`.\n    ///\n    /// Low-level function. Ordinarily, smart contract developers will not need\n    /// to call this directly. Aztec-nr's state variables (see `../state_vars/`)\n    /// are designed to understand when to create and push new nullifier read\n    /// requests.\n    ///\n    /// # Arguments\n    /// * `nullifier` - The nullifier to read and verify\n    ///\n    /// # Advanced\n    /// This approach improves latency between writes and reads:\n    /// a function can read a nullifier which was created earlier in the tx\n    /// (rather than performing the read in a later tx, after waiting for the\n    /// earlier tx to be included, to ensure the note is included in the tree).\n    ///\n    pub fn push_nullifier_read_request(&mut self, nullifier: Field) {\n        let request = ReadRequest { value: nullifier, counter: self.next_counter() };\n        self.nullifier_read_requests.push(request);\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// Advanced function: Only needed if you're designing your own notes and/or\n    /// nullifiers.\n    ///\n    /// Contracts are not allowed to compute nullifiers for other contracts, as\n    /// that would let them read parts of their private state. Because of this,\n    /// a contract is only given an \"app-siloed secret key\", which is\n    /// constructed by hashing the user's master nullifier secret key with the\n    /// contract's address.\n    /// However, because contracts cannot be trusted with a user's master\n    /// nullifier secret key (because we don't know which contracts are honest\n    /// or malicious), the PXE refuses to provide any master secret keys to\n    /// any app smart contract function. This means app functions are unable to\n    /// prove that the derivation of an app-siloed nullifier secret key has been\n    /// computed correctly. Instead, an app function can request to the kernel\n    /// (via `request_nsk_app`) that it validates the siloed derivation, since\n    /// the kernel has been vetted to not leak any master secret keys.\n    ///\n    /// A common nullification scheme is to inject a nullifier secret key into\n    /// the preimage of a nullifier, to make the nullifier deterministic but\n    /// random-looking. This function enables that flow.\n    ///\n    /// # Arguments\n    /// * `npk_m_hash` - A hash of the master nullifier public key of the user\n    ///                  whose PXE is executing this function.\n    ///\n    /// # Returns\n    /// * The app-siloed nullifier secret key that corresponds to the given\n    ///   `npk_m_hash`.\n    ///\n    pub fn request_nsk_app(&mut self, npk_m_hash: Field) -> Field {\n        self.request_sk_app(npk_m_hash, NULLIFIER_INDEX)\n    }\n\n    /// Requests the app-siloed nullifier secret key (nsk_app) for the given\n    /// (hashed) master nullifier public key (npk_m), from the user's PXE.\n    ///\n    /// See `request_nsk_app` and `request_sk_app` for more info.\n    ///\n    /// The intention of the \"outgoing\" keypair is to provide a second secret\n    /// key for all of a user's outgoing activity (i.e. for notes that a user\n    /// creates, as opposed to notes that a user receives from others). The\n    /// separation of incoming and outgoing data was a distinction made by\n    /// zcash, with the intention of enabling a user to optionally share with a\n    /// 3rd party a controlled view of only incoming or outgoing notes.\n    /// Similar functionality of sharing select data can be achieved with\n    /// offchain zero-knowledge proofs. It is up to an app developer whether\n    /// they choose to make use of a user's outgoing keypair within their\n    /// application logic, or instead simply use the same keypair (the address\n    /// keypair (which is effectively the same as the \"incooming\" keypair)) for\n    /// all incoming & outgoing messages to a user.\n    ///\n    /// Currently, all of the exposed encryption functions in aztec-nr ignore\n    /// the outgoing viewing keys, and instead encrypt all note logs and event\n    /// logs to a user's address public key.\n    ///\n    /// # Arguments\n    /// * `ovpk_m_hash` - Hash of the outgoing viewing public key master\n    ///\n    /// # Returns\n    /// * The application-specific outgoing viewing secret key\n    ///\n    pub fn request_ovsk_app(&mut self, ovpk_m_hash: Field) -> Field {\n        self.request_sk_app(ovpk_m_hash, OUTGOING_INDEX)\n    }\n\n    /// Pushes a Key Validation Request to the kernel.\n    ///\n    /// Private functions are not allowed to see a user's master secret keys,\n    /// because we do not trust them. They are instead given \"app-siloed\" secret\n    /// keys with a claim that they relate to a master public key.\n    /// They can then request validation of this claim, by making a \"key\n    /// validation request\" to the protocol's kernel circuits (which _are_\n    /// allowed to see certain master secret keys).\n    ///\n    /// When a Key Validation Request tuple of (sk_app, Pk_m, app_address) is\n    /// submitted to the kernel, it will perform the following derivations\n    /// to validate the relationship between the claimed sk_app and the user's\n    /// Pk_m:\n    ///\n    ///       (sk_m) ----> * G ----> Pk_m\n    ///         |                     |\n    ///         v                       We use the kernel to prove this\n    ///  h(sk_m, app_address)         | sk_app-Pk_m relationship, because app\n    ///         |                       circuits must not be trusted to see sk_m.\n    ///         v                     |\n    ///      sk_app - -  - - - - - - -\n    ///\n    /// The function is named \"request_\" instead of \"get_\" to remind the user\n    /// that a Key Validation Request will be emitted to the kernel.\n    ///\n    fn request_sk_app(&mut self, pk_m_hash: Field, key_index: Field) -> Field {\n        let cached_request = self.last_key_validation_requests[key_index as u32].unwrap_or(\n            KeyValidationRequest::empty(),\n        );\n\n        if cached_request.pk_m.hash() == pk_m_hash {\n            // We get a match so the cached request is the latest one\n            cached_request.sk_app\n        } else {\n            // We didn't get a match meaning the cached result is stale\n            // Typically we'd validate keys by showing that they are the preimage of `pk_m_hash`, but that'd require\n            // the oracle returning the master secret keys, which could cause malicious contracts to leak it or learn\n            // about secrets from other contracts. We therefore silo secret keys, and rely on the private kernel to\n            // validate that we siloed secret key corresponds to correct siloing of the master secret key that hashes\n            // to `pk_m_hash`.\n\n            // Safety: Kernels verify that the key validation request is valid and below we verify that a request\n            // for the correct public key has been received.\n            let request = unsafe { get_key_validation_request(pk_m_hash, key_index) };\n            assert_eq(request.pk_m.hash(), pk_m_hash, \"Obtained invalid key validation request\");\n\n            self.key_validation_requests_and_generators.push(\n                KeyValidationRequestAndGenerator {\n                    request,\n                    sk_app_generator: sk_generators[key_index as u32],\n                },\n            );\n            self.last_key_validation_requests[key_index as u32] = Option::some(request);\n            request.sk_app\n        }\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element).\n    ///               This content has a very specific layout.\n    /// docs:start:context_message_portal\n    pub fn message_portal(&mut self, recipient: EthAddress, content: Field) {\n        // docs:end:context_message_portal\n        let message = L2ToL1Message { recipient, content };\n        self.l2_to_l1_msgs.push(message.count(self.next_counter()));\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2).\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree;\n    /// messages never technically get deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target L2 contract. The message will need to be manually\n    /// consumed by the target contract through a separate Aztec transaction.\n    /// The message will not be available for consumption immediately. Messages\n    /// get copied over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// Validates message existence in the L1-to-L2 message tree and nullifies\n    /// the message to prevent double-consumption.\n    ///\n    // docs:start:context_consume_l1_to_l2_message\n    // docs:start:consume_l1_to_l2_message\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        // docs:end:context_consume_l1_to_l2_message\n        let nullifier = process_l1_to_l2_message(\n            self.historical_header.state.l1_to_l2_message_tree.root,\n            self.this_address(),\n            sender,\n            self.chain_id(),\n            self.version(),\n            content,\n            secret,\n            leaf_index,\n        );\n\n        // Push nullifier (and the \"commitment\" corresponding to this can be \"empty\")\n        self.push_nullifier(nullifier)\n    }\n    // docs:end:consume_l1_to_l2_message\n\n    /// Emits a private log (an array of Fields) that will be published to an\n    /// Ethereum blob.\n    ///\n    /// Private logs are intended for the broadcasting of ciphertexts: that is,\n    /// encrypted events or encrypted note contents.\n    /// Since the data in the logs is meant to be _encrypted_, private_logs are\n    /// broadcast to publicly-visible Ethereum blobs.\n    /// The intended recipients of such encrypted messages can then discover and\n    /// decrypt these encrypted logs using their viewing secret key.\n    /// (See `../messages/discovery` for more details).\n    ///\n    /// Important note: This function DOES NOT _do_ any encryption of the input\n    /// `log` fields. This function blindly publishes whatever input `log` data\n    /// is fed into it, so the caller of this function should have already\n    /// performed the encryption, and the `log` should be the result of that\n    /// encryption.\n    ///\n    /// The protocol does not dictate what encryption scheme should be used:\n    /// a smart contract developer can choose whatever encryption scheme they\n    /// like.\n    /// Aztec-nr includes some off-the-shelf encryption libraries that\n    /// developers might wish to use, for convenience. These libraries not only\n    /// encrypt a plaintext (to produce a ciphertext); they also prepend the\n    /// ciphertext with a `tag` and `ephemeral public key` for easier message\n    /// discovery. This is a very dense topic, and we will be writing more\n    /// libraries and docs soon.\n    ///\n    /// > Currently, AES128 CBC encryption is the main scheme included in\n    /// > aztec.nr.\n    /// > We are currently making significant changes to the interfaces of the\n    /// > encryption library.\n    ///\n    /// In some niche use cases, an app might be tempted to publish\n    /// _un-encrypted_ data via a private log, because _public logs_ are not\n    /// available to private functions. Be warned that emitting public data via\n    /// private logs is strongly discouraged, and is considered a \"privacy\n    /// anti-pattern\", because it reveals identifiable information about _which_\n    /// function has been executed. A tx which leaks such information does not\n    /// contribute to the privacy set of the network.\n    ///\n    /// * Unlike `emit_raw_note_log`, this log is not tied to any specific note\n    ///\n    /// # Arguments\n    /// * `log` - The log data that will be publicly broadcast (so make sure\n    ///           it's already been encrypted before you call this function).\n    ///   Private logs are bounded in size (PRIVATE_LOG_SIZE_IN_FIELDS), to\n    ///   encourage all logs from all smart contracts look identical.\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields). Although the input log has a max size of\n    ///   PRIVATE_LOG_SIZE_IN_FIELDS, the latter values of the array might all\n    ///   be 0's for small logs. This `length` should reflect the trimmed length\n    ///   of the array. The protocol's kernel circuits can then append random\n    ///   fields as \"padding\" after the `length`, so that the logs of this\n    ///   smart contract look indistinguishable from (the same length as) the\n    ///   logs of all other applications. It's up to wallets how much padding\n    ///   to apply, so ideally all wallets should agree on standards for this.\n    ///\n    /// # Advanced\n    ///\n    pub fn emit_private_log(&mut self, log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS], length: u32) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter: 0, counter };\n        self.private_logs.push(private_log);\n    }\n\n    // TODO: rename.\n    /// Emits a private log that is explicitly tied to a newly-emitted note_hash,\n    /// to convey to the kernel: \"this log relates to this note\".\n    ///\n    /// This linkage is important in case the note gets squashed (due to being\n    /// read later in this same tx), since we can then squash the log as well.\n    ///\n    /// See `emit_private_log` for more info about private log emission.\n    ///\n    /// # Arguments\n    /// * `log` - The log data as an array of Field elements\n    /// * `length` - The actual length of the `log` (measured in number of\n    ///              Fields).\n    /// * `note_hash_counter` - The side-effect counter that was assigned to the\n    ///                         new note_hash when it was pushed to this\n    //                          `PrivateContext`.\n    ///\n    /// Important: If your application logic requires the log to always be\n    /// emitted regardless of note squashing, consider using `emit_private_log`\n    /// instead, or emitting additional events.\n    ///\n    pub fn emit_raw_note_log(\n        &mut self,\n        log: [Field; PRIVATE_LOG_SIZE_IN_FIELDS],\n        length: u32,\n        note_hash_counter: u32,\n    ) {\n        let counter = self.next_counter();\n        let private_log =\n            PrivateLogData { log: PrivateLog::new(log, length), note_hash_counter, counter };\n        self.private_logs.push(private_log);\n    }\n\n    pub fn emit_contract_class_log<let N: u32>(&mut self, log: [Field; N]) {\n        let contract_address = self.this_address();\n        let counter = self.next_counter();\n\n        let log_to_emit: [Field; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS] =\n            log.concat([0; CONTRACT_CLASS_LOG_SIZE_IN_FIELDS - N]);\n        // Note: the length is not always N, it is the number of fields we want to broadcast, omitting trailing zeros to save blob space.\n        // Safety: The below length is constrained in the base rollup, which will make sure that all the fields beyond length are zero.\n        let length = unsafe { trimmed_array_length_hint(log_to_emit) };\n        // We hash the entire padded log to ensure a user cannot pass a shorter length and so emit incorrect shorter bytecode.\n        let log_hash = poseidon2_hash(log_to_emit);\n        // Safety: the below only exists to broadcast the raw log, so we can provide it to the base rollup later to be constrained.\n        unsafe {\n            notify_created_contract_class_log(contract_address, log_to_emit, length, counter);\n        }\n\n        self.contract_class_logs_hashes.push(LogHash { value: log_hash, length: length }.count(\n            counter,\n        ));\n    }\n\n    /// Calls a private function on another contract (or the same contract).\n    ///\n    /// Very low-level function.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    /// This enables contracts to interact with each other while maintaining\n    /// privacy. This \"composability\" of private contract functions is a key\n    /// feature of the Aztec network.\n    ///\n    /// If a user's transaction includes multiple private function calls, then\n    /// by the design of Aztec, the following information will remain private[1]:\n    /// - The function selectors and contract addresses of all private function\n    ///   calls will remain private, so an observer of the public mempool will\n    ///   not be able to look at a tx and deduce which private functions have\n    ///   been executed.\n    /// - The arguments and return values of all private function calls will\n    ///   remain private.\n    /// - The person who initiated the tx will remain private.\n    /// - The notes and nullifiers and private logs that are emitted by all\n    ///   private function calls will (if designed well) not leak any user\n    ///   secrets, nor leak which functions have been executed.\n    ///\n    /// [1] Caveats: Some of these privacy guarantees depend on how app\n    /// developers design their smart contracts. Some actions _can_ leak\n    /// information, such as:\n    /// - Calling an internal public function.\n    /// - Calling a public function and not setting msg_sender to Option::none\n    ///   (feature not built yet - see github).\n    /// - Calling any public function will always leak details about the nature\n    ///   of the transaction, so devs should be careful in their contract\n    ///   designs. If it can be done in a private function, then that will give\n    ///   the best privacy.\n    /// - Not padding the side-effects of a tx to some standardised, uniform\n    ///   size. The kernel circuits can take hints to pad side-effects, so a\n    ///   wallet should be able to request for a particular amount of padding.\n    ///   Wallets should ideally agree on some standard.\n    ///   - Padding should include:\n    ///     - Padding the lengths of note & nullifier arrays\n    ///     - Padding private logs with random fields, up to some standardised\n    ///       size.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Advanced\n    /// * The call is added to the private call stack and executed by kernel\n    ///   circuits after this function completes\n    /// * The called function can modify its own contract's private state\n    /// * Side effects from the called function are included in this transaction\n    /// * The call inherits the current transaction's context and gas limits\n    ///\n    pub fn call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            false,\n        )\n    }\n\n    /// Makes a read-only call to a private function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See `call_private_function` for more general info on private function\n    /// calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the called function\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) -> ReturnsHash {\n        let args_hash = hash_args_array(args);\n        execution_cache::store(args, args_hash);\n        self.call_private_function_with_args_hash(\n            contract_address,\n            function_selector,\n            args_hash,\n            true,\n        )\n    }\n\n    /// Calls a private function that takes no arguments.\n    ///\n    /// This is a convenience function for calling private functions that don't\n    /// require any input parameters. It's equivalent to `call_private_function`\n    /// but slightly more efficient to use when no arguments are needed.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, false)\n    }\n\n    /// Makes a read-only call to a private function which takes no arguments.\n    ///\n    /// This combines the optimisation of `call_private_function_no_args` with\n    /// the safety of `static_call_private_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values. Use\n    ///   `.get_preimage()` to extract the actual return values.\n    ///\n    pub fn static_call_private_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) -> ReturnsHash {\n        self.call_private_function_with_args_hash(contract_address, function_selector, 0, true)\n    }\n\n    /// Low-level private function call.\n    ///\n    /// This is the underlying implementation used by all other private function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args_hash` - Pre-computed hash of the function arguments\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    /// # Returns\n    /// * `ReturnsHash` - Hash of the called function's return values\n    ///\n    pub fn call_private_function_with_args_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args_hash: Field,\n        is_static_call: bool,\n    ) -> ReturnsHash {\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n        let start_side_effect_counter = self.side_effect_counter;\n\n        // Safety: The oracle simulates the private call and returns the value of the side effects counter after\n        // execution of the call (which means that end_side_effect_counter - start_side_effect_counter is\n        // the number of side effects that took place), along with the hash of the return values. We validate these\n        // by requesting a private kernel iteration in which the return values are constrained to hash\n        // to `returns_hash` and the side effects counter to increment from start to end.\n        let (end_side_effect_counter, returns_hash) = unsafe {\n            call_private_function_internal(\n                contract_address,\n                function_selector,\n                args_hash,\n                start_side_effect_counter,\n                is_static_call,\n            )\n        };\n\n        self.private_call_requests.push(\n            PrivateCallRequest {\n                call_context: CallContext {\n                    msg_sender: self.this_address(),\n                    contract_address,\n                    function_selector,\n                    is_static_call,\n                },\n                args_hash,\n                returns_hash,\n                start_side_effect_counter,\n                end_side_effect_counter,\n            },\n        );\n\n        // TODO (fees) figure out why this crashes the prover and enable it\n        // we need this in order to pay fees inside child call contexts\n        // assert(\n        //     (item.public_inputs.min_revertible_side_effect_counter == 0 as u32)\n        //     | (item.public_inputs.min_revertible_side_effect_counter\n        //         > self.min_revertible_side_effect_counter)\n        // );\n        // if item.public_inputs.min_revertible_side_effect_counter\n        //     > self.min_revertible_side_effect_counter {\n        //     self.min_revertible_side_effect_counter = item.public_inputs.min_revertible_side_effect_counter;\n        // }\n        self.side_effect_counter = end_side_effect_counter + 1; // TODO: call `next_counter` instead, for consistency\n        ReturnsHash::new(returns_hash)\n    }\n\n    /// Enqueues a call to a public function to be executed later.\n    ///\n    /// Unlike private functions which execute immediately on the user's device,\n    /// public function calls are \"enqueued\" and executed some time later by a\n    /// block proposer.\n    ///\n    /// This means a public function cannot return any values back to a private\n    /// function, because by the time the public function is being executed,\n    /// the private function which called it has already completed execution.\n    /// (In fact, the private function has been executed and proven, along with\n    /// all other private function calls of the user's tx. A single proof of the\n    /// tx has been submitted to the Aztec network, and some time later a\n    /// proposer has picked the tx up from the mempool and begun executing all\n    /// of the enqueued public functions).\n    ///\n    /// # Privacy warning\n    /// Enqueueing a public function call is an inherently leaky action.\n    /// Many interesting applications will require some interaction with public\n    /// state, but smart contract developers should try to use public function\n    /// calls sparingly, and carefully.\n    /// _Internal_ public function calls are especially leaky, because they\n    /// completely leak which private contract made the call.\n    /// See also: https://docs.aztec.network/developers/reference/considerations/privacy_considerations\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// See also `call_public_function` for more important information about\n    /// making private -> public function calls.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    /// * `args` - Array of arguments to pass to the public function\n    ///\n    pub fn static_call_public_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Enqueues a call to a public function that takes no arguments.\n    ///\n    /// This is an optimisation for calling public functions that don't\n    /// take any input parameters. It's otherwise equivalent to\n    /// `call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Enqueues a read-only call to a public function with no arguments.\n    ///\n    /// This combines the optimisation of `call_public_function_no_args` with\n    /// the safety of `static_call_public_function`.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `function_selector` - 4-byte identifier of the function to call\n    ///\n    pub fn static_call_public_function_no_args(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n    ) {\n        let calldata_hash = hash_calldata_array([function_selector.to_field()]);\n        self.call_public_function_with_calldata_hash(contract_address, calldata_hash, true)\n    }\n\n    /// Low-level public function call.\n    ///\n    /// This is the underlying implementation used by all other public function\n    /// call methods. Instead of taking raw arguments, it accepts a\n    /// hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use `call_public_function`\n    /// or `static_call_public_function` instead. This function is exposed for\n    /// performance optimization and advanced use cases.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn call_public_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_enqueued_public_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        let call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n\n        self.public_call_requests.push(Counted::new(call_request, counter));\n    }\n\n    /// Enqueues a public function call, and designates it to be the teardown\n    /// function for this tx. Only one teardown function call can be made by a\n    /// tx.\n    ///\n    /// Niche function: Only wallet developers and paymaster contract developers\n    /// (aka Fee-payment contracts) will need to make use of this function.\n    ///\n    /// Aztec supports a three-phase execution model: setup, app logic, teardown.\n    /// The phases exist to enable a fee payer to take on the risk of paying\n    /// a transaction fee, safe in the knowledge that their payment (in whatever\n    /// token or method the user chooses) will succeed, regardless of whether\n    /// the app logic will succeed. The \"setup\" phase ensures the fee payer\n    /// has sufficient balance to pay the proposer their fees.\n    /// The teardown phase is primarily intended to: calculate exactly\n    /// how much the user owes, based on gas consumption, and refund the user\n    /// any change.\n    ///\n    /// Note: in some cases, the cost of refunding the user (i.e. DA costs of\n    /// tx side-effects) might exceed the refund amount. For app logic with\n    /// fairly stable and predictable gas consumption, a material refund amount\n    /// is unlikely. For app logic with unpredictable gas consumption, a\n    /// refund might be important to the user (e.g. if a heft function reverts\n    /// very early). Wallet/FPC/Paymaster developers should be mindful of this.\n    ///\n    pub fn set_public_teardown_function<let ArgsCount: u32>(\n        &mut self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field; ArgsCount],\n    ) {\n        let calldata = [function_selector.to_field()].concat(args);\n        let calldata_hash = hash_calldata_array(calldata);\n        execution_cache::store(calldata, calldata_hash);\n        self.set_public_teardown_function_with_calldata_hash(contract_address, calldata_hash, false)\n    }\n\n    /// Low-level function to set the public teardown function.\n    ///\n    /// This is the underlying implementation for setting the teardown function\n    /// call that will execute at the end of the transaction. Instead of taking\n    /// raw arguments, it accepts a hash of the arguments.\n    ///\n    /// Advanced function: Most developers should use\n    /// `set_public_teardown_function` instead.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract containing the teardown\n    ///                        function\n    /// * `calldata_hash` - Hash of the function calldata\n    /// * `is_static_call` - Whether this should be a read-only call\n    ///\n    pub fn set_public_teardown_function_with_calldata_hash(\n        &mut self,\n        contract_address: AztecAddress,\n        calldata_hash: Field,\n        is_static_call: bool,\n    ) {\n        let counter = self.next_counter();\n\n        let mut is_static_call = is_static_call | self.inputs.call_context.is_static_call;\n\n        notify_set_public_teardown_function_call(\n            contract_address,\n            calldata_hash,\n            counter,\n            is_static_call,\n        );\n\n        self.public_teardown_call_request = PublicCallRequest {\n            msg_sender: self.this_address(),\n            contract_address,\n            is_static_call,\n            calldata_hash,\n        };\n    }\n\n    /// Increments the side-effect counter.\n    ///\n    /// Very low-level function.\n    ///\n    /// # Advanced\n    ///\n    /// Every side-effect of a private function is given a \"side-effect counter\",\n    /// based on when it is created. This PrivateContext is in charge of\n    /// assigning the counters.\n    ///\n    /// The reason we have side-effect counters is complicated. Consider this\n    /// illustrative pseudocode of inter-contract function calls:\n    /// ```\n    /// contract A {\n    ///    let x = 5; // pseudocode for storage var x.\n    ///    fn a1 {\n    ///        read x; // value: 5, counter: 1.\n    ///        x = x + 1;\n    ///        write x; // value: 6, counter: 2.\n    ///\n    ///        B.b(); // start_counter: 2, end_counter: 4\n    ///\n    ///        read x; // value: 36, counter: 5.\n    ///        x = x + 1;\n    ///        write x; // value: 37, counter: 6.\n    ///    }\n    ///\n    ///    fn a2 {\n    ///        read x; // value: 6, counter: 3.\n    ///        x = x * x;\n    ///        write x; // value: 36, counter: 4.\n    ///    }\n    /// }\n    ///\n    /// contract B {\n    ///     fn b() {\n    ///         A.a2();\n    ///     }\n    /// }\n    /// ```\n    ///\n    /// Suppose a1 is the first function called. The comments show the execution\n    /// counter of each side-effect, and what the new value of `x` is.\n    ///\n    /// These (private) functions are processed by Aztec's kernel circuits in an\n    /// order that is different from execution order:\n    /// All of A.a1 is proven before B.b is proven, before A.a2 is proven.\n    /// So when we're in the 2nd execution frame of A.a1 (after the call to\n    /// B.b), the circuit needs to justify why x went from being `6` to `36`.\n    /// But the circuit doesn't know why, and given the order of proving, the\n    /// kernel hasn't _seen_ a value of 36 get written yet.\n    /// The kernel needs to track big arrays of all side-effects of all\n    /// private functions in a tx. Then, as it recurses and processes B.b(), it\n    /// will eventually see a value of 36 get written.\n    ///\n    /// Suppose side-effect counters weren't exposed:\n    /// The kernel would only see this ordering (in order of proof verification):\n    /// [ A.a1.read, A.a1.write, A.a1.read, A.a1.write, A.a2.read, A.a2.write ]\n    /// [         5,          6,        36,         37,         6,         36 ]\n    /// The kernel wouldn't know _when_ B.b() was called within A.a1(), because\n    /// it can't see what's going on within an app circuit. So the kernel\n    /// wouldn't know that the ordering of reads and writes should actually be:\n    /// [ A.a1.read, A.a1.write, A.a2.read, A.a2.write, A.a1.read, A.a1.write ]\n    /// [         5,          6,        6,         36,         36,         37 ]\n    ///\n    /// And so, we introduced side-effect counters: every private function must\n    /// assign side-effect counters alongside every side-effect that it emits,\n    /// and also expose to the kernel the counters that it started and ended\n    /// with.\n    /// This gives the kernel enough information to arrange all side-effects in\n    /// the correct order.\n    /// It can then catch (for example) if a function tries to read state\n    /// before it has been written (e.g. if A.a2() maliciously tried to read\n    /// a value of x=37) (e.g. if A.a1() maliciously tried to read x=6).\n    ///\n    /// If a malicious app contract _lies_ and does not count correctly:\n    /// - It cannot lie about its start and end counters because the kernel\n    ///   will catch this.\n    /// - It _could_ lie about its intermediate counters:\n    ///   - 1. It could not increment its side-effects correctly\n    ///   - 2. It could label its side-effects with counters outside of its\n    ///        start and end counters' range.\n    ///   The kernel will catch 2.\n    ///   The kernel will not catch 1., but this would only cause corruption\n    ///   to the private state of the malicious contract, and not any other\n    ///   contracts (because a contract can only modify its own state). If\n    ///   a \"good\" contract is given _read access_ to a maliciously-counting\n    ///   contract (via an external getter function, or by reading historic\n    ///   state from the archive tree directly), and they then make state\n    ///   changes to their _own_ state accordingly, that could be dangerous.\n    ///   Developers should be mindful not to trust the claimed innards of\n    ///   external contracts unless they have audited/vetted the contracts\n    ///   including vetting the side-effect counter incrementation.\n    ///   This is a similar paradigm to Ethereum smart contract development:\n    ///   you must vet external contracts that your contract relies upon, and\n    ///   you must not make any presumptions about their claimed behaviour.\n    ///   (Hopefully if a contract imports a version of aztec-nr, we will get\n    ///   contract verification tooling that can validate the authenticity\n    ///   of the imported aztec-nr package, and hence infer that the side-\n    ///   effect counting will be correct, without having to re-audit such logic\n    ///   for every contract).\n    ///\n    fn next_counter(&mut self) -> u32 {\n        let counter = self.side_effect_counter;\n        self.side_effect_counter += 1;\n        counter\n    }\n}\n\nimpl Empty for PrivateContext {\n    fn empty() -> Self {\n        PrivateContext {\n            inputs: PrivateContextInputs::empty(),\n            side_effect_counter: 0 as u32,\n            min_revertible_side_effect_counter: 0 as u32,\n            is_fee_payer: false,\n            args_hash: 0,\n            return_hash: 0,\n            include_by_timestamp: 0,\n            note_hash_read_requests: BoundedVec::new(),\n            nullifier_read_requests: BoundedVec::new(),\n            key_validation_requests_and_generators: BoundedVec::new(),\n            note_hashes: BoundedVec::new(),\n            nullifiers: BoundedVec::new(),\n            private_call_requests: BoundedVec::new(),\n            public_call_requests: BoundedVec::new(),\n            public_teardown_call_request: PublicCallRequest::empty(),\n            l2_to_l1_msgs: BoundedVec::new(),\n            historical_header: BlockHeader::empty(),\n            private_logs: BoundedVec::new(),\n            contract_class_logs_hashes: BoundedVec::new(),\n            last_key_validation_requests: [Option::none(); NUM_KEY_TYPES],\n        }\n    }\n}\n"
    },
    "74": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/public_context.nr",
      "source": "use crate::context::gas::GasOpts;\nuse crate::hash::{\n    compute_l1_to_l2_message_hash, compute_l1_to_l2_message_nullifier, compute_secret_hash,\n};\nuse dep::protocol_types::abis::function_selector::FunctionSelector;\nuse dep::protocol_types::address::{AztecAddress, EthAddress};\nuse dep::protocol_types::constants::MAX_U32_VALUE;\nuse dep::protocol_types::traits::{Empty, FromField, Packable, Serialize, ToField};\n\n/// # PublicContext\n///\n/// The **main interface** between a #[public] function and the Aztec blockchain.\n///\n/// An instance of the PublicContext is initialized automatically at the outset\n/// of every public function, within the #[public] macro, so you'll never\n/// need to consciously instantiate this yourself.\n///\n/// The instance is always named `context`, and it will always be available\n/// within the body of every #[public] function in your smart contract.\n///\n/// Typical usage for a smart contract developer will be to call getter\n/// methods of the PublicContext.\n///\n/// _Pushing_ data and requests to the context is mostly handled within\n/// aztec-nr's own functions, so typically a smart contract developer won't\n/// need to call any setter methods directly.\n///\n/// ## Responsibilities\n/// - Exposes contextual data to a public function:\n///   - Data relating to how this public function was called:\n///     - msg_sender, this_address\n///   - Data relating to the current blockchain state:\n///     - timestamp, block_number, chain_id, version\n///   - Gas and fee information\n/// - Provides state access:\n///   - Read/write public storage (key-value mapping)\n///   - Check existence of notes and nullifiers\n///     (Some patterns use notes & nullifiers to store public (not private)\n///     information)\n///   - Enables consumption of L1->L2 messages.\n/// - Enables calls to other public smart contract functions:\n/// - Writes data to the blockchain:\n///   - Updates to public state variables\n///   - New public logs (for events)\n///   - New L2->L1 messages\n///   - New notes & nullifiers\n///     (E.g. pushing public info to notes/nullifiers, or for completing\n///     \"partial notes\")\n///\n/// ## Key Differences from Private Execution\n///\n/// Unlike private functions -- which are executed on the user's device and which\n/// can only reference historic state -- public functions are executed by a block\n/// proposer and are executed \"live\" on the _current_ tip of the chain.\n/// This means public functions can:\n/// - Read and write _current_ public state\n/// - Immediately see the effects of earlier transactions in the same block\n///\n/// Also, public functions are executed within a zkVM (the \"AVM\"), so that they\n/// can _revert_ whilst still ensuring payment to the proposer and prover.\n/// (Private functions cannot revert: they either succeed, or they cannot be\n/// included).\n///\n/// ## Optimising Public Functions\n///\n/// Using the AVM to execute public functions means they compile down to \"AVM\n/// bytecode\" instead of the ACIR that private functions (standalone circuits)\n/// compile to. Therefore the approach to optimising a public function is\n/// fundamentally different from optimising a public function.\n///\npub struct PublicContext {\n    pub args_hash: Option<Field>,\n    pub compute_args_hash: fn() -> Field,\n}\n\nimpl Eq for PublicContext {\n    fn eq(self, other: Self) -> bool {\n        (self.args_hash == other.args_hash)\n        // Can't compare the function compute_args_hash\n    }\n}\n\nimpl PublicContext {\n    /// Creates a new PublicContext instance.\n    ///\n    /// Low-level function: This is called automatically by the #[public]\n    /// macro, so you shouldn't need to be called directly by smart contract\n    /// developers.\n    ///\n    /// # Arguments\n    /// * `compute_args_hash` - Function to compute the args_hash\n    ///\n    /// # Returns\n    /// * A new PublicContext instance\n    ///\n    pub fn new(compute_args_hash: fn() -> Field) -> Self {\n        PublicContext { args_hash: Option::none(), compute_args_hash }\n    }\n\n    /// Emits a _public_ log that will be visible onchain to everyone.\n    ///\n    /// # Arguments\n    /// * `log` - The data to log, must implement Serialize trait\n    ///\n    pub fn emit_public_log<T>(_self: &mut Self, log: T)\n    where\n        T: Serialize,\n    {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_public_log(Serialize::serialize(log).as_slice()) };\n    }\n\n    /// Checks if a given note hash exists in the note hash tree at a particular\n    /// leaf_index.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The note hash to check for existence\n    /// * `leaf_index` - The index where the note hash should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the note hash exists at the specified index\n    ///\n    pub fn note_hash_exists(_self: Self, note_hash: Field, leaf_index: u64) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { note_hash_exists(note_hash, leaf_index) } == 1\n    }\n\n    /// Checks if a specific L1-to-L2 message exists in the L1-to-L2 message\n    /// tree at a particular leaf index.\n    ///\n    /// Common use cases include token bridging, cross-chain governance, and\n    /// triggering L2 actions based on L1 events.\n    ///\n    /// This function should be called before attempting to consume an L1-to-L2\n    /// message.\n    ///\n    /// # Arguments\n    /// * `msg_hash` - Hash of the L1-to-L2 message to check\n    /// * `msg_leaf_index` - The index where the message should be located\n    ///\n    /// # Returns\n    /// * `bool` - True if the message exists at the specified index\n    ///\n    /// # Advanced\n    /// * Uses the AVM l1_to_l2_msg_exists opcode for tree lookup\n    /// * Messages are copied from L1 Inbox to L2 by block proposers\n    ///\n    pub fn l1_to_l2_msg_exists(_self: Self, msg_hash: Field, msg_leaf_index: Field) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        // TODO(alvaro): Make l1l2msg leaf index a u64 upstream\n        unsafe { l1_to_l2_msg_exists(msg_hash, msg_leaf_index as u64) } == 1\n    }\n\n    /// Checks if a specific nullifier has been emitted by a given contract.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. An example is to check\n    /// whether a contract has been published: we emit a nullifier that is\n    /// deterministic, but whose preimage is _not_ private. This is more\n    /// efficient than using mutable storage, and can be done directly\n    /// from a private function.\n    ///\n    /// Nullifiers can be tested for non-existence in public, which is not the\n    /// case in private. Because private functions do not have access to\n    /// the tip of the blockchain (but only the anchor block they are built\n    /// at) they can only prove nullifier non-existence in the past. But between\n    /// an anchor block and the block in which a tx is included, the nullifier\n    /// might have been inserted into the nullifier tree by some other\n    /// transaction.\n    /// Public functions _do_ have access to the tip of the state, and so\n    /// this pattern is safe.\n    ///\n    /// # Arguments\n    /// * `unsiloed_nullifier` - The raw nullifier value (before siloing with\n    ///                          the contract address that emitted it).\n    /// * `address` - The claimed contract address that emitted the nullifier\n    ///\n    /// # Returns\n    /// * `bool` - True if the nullifier has been emitted by the specified contract\n    ///\n    pub fn nullifier_exists(_self: Self, unsiloed_nullifier: Field, address: AztecAddress) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { nullifier_exists(unsiloed_nullifier, address.to_field()) } == 1\n    }\n\n    /// Consumes a message sent from Ethereum (L1) to Aztec (L2) -- effectively\n    /// marking it as \"read\".\n    ///\n    /// Use this function if you only want the message to ever be \"referred to\"\n    /// once. Once consumed using this method, the message cannot be consumed\n    /// again, because a nullifier is emitted.\n    /// If your use case wants for the message to be read unlimited times, then\n    /// you can always read any historic message from the L1-to-L2 messages tree,\n    /// using the `l1_to_l2_msg_exists` method. Messages never technically get\n    /// deleted from that tree.\n    ///\n    /// The message will first be inserted into an Aztec \"Inbox\" smart contract\n    /// on L1. It will not be available for consumption immediately. Messages\n    /// get copied-over from the L1 Inbox to L2 by the next Proposer in batches.\n    /// So you will need to wait until the messages are copied before you can\n    /// consume them.\n    ///\n    /// # Arguments\n    /// * `content` - The message content that was sent from L1\n    /// * `secret` - Secret value used for message privacy (if needed)\n    /// * `sender` - Ethereum address that sent the message\n    /// * `leaf_index` - Index of the message in the L1-to-L2 message tree\n    ///\n    /// # Advanced\n    /// * Validates message existence in the L1-to-L2 message tree\n    /// * Prevents double-consumption by emitting a nullifier\n    /// * Message hash is computed from all parameters + chain context\n    /// * Will revert if message doesn't exist or was already consumed\n    ///\n    pub fn consume_l1_to_l2_message(\n        &mut self,\n        content: Field,\n        secret: Field,\n        sender: EthAddress,\n        leaf_index: Field,\n    ) {\n        let secret_hash = compute_secret_hash(secret);\n        let message_hash = compute_l1_to_l2_message_hash(\n            sender,\n            self.chain_id(),\n            /*recipient=*/\n            self.this_address(),\n            self.version(),\n            content,\n            secret_hash,\n            leaf_index,\n        );\n        let nullifier = compute_l1_to_l2_message_nullifier(message_hash, secret);\n\n        assert(\n            !self.nullifier_exists(nullifier, self.this_address()),\n            \"L1-to-L2 message is already nullified\",\n        );\n        assert(\n            self.l1_to_l2_msg_exists(message_hash, leaf_index),\n            \"Tried to consume nonexistent L1-to-L2 message\",\n        );\n\n        self.push_nullifier(nullifier);\n    }\n\n    /// Sends an \"L2 -> L1 message\" from this function (Aztec, L2) to a smart\n    /// contract on Ethereum (L1). L1 contracts which are designed to\n    /// send/receive messages to/from Aztec are called \"Portal Contracts\".\n    ///\n    /// Common use cases include withdrawals, cross-chain asset transfers, and\n    /// triggering L1 actions based on L2 state changes.\n    ///\n    /// The message will be inserted into an Aztec \"Outbox\" contract on L1,\n    /// when this transaction's block is proposed to L1.\n    /// Sending the message will not result in any immediate state changes in\n    /// the target portal contract. The message will need to be manually\n    /// consumed from the Outbox through a separate Ethereum transaction: a user\n    /// will need to call a function of the portal contract -- a function\n    /// specifically designed to make a call to the Outbox to consume the\n    /// message.\n    /// The message will only be available for consumption once the _epoch_\n    /// proof has been submitted. Given that there are multiple Aztec blocks\n    /// within an epoch, it might take some time for this epoch proof to be\n    /// submitted -- especially if the block was near the start of an epoch.\n    ///\n    /// # Arguments\n    /// * `recipient` - Ethereum address that will receive the message\n    /// * `content` - Message content (32 bytes as a Field element)\n    ///\n    pub fn message_portal(_self: &mut Self, recipient: EthAddress, content: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { send_l2_to_l1_msg(recipient, content) };\n    }\n\n    /// Calls a public function on another contract.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Arguments to pass to the function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Makes a read-only call to a public function on another contract.\n    ///\n    /// This is similar to Solidity's `staticcall`. The called function\n    /// cannot modify state or emit events. Any nested calls are constrained to\n    /// also be staticcalls.\n    ///\n    /// Useful for querying data from other contracts safely.\n    ///\n    /// Will revert if the called function reverts or runs out of gas.\n    ///\n    /// # Arguments\n    /// * `contract_address` - Address of the contract to call\n    /// * `function_selector` - Function to call on the target contract\n    /// * `args` - Array of arguments to pass to the called function\n    /// * `gas_opts` - An optional allocation of gas to the called function.\n    ///\n    /// # Returns\n    /// * `[Field]` - Return data from the called function\n    ///\n    pub unconstrained fn static_call_public_function(\n        _self: &mut Self,\n        contract_address: AztecAddress,\n        function_selector: FunctionSelector,\n        args: [Field],\n        gas_opts: GasOpts,\n    ) -> [Field] {\n        let calldata = args.push_front(function_selector.to_field());\n\n        call_static(\n            gas_opts.l2_gas.unwrap_or(MAX_U32_VALUE),\n            gas_opts.da_gas.unwrap_or(MAX_U32_VALUE),\n            contract_address,\n            calldata,\n        );\n        // Use success_copy to determine whether the call succeeded\n        let success = success_copy();\n\n        let result_data = returndata_copy(0, returndata_size());\n        if !success {\n            // Rethrow the revert data.\n            avm_revert(result_data);\n        }\n        result_data\n    }\n\n    /// Adds a new note hash to the Aztec blockchain's global Note Hash Tree.\n    ///\n    /// Notes are ordinarily constructed and emitted by _private_ functions, to\n    /// ensure that both the content of the note, and the contract that emitted\n    /// the note, stay private.\n    ///\n    /// There are however some useful patterns whereby a note needs to contain\n    /// _public_ data. The ability to push a new note_hash from a _public_\n    /// function means that notes can be injected with public data immediately\n    /// -- as soon as the public value is known. The slower alternative would\n    /// be to submit a follow-up transaction so that a private function can\n    /// inject the data. Both are possible on Aztec.\n    ///\n    /// Search \"Partial Note\" for a very common pattern which enables a note\n    /// to be \"partially\" populated with some data in a _private_ function, and\n    /// then later \"completed\" with some data in a public function.\n    ///\n    /// # Arguments\n    /// * `note_hash` - The hash of the note to add to the tree\n    ///\n    /// # Advanced\n    /// * The note hash will be siloed with the contract address by the protocol\n    ///\n    pub fn push_note_hash(_self: &mut Self, note_hash: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_note_hash(note_hash) };\n    }\n\n    /// Adds a new nullifier to the Aztec blockchain's global Nullifier Tree.\n    ///\n    /// Whilst nullifiers are primarily intended as a _privacy-preserving_\n    /// record of a one-time action, they can also be used to efficiently\n    /// record _public_ one-time actions too. Hence why you're seeing this\n    /// function within the PublicContext.\n    /// An example is to check whether a contract has been published: we emit\n    /// a nullifier that is deterministic, but whose preimage is _not_ private.\n    ///\n    /// # Arguments\n    /// * `nullifier` - A unique field element that represents the consumed\n    ///   state\n    ///\n    /// # Advanced\n    /// * Nullifier is immediately added to the global nullifier tree\n    /// * Emitted nullifiers are immediately visible to all\n    ///   subsequent transactions in the same block\n    /// * Automatically siloed with the contract address by the protocol\n    /// * Used for preventing double-spending and ensuring one-time actions\n    ///\n    pub fn push_nullifier(_self: &mut Self, nullifier: Field) {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { emit_nullifier(nullifier) };\n    }\n\n    /// Returns the address of the current contract being executed.\n    ///\n    /// This is equivalent to `address(this)` in Solidity (hence the name).\n    /// Use this to identify the current contract's address, commonly needed for\n    /// access control or when interacting with other contracts.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The contract address of the current function being\n    ///                    executed.\n    ///\n    pub fn this_address(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            address()\n        }\n    }\n\n    /// Returns the contract address that initiated this function call.\n    ///\n    /// This is similar to `msg.sender` in Solidity (hence the name).\n    ///\n    /// Important Note: Since Aztec doesn't have a concept of an EoA (\n    /// Externally-owned Account), the msg_sender is \"undefined\" for the first\n    /// function call of every transaction. A value of `-1` is returned in such\n    /// cases, and is enforced by the protocol's kernel circuits.\n    /// The first function call of a tx is likely to be a call to the user's\n    /// account contract, so this quirk will most often be handled by account\n    /// contract developers.\n    ///\n    /// # Returns\n    /// * `AztecAddress` - The address of the account or contract that called\n    ///   this function\n    ///\n    /// # Examples\n    /// ```rust\n    /// #[aztec(public)]\n    /// fn transfer(context: &mut PublicContext, to: AztecAddress, amount: u64) {\n    ///     let sender = context.msg_sender();\n    ///     // Only the sender can transfer their own tokens\n    ///     assert(sender == get_token_owner(), \"Unauthorized\");\n    /// }\n    /// ```\n    ///\n    /// # Advanced\n    /// * Value is provided by the AVM sender opcode\n    /// * In nested calls, this is the immediate caller, not the original\n    ///   transaction sender\n    /// * Globally visible unlike private execution where it's contract-local\n    pub fn msg_sender(_self: Self) -> AztecAddress {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            sender()\n        }\n    }\n\n    /// Returns the function selector of the currently-executing function.\n    ///\n    /// This is similar to `msg.sig` in Solidity, returning the first 4\n    /// bytes of the function signature.\n    ///\n    /// # Returns\n    /// * `FunctionSelector` - The 4-byte function identifier\n    ///\n    /// # Advanced\n    /// * Extracted from the first element of calldata\n    /// * Used internally for function dispatch in the AVM\n    ///\n    pub fn selector(_self: Self) -> FunctionSelector {\n        // The selector is the first element of the calldata when calling a public function through dispatch.\n        // Safety: AVM opcodes are constrained by the AVM itself\n        let raw_selector: [Field; 1] = unsafe { calldata_copy(0, 1) };\n        FunctionSelector::from_field(raw_selector[0])\n    }\n\n    /// Returns the hash of the arguments passed to the current function.\n    ///\n    /// Very low-level function: The #[public] macro uses this internally.\n    /// Smart contract developers typically won't need to access this\n    /// directly as arguments are automatically made available.\n    ///\n    /// # Returns\n    /// * `Field` - Hash of the function arguments\n    ///\n    pub fn get_args_hash(mut self) -> Field {\n        if !self.args_hash.is_some() {\n            self.args_hash = Option::some((self.compute_args_hash)());\n        }\n\n        self.args_hash.unwrap_unchecked()\n    }\n\n    /// Returns the \"transaction fee\" for the current transaction.\n    /// This is the final tx fee that will be deducted from the fee_payer's\n    /// \"fee-juice\" balance (in the protocol's Base Rollup circuit).\n    ///\n    /// # Returns\n    /// * `Field` - The actual, final cost of the transaction, taking into account:\n    ///             the actual gas used during the setup and app-logic phases,\n    ///             and the fixed amount of gas that's been allocated by the user\n    ///             for the teardown phase.\n    ///             I.e. effectiveL2FeePerGas * l2GasUsed + effectiveDAFeePerGas * daGasUsed\n    ///\n    /// This will return `0` during the \"setup\" and \"app-logic\" phases of\n    /// tx execution (because the final tx fee is not known at that time).\n    /// This will only return a nonzero value during the \"teardown\" phase of\n    /// execution, where the final tx fee can actually be computed.\n    ///\n    /// Regardless of _when_ this function is called during the teardown phase,\n    /// it will always return the same final tx fee value. The teardown phase\n    /// does not consume a variable amount of gas: it always consumes a\n    /// pre-allocated amount of gas, as specified by the user when they generate\n    /// their tx.\n    ///\n    pub fn transaction_fee(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            transaction_fee()\n        }\n    }\n\n    /// Returns the chain ID of the current network.\n    ///\n    /// This is similar to `block.chainid` in Solidity. Returns the unique\n    /// identifier for the blockchain network this transaction is executing on.\n    ///\n    /// Helps prevent cross-chain replay attacks. Useful if implementing\n    /// multi-chain contract logic.\n    ///\n    /// # Returns\n    /// * `Field` - The chain ID as a field element\n    ///\n    pub fn chain_id(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            chain_id()\n        }\n    }\n\n    /// Returns the Aztec protocol version that this transaction is executing\n    /// under. Different versions may have different rules, opcodes, or\n    /// cryptographic primitives.\n    ///\n    /// This is similar to how Ethereum has different EVM versions.\n    ///\n    /// Useful for forward/backward compatibility checks\n    ///\n    /// Not to be confused with contract versions; this is the protocol version.\n    ///\n    /// # Returns\n    /// * `Field` - The protocol version as a field element\n    ///\n    pub fn version(_self: Self) -> Field {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            version()\n        }\n    }\n    /// Returns the current block number.\n    ///\n    /// This is similar to `block.number` in Solidity.\n    ///\n    /// Note: the current block number is only available within a public function\n    /// (as opposed to a private function).\n    ///\n    /// Note: the time intervals between blocks should not be relied upon as\n    /// being consistent:\n    /// - Timestamps of blocks fall within a range, rather than at exact regular\n    ///   intervals.\n    /// - Slots can be missed.\n    /// - Protocol upgrades can completely change the intervals between blocks\n    ///   (and indeed the current roadmap plans to reduce the time between\n    ///   blocks, eventually).\n    /// Use `context.timestamp()` for more-reliable time-based logic.\n    ///\n    /// # Returns\n    /// * `u32` - The current block number\n    ///\n    pub fn block_number(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            block_number()\n        }\n    }\n\n    /// Returns the timestamp of the current block.\n    ///\n    /// This is similar to `block.timestamp` in Solidity.\n    ///\n    /// All functions of all transactions in a block share the exact same\n    /// timestamp (even though technically each transaction is executed\n    /// one-after-the-other).\n    ///\n    /// Important note: Timestamps of Aztec blocks are not at reliably-fixed\n    /// intervals. The proposer of the block has some flexibility to choose a\n    /// timestamp which is in a valid _range_: Obviously the timestamp of this\n    /// block must be strictly greater than that of the previous block, and must\n    /// must be less than the timestamp of whichever ethereum block the aztec\n    /// block is proposed to. Furthermore, if the timestamp is not deemed close\n    /// enough to the actual current time, the committee of validators will not\n    /// attest to the block.\n    ///\n    /// # Returns\n    /// * `u64` - Unix timestamp in seconds\n    ///\n    pub fn timestamp(_self: Self) -> u64 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            timestamp()\n        }\n    }\n\n    /// Returns the fee per unit of L2 gas for this transaction (aka the \"L2 gas\n    /// price\"), as chosen by the user.\n    ///\n    /// L2 gas covers the cost of executing public functions and handling\n    /// side-effects within the AVM.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of L2 gas\n    ///\n    /// Wallet developers should be mindful that the choice of gas price (which\n    /// is publicly visible) can leak information about the user, e.g.:\n    /// - which wallet software the user is using;\n    /// - the amount of time which has elapsed from the time the user's wallet\n    ///   chose a gas price (at the going rate), to the time of tx submission.\n    ///   This can give clues about the proving time, and hence the nature of\n    ///   the tx.\n    /// - the urgency of the transaction (which is kind of unavoidable, if the\n    ///   tx is indeed urgent).\n    /// - the wealth of the user.\n    /// - the exact user (if the gas price is explicitly chosen by the user to\n    ///   be some unique number like 0.123456789, or their favourite number).\n    /// Wallet devs might wish to consider fuzzing the choice of gas price.\n    ///\n    pub fn base_fee_per_l2_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_l2_gas()\n        }\n    }\n\n    /// Returns the fee per unit of DA (Data Availability) gas (aka the \"DA gas\n    /// price\").\n    ///\n    /// DA gas covers the cost of making transaction data available on L1.\n    ///\n    /// See the warning in `fee_pre_l2_gas` for how gas prices can be leaky.\n    ///\n    /// # Returns\n    /// * `u128` - Fee per unit of DA gas\n    ///\n    pub fn base_fee_per_da_gas(_self: Self) -> u128 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            base_fee_per_da_gas()\n        }\n    }\n\n    /// Returns the remaining L2 gas available for this transaction.\n    ///\n    /// Different AVM opcodes consume different amounts of gas.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining L2 gas units\n    ///\n    pub fn l2_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            l2_gas_left()\n        }\n    }\n\n    /// Returns the remaining DA (Data Availability) gas available for this\n    /// transaction.\n    ///\n    /// DA gas is consumed when emitting data that needs to be made available\n    /// on L1, such as public logs or state updates.\n    /// All of the side-effects from the private part of the tx also consume\n    /// DA gas before execution of any public functions even begins.\n    ///\n    /// # Returns\n    /// * `u32` - Remaining DA gas units\n    ///\n    pub fn da_gas_left(_self: Self) -> u32 {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe {\n            da_gas_left()\n        }\n    }\n\n    /// Checks if the current execution is within a staticcall context, where\n    /// no state changes or logs are allowed to be emitted (by this function\n    /// or any nested function calls).\n    ///\n    /// # Returns\n    /// * `bool` - True if in staticcall context, false otherwise\n    ///\n    pub fn is_static_call(_self: Self) -> bool {\n        // Safety: AVM opcodes are constrained by the AVM itself\n        unsafe { is_static_call() } == 1\n    }\n\n    /// Reads raw field values from public storage.\n    /// Reads N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to read from\n    ///\n    /// # Returns\n    /// * `[Field; N]` - Array of N field values from consecutive storage slots\n    ///\n    /// # Generic Parameters\n    /// * `N` - the number of consecutive slots to return, starting from the\n    ///         `storage_slot`.\n    ///\n    pub fn raw_storage_read<let N: u32>(_self: Self, storage_slot: Field) -> [Field; N] {\n        let mut out = [0; N];\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            out[i] = unsafe { storage_read(storage_slot + i as Field) };\n        }\n        out\n    }\n\n    /// Reads a typed value from public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform reads: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to read from\n    ///\n    /// # Returns\n    /// * `T` - The deserialized value from storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type that the caller expects to read from the `storage_slot`.\n    ///\n    pub fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n\n    /// Writes raw field values to public storage.\n    /// Writes to N consecutive storage slots starting from the given slot.\n    ///\n    /// Very low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// Public storage writes take effect immediately.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The starting storage slot to write to\n    /// * `values` - Array of N Fields to write to storage\n    ///\n    pub fn raw_storage_write<let N: u32>(_self: Self, storage_slot: Field, values: [Field; N]) {\n        for i in 0..N {\n            // Safety: AVM opcodes are constrained by the AVM itself\n            unsafe { storage_write(storage_slot + i as Field, values[i]) };\n        }\n    }\n\n    /// Writes a typed value to public storage.\n    ///\n    /// Low-level function. Users should typically use the public state\n    /// variable abstractions to perform writes: PublicMutable & PublicImmutable.\n    ///\n    /// # Arguments\n    /// * `storage_slot` - The storage slot to write to\n    /// * `value` - The typed value to write to storage\n    ///\n    /// # Generic Parameters\n    /// * `T` - The type to write to storage.\n    ///\n    pub fn storage_write<T>(self, storage_slot: Field, value: T)\n    where\n        T: Packable,\n    {\n        self.raw_storage_write(storage_slot, value.pack());\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// Unconstrained opcode wrappers (do not use directly).\nunconstrained fn address() -> AztecAddress {\n    address_opcode()\n}\nunconstrained fn sender() -> AztecAddress {\n    sender_opcode()\n}\nunconstrained fn transaction_fee() -> Field {\n    transaction_fee_opcode()\n}\nunconstrained fn chain_id() -> Field {\n    chain_id_opcode()\n}\nunconstrained fn version() -> Field {\n    version_opcode()\n}\nunconstrained fn block_number() -> u32 {\n    block_number_opcode()\n}\nunconstrained fn timestamp() -> u64 {\n    timestamp_opcode()\n}\nunconstrained fn base_fee_per_l2_gas() -> u128 {\n    base_fee_per_l2_gas_opcode()\n}\nunconstrained fn base_fee_per_da_gas() -> u128 {\n    base_fee_per_da_gas_opcode()\n}\nunconstrained fn l2_gas_left() -> u32 {\n    l2_gas_left_opcode()\n}\nunconstrained fn da_gas_left() -> u32 {\n    da_gas_left_opcode()\n}\nunconstrained fn is_static_call() -> u1 {\n    is_static_call_opcode()\n}\nunconstrained fn note_hash_exists(note_hash: Field, leaf_index: u64) -> u1 {\n    note_hash_exists_opcode(note_hash, leaf_index)\n}\nunconstrained fn emit_note_hash(note_hash: Field) {\n    emit_note_hash_opcode(note_hash)\n}\nunconstrained fn nullifier_exists(nullifier: Field, address: Field) -> u1 {\n    nullifier_exists_opcode(nullifier, address)\n}\nunconstrained fn emit_nullifier(nullifier: Field) {\n    emit_nullifier_opcode(nullifier)\n}\nunconstrained fn emit_public_log(message: [Field]) {\n    emit_public_log_opcode(message)\n}\nunconstrained fn l1_to_l2_msg_exists(msg_hash: Field, msg_leaf_index: u64) -> u1 {\n    l1_to_l2_msg_exists_opcode(msg_hash, msg_leaf_index)\n}\nunconstrained fn send_l2_to_l1_msg(recipient: EthAddress, content: Field) {\n    send_l2_to_l1_msg_opcode(recipient, content)\n}\n\nunconstrained fn call(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\nunconstrained fn call_static(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {\n    call_static_opcode(l2_gas_allocation, da_gas_allocation, address, args)\n}\n\npub unconstrained fn calldata_copy<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {\n    calldata_copy_opcode(cdoffset, copy_size)\n}\n\n// `success_copy` is placed immediately after the CALL opcode to get the success value\nunconstrained fn success_copy() -> bool {\n    success_copy_opcode()\n}\n\nunconstrained fn returndata_size() -> u32 {\n    returndata_size_opcode()\n}\n\nunconstrained fn returndata_copy(rdoffset: u32, copy_size: u32) -> [Field] {\n    returndata_copy_opcode(rdoffset, copy_size)\n}\n\npub unconstrained fn avm_return(returndata: [Field]) {\n    return_opcode(returndata)\n}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\nunconstrained fn avm_revert(revertdata: [Field]) {\n    revert_opcode(revertdata)\n}\n\nunconstrained fn storage_read(storage_slot: Field) -> Field {\n    storage_read_opcode(storage_slot)\n}\n\nunconstrained fn storage_write(storage_slot: Field, value: Field) {\n    storage_write_opcode(storage_slot, value);\n}\n\nimpl Empty for PublicContext {\n    fn empty() -> Self {\n        PublicContext::new(|| 0)\n    }\n}\n\n// TODO: consider putting this oracle code in its own file.\n// AVM oracles (opcodes) follow, do not use directly.\n#[oracle(avmOpcodeAddress)]\nunconstrained fn address_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeSender)]\nunconstrained fn sender_opcode() -> AztecAddress {}\n\n#[oracle(avmOpcodeTransactionFee)]\nunconstrained fn transaction_fee_opcode() -> Field {}\n\n#[oracle(avmOpcodeChainId)]\nunconstrained fn chain_id_opcode() -> Field {}\n\n#[oracle(avmOpcodeVersion)]\nunconstrained fn version_opcode() -> Field {}\n\n#[oracle(avmOpcodeBlockNumber)]\nunconstrained fn block_number_opcode() -> u32 {}\n\n#[oracle(avmOpcodeTimestamp)]\nunconstrained fn timestamp_opcode() -> u64 {}\n\n#[oracle(avmOpcodeBaseFeePerL2Gas)]\nunconstrained fn base_fee_per_l2_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeBaseFeePerDaGas)]\nunconstrained fn base_fee_per_da_gas_opcode() -> u128 {}\n\n#[oracle(avmOpcodeL2GasLeft)]\nunconstrained fn l2_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeDaGasLeft)]\nunconstrained fn da_gas_left_opcode() -> u32 {}\n\n#[oracle(avmOpcodeIsStaticCall)]\nunconstrained fn is_static_call_opcode() -> u1 {}\n\n#[oracle(avmOpcodeNoteHashExists)]\nunconstrained fn note_hash_exists_opcode(note_hash: Field, leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeEmitNoteHash)]\nunconstrained fn emit_note_hash_opcode(note_hash: Field) {}\n\n#[oracle(avmOpcodeNullifierExists)]\nunconstrained fn nullifier_exists_opcode(nullifier: Field, address: Field) -> u1 {}\n\n#[oracle(avmOpcodeEmitNullifier)]\nunconstrained fn emit_nullifier_opcode(nullifier: Field) {}\n\n// TODO(#11124): rename unencrypted to public in avm\n#[oracle(avmOpcodeEmitUnencryptedLog)]\nunconstrained fn emit_public_log_opcode(message: [Field]) {}\n\n#[oracle(avmOpcodeL1ToL2MsgExists)]\nunconstrained fn l1_to_l2_msg_exists_opcode(msg_hash: Field, msg_leaf_index: u64) -> u1 {}\n\n#[oracle(avmOpcodeSendL2ToL1Msg)]\nunconstrained fn send_l2_to_l1_msg_opcode(recipient: EthAddress, content: Field) {}\n\n#[oracle(avmOpcodeCalldataCopy)]\nunconstrained fn calldata_copy_opcode<let N: u32>(cdoffset: u32, copy_size: u32) -> [Field; N] {}\n\n#[oracle(avmOpcodeReturndataSize)]\nunconstrained fn returndata_size_opcode() -> u32 {}\n\n#[oracle(avmOpcodeReturndataCopy)]\nunconstrained fn returndata_copy_opcode(rdoffset: u32, copy_size: u32) -> [Field] {}\n\n#[oracle(avmOpcodeReturn)]\nunconstrained fn return_opcode(returndata: [Field]) {}\n\n// This opcode reverts using the exact data given. In general it should only be used\n// to do rethrows, where the revert data is the same as the original revert data.\n// For normal reverts, use Noir's `assert` which, on top of reverting, will also add\n// an error selector to the revert data.\n#[oracle(avmOpcodeRevert)]\nunconstrained fn revert_opcode(revertdata: [Field]) {}\n\n#[oracle(avmOpcodeCall)]\nunconstrained fn call_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeStaticCall)]\nunconstrained fn call_static_opcode(\n    l2_gas_allocation: u32,\n    da_gas_allocation: u32,\n    address: AztecAddress,\n    args: [Field],\n) {}\n\n#[oracle(avmOpcodeSuccessCopy)]\nunconstrained fn success_copy_opcode() -> bool {}\n\n#[oracle(avmOpcodeStorageRead)]\nunconstrained fn storage_read_opcode(storage_slot: Field) -> Field {}\n\n#[oracle(avmOpcodeStorageWrite)]\nunconstrained fn storage_write_opcode(storage_slot: Field, value: Field) {}\n"
    },
    "75": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/returns_hash.nr",
      "source": "use crate::{hash::hash_args_array, oracle::execution_cache};\nuse dep::protocol_types::traits::Deserialize;\n\n/// A hash that represents a private contract function call's return value. Call `get_preimage` to get the underlying\n/// value.\n///\n/// The kernels don't process the actual return values but instead their hashes, so it is up to contracts to populate\n/// oracles with the preimages of these hashes on return to make them available to their callers.\n///\n/// Public calls don't utilize this mechanism since the AVM does process the full return values.\npub struct ReturnsHash {\n    hash: Field,\n}\n\nimpl ReturnsHash {\n    pub fn new(hash: Field) -> Self {\n        ReturnsHash { hash }\n    }\n\n    /// Fetches the underlying return value from an oracle, constraining that it corresponds to the return data hash.\n    pub fn get_preimage<T>(self) -> T\n    where\n        T: Deserialize,\n    {\n        // Safety: We verify that the value returned by `load` is the preimage of `hash`, fully constraining it. If `T`\n        // is `()`, then `preimage` must be an array of length 0 (since that is `()`'s deserialization length).\n        // `hash_args_array` handles empty arrays following the protocol rules (i.e. an empty args array is signaled\n        // with a zero hash), correctly constraining `self.hash`.\n        let preimage = unsafe { execution_cache::load(self.hash) };\n        assert_eq(self.hash, hash_args_array(preimage), \"Preimage mismatch\");\n\n        Deserialize::deserialize(preimage)\n    }\n}\n\nmod test {\n    use crate::{\n        hash::hash_args_array,\n        oracle::execution_cache,\n        test::{helpers::test_environment::TestEnvironment, mocks::mock_struct::MockStruct},\n    };\n    use super::ReturnsHash;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    #[test]\n    unconstrained fn retrieves_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = MockStruct::new(4, 7);\n            let serialized = value.serialize();\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test]\n    unconstrained fn retrieves_empty_preimage() {\n        let env = TestEnvironment::new();\n        env.private_context(|_| {\n            let value = ();\n            let serialized = [];\n\n            let hash = hash_args_array(serialized);\n            execution_cache::store(serialized, hash);\n\n            assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n        });\n    }\n\n    #[test(should_fail_with = \"Preimage mismatch\")]\n    unconstrained fn rejects_bad_preimage() {\n        let value = MockStruct::new(4, 7);\n        let serialized = value.serialize();\n\n        let mut bad_serialized = serialized;\n        bad_serialized[0] += 1;\n\n        let hash = hash_args_array(serialized);\n\n        let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns(bad_serialized);\n        assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    }\n\n    // This test passes due to a Noir bug.\n    // #[test(should_fail_with=\"Preimage mismatch\")]\n    // unconstrained fn rejects_bad_empty_preimage() {\n    //     let value = ();\n    //     let serialized = [];\n\n    //     let hash = hash_args_array(serialized);\n\n    //     let _ = OracleMock::mock(\"privateLoadFromExecutionCache\").returns([1]);\n    //     assert_eq(ReturnsHash::new(hash).get_preimage(), value);\n    // }\n}\n"
    },
    "76": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/context/utility_context.nr",
      "source": "use crate::oracle::{\n    execution::{get_block_number, get_chain_id, get_contract_address, get_timestamp, get_version},\n    storage::storage_read,\n};\nuse dep::protocol_types::{address::AztecAddress, traits::Packable};\n\npub struct UtilityContext {\n    block_number: u32,\n    timestamp: u64,\n    contract_address: AztecAddress,\n    version: Field,\n    chain_id: Field,\n}\n\nimpl UtilityContext {\n    pub unconstrained fn new() -> Self {\n        // We could call these oracles on the getters instead of at creation, which makes sense given that they might\n        // not even be accessed. However any performance gains are minimal, and we'd rather fail early if a user\n        // incorrectly attempts to create a UtilityContext in an environment in which these oracles are not\n        // available.\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let contract_address = get_contract_address();\n        let version = get_version();\n        let chain_id = get_chain_id();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at(contract_address: AztecAddress) -> Self {\n        let block_number = get_block_number();\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub unconstrained fn at_historical(contract_address: AztecAddress, block_number: u32) -> Self {\n        let timestamp = get_timestamp();\n        let chain_id = get_chain_id();\n        let version = get_version();\n        Self { block_number, timestamp, contract_address, version, chain_id }\n    }\n\n    pub fn block_number(self) -> u32 {\n        self.block_number\n    }\n\n    pub fn timestamp(self) -> u64 {\n        self.timestamp\n    }\n\n    pub fn this_address(self) -> AztecAddress {\n        self.contract_address\n    }\n\n    pub fn version(self) -> Field {\n        self.version\n    }\n\n    pub fn chain_id(self) -> Field {\n        self.chain_id\n    }\n\n    pub unconstrained fn raw_storage_read<let N: u32>(\n        self: Self,\n        storage_slot: Field,\n    ) -> [Field; N] {\n        storage_read(self.this_address(), storage_slot, self.block_number())\n    }\n\n    pub unconstrained fn storage_read<T>(self, storage_slot: Field) -> T\n    where\n        T: Packable,\n    {\n        T::unpack(self.raw_storage_read(storage_slot))\n    }\n}\n"
    },
    "78": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/event/event_selector.nr",
      "source": "use dep::protocol_types::{\n    hash::poseidon2_hash_bytes,\n    traits::{Deserialize, Empty, FromField, Serialize, ToField},\n};\n\n#[derive(Deserialize, Eq, Serialize)]\npub struct EventSelector {\n    // 1st 4-bytes (big-endian leftmost) of abi-encoding of an event.\n    inner: u32,\n}\n\nimpl FromField for EventSelector {\n    fn from_field(field: Field) -> Self {\n        Self { inner: field as u32 }\n    }\n}\n\nimpl ToField for EventSelector {\n    fn to_field(self) -> Field {\n        self.inner as Field\n    }\n}\n\nimpl Empty for EventSelector {\n    fn empty() -> Self {\n        Self { inner: 0 as u32 }\n    }\n}\n\nimpl EventSelector {\n    pub fn from_u32(value: u32) -> Self {\n        Self { inner: value }\n    }\n\n    pub fn from_signature<let N: u32>(signature: str<N>) -> Self {\n        let bytes = signature.as_bytes();\n        let hash = poseidon2_hash_bytes(bytes);\n\n        // `hash` is automatically truncated to fit within 32 bits.\n        EventSelector::from_field(hash)\n    }\n\n    pub fn zero() -> Self {\n        Self { inner: 0 }\n    }\n}\n"
    },
    "80": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/hash.nr",
      "source": "use dep::protocol_types::{\n    address::{AztecAddress, EthAddress},\n    constants::{\n        GENERATOR_INDEX__FUNCTION_ARGS, GENERATOR_INDEX__MESSAGE_NULLIFIER,\n        GENERATOR_INDEX__PUBLIC_BYTECODE, GENERATOR_INDEX__PUBLIC_CALLDATA,\n        GENERATOR_INDEX__SECRET_HASH, MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS,\n    },\n    hash::{\n        poseidon2_hash_subarray, poseidon2_hash_with_separator, poseidon2_hash_with_separator_slice,\n        sha256_to_field,\n    },\n    point::Point,\n    traits::{Hash, ToField},\n};\n\npub use dep::protocol_types::hash::{compute_siloed_nullifier, pedersen_hash};\n\npub fn pedersen_commitment<let N: u32>(inputs: [Field; N], hash_index: u32) -> Point {\n    std::hash::pedersen_commitment_with_separator(inputs, hash_index)\n}\n\npub fn compute_secret_hash(secret: Field) -> Field {\n    poseidon2_hash_with_separator([secret], GENERATOR_INDEX__SECRET_HASH)\n}\n\npub fn compute_l1_to_l2_message_hash(\n    sender: EthAddress,\n    chain_id: Field,\n    recipient: AztecAddress,\n    version: Field,\n    content: Field,\n    secret_hash: Field,\n    leaf_index: Field,\n) -> Field {\n    let mut hash_bytes = [0 as u8; 224];\n    let sender_bytes: [u8; 32] = sender.to_field().to_be_bytes();\n    let chain_id_bytes: [u8; 32] = chain_id.to_be_bytes();\n    let recipient_bytes: [u8; 32] = recipient.to_field().to_be_bytes();\n    let version_bytes: [u8; 32] = version.to_be_bytes();\n    let content_bytes: [u8; 32] = content.to_be_bytes();\n    let secret_hash_bytes: [u8; 32] = secret_hash.to_be_bytes();\n    let leaf_index_bytes: [u8; 32] = leaf_index.to_be_bytes();\n\n    for i in 0..32 {\n        hash_bytes[i] = sender_bytes[i];\n        hash_bytes[i + 32] = chain_id_bytes[i];\n        hash_bytes[i + 64] = recipient_bytes[i];\n        hash_bytes[i + 96] = version_bytes[i];\n        hash_bytes[i + 128] = content_bytes[i];\n        hash_bytes[i + 160] = secret_hash_bytes[i];\n        hash_bytes[i + 192] = leaf_index_bytes[i];\n    }\n\n    sha256_to_field(hash_bytes)\n}\n\n// The nullifier of a l1 to l2 message is the hash of the message salted with the secret\npub fn compute_l1_to_l2_message_nullifier(message_hash: Field, secret: Field) -> Field {\n    poseidon2_hash_with_separator([message_hash, secret], GENERATOR_INDEX__MESSAGE_NULLIFIER)\n}\n\npub struct ArgsHasher {\n    pub fields: [Field],\n}\n\nimpl Hash for ArgsHasher {\n    fn hash(self) -> Field {\n        hash_args(self.fields)\n    }\n}\n\nimpl ArgsHasher {\n    pub fn new() -> Self {\n        Self { fields: [] }\n    }\n\n    pub fn add(&mut self, field: Field) {\n        self.fields = self.fields.push_back(field);\n    }\n\n    pub fn add_multiple<let N: u32>(&mut self, fields: [Field; N]) {\n        for i in 0..N {\n            self.fields = self.fields.push_back(fields[i]);\n        }\n    }\n}\n\n// Computes the hash of input arguments or return values for private functions, or for authwit creation.\npub fn hash_args_array<let N: u32>(args: [Field; N]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Same as `hash_args_array`, but takes a slice instead of an array.\npub fn hash_args(args: [Field]) -> Field {\n    if args.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(args, GENERATOR_INDEX__FUNCTION_ARGS)\n    }\n}\n\n// Computes the hash of calldata for public functions.\npub fn hash_calldata_array<let N: u32>(calldata: [Field; N]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n// Same as `hash_calldata_array`, but takes a slice instead of an array.\npub fn hash_calldata(calldata: [Field]) -> Field {\n    if calldata.len() == 0 {\n        0\n    } else {\n        poseidon2_hash_with_separator_slice(calldata, GENERATOR_INDEX__PUBLIC_CALLDATA)\n    }\n}\n\n/**\n * Computes the public bytecode commitment for a contract class.\n * The commitment is `hash([separator, ...bytecode])` where bytecode omits the length prefix present\n * in `packed_bytecode`.\n *\n * @param packed_bytecode - The packed bytecode of the contract class. 0th word is the length in bytes.\n *    packed_bytecode is mutable so that we can avoid copying the array to construct one starting with\n *    separator instead of length.\n * @returns The public bytecode commitment.\n */\npub fn compute_public_bytecode_commitment(\n    mut packed_public_bytecode: [Field; MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS],\n) -> Field {\n    // First field element contains the length of the bytecode\n    let bytecode_length_in_bytes: u32 = packed_public_bytecode[0] as u32;\n    let bytecode_length_in_fields: u32 =\n        (bytecode_length_in_bytes / 31) + (bytecode_length_in_bytes % 31 != 0) as u32;\n    // Don't allow empty public bytecode.\n    // AVM doesn't handle execution of contracts that exist with empty bytecode.\n    assert(bytecode_length_in_fields != 0);\n    assert(bytecode_length_in_fields < MAX_PACKED_PUBLIC_BYTECODE_SIZE_IN_FIELDS);\n\n    // Packed_bytecode's 0th entry is the length. Replace it with separator before hashing.\n    let separator = GENERATOR_INDEX__PUBLIC_BYTECODE.to_field();\n    packed_public_bytecode[0] = separator;\n    // +1 to length to account for the separator\n    let nonzero_length = bytecode_length_in_fields + 1;\n\n    poseidon2_hash_subarray(packed_public_bytecode, nonzero_length)\n    // NOTE: we use poseidon2_hash_subarray here because we want to hash the bytecode only up to\n    // its nonzero length. We do NOT want to include a `1` at the end to indicate \"variable length\",\n    // and we want to enforce that all trailing elements are zero.\n}\n\n#[test]\nunconstrained fn compute_var_args_hash() {\n    let mut input = ArgsHasher::new();\n    for i in 0..100 {\n        input.add(i as Field);\n    }\n    let hash = input.hash();\n    dep::std::println(hash);\n    assert(hash == 0x19b0d74feb06ebde19edd85a28986c97063e84b3b351a8b666c7cac963ce655f);\n}\n"
    },
    "92": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/history/public_storage.nr",
      "source": "use dep::protocol_types::{\n    abis::block_header::BlockHeader, address::AztecAddress,\n    constants::GENERATOR_INDEX__PUBLIC_LEAF_INDEX, hash::poseidon2_hash_with_separator,\n    utils::field::full_field_less_than,\n};\nuse dep::protocol_types::merkle_tree::root::root_from_sibling_path;\n\nuse crate::oracle::get_public_data_witness::get_public_data_witness;\nuse protocol_types::traits::{Hash, ToField};\n\nmod test;\n\npub trait PublicStorageHistoricalRead {\n    fn public_storage_historical_read(\n        header: BlockHeader,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field;\n}\n\nimpl PublicStorageHistoricalRead for BlockHeader {\n    fn public_storage_historical_read(\n        self,\n        storage_slot: Field,\n        contract_address: AztecAddress,\n    ) -> Field {\n        // 1) Compute the leaf index by siloing the storage slot with the contract address\n        let public_data_tree_index = poseidon2_hash_with_separator(\n            [contract_address.to_field(), storage_slot],\n            GENERATOR_INDEX__PUBLIC_LEAF_INDEX,\n        );\n\n        // 2) Get the membership witness for the tree index.\n        // Safety: The witness is only used as a \"magical value\" that makes the proof below pass. Hence it's safe.\n        let witness = unsafe {\n            get_public_data_witness(self.global_variables.block_number, public_data_tree_index)\n        };\n\n        // 3) The witness is made up of two parts: the preimage of the leaf and the proof that it exists in the tree.\n        // We first prove that the witness is indeed valid for the public data tree, i.e. that the preimage is of a\n        // value present in the tree. Note that `hash` returns not just the hash of the value but also the metadata\n        // (slot, next index and next slot).\n        assert_eq(\n            self.state.partial.public_data_tree.root,\n            root_from_sibling_path(witness.leaf_preimage.hash(), witness.index, witness.path),\n            \"Proving public value inclusion failed\",\n        );\n\n        // 4) Now that we know the preimage is valid, we determine the value that's represented by this tree entry. Here\n        // we have two scenarios:\n        // 1. The tree entry is initialized, and the value is the same as the one in the witness\n        // 2. The entry was never initialized, and the value is default zero (the default)\n        // The code below is based on the same checks in `validate_public_data_reads` in `base_rollup_inputs`.\n        let preimage = witness.leaf_preimage;\n\n        let is_less_than_slot = full_field_less_than(preimage.slot, public_data_tree_index);\n        let is_next_greater_than = full_field_less_than(public_data_tree_index, preimage.next_slot);\n        let is_max = ((preimage.next_index == 0) & (preimage.next_slot == 0));\n        let is_in_range = is_less_than_slot & (is_next_greater_than | is_max);\n\n        let value = if is_in_range {\n            0\n        } else {\n            assert_eq(\n                preimage.slot,\n                public_data_tree_index,\n                \"Public data tree index doesn't match witness\",\n            );\n            preimage.value\n        };\n\n        value\n    }\n}\n"
    },
    "97": {
      "path": "/home/aztec-dev/aztec-packages/noir-projects/aztec-nr/aztec/src/keys/getters/mod.nr",
      "source": "use crate::{\n    keys::constants::{NULLIFIER_INDEX, OUTGOING_INDEX},\n    oracle::{\n        key_validation_request::get_key_validation_request,\n        keys::get_public_keys_and_partial_address,\n    },\n};\nuse dep::protocol_types::{address::AztecAddress, public_keys::PublicKeys};\n\npub unconstrained fn get_nsk_app(npk_m_hash: Field) -> Field {\n    get_key_validation_request(npk_m_hash, NULLIFIER_INDEX).sk_app\n}\n\n// A helper function that gets app-siloed outgoing viewing key for a given `ovpk_m_hash`. This function is used\n// in unconstrained contexts only - when computing unconstrained note logs. The safe alternative is `request_ovsk_app`\n// function defined on `PrivateContext`.\npub unconstrained fn get_ovsk_app(ovpk_m_hash: Field) -> Field {\n    get_key_validation_request(ovpk_m_hash, OUTGOING_INDEX).sk_app\n}\n\n// Returns all public keys for a given account, applying proper constraints to the context. We read all\n// keys at once since the constraints for reading them all are actually fewer than if we read them one at a time - any\n// read keys that are not required by the caller can simply be discarded.\npub fn get_public_keys(account: AztecAddress) -> PublicKeys {\n    // Safety: Public keys are constrained by showing their inclusion in the address's preimage.\n    let (public_keys, partial_address) = unsafe { get_public_keys_and_partial_address(account) };\n    assert_eq(\n        account,\n        AztecAddress::compute(public_keys, partial_address),\n        \"Invalid public keys hint for address\",\n    );\n\n    public_keys\n}\n\nmod test {\n    use super::get_public_keys;\n\n    use crate::test::helpers::test_environment::TestEnvironment;\n    use protocol_types::traits::Serialize;\n    use std::test::OracleMock;\n\n    global KEY_ORACLE_RESPONSE_LENGTH: u32 = 13; // 12 fields for the keys, one field for the partial address\n\n    #[test(should_fail_with = \"Invalid public keys hint for address\")]\n    unconstrained fn get_public_keys_fails_with_bad_hint() {\n        let mut env = TestEnvironment::new();\n        let account = env.create_light_account();\n\n        // Instead of querying for some unknown account, which would result in the oracle erroring out, we mock a bad oracle\n        // response to check that the circuit properly checks the address derivation.\n        let mut random_keys_and_partial_address = [0; KEY_ORACLE_RESPONSE_LENGTH];\n        // We use randomly generated points on the curve, and a random partial address to ensure that\n        // this combination does not derive the address and we should see the assertion fail.\n        // npk_m\n        random_keys_and_partial_address[0] =\n            0x292364b852c6c6f01472951e76a39cbcf074591fd0e063a81965e7b51ad868a5;\n        random_keys_and_partial_address[1] =\n            0x0a687b46cdc9238f1c311f126aaaa4acbd7a737bff2efd7aeabdb8d805843a27;\n        random_keys_and_partial_address[2] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ivpk_m\n        random_keys_and_partial_address[3] =\n            0x173c5229a00c5425255680dd6edc27e278c48883991f348fe6985de43b4ec25f;\n        random_keys_and_partial_address[4] =\n            0x1698608e23b5f6c2f43c49a559108bb64e2247b8fc2da842296a416817f40b7f;\n        random_keys_and_partial_address[5] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // ovpk_m\n        random_keys_and_partial_address[6] =\n            0x1bad2f7d1ad960a1bd0fe4d2c8d17f5ab4a86ef8b103e0a9e7f67ec0d3b4795e;\n        random_keys_and_partial_address[7] =\n            0x206db87110abbecc9fbaef2c865189d94ef2c106202f734ee4eba9257fd28bf1;\n        random_keys_and_partial_address[8] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // tpk_m\n        random_keys_and_partial_address[9] =\n            0x05e3bd9cfe6b47daa139613619cf7d7fd8bb0112b6f2908caa6d9b536ed948ed;\n        random_keys_and_partial_address[10] =\n            0x051066f877c9df47552d02e7dc32127ff4edefc8498e813bca1cbd3f5d1be429;\n        random_keys_and_partial_address[11] =\n            0x0000000000000000000000000000000000000000000000000000000000000000;\n        // partial address\n        random_keys_and_partial_address[12] =\n            0x236703e2cb00a182e024e98e9f759231b556d25ff19f98896cebb69e9e678cc9;\n\n        let _ = OracleMock::mock(\"utilityGetPublicKeysAndPartialAddress\").returns(\n            random_keys_and_partial_address.serialize(),\n        );\n        let _ = get_public_keys(account);\n    }\n}\n"
    }
  }
}
