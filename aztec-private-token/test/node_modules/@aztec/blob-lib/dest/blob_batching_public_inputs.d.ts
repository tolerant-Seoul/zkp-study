import { BLS12Fr, BLS12Point, Fr } from '@aztec/foundation/fields';
import { BufferReader, FieldReader } from '@aztec/foundation/serialize';
import { inspect } from 'util';
import { Blob } from './blob.js';
import { BatchedBlob, BatchedBlobAccumulator, FinalBlobBatchingChallenges } from './blob_batching.js';
/**
 * See nr BlobAccumulatorPublicInputs and ts BatchedBlobAccumulator for documentation.
 */
export declare class BlobAccumulatorPublicInputs {
    blobCommitmentsHashAcc: Fr;
    zAcc: Fr;
    yAcc: BLS12Fr;
    cAcc: BLS12Point;
    gammaAcc: Fr;
    gammaPowAcc: BLS12Fr;
    constructor(blobCommitmentsHashAcc: Fr, zAcc: Fr, yAcc: BLS12Fr, cAcc: BLS12Point, gammaAcc: Fr, gammaPowAcc: BLS12Fr);
    static empty(): BlobAccumulatorPublicInputs;
    equals(other: BlobAccumulatorPublicInputs): boolean;
    static fromBuffer(buffer: Buffer | BufferReader): BlobAccumulatorPublicInputs;
    toBuffer(): Buffer<ArrayBufferLike>;
    /**
     * Given blobs, accumulate all public inputs state.
     * We assume the input blobs have not been evaluated at z.
     * NOTE: Does NOT accumulate non circuit values including Q. This exists to simulate/check exactly what the circuit is doing
     * and is unsafe for other use. For that reason, a toBatchedBlobAccumulator does not exist. See evaluateBlobs() oracle for usage.
     * @returns An updated blob accumulator.
     */
    accumulateBlobs(blobs: Blob[], finalBlobChallenges: FinalBlobBatchingChallenges): Promise<BlobAccumulatorPublicInputs>;
    toFields(): Fr[];
    static fromFields(fields: Fr[] | FieldReader): BlobAccumulatorPublicInputs;
    /**
     * Converts from an accumulator to a struct for the public inputs of our rollup circuits.
     * @returns A BlobAccumulatorPublicInputs instance.
     */
    static fromBatchedBlobAccumulator(accumulator: BatchedBlobAccumulator): BlobAccumulatorPublicInputs;
}
/**
 * See nr FinalBlobAccumulatorPublicInputs and ts BatchedBlobAccumulator for documentation.
 */
export declare class FinalBlobAccumulatorPublicInputs {
    blobCommitmentsHash: Fr;
    z: Fr;
    y: BLS12Fr;
    c: BLS12Point;
    constructor(blobCommitmentsHash: Fr, z: Fr, y: BLS12Fr, c: BLS12Point);
    static empty(): FinalBlobAccumulatorPublicInputs;
    static fromBuffer(buffer: Buffer | BufferReader): FinalBlobAccumulatorPublicInputs;
    toBuffer(): Buffer<ArrayBufferLike>;
    static fromBatchedBlob(blob: BatchedBlob): FinalBlobAccumulatorPublicInputs;
    toFields(): Fr[];
    toString(): string;
    equals(other: FinalBlobAccumulatorPublicInputs): boolean;
    static random(): FinalBlobAccumulatorPublicInputs;
    static fromBatchedBlobAccumulator(accumulator: BatchedBlobAccumulator): FinalBlobAccumulatorPublicInputs;
    [inspect.custom](): string;
}
/**
 * startBlobAccumulator: Accumulated opening proofs for all blobs before this block range.
 * endBlobAccumulator: Accumulated opening proofs for all blobs after adding this block range.
 * finalBlobChallenges:  Final values z and gamma, shared across the epoch.
 */
export declare class BlockBlobPublicInputs {
    startBlobAccumulator: BlobAccumulatorPublicInputs;
    endBlobAccumulator: BlobAccumulatorPublicInputs;
    finalBlobChallenges: FinalBlobBatchingChallenges;
    constructor(startBlobAccumulator: BlobAccumulatorPublicInputs, endBlobAccumulator: BlobAccumulatorPublicInputs, finalBlobChallenges: FinalBlobBatchingChallenges);
    static empty(): BlockBlobPublicInputs;
    static fromBuffer(buffer: Buffer | BufferReader): BlockBlobPublicInputs;
    toBuffer(): Buffer<ArrayBufferLike>;
}
//# sourceMappingURL=blob_batching_public_inputs.d.ts.map