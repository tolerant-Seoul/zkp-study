import { Fr } from '@aztec/foundation/fields';
import { BufferReader } from '@aztec/foundation/serialize';
import cKzg from 'c-kzg';
import type { Blob as BlobBuffer } from 'c-kzg';
import type { BlobJson } from './interface.js';
export declare const VERSIONED_HASH_VERSION_KZG = 1;
/** Versioned blob hash for an empty blob */
export declare const EMPTY_BLOB_VERSIONED_HASH: Buffer<ArrayBuffer>;
/**
 * A class to create, manage, and prove EVM blobs.
 */
export declare class Blob {
    /** The blob to be broadcast on L1 in bytes form. */
    readonly data: BlobBuffer;
    /** The hash of all tx effects inside the blob. Used in generating the challenge z and proving that we have included all required effects. */
    readonly fieldsHash: Fr;
    /** Challenge point z (= H(H(tx_effects), kzgCommmitment). Used such that p(z) = y for a single blob, used as z_i in batching (see ./blob_batching.ts). */
    readonly challengeZ: Fr;
    /** Commitment to the blob C. Used in compressed BLS12 point format (48 bytes). */
    readonly commitment: Buffer;
    constructor(
    /** The blob to be broadcast on L1 in bytes form. */
    data: BlobBuffer, 
    /** The hash of all tx effects inside the blob. Used in generating the challenge z and proving that we have included all required effects. */
    fieldsHash: Fr, 
    /** Challenge point z (= H(H(tx_effects), kzgCommmitment). Used such that p(z) = y for a single blob, used as z_i in batching (see ./blob_batching.ts). */
    challengeZ: Fr, 
    /** Commitment to the blob C. Used in compressed BLS12 point format (48 bytes). */
    commitment: Buffer);
    /**
     * The encoded version of the blob will determine the end of the blob based on the transaction encoding.
     * This is required when the fieldsHash of a blob will contain trailing zeros.
     *
     * See `./encoding.ts` for more details.
     *
     * This method is used to create a Blob from a buffer.
     * @param blob - The buffer to create the Blob from.
     * @param multiBlobFieldsHash - The fields hash to use for the Blob.
     * @returns A Blob created from the buffer.
     *
     * @throws If unable to deserialize the blob.
     */
    static fromEncodedBlobBuffer(blob: BlobBuffer, multiBlobFieldsHash?: Fr): Promise<Blob>;
    /**
     * Create a Blob from an array of fields.
     *
     * @param fields - The array of fields to create the Blob from.
     * @param multiBlobFieldsHash - The fields hash to use for the Blob.
     * @returns A Blob created from the array of fields.
     */
    static fromFields(fields: Fr[], multiBlobFieldsHash?: Fr): Promise<Blob>;
    /**
     * Create a Blob from a JSON object.
     *
     * Blobs will be in this form when requested from the blob sink, or from
     * the beacon chain via `getBlobSidecars`
     * https://ethereum.github.io/beacon-APIs/?urls.primaryName=dev#/Beacon/getBlobSidecars
     *
     * @dev WARNING: by default json deals with encoded buffers
     *
     * @param json - The JSON object to create the Blob from.
     * @returns A Blob created from the JSON object.
     */
    static fromJson(json: BlobJson): Promise<Blob>;
    /**
     * Get the JSON representation of the blob.
     *
     * @dev WARNING: by default json deals with encoded buffers
     * @param index - optional - The index of the blob in the block.
     * @returns The JSON representation of the blob.
     */
    toJson(index: number): BlobJson;
    /**
     * Get the fields from the blob.
     *
     * @dev WARNING: this method does not take into account trailing zeros
     *
     * @returns The fields from the blob.
     */
    toFields(): Fr[];
    /**
     * Get the encoded fields from the blob.
     *
     * @dev This method takes into account trailing zeros
     *
     * @returns The encoded fields from the blob.
     *
     * @throws If unable to deserialize the blob.
     */
    toEncodedFields(): Fr[];
    /**
     * Get the encoded fields from multiple blobs.
     *
     * @dev This method takes into account trailing zeros
     *
     * @returns The encoded fields from the blobs.
     */
    static toEncodedFields(blobs: Blob[]): Fr[];
    /**
     * Get the commitment fields from the blob.
     *
     * The 48-byte commitment is encoded into two field elements:
     * +------------------+------------------+
     * | Field Element 1  | Field Element 2  |
     * | [bytes 0-31]     | [bytes 32-47]   |
     * +------------------+------------------+
     * |     32 bytes     |     16 bytes    |
     * +------------------+------------------+
     * @returns The commitment fields from the blob.
     */
    commitmentToFields(): [Fr, Fr];
    getEthVersionedBlobHash(): Buffer;
    static getEthVersionedBlobHash(commitment: Buffer): Buffer;
    /**
     * Evaluate the blob at a given challenge and return the evaluation and KZG proof.
     *
     * @param challengeZ - The challenge z at which to evaluate the blob. If not given, assume we want to evaluate at the individual blob's z.
     *
     * @returns -
     *  y: Buffer -  Evaluation y = p(z), where p() is the blob polynomial. BLS12 field element, rep. as BigNum in nr, bigint in ts
     *  proof: Buffer - KZG opening proof for y = p(z). The commitment to quotient polynomial Q, used in compressed BLS12 point format (48 bytes).
     */
    evaluate(challengeZ?: Fr): {
        y: Buffer<ArrayBuffer>;
        proof: Buffer<ArrayBuffer>;
    };
    /**
     * Get the buffer representation of the ENTIRE blob.
     *
     * @dev WARNING: this buffer contains all metadata aswell as the data itself
     *
     * @returns The buffer representation of the blob.
     */
    toBuffer(): Buffer;
    /**
     * Create a Blob from a buffer.
     *
     * @dev WARNING: this method contains all metadata aswell as the data itself
     *
     * @param buf - The buffer to create the Blob from.
     * @returns A Blob created from the buffer.
     */
    static fromBuffer(buf: Buffer | BufferReader): Blob;
    /**
     * Get the size of the blob in bytes
     */
    getSize(): number;
    /**
     * @param blobs - The blobs to emit
     * @returns The blobs' compressed commitments in hex prefixed by the number of blobs
     * @dev Used for proposing blocks to validate injected blob commitments match real broadcast blobs:
     * One byte for the number blobs + 48 bytes per blob commitment
     */
    static getPrefixedEthBlobCommitments(blobs: Blob[]): `0x${string}`;
    static getViemKzgInstance(): {
        blobToKzgCommitment: typeof cKzg.blobToKzgCommitment;
        computeBlobKzgProof: typeof cKzg.computeBlobKzgProof;
        computeCellsAndKzgProofs: typeof cKzg.computeCellsAndKzgProofs;
    };
    /**
     * @param fields - Fields to broadcast in the blob(s)
     * @returns As many blobs as we require to broadcast the given fields for a block
     * @dev Assumes we share the fields hash between all blobs which can only be done for ONE BLOCK because the hash is calculated in block root.
     */
    static getBlobsPerBlock(fields: Fr[]): Promise<Blob[]>;
}
//# sourceMappingURL=blob.d.ts.map