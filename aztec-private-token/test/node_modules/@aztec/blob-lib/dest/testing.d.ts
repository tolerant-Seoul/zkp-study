import { Fr } from '@aztec/foundation/fields';
import { Blob } from './blob.js';
import { BatchedBlobAccumulator } from './blob_batching.js';
import { BlockBlobPublicInputs } from './blob_batching_public_inputs.js';
import { SpongeBlob } from './sponge_blob.js';
/**
 * Makes arbitrary poseidon sponge for blob inputs.
 * Note: will not verify inside the circuit.
 * @param seed - The seed to use for generating the sponge.
 * @returns A sponge blob instance.
 */
export declare function makeSpongeBlob(seed?: number): SpongeBlob;
/**
 * Makes arbitrary blob public accumulator.
 * Note: will not verify inside the circuit.
 * @param seed - The seed to use for generating the blob accumulator.
 * @returns A blob accumulator instance.
 */
export declare function makeBatchedBlobAccumulator(seed?: number): BatchedBlobAccumulator;
/**
 * Makes arbitrary block blob public inputs.
 * Note: will not verify inside the circuit.
 * @param seed - The seed to use for generating the blob inputs.
 * @returns A block blob public inputs instance.
 */
export declare function makeBlockBlobPublicInputs(seed?: number): BlockBlobPublicInputs;
/**
 * Make an encoded blob with the given length
 *
 * This will deserialise correctly in the archiver
 * @param length
 * @returns
 */
export declare function makeEncodedBlob(length: number): Promise<Blob>;
/**
 * Make an unencoded blob with the given length
 *
 * This will fail deserialisation in the archiver
 * @param length
 * @returns
 */
export declare function makeUnencodedBlob(length: number): Promise<Blob>;
export declare function makeEncodedBlobFields(fields: Fr[]): Promise<Blob>;
//# sourceMappingURL=testing.d.ts.map