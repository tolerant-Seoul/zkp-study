export type Field2 = [Uint8Array, Uint8Array];
export type Fq = Uint8Array;
export type Fr = Uint8Array;
export type Uint256T = Uint8Array;
export interface Bn254FqSqrt {
    input: Fq;
}
interface MsgpackBn254FqSqrt {
    input: Uint8Array;
}
export interface Bn254FqSqrtResponse {
    isSquareRoot: boolean;
    value: Fq;
}
interface MsgpackBn254FqSqrtResponse {
    is_square_root: boolean;
    value: Uint8Array;
}
export interface Bn254FrSqrt {
    input: Fr;
}
interface MsgpackBn254FrSqrt {
    input: Uint8Array;
}
export interface Bn254FrSqrtResponse {
    isSquareRoot: boolean;
    value: Fr;
}
interface MsgpackBn254FrSqrtResponse {
    is_square_root: boolean;
    value: Uint8Array;
}
export interface Bn254G1FromCompressed {
    compressed: Uint8Array;
}
interface MsgpackBn254G1FromCompressed {
    compressed: Uint8Array;
}
export interface Bn254G1FromCompressedResponse {
    point: Bn254G1Point;
}
interface MsgpackBn254G1FromCompressedResponse {
    point: MsgpackBn254G1Point;
}
export interface Bn254G1IsOnCurve {
    point: Bn254G1Point;
}
interface MsgpackBn254G1IsOnCurve {
    point: MsgpackBn254G1Point;
}
export interface Bn254G1IsOnCurveResponse {
    isOnCurve: boolean;
}
interface MsgpackBn254G1IsOnCurveResponse {
    is_on_curve: boolean;
}
export interface Bn254G1Mul {
    point: Bn254G1Point;
    scalar: Fr;
}
interface MsgpackBn254G1Mul {
    point: MsgpackBn254G1Point;
    scalar: Uint8Array;
}
export interface Bn254G1MulResponse {
    point: Bn254G1Point;
}
interface MsgpackBn254G1MulResponse {
    point: MsgpackBn254G1Point;
}
export interface Bn254G1Point {
    x: Fq;
    y: Fq;
}
interface MsgpackBn254G1Point {
    x: Uint8Array;
    y: Uint8Array;
}
export interface Bn254G2Mul {
    point: Bn254G2Point;
    scalar: Fr;
}
interface MsgpackBn254G2Mul {
    point: MsgpackBn254G2Point;
    scalar: Uint8Array;
}
export interface Bn254G2MulResponse {
    point: Bn254G2Point;
}
interface MsgpackBn254G2MulResponse {
    point: MsgpackBn254G2Point;
}
export interface Bn254G2Point {
    x: Field2;
    y: Field2;
}
interface MsgpackBn254G2Point {
    x: [Uint8Array, Uint8Array];
    y: [Uint8Array, Uint8Array];
}
export interface CircuitComputeVk {
    circuit: CircuitInputNoVK;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitComputeVk {
    circuit: MsgpackCircuitInputNoVK;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitComputeVkResponse {
    bytes: Uint8Array;
    fields: Uint256T[];
    hash: Uint8Array;
}
interface MsgpackCircuitComputeVkResponse {
    bytes: Uint8Array;
    fields: Uint8Array[];
    hash: Uint8Array;
}
export interface CircuitInfoResponse {
    numGates: number;
    numGatesDyadic: number;
    numAcirOpcodes: number;
    gatesPerOpcode: number[];
}
interface MsgpackCircuitInfoResponse {
    num_gates: number;
    num_gates_dyadic: number;
    num_acir_opcodes: number;
    gates_per_opcode: number[];
}
export interface CircuitInput {
    name: string;
    bytecode: Uint8Array;
    verificationKey: Uint8Array;
}
interface MsgpackCircuitInput {
    name: string;
    bytecode: Uint8Array;
    verification_key: Uint8Array;
}
export interface CircuitInputNoVK {
    name: string;
    bytecode: Uint8Array;
}
interface MsgpackCircuitInputNoVK {
    name: string;
    bytecode: Uint8Array;
}
export interface CircuitProve {
    circuit: CircuitInput;
    witness: Uint8Array;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitProve {
    circuit: MsgpackCircuitInput;
    witness: Uint8Array;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitProveResponse {
    publicInputs: Uint256T[];
    proof: Uint256T[];
    vk: CircuitComputeVkResponse;
}
interface MsgpackCircuitProveResponse {
    public_inputs: Uint8Array[];
    proof: Uint8Array[];
    vk: MsgpackCircuitComputeVkResponse;
}
export interface CircuitStats {
    circuit: CircuitInput;
    includeGatesPerOpcode: boolean;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitStats {
    circuit: MsgpackCircuitInput;
    include_gates_per_opcode: boolean;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitVerify {
    verificationKey: Uint8Array;
    publicInputs: Uint256T[];
    proof: Uint256T[];
    settings: ProofSystemSettings;
}
interface MsgpackCircuitVerify {
    verification_key: Uint8Array;
    public_inputs: Uint8Array[];
    proof: Uint8Array[];
    settings: MsgpackProofSystemSettings;
}
export interface CircuitVerifyResponse {
    verified: boolean;
}
interface MsgpackCircuitVerifyResponse {
    verified: boolean;
}
export interface CircuitWriteSolidityVerifier {
    verificationKey: Uint8Array;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitWriteSolidityVerifier {
    verification_key: Uint8Array;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitWriteSolidityVerifierResponse {
    solidityCode: string;
}
interface MsgpackCircuitWriteSolidityVerifierResponse {
    solidity_code: string;
}
export interface ClientIvcAccumulate {
    witness: Uint8Array;
}
interface MsgpackClientIvcAccumulate {
    witness: Uint8Array;
}
export interface ClientIvcAccumulateResponse {
}
interface MsgpackClientIvcAccumulateResponse {
}
export interface ClientIvcCheckPrecomputedVk {
    circuit: CircuitInput;
}
interface MsgpackClientIvcCheckPrecomputedVk {
    circuit: MsgpackCircuitInput;
}
export interface ClientIvcCheckPrecomputedVkResponse {
    valid: boolean;
    actualVk: Uint8Array;
}
interface MsgpackClientIvcCheckPrecomputedVkResponse {
    valid: boolean;
    actual_vk: Uint8Array;
}
export interface ClientIvcComputeIvcVk {
    circuit: CircuitInputNoVK;
}
interface MsgpackClientIvcComputeIvcVk {
    circuit: MsgpackCircuitInputNoVK;
}
export interface ClientIvcComputeIvcVkResponse {
    bytes: Uint8Array;
}
interface MsgpackClientIvcComputeIvcVkResponse {
    bytes: Uint8Array;
}
export interface ClientIvcComputeStandaloneVk {
    circuit: CircuitInputNoVK;
}
interface MsgpackClientIvcComputeStandaloneVk {
    circuit: MsgpackCircuitInputNoVK;
}
export interface ClientIvcComputeStandaloneVkResponse {
    bytes: Uint8Array;
    fields: Fr[];
}
interface MsgpackClientIvcComputeStandaloneVkResponse {
    bytes: Uint8Array;
    fields: Uint8Array[];
}
export interface ClientIvcLoad {
    circuit: CircuitInput;
}
interface MsgpackClientIvcLoad {
    circuit: MsgpackCircuitInput;
}
export interface ClientIvcLoadResponse {
}
interface MsgpackClientIvcLoadResponse {
}
export interface ClientIVCProof {
    megaProof: Fr[];
    goblinProof: GoblinProof;
}
interface MsgpackClientIVCProof {
    mega_proof: Uint8Array[];
    goblin_proof: MsgpackGoblinProof;
}
export interface ClientIvcProve {
}
interface MsgpackClientIvcProve {
}
export interface ClientIvcProveResponse {
    proof: ClientIVCProof;
}
interface MsgpackClientIvcProveResponse {
    proof: MsgpackClientIVCProof;
}
export interface ClientIvcStart {
    numCircuits: number;
}
interface MsgpackClientIvcStart {
    num_circuits: number;
}
export interface ClientIvcStartResponse {
}
interface MsgpackClientIvcStartResponse {
}
export interface ClientIvcStats {
    circuit: CircuitInputNoVK;
    includeGatesPerOpcode: boolean;
}
interface MsgpackClientIvcStats {
    circuit: MsgpackCircuitInputNoVK;
    include_gates_per_opcode: boolean;
}
export interface ClientIvcStatsResponse {
    acirOpcodes: number;
    circuitSize: number;
    gatesPerOpcode: number[];
}
interface MsgpackClientIvcStatsResponse {
    acir_opcodes: number;
    circuit_size: number;
    gates_per_opcode: number[];
}
export interface ClientIvcVerify {
    proof: ClientIVCProof;
    vk: Uint8Array;
}
interface MsgpackClientIvcVerify {
    proof: MsgpackClientIVCProof;
    vk: Uint8Array;
}
export interface ClientIvcVerifyResponse {
    valid: boolean;
}
interface MsgpackClientIvcVerifyResponse {
    valid: boolean;
}
export interface ECCVMProof {
    preIpaProof: Fr[];
    ipaProof: Fr[];
}
interface MsgpackECCVMProof {
    pre_ipa_proof: Uint8Array[];
    ipa_proof: Uint8Array[];
}
export interface ErrorResponse {
    message: string;
}
interface MsgpackErrorResponse {
    message: string;
}
export interface GoblinProof {
    mergeProof: Fr[];
    eccvmProof: ECCVMProof;
    translatorProof: Fr[];
}
interface MsgpackGoblinProof {
    merge_proof: Uint8Array[];
    eccvm_proof: MsgpackECCVMProof;
    translator_proof: Uint8Array[];
}
export interface ProofSystemSettings {
    ipaAccumulation: boolean;
    oracleHashType: string;
    disableZk: boolean;
    optimizedSolidityVerifier: boolean;
}
interface MsgpackProofSystemSettings {
    ipa_accumulation: boolean;
    oracle_hash_type: string;
    disable_zk: boolean;
    optimized_solidity_verifier: boolean;
}
export interface VkAsFields {
    verificationKey: Uint8Array;
}
interface MsgpackVkAsFields {
    verification_key: Uint8Array;
}
export interface VkAsFieldsResponse {
    fields: Fr[];
}
interface MsgpackVkAsFieldsResponse {
    fields: Uint8Array[];
}
export interface Bn254FqSqrt {
    input: Fq;
}
interface MsgpackBn254FqSqrt {
    input: Uint8Array;
}
export interface Bn254FqSqrtResponse {
    isSquareRoot: boolean;
    value: Fq;
}
interface MsgpackBn254FqSqrtResponse {
    is_square_root: boolean;
    value: Uint8Array;
}
export interface Bn254FrSqrt {
    input: Fr;
}
interface MsgpackBn254FrSqrt {
    input: Uint8Array;
}
export interface Bn254FrSqrtResponse {
    isSquareRoot: boolean;
    value: Fr;
}
interface MsgpackBn254FrSqrtResponse {
    is_square_root: boolean;
    value: Uint8Array;
}
export interface Bn254G1FromCompressed {
    compressed: Uint8Array;
}
interface MsgpackBn254G1FromCompressed {
    compressed: Uint8Array;
}
export interface Bn254G1FromCompressedResponse {
    point: Bn254G1Point;
}
interface MsgpackBn254G1FromCompressedResponse {
    point: MsgpackBn254G1Point;
}
export interface Bn254G1IsOnCurve {
    point: Bn254G1Point;
}
interface MsgpackBn254G1IsOnCurve {
    point: MsgpackBn254G1Point;
}
export interface Bn254G1IsOnCurveResponse {
    isOnCurve: boolean;
}
interface MsgpackBn254G1IsOnCurveResponse {
    is_on_curve: boolean;
}
export interface Bn254G1Mul {
    point: Bn254G1Point;
    scalar: Fr;
}
interface MsgpackBn254G1Mul {
    point: MsgpackBn254G1Point;
    scalar: Uint8Array;
}
export interface Bn254G1MulResponse {
    point: Bn254G1Point;
}
interface MsgpackBn254G1MulResponse {
    point: MsgpackBn254G1Point;
}
export interface Bn254G1Point {
    x: Fq;
    y: Fq;
}
interface MsgpackBn254G1Point {
    x: Uint8Array;
    y: Uint8Array;
}
export interface Bn254G2Mul {
    point: Bn254G2Point;
    scalar: Fr;
}
interface MsgpackBn254G2Mul {
    point: MsgpackBn254G2Point;
    scalar: Uint8Array;
}
export interface Bn254G2MulResponse {
    point: Bn254G2Point;
}
interface MsgpackBn254G2MulResponse {
    point: MsgpackBn254G2Point;
}
export interface Bn254G2Point {
    x: Field2;
    y: Field2;
}
interface MsgpackBn254G2Point {
    x: [Uint8Array, Uint8Array];
    y: [Uint8Array, Uint8Array];
}
export interface CircuitComputeVk {
    circuit: CircuitInputNoVK;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitComputeVk {
    circuit: MsgpackCircuitInputNoVK;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitComputeVkResponse {
    bytes: Uint8Array;
    fields: Uint256T[];
    hash: Uint8Array;
}
interface MsgpackCircuitComputeVkResponse {
    bytes: Uint8Array;
    fields: Uint8Array[];
    hash: Uint8Array;
}
export interface CircuitInfoResponse {
    numGates: number;
    numGatesDyadic: number;
    numAcirOpcodes: number;
    gatesPerOpcode: number[];
}
interface MsgpackCircuitInfoResponse {
    num_gates: number;
    num_gates_dyadic: number;
    num_acir_opcodes: number;
    gates_per_opcode: number[];
}
export interface CircuitInput {
    name: string;
    bytecode: Uint8Array;
    verificationKey: Uint8Array;
}
interface MsgpackCircuitInput {
    name: string;
    bytecode: Uint8Array;
    verification_key: Uint8Array;
}
export interface CircuitInputNoVK {
    name: string;
    bytecode: Uint8Array;
}
interface MsgpackCircuitInputNoVK {
    name: string;
    bytecode: Uint8Array;
}
export interface CircuitProve {
    circuit: CircuitInput;
    witness: Uint8Array;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitProve {
    circuit: MsgpackCircuitInput;
    witness: Uint8Array;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitProveResponse {
    publicInputs: Uint256T[];
    proof: Uint256T[];
    vk: CircuitComputeVkResponse;
}
interface MsgpackCircuitProveResponse {
    public_inputs: Uint8Array[];
    proof: Uint8Array[];
    vk: MsgpackCircuitComputeVkResponse;
}
export interface CircuitStats {
    circuit: CircuitInput;
    includeGatesPerOpcode: boolean;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitStats {
    circuit: MsgpackCircuitInput;
    include_gates_per_opcode: boolean;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitVerify {
    verificationKey: Uint8Array;
    publicInputs: Uint256T[];
    proof: Uint256T[];
    settings: ProofSystemSettings;
}
interface MsgpackCircuitVerify {
    verification_key: Uint8Array;
    public_inputs: Uint8Array[];
    proof: Uint8Array[];
    settings: MsgpackProofSystemSettings;
}
export interface CircuitVerifyResponse {
    verified: boolean;
}
interface MsgpackCircuitVerifyResponse {
    verified: boolean;
}
export interface CircuitWriteSolidityVerifier {
    verificationKey: Uint8Array;
    settings: ProofSystemSettings;
}
interface MsgpackCircuitWriteSolidityVerifier {
    verification_key: Uint8Array;
    settings: MsgpackProofSystemSettings;
}
export interface CircuitWriteSolidityVerifierResponse {
    solidityCode: string;
}
interface MsgpackCircuitWriteSolidityVerifierResponse {
    solidity_code: string;
}
export interface ClientIvcAccumulate {
    witness: Uint8Array;
}
interface MsgpackClientIvcAccumulate {
    witness: Uint8Array;
}
export interface ClientIvcAccumulateResponse {
}
interface MsgpackClientIvcAccumulateResponse {
}
export interface ClientIvcCheckPrecomputedVk {
    circuit: CircuitInput;
}
interface MsgpackClientIvcCheckPrecomputedVk {
    circuit: MsgpackCircuitInput;
}
export interface ClientIvcCheckPrecomputedVkResponse {
    valid: boolean;
    actualVk: Uint8Array;
}
interface MsgpackClientIvcCheckPrecomputedVkResponse {
    valid: boolean;
    actual_vk: Uint8Array;
}
export interface ClientIvcComputeIvcVk {
    circuit: CircuitInputNoVK;
}
interface MsgpackClientIvcComputeIvcVk {
    circuit: MsgpackCircuitInputNoVK;
}
export interface ClientIvcComputeIvcVkResponse {
    bytes: Uint8Array;
}
interface MsgpackClientIvcComputeIvcVkResponse {
    bytes: Uint8Array;
}
export interface ClientIvcComputeStandaloneVk {
    circuit: CircuitInputNoVK;
}
interface MsgpackClientIvcComputeStandaloneVk {
    circuit: MsgpackCircuitInputNoVK;
}
export interface ClientIvcComputeStandaloneVkResponse {
    bytes: Uint8Array;
    fields: Fr[];
}
interface MsgpackClientIvcComputeStandaloneVkResponse {
    bytes: Uint8Array;
    fields: Uint8Array[];
}
export interface ClientIvcLoad {
    circuit: CircuitInput;
}
interface MsgpackClientIvcLoad {
    circuit: MsgpackCircuitInput;
}
export interface ClientIvcLoadResponse {
}
interface MsgpackClientIvcLoadResponse {
}
export interface ClientIVCProof {
    megaProof: Fr[];
    goblinProof: GoblinProof;
}
interface MsgpackClientIVCProof {
    mega_proof: Uint8Array[];
    goblin_proof: MsgpackGoblinProof;
}
export interface ClientIvcProve {
}
interface MsgpackClientIvcProve {
}
export interface ClientIvcProveResponse {
    proof: ClientIVCProof;
}
interface MsgpackClientIvcProveResponse {
    proof: MsgpackClientIVCProof;
}
export interface ClientIvcStart {
    numCircuits: number;
}
interface MsgpackClientIvcStart {
    num_circuits: number;
}
export interface ClientIvcStartResponse {
}
interface MsgpackClientIvcStartResponse {
}
export interface ClientIvcStats {
    circuit: CircuitInputNoVK;
    includeGatesPerOpcode: boolean;
}
interface MsgpackClientIvcStats {
    circuit: MsgpackCircuitInputNoVK;
    include_gates_per_opcode: boolean;
}
export interface ClientIvcStatsResponse {
    acirOpcodes: number;
    circuitSize: number;
    gatesPerOpcode: number[];
}
interface MsgpackClientIvcStatsResponse {
    acir_opcodes: number;
    circuit_size: number;
    gates_per_opcode: number[];
}
export interface ClientIvcVerify {
    proof: ClientIVCProof;
    vk: Uint8Array;
}
interface MsgpackClientIvcVerify {
    proof: MsgpackClientIVCProof;
    vk: Uint8Array;
}
export interface ClientIvcVerifyResponse {
    valid: boolean;
}
interface MsgpackClientIvcVerifyResponse {
    valid: boolean;
}
export interface ECCVMProof {
    preIpaProof: Fr[];
    ipaProof: Fr[];
}
interface MsgpackECCVMProof {
    pre_ipa_proof: Uint8Array[];
    ipa_proof: Uint8Array[];
}
export interface ErrorResponse {
    message: string;
}
interface MsgpackErrorResponse {
    message: string;
}
export interface GoblinProof {
    mergeProof: Fr[];
    eccvmProof: ECCVMProof;
    translatorProof: Fr[];
}
interface MsgpackGoblinProof {
    merge_proof: Uint8Array[];
    eccvm_proof: MsgpackECCVMProof;
    translator_proof: Uint8Array[];
}
export interface ProofSystemSettings {
    ipaAccumulation: boolean;
    oracleHashType: string;
    disableZk: boolean;
    optimizedSolidityVerifier: boolean;
}
interface MsgpackProofSystemSettings {
    ipa_accumulation: boolean;
    oracle_hash_type: string;
    disable_zk: boolean;
    optimized_solidity_verifier: boolean;
}
export interface VkAsFields {
    verificationKey: Uint8Array;
}
interface MsgpackVkAsFields {
    verification_key: Uint8Array;
}
export interface VkAsFieldsResponse {
    fields: Fr[];
}
interface MsgpackVkAsFieldsResponse {
    fields: Uint8Array[];
}
export declare function toBn254FqSqrt(o: MsgpackBn254FqSqrt): Bn254FqSqrt;
export declare function fromBn254FqSqrt(o: Bn254FqSqrt): MsgpackBn254FqSqrt;
export declare function toBn254FqSqrtResponse(o: MsgpackBn254FqSqrtResponse): Bn254FqSqrtResponse;
export declare function fromBn254FqSqrtResponse(o: Bn254FqSqrtResponse): MsgpackBn254FqSqrtResponse;
export declare function toBn254FrSqrt(o: MsgpackBn254FrSqrt): Bn254FrSqrt;
export declare function fromBn254FrSqrt(o: Bn254FrSqrt): MsgpackBn254FrSqrt;
export declare function toBn254FrSqrtResponse(o: MsgpackBn254FrSqrtResponse): Bn254FrSqrtResponse;
export declare function fromBn254FrSqrtResponse(o: Bn254FrSqrtResponse): MsgpackBn254FrSqrtResponse;
export declare function toBn254G1FromCompressed(o: MsgpackBn254G1FromCompressed): Bn254G1FromCompressed;
export declare function fromBn254G1FromCompressed(o: Bn254G1FromCompressed): MsgpackBn254G1FromCompressed;
export declare function toBn254G1FromCompressedResponse(o: MsgpackBn254G1FromCompressedResponse): Bn254G1FromCompressedResponse;
export declare function fromBn254G1FromCompressedResponse(o: Bn254G1FromCompressedResponse): MsgpackBn254G1FromCompressedResponse;
export declare function toBn254G1IsOnCurve(o: MsgpackBn254G1IsOnCurve): Bn254G1IsOnCurve;
export declare function fromBn254G1IsOnCurve(o: Bn254G1IsOnCurve): MsgpackBn254G1IsOnCurve;
export declare function toBn254G1IsOnCurveResponse(o: MsgpackBn254G1IsOnCurveResponse): Bn254G1IsOnCurveResponse;
export declare function fromBn254G1IsOnCurveResponse(o: Bn254G1IsOnCurveResponse): MsgpackBn254G1IsOnCurveResponse;
export declare function toBn254G1Mul(o: MsgpackBn254G1Mul): Bn254G1Mul;
export declare function fromBn254G1Mul(o: Bn254G1Mul): MsgpackBn254G1Mul;
export declare function toBn254G1MulResponse(o: MsgpackBn254G1MulResponse): Bn254G1MulResponse;
export declare function fromBn254G1MulResponse(o: Bn254G1MulResponse): MsgpackBn254G1MulResponse;
export declare function toBn254G1Point(o: MsgpackBn254G1Point): Bn254G1Point;
export declare function fromBn254G1Point(o: Bn254G1Point): MsgpackBn254G1Point;
export declare function toBn254G2Mul(o: MsgpackBn254G2Mul): Bn254G2Mul;
export declare function fromBn254G2Mul(o: Bn254G2Mul): MsgpackBn254G2Mul;
export declare function toBn254G2MulResponse(o: MsgpackBn254G2MulResponse): Bn254G2MulResponse;
export declare function fromBn254G2MulResponse(o: Bn254G2MulResponse): MsgpackBn254G2MulResponse;
export declare function toBn254G2Point(o: MsgpackBn254G2Point): Bn254G2Point;
export declare function fromBn254G2Point(o: Bn254G2Point): MsgpackBn254G2Point;
export declare function toCircuitComputeVk(o: MsgpackCircuitComputeVk): CircuitComputeVk;
export declare function fromCircuitComputeVk(o: CircuitComputeVk): MsgpackCircuitComputeVk;
export declare function toCircuitComputeVkResponse(o: MsgpackCircuitComputeVkResponse): CircuitComputeVkResponse;
export declare function fromCircuitComputeVkResponse(o: CircuitComputeVkResponse): MsgpackCircuitComputeVkResponse;
export declare function toCircuitInfoResponse(o: MsgpackCircuitInfoResponse): CircuitInfoResponse;
export declare function fromCircuitInfoResponse(o: CircuitInfoResponse): MsgpackCircuitInfoResponse;
export declare function toCircuitInput(o: MsgpackCircuitInput): CircuitInput;
export declare function fromCircuitInput(o: CircuitInput): MsgpackCircuitInput;
export declare function toCircuitInputNoVK(o: MsgpackCircuitInputNoVK): CircuitInputNoVK;
export declare function fromCircuitInputNoVK(o: CircuitInputNoVK): MsgpackCircuitInputNoVK;
export declare function toCircuitProve(o: MsgpackCircuitProve): CircuitProve;
export declare function fromCircuitProve(o: CircuitProve): MsgpackCircuitProve;
export declare function toCircuitProveResponse(o: MsgpackCircuitProveResponse): CircuitProveResponse;
export declare function fromCircuitProveResponse(o: CircuitProveResponse): MsgpackCircuitProveResponse;
export declare function toCircuitStats(o: MsgpackCircuitStats): CircuitStats;
export declare function fromCircuitStats(o: CircuitStats): MsgpackCircuitStats;
export declare function toCircuitVerify(o: MsgpackCircuitVerify): CircuitVerify;
export declare function fromCircuitVerify(o: CircuitVerify): MsgpackCircuitVerify;
export declare function toCircuitVerifyResponse(o: MsgpackCircuitVerifyResponse): CircuitVerifyResponse;
export declare function fromCircuitVerifyResponse(o: CircuitVerifyResponse): MsgpackCircuitVerifyResponse;
export declare function toCircuitWriteSolidityVerifier(o: MsgpackCircuitWriteSolidityVerifier): CircuitWriteSolidityVerifier;
export declare function fromCircuitWriteSolidityVerifier(o: CircuitWriteSolidityVerifier): MsgpackCircuitWriteSolidityVerifier;
export declare function toCircuitWriteSolidityVerifierResponse(o: MsgpackCircuitWriteSolidityVerifierResponse): CircuitWriteSolidityVerifierResponse;
export declare function fromCircuitWriteSolidityVerifierResponse(o: CircuitWriteSolidityVerifierResponse): MsgpackCircuitWriteSolidityVerifierResponse;
export declare function toClientIvcAccumulate(o: MsgpackClientIvcAccumulate): ClientIvcAccumulate;
export declare function fromClientIvcAccumulate(o: ClientIvcAccumulate): MsgpackClientIvcAccumulate;
export declare function toClientIvcAccumulateResponse(o: MsgpackClientIvcAccumulateResponse): ClientIvcAccumulateResponse;
export declare function fromClientIvcAccumulateResponse(o: ClientIvcAccumulateResponse): MsgpackClientIvcAccumulateResponse;
export declare function toClientIvcCheckPrecomputedVk(o: MsgpackClientIvcCheckPrecomputedVk): ClientIvcCheckPrecomputedVk;
export declare function fromClientIvcCheckPrecomputedVk(o: ClientIvcCheckPrecomputedVk): MsgpackClientIvcCheckPrecomputedVk;
export declare function toClientIvcCheckPrecomputedVkResponse(o: MsgpackClientIvcCheckPrecomputedVkResponse): ClientIvcCheckPrecomputedVkResponse;
export declare function fromClientIvcCheckPrecomputedVkResponse(o: ClientIvcCheckPrecomputedVkResponse): MsgpackClientIvcCheckPrecomputedVkResponse;
export declare function toClientIvcComputeIvcVk(o: MsgpackClientIvcComputeIvcVk): ClientIvcComputeIvcVk;
export declare function fromClientIvcComputeIvcVk(o: ClientIvcComputeIvcVk): MsgpackClientIvcComputeIvcVk;
export declare function toClientIvcComputeIvcVkResponse(o: MsgpackClientIvcComputeIvcVkResponse): ClientIvcComputeIvcVkResponse;
export declare function fromClientIvcComputeIvcVkResponse(o: ClientIvcComputeIvcVkResponse): MsgpackClientIvcComputeIvcVkResponse;
export declare function toClientIvcComputeStandaloneVk(o: MsgpackClientIvcComputeStandaloneVk): ClientIvcComputeStandaloneVk;
export declare function fromClientIvcComputeStandaloneVk(o: ClientIvcComputeStandaloneVk): MsgpackClientIvcComputeStandaloneVk;
export declare function toClientIvcComputeStandaloneVkResponse(o: MsgpackClientIvcComputeStandaloneVkResponse): ClientIvcComputeStandaloneVkResponse;
export declare function fromClientIvcComputeStandaloneVkResponse(o: ClientIvcComputeStandaloneVkResponse): MsgpackClientIvcComputeStandaloneVkResponse;
export declare function toClientIvcLoad(o: MsgpackClientIvcLoad): ClientIvcLoad;
export declare function fromClientIvcLoad(o: ClientIvcLoad): MsgpackClientIvcLoad;
export declare function toClientIvcLoadResponse(o: MsgpackClientIvcLoadResponse): ClientIvcLoadResponse;
export declare function fromClientIvcLoadResponse(o: ClientIvcLoadResponse): MsgpackClientIvcLoadResponse;
export declare function toClientIVCProof(o: MsgpackClientIVCProof): ClientIVCProof;
export declare function fromClientIVCProof(o: ClientIVCProof): MsgpackClientIVCProof;
export declare function toClientIvcProve(o: MsgpackClientIvcProve): ClientIvcProve;
export declare function fromClientIvcProve(o: ClientIvcProve): MsgpackClientIvcProve;
export declare function toClientIvcProveResponse(o: MsgpackClientIvcProveResponse): ClientIvcProveResponse;
export declare function fromClientIvcProveResponse(o: ClientIvcProveResponse): MsgpackClientIvcProveResponse;
export declare function toClientIvcStart(o: MsgpackClientIvcStart): ClientIvcStart;
export declare function fromClientIvcStart(o: ClientIvcStart): MsgpackClientIvcStart;
export declare function toClientIvcStartResponse(o: MsgpackClientIvcStartResponse): ClientIvcStartResponse;
export declare function fromClientIvcStartResponse(o: ClientIvcStartResponse): MsgpackClientIvcStartResponse;
export declare function toClientIvcStats(o: MsgpackClientIvcStats): ClientIvcStats;
export declare function fromClientIvcStats(o: ClientIvcStats): MsgpackClientIvcStats;
export declare function toClientIvcStatsResponse(o: MsgpackClientIvcStatsResponse): ClientIvcStatsResponse;
export declare function fromClientIvcStatsResponse(o: ClientIvcStatsResponse): MsgpackClientIvcStatsResponse;
export declare function toClientIvcVerify(o: MsgpackClientIvcVerify): ClientIvcVerify;
export declare function fromClientIvcVerify(o: ClientIvcVerify): MsgpackClientIvcVerify;
export declare function toClientIvcVerifyResponse(o: MsgpackClientIvcVerifyResponse): ClientIvcVerifyResponse;
export declare function fromClientIvcVerifyResponse(o: ClientIvcVerifyResponse): MsgpackClientIvcVerifyResponse;
export declare function toECCVMProof(o: MsgpackECCVMProof): ECCVMProof;
export declare function fromECCVMProof(o: ECCVMProof): MsgpackECCVMProof;
export declare function toErrorResponse(o: MsgpackErrorResponse): ErrorResponse;
export declare function fromErrorResponse(o: ErrorResponse): MsgpackErrorResponse;
export declare function toGoblinProof(o: MsgpackGoblinProof): GoblinProof;
export declare function fromGoblinProof(o: GoblinProof): MsgpackGoblinProof;
export declare function toProofSystemSettings(o: MsgpackProofSystemSettings): ProofSystemSettings;
export declare function fromProofSystemSettings(o: ProofSystemSettings): MsgpackProofSystemSettings;
export declare function toVkAsFields(o: MsgpackVkAsFields): VkAsFields;
export declare function fromVkAsFields(o: VkAsFields): MsgpackVkAsFields;
export declare function toVkAsFieldsResponse(o: MsgpackVkAsFieldsResponse): VkAsFieldsResponse;
export declare function fromVkAsFieldsResponse(o: VkAsFieldsResponse): MsgpackVkAsFieldsResponse;
export interface BbApiBase {
    circuitProve(command: CircuitProve): Promise<CircuitProveResponse>;
    circuitComputeVk(command: CircuitComputeVk): Promise<CircuitComputeVkResponse>;
    circuitStats(command: CircuitStats): Promise<CircuitInfoResponse>;
    circuitVerify(command: CircuitVerify): Promise<CircuitVerifyResponse>;
    clientIvcComputeStandaloneVk(command: ClientIvcComputeStandaloneVk): Promise<ClientIvcComputeStandaloneVkResponse>;
    clientIvcComputeIvcVk(command: ClientIvcComputeIvcVk): Promise<ClientIvcComputeIvcVkResponse>;
    clientIvcStart(command: ClientIvcStart): Promise<ClientIvcStartResponse>;
    clientIvcLoad(command: ClientIvcLoad): Promise<ClientIvcLoadResponse>;
    clientIvcAccumulate(command: ClientIvcAccumulate): Promise<ClientIvcAccumulateResponse>;
    clientIvcProve(command: ClientIvcProve): Promise<ClientIvcProveResponse>;
    clientIvcVerify(command: ClientIvcVerify): Promise<ClientIvcVerifyResponse>;
    vkAsFields(command: VkAsFields): Promise<VkAsFieldsResponse>;
    circuitWriteSolidityVerifier(command: CircuitWriteSolidityVerifier): Promise<CircuitWriteSolidityVerifierResponse>;
    clientIvcCheckPrecomputedVk(command: ClientIvcCheckPrecomputedVk): Promise<ClientIvcCheckPrecomputedVkResponse>;
    clientIvcStats(command: ClientIvcStats): Promise<ClientIvcStatsResponse>;
    bn254FrSqrt(command: Bn254FrSqrt): Promise<Bn254FrSqrtResponse>;
    bn254FqSqrt(command: Bn254FqSqrt): Promise<Bn254FqSqrtResponse>;
    bn254G1Mul(command: Bn254G1Mul): Promise<Bn254G1MulResponse>;
    bn254G2Mul(command: Bn254G2Mul): Promise<Bn254G2MulResponse>;
    bn254G1IsOnCurve(command: Bn254G1IsOnCurve): Promise<Bn254G1IsOnCurveResponse>;
    bn254G1FromCompressed(command: Bn254G1FromCompressed): Promise<Bn254G1FromCompressedResponse>;
    destroy(): Promise<void>;
}
export {};
//# sourceMappingURL=api_types.d.ts.map