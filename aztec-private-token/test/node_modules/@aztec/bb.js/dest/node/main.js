#!/usr/bin/env node
import 'source-map-support/register.js';
// NOTE(backport) in next we will delete this entirely
// import { Crs, Barretenberg, RawBuffer } from './index.js';
// import { createDebugLogger, initLogger } from './log/index.js';
// import { readFileSync, writeFileSync } from 'fs';
// import { gunzipSync } from 'zlib';
// import { Command } from 'commander';
// import { UltraHonkBackendOptions } from './barretenberg/backend.js';
// let debug: (msg: string) => void;
// const threads = +process.env.HARDWARE_CONCURRENCY! || undefined;
// function getBytecode(bytecodePath: string): Uint8Array {
//   const extension = bytecodePath.substring(bytecodePath.lastIndexOf('.') + 1);
//   if (extension == 'json') {
//     const encodedCircuit = JSON.parse(readFileSync(bytecodePath, 'utf8'));
//     const decompressed = gunzipSync(Buffer.from(encodedCircuit.bytecode, 'base64'));
//     return Uint8Array.from(decompressed);
//   }
//   const encodedCircuit = readFileSync(bytecodePath);
//   const decompressed = gunzipSync(encodedCircuit);
//   return Uint8Array.from(decompressed);
// }
// // TODO(https://github.com/AztecProtocol/barretenberg/issues/1126): split this into separate Plonk and Honk functions as their gate count differs
// async function getGatesUltra(bytecodePath: string, recursive: boolean, honkRecursion: boolean, api: Barretenberg) {
//   const { total } = await computeCircuitSize(bytecodePath, recursive, honkRecursion, api);
//   return total;
// }
// function getWitness(witnessPath: string): Uint8Array {
//   const data = readFileSync(witnessPath);
//   const decompressed = gunzipSync(data);
//   return Uint8Array.from(decompressed);
// }
// async function computeCircuitSize(bytecodePath: string, recursive: boolean, honkRecursion: boolean, api: Barretenberg) {
//   debug(`Computing circuit size for ${bytecodePath}`);
//   const bytecode = getBytecode(bytecodePath);
//   const [total, subgroup] = await api.acirGetCircuitSizes(bytecode, recursive, honkRecursion);
//   return { total, subgroup };
// }
// async function initUltraHonk(bytecodePath: string, crsPath: string) {
//   const api = await Barretenberg.new({
//     threads,
//   });
//   // TODO(https://github.com/AztecProtocol/barretenberg/issues/1248): Get rid of this call to avoid building the circuit twice.
//   // TODO(https://github.com/AztecProtocol/barretenberg/issues/1126): use specific UltraHonk function
//   // recursive here is useless for UH, as it does not affect anything
//   const circuitSize = await getGatesUltra(bytecodePath, /*recursive=*/ false, /*honkRecursion=*/ true, api);
//   // TODO(https://github.com/AztecProtocol/barretenberg/issues/811): remove subgroupSizeOverride hack for goblin
//   const dyadicCircuitSize = Math.pow(2, Math.ceil(Math.log2(circuitSize)));
//   debug(`Loading CRS for UltraHonk with circuit-size=${circuitSize} dyadic-circuit-size=${dyadicCircuitSize}`);
//   const crs = await Crs.new(dyadicCircuitSize + 1, crsPath);
//   // Load CRS into wasm global CRS state.
//   // TODO: Make RawBuffer be default behavior, and have a specific Vector type for when wanting length prefixed.
//   await api.srsInitSrs(new RawBuffer(crs.getG1Data()), crs.numPoints, new RawBuffer(crs.getG2Data()));
//   return { api, circuitSize, dyadicCircuitSize };
// }
// async function initLite(crsPath: string) {
//   const api = await Barretenberg.new({ threads: 1 });
//   // Plus 1 needed! (Move +1 into Crs?)
//   const crs = await Crs.new(1, crsPath);
//   // Load CRS into wasm global CRS state.
//   await api.srsInitSrs(new RawBuffer(crs.getG1Data()), crs.numPoints, new RawBuffer(crs.getG2Data()));
//   return { api };
// }
// export async function proveAndVerifyUltraHonk(bytecodePath: string, witnessPath: string, crsPath: string) {
//   /* eslint-disable camelcase */
//   const { api } = await initUltraHonk(bytecodePath, crsPath);
//   try {
//     const bytecode = getBytecode(bytecodePath);
//     const witness = getWitness(witnessPath);
//     const verified = await api.acirProveAndVerifyUltraHonk(bytecode, witness);
//     return verified;
//   } finally {
//     await api.destroy();
//   }
//   /* eslint-enable camelcase */
// }
// export async function proveAndVerifyMegaHonk(bytecodePath: string, witnessPath: string, crsPath: string) {
//   /* eslint-disable camelcase */
//   const { api } = await initUltraHonk(bytecodePath, crsPath);
//   try {
//     const bytecode = getBytecode(bytecodePath);
//     const witness = getWitness(witnessPath);
//     const verified = await api.acirProveAndVerifyMegaHonk(bytecode, witness);
//     return verified;
//   } finally {
//     await api.destroy();
//   }
//   /* eslint-enable camelcase */
// }
// export async function gateCountUltra(bytecodePath: string, recursive: boolean, honkRecursion: boolean) {
//   const api = await Barretenberg.new({ threads: 1 });
//   try {
//     const numberOfGates = await getGatesUltra(bytecodePath, recursive, honkRecursion, api);
//     debug(`Number of gates: ${numberOfGates}`);
//     // Create an 8-byte buffer and write the number into it.
//     // Writing number directly to stdout will result in a variable sized
//     // input depending on the size.
//     const buffer = Buffer.alloc(8);
//     buffer.writeBigInt64LE(BigInt(numberOfGates));
//     process.stdout.write(Uint8Array.from(buffer));
//   } finally {
//     await api.destroy();
//   }
// }
// export async function contractUltraHonk(bytecodePath: string, vkPath: string, crsPath: string, outputPath: string) {
//   const { api } = await initUltraHonk(bytecodePath, crsPath);
//   try {
//     debug(`Creating UltraHonk verifier contract bytecode=${bytecodePath} vk=${vkPath}`);
//     const bytecode = getBytecode(bytecodePath);
//     const vk = new RawBuffer(readFileSync(vkPath));
//     const contract = await api.acirHonkSolidityVerifier(bytecode, vk);
//     if (outputPath === '-') {
//       process.stdout.write(contract);
//       debug(`Solidity verifier contract written to stdout`);
//     } else {
//       writeFileSync(outputPath, contract);
//       debug(`Solidity verifier contract written to ${outputPath}`);
//     }
//   } finally {
//     await api.destroy();
//   }
// }
// export async function proveUltraHonk(
//   bytecodePath: string,
//   witnessPath: string,
//   crsPath: string,
//   vkPath: string,
//   outputPath: string,
//   options?: UltraHonkBackendOptions,
// ) {
//   const { api } = await initUltraHonk(bytecodePath, crsPath);
//   try {
//     debug(`Creating UltraHonk proof bytecode=${bytecodePath}`);
//     const bytecode = getBytecode(bytecodePath);
//     const witness = getWitness(witnessPath);
//     const acirProveUltraHonk = options?.keccak
//       ? api.acirProveUltraKeccakHonk.bind(api)
//       : options?.keccakZK
//         ? api.acirProveUltraKeccakZkHonk.bind(api)
//         : options?.starknet
//           ? api.acirProveUltraStarknetHonk.bind(api)
//           : options?.starknetZK
//             ? api.acirProveUltraStarknetZkHonk.bind(api)
//             : api.acirProveUltraZKHonk.bind(api);
//     const proof = await acirProveUltraHonk(bytecode, witness, new RawBuffer(readFileSync(vkPath)));
//     if (outputPath === '-') {
//       process.stdout.write(proof);
//       debug(`Proof written to stdout`);
//     } else {
//       writeFileSync(outputPath, proof);
//       debug(`Proof written to ${outputPath}`);
//     }
//   } finally {
//     await api.destroy();
//   }
// }
// export async function writeVkUltraHonk(
//   bytecodePath: string,
//   crsPath: string,
//   outputPath: string,
//   options?: UltraHonkBackendOptions,
// ) {
//   const { api } = await initUltraHonk(bytecodePath, crsPath);
//   try {
//     const bytecode = getBytecode(bytecodePath);
//     debug(`Initializing UltraHonk verification key bytecode=${bytecodePath}`);
//     const acirWriteVkUltraHonk = options?.keccak
//       ? api.acirWriteVkUltraKeccakHonk.bind(api)
//       : options?.keccakZK
//         ? api.acirWriteVkUltraKeccakZkHonk.bind(api)
//         : options?.starknet
//           ? api.acirWriteVkUltraStarknetHonk.bind(api)
//           : options?.starknetZK
//             ? api.acirWriteVkUltraStarknetZkHonk.bind(api)
//             : api.acirWriteVkUltraHonk.bind(api);
//     const vk = await acirWriteVkUltraHonk(bytecode);
//     if (outputPath === '-') {
//       process.stdout.write(vk);
//       debug(`Verification key written to stdout`);
//     } else {
//       writeFileSync(outputPath, vk);
//       debug(`Verification key written to ${outputPath}`);
//     }
//   } finally {
//     await api.destroy();
//   }
// }
// export async function verifyUltraHonk(
//   proofPath: string,
//   vkPath: string,
//   crsPath: string,
//   options?: UltraHonkBackendOptions,
// ) {
//   const { api } = await initLite(crsPath);
//   try {
//     const acirVerifyUltraHonk = options?.keccak
//       ? api.acirVerifyUltraKeccakHonk.bind(api)
//       : options?.keccakZK
//         ? api.acirVerifyUltraKeccakZkHonk.bind(api)
//         : options?.starknet
//           ? api.acirVerifyUltraStarknetHonk.bind(api)
//           : options?.starknetZK
//             ? api.acirVerifyUltraStarknetZkHonk.bind(api)
//             : api.acirVerifyUltraZKHonk.bind(api);
//     const verified = await acirVerifyUltraHonk(
//       Uint8Array.from(readFileSync(proofPath)),
//       new RawBuffer(readFileSync(vkPath)),
//     );
//     debug(`Verification ${verified ? 'successful' : 'failed'}`);
//     return verified;
//   } finally {
//     await api.destroy();
//   }
// }
// export async function proofAsFieldsUltraHonk(proofPath: string, outputPath: string, crsPath: string) {
//   const { api } = await initLite(crsPath);
//   try {
//     debug(`Outputting UltraHonk proof as vector of fields proof=${proofPath}`);
//     const proofAsFields = await api.acirProofAsFieldsUltraHonk(Uint8Array.from(readFileSync(proofPath)));
//     const jsonProofAsFields = JSON.stringify(proofAsFields.map(f => f.toString()));
//     if (outputPath === '-') {
//       process.stdout.write(jsonProofAsFields);
//       debug(`Proof as fields written to stdout`);
//     } else {
//       writeFileSync(outputPath, jsonProofAsFields);
//       debug(`Proof as fields written to ${outputPath}`);
//     }
//   } finally {
//     await api.destroy();
//   }
// }
// export async function vkAsFieldsUltraHonk(vkPath: string, vkeyOutputPath: string, crsPath: string) {
//   const { api } = await initLite(crsPath);
//   try {
//     debug(`Serializing vk byte array into field elements vk=${vkPath}`);
//     const vkAsFields = await api.acirVkAsFieldsUltraHonk(new RawBuffer(readFileSync(vkPath)));
//     const jsonVKAsFields = JSON.stringify(vkAsFields.map(f => f.toString()));
//     if (vkeyOutputPath === '-') {
//       process.stdout.write(jsonVKAsFields);
//       debug(`Verification key as fields written to stdout`);
//     } else {
//       writeFileSync(vkeyOutputPath, jsonVKAsFields);
//       debug(`Verification key as fields written to ${vkeyOutputPath}`);
//     }
//   } finally {
//     await api.destroy();
//   }
// }
// const program = new Command('bb');
// program.option('-v, --verbose', 'enable verbose logging', false);
// program.option('-c, --crs-path <path>', 'set crs path', './crs');
// function handleGlobalOptions() {
//   initLogger({ useStdErr: true, level: program.opts().verbose ? 'debug' : 'info' });
//   debug = createDebugLogger('bb');
//   return { crsPath: program.opts().crsPath };
// }
// const deprecatedCommandError = () => async () => {
//   console.error(
//     `Error: UltraPlonk is now deprecated (see https://github.com/AztecProtocol/barretenberg/issues/1377). Use UltraHonk!`,
//   );
//   process.exit(1);
// };
// program
//   .command('prove_and_verify')
//   .description('Generate a proof and verify it. Process exits with success or failure code. [DEPRECATED]')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-r, --recursive', 'Whether to use a SNARK friendly proof', false)
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .action(deprecatedCommandError());
// program
//   .command('prove_and_verify_ultra_honk')
//   .description('Generate an UltraHonk proof and verify it. Process exits with success or failure code.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .action(async ({ bytecodePath, witnessPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     const result = await proveAndVerifyUltraHonk(bytecodePath, witnessPath, crsPath);
//     process.exit(result ? 0 : 1);
//   });
// program
//   .command('prove_and_verify_mega_honk')
//   .description('Generate a MegaHonk proof and verify it. Process exits with success or failure code.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .action(async ({ bytecodePath, witnessPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     const result = await proveAndVerifyMegaHonk(bytecodePath, witnessPath, crsPath);
//     process.exit(result ? 0 : 1);
//   });
// program
//   .command('prove')
//   .description('Generate a proof and write it to a file. [DEPRECATED]')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-r, --recursive', 'Create a SNARK friendly proof', false)
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .option('-o, --output-path <path>', 'Specify the proof output path', './proofs/proof')
//   .action(deprecatedCommandError());
// program
//   .command('gates')
//   .description('Print Ultra Builder gate count to standard output.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-r, --recursive', 'Create a SNARK friendly proof', false)
//   .option('-hr, --honk-recursion', 'Specify whether to use UltraHonk recursion', false)
//   .action(async ({ bytecodePath, recursive, honkRecursion: honkRecursion }) => {
//     handleGlobalOptions();
//     await gateCountUltra(bytecodePath, recursive, honkRecursion);
//   });
// program
//   .command('verify')
//   .description('Verify a proof. Process exists with success or failure code. [DEPRECATED]')
//   .requiredOption('-p, --proof-path <path>', 'Specify the path to the proof')
//   .requiredOption('-k, --vk <path>', 'path to a verification key. avoids recomputation.')
//   .action(deprecatedCommandError());
// program
//   .command('contract')
//   .description('Output solidity verification key contract. [DEPRECATED]')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-o, --output-path <path>', 'Specify the path to write the contract', './target/contract.sol')
//   .requiredOption('-k, --vk-path <path>', 'Path to a verification key. avoids recomputation.')
//   .action(deprecatedCommandError());
// program
//   .command('contract_ultra_honk')
//   .description('Output solidity verification key contract.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-o, --output-path <path>', 'Specify the path to write the contract', './target/contract.sol')
//   .requiredOption('-k, --vk-path <path>', 'Path to a verification key.')
//   .action(async ({ bytecodePath, outputPath, vkPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await contractUltraHonk(bytecodePath, vkPath, crsPath, outputPath);
//   });
// program
//   .command('write_vk')
//   .description('Output verification key. [DEPRECATED]')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-r, --recursive', 'Create a SNARK friendly proof', false)
//   .option('-o, --output-path <path>', 'Specify the path to write the key')
//   .action(deprecatedCommandError());
// program
//   .command('write_pk')
//   .description('Output proving key. [DEPRECATED]')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-r, --recursive', 'Create a SNARK friendly proof', false)
//   .requiredOption('-o, --output-path <path>', 'Specify the path to write the key')
//   .action(deprecatedCommandError());
// program
//   .command('proof_as_fields')
//   .description('Return the proof as fields elements. [DEPRECATED]')
//   .requiredOption('-p, --proof-path <path>', 'Specify the proof path')
//   .requiredOption('-k, --vk-path <path>', 'Path to verification key.')
//   .requiredOption('-o, --output-path <path>', 'Specify the JSON path to write the proof fields')
//   .action(deprecatedCommandError());
// program
//   .command('vk_as_fields')
//   .description(
//     'Return the verification key represented as fields elements. Also return the verification key hash. [DEPRECATED]',
//   )
//   .requiredOption('-k, --vk-path <path>', 'Path to verification key.')
//   .requiredOption('-o, --output-path <path>', 'Specify the JSON path to write the verification key fields and key hash')
//   .action(deprecatedCommandError());
// program
//   .command('prove_ultra_honk')
//   .description('Generate a proof and write it to a file.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .option('-k, --vk-path <path>', 'path to a verification key. avoids recomputation.')
//   .option('-o, --output-path <path>', 'Specify the proof output path', './proofs/proof')
//   .action(async ({ bytecodePath, witnessPath, vkPath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     debug(`Creating UltraHonk proof bytecodePath=${bytecodePath}, witnessPath=${witnessPath}, vkPath=${vkPath}`);
//     await proveUltraHonk(bytecodePath, witnessPath, crsPath, vkPath, outputPath);
//   });
// program
//   .command('prove_ultra_keccak_honk')
//   .description('Generate a proof and write it to a file.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .option('-k, --vk-path <path>', 'path to a verification key. avoids recomputation.')
//   .option('-o, --output-path <path>', 'Specify the proof output path', './proofs/proof')
//   .action(async ({ bytecodePath, witnessPath, vkPath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await proveUltraHonk(bytecodePath, witnessPath, crsPath, vkPath, outputPath, { keccak: true });
//   });
// program
//   .command('prove_ultra_starknet_honk')
//   .description('Generate a proof and write it to a file.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .option('-k, --vk-path <path>', 'path to a verification key. avoids recomputation.')
//   .option('-o, --output-path <path>', 'Specify the proof output path', './proofs/proof')
//   .action(async ({ bytecodePath, witnessPath, vkPath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await proveUltraHonk(bytecodePath, witnessPath, crsPath, vkPath, outputPath, { starknet: true });
//   });
// program
//   .command('write_vk_ultra_honk')
//   .description('Output verification key.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .requiredOption('-o, --output-path <path>', 'Specify the path to write the key')
//   .action(async ({ bytecodePath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     debug(`Writing verification key to ${outputPath}`);
//     await writeVkUltraHonk(bytecodePath, crsPath, outputPath);
//   });
// program
//   .command('write_vk_ultra_keccak_honk')
//   .description('Output verification key.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .requiredOption('-o, --output-path <path>', 'Specify the path to write the key')
//   .action(async ({ bytecodePath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await writeVkUltraHonk(bytecodePath, crsPath, outputPath, { keccak: true });
//   });
// program
//   .command('write_vk_ultra_starknet_honk')
//   .description('Output verification key.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .requiredOption('-o, --output-path <path>', 'Specify the path to write the key')
//   .action(async ({ bytecodePath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await writeVkUltraHonk(bytecodePath, crsPath, outputPath, { starknet: true });
//   });
// program
//   .command('verify_ultra_honk')
//   .description('Verify a proof. Process exists with success or failure code.')
//   .requiredOption('-p, --proof-path <path>', 'Specify the path to the proof')
//   .requiredOption('-k, --vk-path <path>', 'path to a verification key. avoids recomputation.')
//   .action(async ({ proofPath, vkPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     const result = await verifyUltraHonk(proofPath, vkPath, crsPath);
//     process.exit(result ? 0 : 1);
//   });
// program
//   .command('verify_ultra_keccak_honk')
//   .description('Verify a proof. Process exists with success or failure code.')
//   .requiredOption('-p, --proof-path <path>', 'Specify the path to the proof')
//   .requiredOption('-k, --vk-path <path>', 'path to a verification key. avoids recomputation.')
//   .action(async ({ proofPath, vkPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     const result = await verifyUltraHonk(proofPath, vkPath, crsPath, { keccak: true });
//     process.exit(result ? 0 : 1);
//   });
// program
//   .command('verify_ultra_starknet_honk')
//   .description('Verify a proof. Process exists with success or failure code.')
//   .requiredOption('-p, --proof-path <path>', 'Specify the path to the proof')
//   .requiredOption('-k, --vk <path>', 'path to a verification key. avoids recomputation.')
//   .action(async ({ proofPath, vk }) => {
//     const { crsPath } = handleGlobalOptions();
//     const result = await verifyUltraHonk(proofPath, vk, crsPath, { starknet: true });
//     process.exit(result ? 0 : 1);
//   });
// program
//   .command('proof_as_fields_honk')
//   .description('Return the proof as fields elements')
//   .requiredOption('-p, --proof-path <path>', 'Specify the proof path')
//   .requiredOption('-o, --output-path <path>', 'Specify the JSON path to write the proof fields')
//   .action(async ({ proofPath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await proofAsFieldsUltraHonk(proofPath, outputPath, crsPath);
//   });
// program
//   .command('vk_as_fields_ultra_honk')
//   .description('Return the verification key represented as fields elements.')
//   .requiredOption('-k, --vk-path <path>', 'Path to verification key.')
//   .requiredOption('-o, --output-path <path>', 'Specify the JSON path to write the verification key fields.')
//   .action(async ({ vkPath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await vkAsFieldsUltraHonk(vkPath, outputPath, crsPath);
//   });
// program.name('bb.js').parse(process.argv);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7QUFDQSxPQUFPLGdDQUFnQyxDQUFDO0FBQ3hDLHNEQUFzRDtBQUN0RCw2REFBNkQ7QUFDN0Qsa0VBQWtFO0FBQ2xFLG9EQUFvRDtBQUNwRCxxQ0FBcUM7QUFDckMsdUNBQXVDO0FBQ3ZDLHVFQUF1RTtBQUV2RSxvQ0FBb0M7QUFFcEMsbUVBQW1FO0FBRW5FLDJEQUEyRDtBQUMzRCxpRkFBaUY7QUFFakYsK0JBQStCO0FBQy9CLDZFQUE2RTtBQUM3RSx1RkFBdUY7QUFDdkYsNENBQTRDO0FBQzVDLE1BQU07QUFFTix1REFBdUQ7QUFDdkQscURBQXFEO0FBQ3JELDBDQUEwQztBQUMxQyxJQUFJO0FBRUosb0pBQW9KO0FBQ3BKLHNIQUFzSDtBQUN0SCw2RkFBNkY7QUFDN0Ysa0JBQWtCO0FBQ2xCLElBQUk7QUFFSix5REFBeUQ7QUFDekQsNENBQTRDO0FBQzVDLDJDQUEyQztBQUMzQywwQ0FBMEM7QUFDMUMsSUFBSTtBQUVKLDJIQUEySDtBQUMzSCx5REFBeUQ7QUFDekQsZ0RBQWdEO0FBQ2hELGlHQUFpRztBQUNqRyxnQ0FBZ0M7QUFDaEMsSUFBSTtBQUVKLHdFQUF3RTtBQUN4RSx5Q0FBeUM7QUFDekMsZUFBZTtBQUNmLFFBQVE7QUFFUixrSUFBa0k7QUFDbEksd0dBQXdHO0FBQ3hHLHdFQUF3RTtBQUN4RSwrR0FBK0c7QUFDL0csbUhBQW1IO0FBQ25ILDhFQUE4RTtBQUU5RSxrSEFBa0g7QUFDbEgsK0RBQStEO0FBRS9ELDRDQUE0QztBQUM1QyxtSEFBbUg7QUFDbkgseUdBQXlHO0FBQ3pHLG9EQUFvRDtBQUNwRCxJQUFJO0FBRUosNkNBQTZDO0FBQzdDLHdEQUF3RDtBQUV4RCwwQ0FBMEM7QUFDMUMsMkNBQTJDO0FBRTNDLDRDQUE0QztBQUM1Qyx5R0FBeUc7QUFFekcsb0JBQW9CO0FBQ3BCLElBQUk7QUFFSiw4R0FB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