#!/usr/bin/env node
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
require("source-map-support/register.js");
// NOTE(backport) in next we will delete this entirely
// import { Crs, Barretenberg, RawBuffer } from './index.js';
// import { createDebugLogger, initLogger } from './log/index.js';
// import { readFileSync, writeFileSync } from 'fs';
// import { gunzipSync } from 'zlib';
// import { Command } from 'commander';
// import { UltraHonkBackendOptions } from './barretenberg/backend.js';
// let debug: (msg: string) => void;
// const threads = +process.env.HARDWARE_CONCURRENCY! || undefined;
// function getBytecode(bytecodePath: string): Uint8Array {
//   const extension = bytecodePath.substring(bytecodePath.lastIndexOf('.') + 1);
//   if (extension == 'json') {
//     const encodedCircuit = JSON.parse(readFileSync(bytecodePath, 'utf8'));
//     const decompressed = gunzipSync(Buffer.from(encodedCircuit.bytecode, 'base64'));
//     return Uint8Array.from(decompressed);
//   }
//   const encodedCircuit = readFileSync(bytecodePath);
//   const decompressed = gunzipSync(encodedCircuit);
//   return Uint8Array.from(decompressed);
// }
// // TODO(https://github.com/AztecProtocol/barretenberg/issues/1126): split this into separate Plonk and Honk functions as their gate count differs
// async function getGatesUltra(bytecodePath: string, recursive: boolean, honkRecursion: boolean, api: Barretenberg) {
//   const { total } = await computeCircuitSize(bytecodePath, recursive, honkRecursion, api);
//   return total;
// }
// function getWitness(witnessPath: string): Uint8Array {
//   const data = readFileSync(witnessPath);
//   const decompressed = gunzipSync(data);
//   return Uint8Array.from(decompressed);
// }
// async function computeCircuitSize(bytecodePath: string, recursive: boolean, honkRecursion: boolean, api: Barretenberg) {
//   debug(`Computing circuit size for ${bytecodePath}`);
//   const bytecode = getBytecode(bytecodePath);
//   const [total, subgroup] = await api.acirGetCircuitSizes(bytecode, recursive, honkRecursion);
//   return { total, subgroup };
// }
// async function initUltraHonk(bytecodePath: string, crsPath: string) {
//   const api = await Barretenberg.new({
//     threads,
//   });
//   // TODO(https://github.com/AztecProtocol/barretenberg/issues/1248): Get rid of this call to avoid building the circuit twice.
//   // TODO(https://github.com/AztecProtocol/barretenberg/issues/1126): use specific UltraHonk function
//   // recursive here is useless for UH, as it does not affect anything
//   const circuitSize = await getGatesUltra(bytecodePath, /*recursive=*/ false, /*honkRecursion=*/ true, api);
//   // TODO(https://github.com/AztecProtocol/barretenberg/issues/811): remove subgroupSizeOverride hack for goblin
//   const dyadicCircuitSize = Math.pow(2, Math.ceil(Math.log2(circuitSize)));
//   debug(`Loading CRS for UltraHonk with circuit-size=${circuitSize} dyadic-circuit-size=${dyadicCircuitSize}`);
//   const crs = await Crs.new(dyadicCircuitSize + 1, crsPath);
//   // Load CRS into wasm global CRS state.
//   // TODO: Make RawBuffer be default behavior, and have a specific Vector type for when wanting length prefixed.
//   await api.srsInitSrs(new RawBuffer(crs.getG1Data()), crs.numPoints, new RawBuffer(crs.getG2Data()));
//   return { api, circuitSize, dyadicCircuitSize };
// }
// async function initLite(crsPath: string) {
//   const api = await Barretenberg.new({ threads: 1 });
//   // Plus 1 needed! (Move +1 into Crs?)
//   const crs = await Crs.new(1, crsPath);
//   // Load CRS into wasm global CRS state.
//   await api.srsInitSrs(new RawBuffer(crs.getG1Data()), crs.numPoints, new RawBuffer(crs.getG2Data()));
//   return { api };
// }
// export async function proveAndVerifyUltraHonk(bytecodePath: string, witnessPath: string, crsPath: string) {
//   /* eslint-disable camelcase */
//   const { api } = await initUltraHonk(bytecodePath, crsPath);
//   try {
//     const bytecode = getBytecode(bytecodePath);
//     const witness = getWitness(witnessPath);
//     const verified = await api.acirProveAndVerifyUltraHonk(bytecode, witness);
//     return verified;
//   } finally {
//     await api.destroy();
//   }
//   /* eslint-enable camelcase */
// }
// export async function proveAndVerifyMegaHonk(bytecodePath: string, witnessPath: string, crsPath: string) {
//   /* eslint-disable camelcase */
//   const { api } = await initUltraHonk(bytecodePath, crsPath);
//   try {
//     const bytecode = getBytecode(bytecodePath);
//     const witness = getWitness(witnessPath);
//     const verified = await api.acirProveAndVerifyMegaHonk(bytecode, witness);
//     return verified;
//   } finally {
//     await api.destroy();
//   }
//   /* eslint-enable camelcase */
// }
// export async function gateCountUltra(bytecodePath: string, recursive: boolean, honkRecursion: boolean) {
//   const api = await Barretenberg.new({ threads: 1 });
//   try {
//     const numberOfGates = await getGatesUltra(bytecodePath, recursive, honkRecursion, api);
//     debug(`Number of gates: ${numberOfGates}`);
//     // Create an 8-byte buffer and write the number into it.
//     // Writing number directly to stdout will result in a variable sized
//     // input depending on the size.
//     const buffer = Buffer.alloc(8);
//     buffer.writeBigInt64LE(BigInt(numberOfGates));
//     process.stdout.write(Uint8Array.from(buffer));
//   } finally {
//     await api.destroy();
//   }
// }
// export async function contractUltraHonk(bytecodePath: string, vkPath: string, crsPath: string, outputPath: string) {
//   const { api } = await initUltraHonk(bytecodePath, crsPath);
//   try {
//     debug(`Creating UltraHonk verifier contract bytecode=${bytecodePath} vk=${vkPath}`);
//     const bytecode = getBytecode(bytecodePath);
//     const vk = new RawBuffer(readFileSync(vkPath));
//     const contract = await api.acirHonkSolidityVerifier(bytecode, vk);
//     if (outputPath === '-') {
//       process.stdout.write(contract);
//       debug(`Solidity verifier contract written to stdout`);
//     } else {
//       writeFileSync(outputPath, contract);
//       debug(`Solidity verifier contract written to ${outputPath}`);
//     }
//   } finally {
//     await api.destroy();
//   }
// }
// export async function proveUltraHonk(
//   bytecodePath: string,
//   witnessPath: string,
//   crsPath: string,
//   vkPath: string,
//   outputPath: string,
//   options?: UltraHonkBackendOptions,
// ) {
//   const { api } = await initUltraHonk(bytecodePath, crsPath);
//   try {
//     debug(`Creating UltraHonk proof bytecode=${bytecodePath}`);
//     const bytecode = getBytecode(bytecodePath);
//     const witness = getWitness(witnessPath);
//     const acirProveUltraHonk = options?.keccak
//       ? api.acirProveUltraKeccakHonk.bind(api)
//       : options?.keccakZK
//         ? api.acirProveUltraKeccakZkHonk.bind(api)
//         : options?.starknet
//           ? api.acirProveUltraStarknetHonk.bind(api)
//           : options?.starknetZK
//             ? api.acirProveUltraStarknetZkHonk.bind(api)
//             : api.acirProveUltraZKHonk.bind(api);
//     const proof = await acirProveUltraHonk(bytecode, witness, new RawBuffer(readFileSync(vkPath)));
//     if (outputPath === '-') {
//       process.stdout.write(proof);
//       debug(`Proof written to stdout`);
//     } else {
//       writeFileSync(outputPath, proof);
//       debug(`Proof written to ${outputPath}`);
//     }
//   } finally {
//     await api.destroy();
//   }
// }
// export async function writeVkUltraHonk(
//   bytecodePath: string,
//   crsPath: string,
//   outputPath: string,
//   options?: UltraHonkBackendOptions,
// ) {
//   const { api } = await initUltraHonk(bytecodePath, crsPath);
//   try {
//     const bytecode = getBytecode(bytecodePath);
//     debug(`Initializing UltraHonk verification key bytecode=${bytecodePath}`);
//     const acirWriteVkUltraHonk = options?.keccak
//       ? api.acirWriteVkUltraKeccakHonk.bind(api)
//       : options?.keccakZK
//         ? api.acirWriteVkUltraKeccakZkHonk.bind(api)
//         : options?.starknet
//           ? api.acirWriteVkUltraStarknetHonk.bind(api)
//           : options?.starknetZK
//             ? api.acirWriteVkUltraStarknetZkHonk.bind(api)
//             : api.acirWriteVkUltraHonk.bind(api);
//     const vk = await acirWriteVkUltraHonk(bytecode);
//     if (outputPath === '-') {
//       process.stdout.write(vk);
//       debug(`Verification key written to stdout`);
//     } else {
//       writeFileSync(outputPath, vk);
//       debug(`Verification key written to ${outputPath}`);
//     }
//   } finally {
//     await api.destroy();
//   }
// }
// export async function verifyUltraHonk(
//   proofPath: string,
//   vkPath: string,
//   crsPath: string,
//   options?: UltraHonkBackendOptions,
// ) {
//   const { api } = await initLite(crsPath);
//   try {
//     const acirVerifyUltraHonk = options?.keccak
//       ? api.acirVerifyUltraKeccakHonk.bind(api)
//       : options?.keccakZK
//         ? api.acirVerifyUltraKeccakZkHonk.bind(api)
//         : options?.starknet
//           ? api.acirVerifyUltraStarknetHonk.bind(api)
//           : options?.starknetZK
//             ? api.acirVerifyUltraStarknetZkHonk.bind(api)
//             : api.acirVerifyUltraZKHonk.bind(api);
//     const verified = await acirVerifyUltraHonk(
//       Uint8Array.from(readFileSync(proofPath)),
//       new RawBuffer(readFileSync(vkPath)),
//     );
//     debug(`Verification ${verified ? 'successful' : 'failed'}`);
//     return verified;
//   } finally {
//     await api.destroy();
//   }
// }
// export async function proofAsFieldsUltraHonk(proofPath: string, outputPath: string, crsPath: string) {
//   const { api } = await initLite(crsPath);
//   try {
//     debug(`Outputting UltraHonk proof as vector of fields proof=${proofPath}`);
//     const proofAsFields = await api.acirProofAsFieldsUltraHonk(Uint8Array.from(readFileSync(proofPath)));
//     const jsonProofAsFields = JSON.stringify(proofAsFields.map(f => f.toString()));
//     if (outputPath === '-') {
//       process.stdout.write(jsonProofAsFields);
//       debug(`Proof as fields written to stdout`);
//     } else {
//       writeFileSync(outputPath, jsonProofAsFields);
//       debug(`Proof as fields written to ${outputPath}`);
//     }
//   } finally {
//     await api.destroy();
//   }
// }
// export async function vkAsFieldsUltraHonk(vkPath: string, vkeyOutputPath: string, crsPath: string) {
//   const { api } = await initLite(crsPath);
//   try {
//     debug(`Serializing vk byte array into field elements vk=${vkPath}`);
//     const vkAsFields = await api.acirVkAsFieldsUltraHonk(new RawBuffer(readFileSync(vkPath)));
//     const jsonVKAsFields = JSON.stringify(vkAsFields.map(f => f.toString()));
//     if (vkeyOutputPath === '-') {
//       process.stdout.write(jsonVKAsFields);
//       debug(`Verification key as fields written to stdout`);
//     } else {
//       writeFileSync(vkeyOutputPath, jsonVKAsFields);
//       debug(`Verification key as fields written to ${vkeyOutputPath}`);
//     }
//   } finally {
//     await api.destroy();
//   }
// }
// const program = new Command('bb');
// program.option('-v, --verbose', 'enable verbose logging', false);
// program.option('-c, --crs-path <path>', 'set crs path', './crs');
// function handleGlobalOptions() {
//   initLogger({ useStdErr: true, level: program.opts().verbose ? 'debug' : 'info' });
//   debug = createDebugLogger('bb');
//   return { crsPath: program.opts().crsPath };
// }
// const deprecatedCommandError = () => async () => {
//   console.error(
//     `Error: UltraPlonk is now deprecated (see https://github.com/AztecProtocol/barretenberg/issues/1377). Use UltraHonk!`,
//   );
//   process.exit(1);
// };
// program
//   .command('prove_and_verify')
//   .description('Generate a proof and verify it. Process exits with success or failure code. [DEPRECATED]')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-r, --recursive', 'Whether to use a SNARK friendly proof', false)
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .action(deprecatedCommandError());
// program
//   .command('prove_and_verify_ultra_honk')
//   .description('Generate an UltraHonk proof and verify it. Process exits with success or failure code.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .action(async ({ bytecodePath, witnessPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     const result = await proveAndVerifyUltraHonk(bytecodePath, witnessPath, crsPath);
//     process.exit(result ? 0 : 1);
//   });
// program
//   .command('prove_and_verify_mega_honk')
//   .description('Generate a MegaHonk proof and verify it. Process exits with success or failure code.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .action(async ({ bytecodePath, witnessPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     const result = await proveAndVerifyMegaHonk(bytecodePath, witnessPath, crsPath);
//     process.exit(result ? 0 : 1);
//   });
// program
//   .command('prove')
//   .description('Generate a proof and write it to a file. [DEPRECATED]')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-r, --recursive', 'Create a SNARK friendly proof', false)
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .option('-o, --output-path <path>', 'Specify the proof output path', './proofs/proof')
//   .action(deprecatedCommandError());
// program
//   .command('gates')
//   .description('Print Ultra Builder gate count to standard output.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-r, --recursive', 'Create a SNARK friendly proof', false)
//   .option('-hr, --honk-recursion', 'Specify whether to use UltraHonk recursion', false)
//   .action(async ({ bytecodePath, recursive, honkRecursion: honkRecursion }) => {
//     handleGlobalOptions();
//     await gateCountUltra(bytecodePath, recursive, honkRecursion);
//   });
// program
//   .command('verify')
//   .description('Verify a proof. Process exists with success or failure code. [DEPRECATED]')
//   .requiredOption('-p, --proof-path <path>', 'Specify the path to the proof')
//   .requiredOption('-k, --vk <path>', 'path to a verification key. avoids recomputation.')
//   .action(deprecatedCommandError());
// program
//   .command('contract')
//   .description('Output solidity verification key contract. [DEPRECATED]')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-o, --output-path <path>', 'Specify the path to write the contract', './target/contract.sol')
//   .requiredOption('-k, --vk-path <path>', 'Path to a verification key. avoids recomputation.')
//   .action(deprecatedCommandError());
// program
//   .command('contract_ultra_honk')
//   .description('Output solidity verification key contract.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-o, --output-path <path>', 'Specify the path to write the contract', './target/contract.sol')
//   .requiredOption('-k, --vk-path <path>', 'Path to a verification key.')
//   .action(async ({ bytecodePath, outputPath, vkPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await contractUltraHonk(bytecodePath, vkPath, crsPath, outputPath);
//   });
// program
//   .command('write_vk')
//   .description('Output verification key. [DEPRECATED]')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-r, --recursive', 'Create a SNARK friendly proof', false)
//   .option('-o, --output-path <path>', 'Specify the path to write the key')
//   .action(deprecatedCommandError());
// program
//   .command('write_pk')
//   .description('Output proving key. [DEPRECATED]')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-r, --recursive', 'Create a SNARK friendly proof', false)
//   .requiredOption('-o, --output-path <path>', 'Specify the path to write the key')
//   .action(deprecatedCommandError());
// program
//   .command('proof_as_fields')
//   .description('Return the proof as fields elements. [DEPRECATED]')
//   .requiredOption('-p, --proof-path <path>', 'Specify the proof path')
//   .requiredOption('-k, --vk-path <path>', 'Path to verification key.')
//   .requiredOption('-o, --output-path <path>', 'Specify the JSON path to write the proof fields')
//   .action(deprecatedCommandError());
// program
//   .command('vk_as_fields')
//   .description(
//     'Return the verification key represented as fields elements. Also return the verification key hash. [DEPRECATED]',
//   )
//   .requiredOption('-k, --vk-path <path>', 'Path to verification key.')
//   .requiredOption('-o, --output-path <path>', 'Specify the JSON path to write the verification key fields and key hash')
//   .action(deprecatedCommandError());
// program
//   .command('prove_ultra_honk')
//   .description('Generate a proof and write it to a file.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .option('-k, --vk-path <path>', 'path to a verification key. avoids recomputation.')
//   .option('-o, --output-path <path>', 'Specify the proof output path', './proofs/proof')
//   .action(async ({ bytecodePath, witnessPath, vkPath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     debug(`Creating UltraHonk proof bytecodePath=${bytecodePath}, witnessPath=${witnessPath}, vkPath=${vkPath}`);
//     await proveUltraHonk(bytecodePath, witnessPath, crsPath, vkPath, outputPath);
//   });
// program
//   .command('prove_ultra_keccak_honk')
//   .description('Generate a proof and write it to a file.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .option('-k, --vk-path <path>', 'path to a verification key. avoids recomputation.')
//   .option('-o, --output-path <path>', 'Specify the proof output path', './proofs/proof')
//   .action(async ({ bytecodePath, witnessPath, vkPath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await proveUltraHonk(bytecodePath, witnessPath, crsPath, vkPath, outputPath, { keccak: true });
//   });
// program
//   .command('prove_ultra_starknet_honk')
//   .description('Generate a proof and write it to a file.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .option('-w, --witness-path <path>', 'Specify the witness path', './target/witness.gz')
//   .option('-k, --vk-path <path>', 'path to a verification key. avoids recomputation.')
//   .option('-o, --output-path <path>', 'Specify the proof output path', './proofs/proof')
//   .action(async ({ bytecodePath, witnessPath, vkPath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await proveUltraHonk(bytecodePath, witnessPath, crsPath, vkPath, outputPath, { starknet: true });
//   });
// program
//   .command('write_vk_ultra_honk')
//   .description('Output verification key.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .requiredOption('-o, --output-path <path>', 'Specify the path to write the key')
//   .action(async ({ bytecodePath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     debug(`Writing verification key to ${outputPath}`);
//     await writeVkUltraHonk(bytecodePath, crsPath, outputPath);
//   });
// program
//   .command('write_vk_ultra_keccak_honk')
//   .description('Output verification key.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .requiredOption('-o, --output-path <path>', 'Specify the path to write the key')
//   .action(async ({ bytecodePath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await writeVkUltraHonk(bytecodePath, crsPath, outputPath, { keccak: true });
//   });
// program
//   .command('write_vk_ultra_starknet_honk')
//   .description('Output verification key.')
//   .option('-b, --bytecode-path <path>', 'Specify the bytecode path', './target/program.json')
//   .requiredOption('-o, --output-path <path>', 'Specify the path to write the key')
//   .action(async ({ bytecodePath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await writeVkUltraHonk(bytecodePath, crsPath, outputPath, { starknet: true });
//   });
// program
//   .command('verify_ultra_honk')
//   .description('Verify a proof. Process exists with success or failure code.')
//   .requiredOption('-p, --proof-path <path>', 'Specify the path to the proof')
//   .requiredOption('-k, --vk-path <path>', 'path to a verification key. avoids recomputation.')
//   .action(async ({ proofPath, vkPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     const result = await verifyUltraHonk(proofPath, vkPath, crsPath);
//     process.exit(result ? 0 : 1);
//   });
// program
//   .command('verify_ultra_keccak_honk')
//   .description('Verify a proof. Process exists with success or failure code.')
//   .requiredOption('-p, --proof-path <path>', 'Specify the path to the proof')
//   .requiredOption('-k, --vk-path <path>', 'path to a verification key. avoids recomputation.')
//   .action(async ({ proofPath, vkPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     const result = await verifyUltraHonk(proofPath, vkPath, crsPath, { keccak: true });
//     process.exit(result ? 0 : 1);
//   });
// program
//   .command('verify_ultra_starknet_honk')
//   .description('Verify a proof. Process exists with success or failure code.')
//   .requiredOption('-p, --proof-path <path>', 'Specify the path to the proof')
//   .requiredOption('-k, --vk <path>', 'path to a verification key. avoids recomputation.')
//   .action(async ({ proofPath, vk }) => {
//     const { crsPath } = handleGlobalOptions();
//     const result = await verifyUltraHonk(proofPath, vk, crsPath, { starknet: true });
//     process.exit(result ? 0 : 1);
//   });
// program
//   .command('proof_as_fields_honk')
//   .description('Return the proof as fields elements')
//   .requiredOption('-p, --proof-path <path>', 'Specify the proof path')
//   .requiredOption('-o, --output-path <path>', 'Specify the JSON path to write the proof fields')
//   .action(async ({ proofPath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await proofAsFieldsUltraHonk(proofPath, outputPath, crsPath);
//   });
// program
//   .command('vk_as_fields_ultra_honk')
//   .description('Return the verification key represented as fields elements.')
//   .requiredOption('-k, --vk-path <path>', 'Path to verification key.')
//   .requiredOption('-o, --output-path <path>', 'Specify the JSON path to write the verification key fields.')
//   .action(async ({ vkPath, outputPath }) => {
//     const { crsPath } = handleGlobalOptions();
//     await vkAsFieldsUltraHonk(vkPath, outputPath, crsPath);
//   });
// program.name('bb.js').parse(process.argv);
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibWFpbi5qcyIsInNvdXJjZVJvb3QiOiIiLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9tYWluLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7OztBQUNBLDBDQUF3QztBQUN4QyxzREFBc0Q7QUFDdEQsNkRBQTZEO0FBQzdELGtFQUFrRTtBQUNsRSxvREFBb0Q7QUFDcEQscUNBQXFDO0FBQ3JDLHVDQUF1QztBQUN2Qyx1RUFBdUU7QUFFdkUsb0NBQW9DO0FBRXBDLG1FQUFtRTtBQUVuRSwyREFBMkQ7QUFDM0QsaUZBQWlGO0FBRWpGLCtCQUErQjtBQUMvQiw2RUFBNkU7QUFDN0UsdUZBQXVGO0FBQ3ZGLDRDQUE0QztBQUM1QyxNQUFNO0FBRU4sdURBQXVEO0FBQ3ZELHFEQUFxRDtBQUNyRCwwQ0FBMEM7QUFDMUMsSUFBSTtBQUVKLG9KQUFvSjtBQUNwSixzSEFBc0g7QUFDdEgsNkZBQTZGO0FBQzdGLGtCQUFrQjtBQUNsQixJQUFJO0FBRUoseURBQXlEO0FBQ3pELDRDQUE0QztBQUM1QywyQ0FBMkM7QUFDM0MsMENBQTBDO0FBQzFDLElBQUk7QUFFSiwySEFBMkg7QUFDM0gseURBQXlEO0FBQ3pELGdEQUFnRDtBQUNoRCxpR0FBaUc7QUFDakcsZ0NBQWdDO0FBQ2hDLElBQUk7QUFFSix3RUFBd0U7QUFDeEUseUNBQXlDO0FBQ3pDLGVBQWU7QUFDZixRQUFRO0FBRVIsa0lBQWtJO0FBQ2xJLHdHQUF3RztBQUN4Ryx3RUFBd0U7QUFDeEUsK0dBQStHO0FBQy9HLG1IQUFtSDtBQUNuSCw4RUFBOEU7QUFFOUUsa0hBQWtIO0FBQ2xILCtEQUErRDtBQUUvRCw0Q0FBNEM7QUFDNUMsbUhBQW1IO0FBQ25ILHlHQUF5RztBQUN6RyxvREFBb0Q7QUFDcEQsSUFBSTtBQUVKLDZDQUE2QztBQUM3Qyx3REFBd0Q7QUFFeEQsMENBQTBDO0FBQzFDLDJDQUEyQztBQUUzQyw0Q0FBNEM7QUFDNUMseUdBQXlHO0FBRXpHLG9CQUFvQjtBQUNwQixJQUFJO0FBRUosOEdBQThHO0FBQzlH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