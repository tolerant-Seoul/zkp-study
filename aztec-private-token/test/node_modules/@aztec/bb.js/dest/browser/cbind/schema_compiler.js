/**
 * Unified schema compiler with integrated strategies
 */
// Helper functions
function capitalize(s) {
    return s.charAt(0).toUpperCase() + s.substring(1);
}
function camelCase(s) {
    return s
        .split('_')
        .map((part, index) => (index === 0 ? part.charAt(0).toLowerCase() + part.substring(1) : capitalize(part)))
        .join('');
}
function pascalCase(s) {
    return s.split('_').map(capitalize).join('');
}
export class SchemaCompiler {
    constructor(config) {
        this.config = config;
        this.typeCache = new Map();
        this.functionMetadata = [];
        // WORKTODO(bbapi): AI slop fixup - redundant with typeCache, remove
        this.referencedTypes = new Set();
    }
    /**
     * Process API schema and extract function metadata
     */
    processApiSchema(commandsSchema, responsesSchema) {
        // Process types
        this.processSchema(commandsSchema);
        this.processSchema(responsesSchema);
        // Extract function metadata from named unions
        if (!Array.isArray(commandsSchema) || commandsSchema[0] !== 'named_union' ||
            !Array.isArray(responsesSchema) || responsesSchema[0] !== 'named_union') {
            throw new Error('Expected named_union schema format');
        }
        const commands = commandsSchema[1];
        const responses = responsesSchema[1];
        // Filter out ErrorResponse - it's a special error variant, not a command response
        const normalResponses = responses.filter(([name]) => name !== 'ErrorResponse');
        if (commands.length !== normalResponses.length) {
            throw new Error(`Command count (${commands.length}) does not match response count (${normalResponses.length})`);
        }
        for (let i = 0; i < commands.length; i++) {
            const [commandName] = commands[i];
            const [responseName] = normalResponses[i];
            this.functionMetadata.push({
                name: camelCase(commandName),
                commandType: pascalCase(commandName),
                responseType: pascalCase(responseName),
            });
        }
    }
    /**
     * Process a schema and populate type cache
     */
    processSchema(schema) {
        const key = this.getSchemaKey(schema);
        if (this.typeCache.has(key)) {
            const ret = this.typeCache.get(key);
            if (ret.typeName === 'unknown') {
                throw new Error(`Recursive schema detected at ${key}, please check your schema for circular references.`);
            }
            return ret;
        }
        this.typeCache.set(key, { typeName: 'unknown', msgpackTypeName: '' });
        const typeInfo = this.generateTypeInfo(schema);
        this.typeCache.set(key, typeInfo);
        return typeInfo;
    }
    /**
     * Generate the complete output
     */
    compile() {
        const parts = [
            '// AUTOGENERATED FILE - DO NOT EDIT',
            '',
        ];
        // Generate imports
        parts.push(...this.generateImports());
        parts.push('');
        // Generate type declarations only for 'types' mode
        if (this.config.mode === 'types') {
            const sortedTypes = Array.from(this.typeCache.values())
                .filter(t => t.declaration)
                .sort((a, b) => a.typeName.localeCompare(b.typeName));
            // Group declarations
            const typeAliases = sortedTypes.filter(t => t.declaration?.startsWith('export type') && !t.declaration?.includes('interface'));
            const publicInterfaces = sortedTypes.filter(t => t.declaration?.includes('export interface'));
            const privateInterfaces = sortedTypes.filter(t => t.declaration?.includes('interface Msgpack'));
            // Add type aliases if needed
            if (typeAliases.length > 0) {
                parts.push('// Type aliases');
                for (const type of typeAliases) {
                    parts.push(type.declaration);
                }
                parts.push('');
            }
            // Add tuple helper if needed
            if (this.needsTupleHelper()) {
                parts.push('// Tuple type for fixed-size arrays', 'type Tuple<T, N extends number> = N extends N ? (number extends N ? T[] : _TupleOf<T, N, []>) : never;', 'type _TupleOf<T, N extends number, R extends unknown[]> = R[\'length\'] extends N ? R : _TupleOf<T, N, [T, ...R]>;', '', '// Helper functions', 'function mapTuple<T, S, N extends number>(tuple: Tuple<T, N>, fn: (item: T) => S): Tuple<S, N> {', '  return tuple.map(fn) as Tuple<S, N>;', '}', '');
            }
            // Add public interfaces
            if (publicInterfaces.length > 0) {
                parts.push('// Public interfaces (exported)');
                for (const type of publicInterfaces) {
                    parts.push(type.declaration, '');
                }
            }
            // Add private interfaces
            if (privateInterfaces.length > 0) {
                parts.push('// Private Msgpack interfaces (not exported)');
                for (const type of privateInterfaces) {
                    parts.push(type.declaration, '');
                }
            }
            // Add conversion functions (only for api_types.ts)
            const conversions = sortedTypes.filter(t => t.toMethod || t.fromMethod);
            if (conversions.length > 0) {
                parts.push('// Conversion functions (exported)');
                for (const type of conversions) {
                    if (type.toMethod) {
                        parts.push('export ' + type.toMethod, '');
                    }
                    if (type.fromMethod) {
                        parts.push('export ' + type.fromMethod, '');
                    }
                }
            }
            // Add BbApiBase interface
            if (this.functionMetadata.length > 0) {
                parts.push('', '// Base API interface');
                parts.push(this.generateBbApiBaseInterface());
            }
        }
        // Add API class for non-types modes
        if (this.config.mode !== 'types' && this.functionMetadata.length > 0) {
            parts.push(this.generateApiClass());
        }
        return parts.join('\n') + '\n';
    }
    getSchemaKey(schema) {
        if (typeof schema === 'string')
            return schema;
        if (Array.isArray(schema))
            return JSON.stringify(schema);
        if (typeof schema === 'object')
            return schema.__typename || JSON.stringify(schema);
        return String(schema);
    }
    needsTupleHelper() {
        return Array.from(this.typeCache.values()).some(t => t.typeName.includes('Tuple<'));
    }
    trackTypeUsage(typeName) {
        // Only track for API modes
        if (this.config.mode === 'types')
            return;
        // Extract base types from complex types
        const baseTypes = this.extractBaseTypes(typeName);
        for (const type of baseTypes) {
            // Skip built-in types
            if (['string', 'number', 'boolean', 'Uint8Array'].includes(type)) {
                continue;
            }
            this.referencedTypes.add(type);
        }
    }
    extractBaseTypes(typeName) {
        const types = [];
        // Handle arrays
        const arrayMatch = typeName.match(/^(.+)\[\]$/);
        if (arrayMatch) {
            types.push(...this.extractBaseTypes(arrayMatch[1]));
            return types;
        }
        // Handle Tuple
        const tupleMatch = typeName.match(/^Tuple<(.+),\s*\d+>$/);
        if (tupleMatch) {
            types.push(...this.extractBaseTypes(tupleMatch[1]));
            return types;
        }
        // Handle Record
        const recordMatch = typeName.match(/^Record<(.+),\s*(.+)>$/);
        if (recordMatch) {
            types.push(...this.extractBaseTypes(recordMatch[1]));
            types.push(...this.extractBaseTypes(recordMatch[2]));
            return types;
        }
        // Handle union types
        if (typeName.includes(' | ')) {
            const parts = typeName.split(' | ');
            for (const part of parts) {
                types.push(...this.extractBaseTypes(part.trim()));
            }
            return types;
        }
        // Base case - simple type
        types.push(typeName);
        return types;
    }
    generateTypeInfo(schema) {
        if (Array.isArray(schema)) {
            return this.processArraySchema(schema);
        }
        else if (typeof schema === 'string') {
            return this.processPrimitiveSchema(schema);
        }
        else if (typeof schema === 'object') {
            return this.processObjectSchema(schema);
        }
        throw new Error(`Unsupported schema type: ${schema}`);
    }
    processArraySchema(schema) {
        const [type, ...args] = schema;
        switch (type) {
            case 'array': {
                const [subtype, size] = args[0];
                if (subtype === 'unsigned char') {
                    return { typeName: 'Uint8Array' };
                }
                const subtypeInfo = this.processSchema(subtype);
                return {
                    typeName: `Tuple<${subtypeInfo.typeName}, ${size}>`,
                    msgpackTypeName: `Tuple<${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}, ${size}>`,
                };
            }
            case 'variant': {
                const variants = args[0];
                const variantInfos = variants.map(v => this.processSchema(v));
                const typeName = variantInfos.map(v => v.typeName).join(' | ');
                const msgpackUnion = variantInfos.map(v => v.msgpackTypeName || v.typeName).join(' | ');
                return {
                    typeName,
                    msgpackTypeName: `[number, ${msgpackUnion}]`,
                };
            }
            case 'named_union': {
                const namedTypes = args[0];
                const tupleTypes = [];
                for (const [name, schemaOrName] of namedTypes) {
                    let typeInfo = this.processSchema(schemaOrName);
                    // Track usage of the type
                    this.trackTypeUsage(typeInfo.typeName);
                    tupleTypes.push(`["${name}", ${typeInfo.typeName}]`);
                }
                return {
                    typeName: tupleTypes.join(' | '),
                    msgpackTypeName: tupleTypes.join(' | '),
                };
            }
            case 'vector': {
                const [subtype] = args[0];
                if (subtype === 'unsigned char') {
                    return { typeName: 'Uint8Array' };
                }
                const subtypeInfo = this.processSchema(subtype);
                return {
                    typeName: `${subtypeInfo.typeName}[]`,
                    msgpackTypeName: `${subtypeInfo.msgpackTypeName || subtypeInfo.typeName}[]`,
                };
            }
            case 'alias': {
                const [rawTypeName, msgpackName] = args[0];
                const typeName = pascalCase(rawTypeName);
                let targetType;
                if (msgpackName.startsWith('bin')) {
                    targetType = 'Uint8Array';
                }
                else if (['int', 'unsigned int', 'unsigned short'].includes(msgpackName)) {
                    targetType = 'number';
                }
                else {
                    throw new Error(`Unsupported alias type: ${msgpackName}`);
                }
                // Create a proper type alias declaration
                return {
                    typeName,
                    msgpackTypeName: targetType,
                    declaration: `export type ${typeName} = ${targetType};`,
                };
            }
            case 'shared_ptr': {
                const [subtype] = args[0];
                return this.processSchema(subtype);
            }
            case 'map': {
                const [keyType, valueType] = args[0];
                const keyInfo = this.processSchema(keyType);
                const valueInfo = this.processSchema(valueType);
                return {
                    typeName: `Record<${keyInfo.typeName}, ${valueInfo.typeName}>`,
                    msgpackTypeName: `Record<${keyInfo.msgpackTypeName || keyInfo.typeName}, ${valueInfo.msgpackTypeName || valueInfo.typeName}>`,
                };
            }
            default:
                throw new Error(`Unsupported array schema type: ${type}`);
        }
    }
    processPrimitiveSchema(schema) {
        switch (schema) {
            case 'bool':
                return { typeName: 'boolean' };
            case 'int':
            case 'unsigned int':
            case 'unsigned short':
            case 'unsigned long':
            case 'double':
                return { typeName: 'number' };
            case 'string':
                return { typeName: 'string' };
            case 'bin32':
                return { typeName: 'Uint8Array' };
            case 'field2':
                // field2 is an extension field type (fq2) represented as a tuple of two Uint8Arrays
                return {
                    typeName: 'Field2',
                    msgpackTypeName: '[Uint8Array, Uint8Array]',
                    declaration: 'export type Field2 = [Uint8Array, Uint8Array];',
                };
            default:
                return { typeName: pascalCase(schema) };
        }
    }
    processObjectSchema(schema) {
        const typeName = pascalCase(schema.__typename);
        const msgpackTypeName = 'Msgpack' + typeName;
        const declaration = this.generateInterfaces(typeName, schema);
        const toMethod = this.generateToMethod(typeName, schema);
        const fromMethod = this.generateFromMethod(typeName, schema);
        return {
            typeName,
            msgpackTypeName,
            declaration,
            toMethod,
            fromMethod,
        };
    }
    getOrCreateEmptyType(typeName) {
        const key = `empty_${typeName}`;
        if (this.typeCache.has(key)) {
            return this.typeCache.get(key);
        }
        const typeInfo = {
            typeName,
            msgpackTypeName: 'Msgpack' + typeName,
            declaration: `export interface ${typeName} {}\n\ninterface Msgpack${typeName} {}`,
            toMethod: `function to${typeName}(o: Msgpack${typeName}): ${typeName} {\n  return {};\n}`,
            fromMethod: `function from${typeName}(o: ${typeName}): Msgpack${typeName} {\n  return {};\n}`,
        };
        this.typeCache.set(key, typeInfo);
        return typeInfo;
    }
    generateInterfaces(name, schema) {
        const publicInterface = this.generatePublicInterface(name, schema);
        const msgpackInterface = this.generateMsgpackInterface(name, schema);
        return publicInterface + '\n\n' + msgpackInterface;
    }
    generatePublicInterface(name, schema) {
        let result = `export interface ${name} {\n`;
        for (const [key, value] of Object.entries(schema)) {
            if (key === '__typename')
                continue;
            const typeInfo = this.processSchema(value);
            // Track type usage
            this.trackTypeUsage(typeInfo.typeName);
            result += `  ${camelCase(key)}: ${typeInfo.typeName};\n`;
        }
        result += '}';
        return result;
    }
    generateMsgpackInterface(name, schema) {
        let result = `interface Msgpack${name} {\n`;
        for (const [key, value] of Object.entries(schema)) {
            if (key === '__typename')
                continue;
            const typeInfo = this.processSchema(value);
            result += `  ${key}: ${typeInfo.msgpackTypeName || typeInfo.typeName};\n`;
        }
        result += '}';
        return result;
    }
    generateToMethod(name, schema) {
        const fields = Object.entries(schema).filter(([key]) => key !== '__typename');
        if (fields.length === 0) {
            return `function to${name}(o: Msgpack${name}): ${name} {\n  return {};\n}`;
        }
        const checks = fields.map(([key]) => `  if (o.${key} === undefined) { throw new Error("Expected ${key} in ${name} deserialization"); }`).join('\n');
        const conversions = fields.map(([key, value]) => {
            const typeInfo = this.processSchema(value);
            const converter = this.generateConverter(typeInfo, `o.${key}`, 'to');
            return `    ${camelCase(key)}: ${converter},`;
        }).join('\n');
        return `function to${name}(o: Msgpack${name}): ${name} {
${checks};
  return {
${conversions}
  };
}`;
    }
    generateFromMethod(name, schema) {
        const fields = Object.entries(schema).filter(([key]) => key !== '__typename');
        if (fields.length === 0) {
            return `function from${name}(o: ${name}): Msgpack${name} {\n  return {};\n}`;
        }
        const checks = fields.map(([key]) => `  if (o.${camelCase(key)} === undefined) { throw new Error("Expected ${camelCase(key)} in ${name} serialization"); }`).join('\n');
        const conversions = fields.map(([key, value]) => {
            const typeInfo = this.processSchema(value);
            const converter = this.generateConverter(typeInfo, `o.${camelCase(key)}`, 'from');
            return `  ${key}: ${converter},`;
        }).join('\n');
        return `function from${name}(o: ${name}): Msgpack${name} {
${checks};
  return {
${conversions}
  };
}`;
    }
    generateConverter(typeInfo, value, direction) {
        // Handle arrays/tuples
        if (typeInfo.typeName.includes('[]') || typeInfo.typeName.includes('Tuple<')) {
            const elementType = typeInfo.typeName.match(/^(.+)\[\]$/) || typeInfo.typeName.match(/^Tuple<(.+),/);
            if (elementType) {
                const isTuple = typeInfo.typeName.includes('Tuple<');
                const mapFn = isTuple ? 'mapTuple' : 'map';
                return `${value}.${mapFn}((v: any) => v)`; // Simplified for now
            }
        }
        // Handle custom types
        if (typeInfo.declaration && typeInfo.typeName !== 'Fr' && typeInfo.typeName !== 'Fq' && typeInfo.typeName !== 'Field2') {
            return `${direction}${typeInfo.typeName}(${value})`;
        }
        return value;
    }
    generateImports() {
        const imports = [];
        // Base imports
        if (this.config.imports) {
            imports.push(...this.config.imports);
        }
        // For API modes, import from api_types
        if (this.config.mode !== 'types') {
            const neededImports = new Set();
            // Add types and conversion functions from function metadata
            for (const metadata of this.functionMetadata) {
                neededImports.add(metadata.commandType);
                neededImports.add(metadata.responseType);
                neededImports.add(`from${metadata.commandType}`);
                neededImports.add(`to${metadata.responseType}`);
            }
            // Add referenced types
            for (const type of this.referencedTypes) {
                neededImports.add(type);
            }
            // Add BbApiBase interface
            neededImports.add('BbApiBase');
            if (neededImports.size > 0) {
                const sortedImports = Array.from(neededImports).sort();
                // Remove duplicates
                const uniqueImports = sortedImports.filter((item, index) => sortedImports.indexOf(item) === index);
                imports.push(`import { ${uniqueImports.join(', ')} } from './api_types.js';`);
            }
        }
        return imports;
    }
    generateBbApiBaseInterface() {
        const methods = this.functionMetadata.map(m => `  ${m.name}(command: ${m.commandType}): Promise<${m.responseType}>;`).join('\n');
        return `export interface BbApiBase {
${methods}
  destroy(): Promise<void>;
}`;
    }
    generateApiClass() {
        const className = this.getApiClassName();
        const methods = this.functionMetadata.map(m => this.generateApiMethod(m)).join('\n\n');
        if (this.config.mode === 'native') {
            return this.generateNativeApiClass(methods);
        }
        // For sync API, don't implement BbApiBase since methods are synchronous
        const implementsClause = this.config.mode === 'sync' ? '' : ' implements BbApiBase';
        const msgpackCallHelper = `${this.config.mode === 'async' ? 'async ' : ''}function msgpackCall(wasm: ${this.getWasmType()}, cbind: string, input: any[]) {` +
            `  const inputBuffer = new Encoder({ useRecords: false }).pack(input);` +
            `  const encodedResult = ${this.config.mode === 'async' ? 'await ' : ''}wasm.cbindCall(cbind, inputBuffer);` +
            `  return new Decoder({ useRecords: false }).unpack(encodedResult);` +
            `}\n`;
        return (msgpackCallHelper +
            `export class ${className}${implementsClause} {
  constructor(protected wasm: ${this.getWasmType()}) {}

${methods}

  destroy(): Promise<void> {
    return this.wasm.destroy();
  }
}`);
    }
    getApiClassName() {
        switch (this.config.mode) {
            case 'sync': return 'SyncApi';
            case 'async': return 'AsyncApi';
            case 'native': return 'NativeApi';
            default: throw new Error(`Invalid mode: ${this.config.mode}`);
        }
    }
    getWasmType() {
        switch (this.config.mode) {
            case 'sync': return 'BarretenbergWasmMain';
            case 'async': return 'BarretenbergWasmMainWorker';
            default: return '';
        }
    }
    generateApiMethod(metadata) {
        const { name, commandType, responseType } = metadata;
        if (this.config.mode === 'native') {
            return `  ${name}(command: ${commandType}): Promise<${responseType}> {
    const msgpackCommand = from${commandType}(command);
    return this.sendCommand(['${metadata.commandType}', msgpackCommand]).then(([variantName, result]: [string, any]) => {
      if (variantName !== '${responseType}') {
        throw new Error(\`Expected variant name '${responseType}' but got '\${variantName}'\`);
      }
      return to${responseType}(result);
    });
  }`;
        }
        // For async mode, queue immediately and return promise
        if (this.config.mode === 'async') {
            return `  ${name}(command: ${commandType}): Promise<${responseType}> {
    const msgpackCommand = from${commandType}(command);
    return msgpackCall(this.wasm, 'bbapi', [["${capitalize(name)}", msgpackCommand]]).then(([variantName, result]: [string, any]) => {
      if (variantName === 'ErrorResponse') {
        throw new BBApiException(result.message || 'Unknown error from barretenberg');
      }
      if (variantName !== '${responseType}') {
        throw new BBApiException(\`Expected variant name '${responseType}' but got '\${variantName}'\`);
      }
      return to${responseType}(result);
    });
  }`;
        }
        // For sync mode, keep the synchronous behavior
        return `  ${name}(command: ${commandType}): ${responseType} {
    const msgpackCommand = from${commandType}(command);
    const [variantName, result] = msgpackCall(this.wasm, 'bbapi', [["${capitalize(name)}", msgpackCommand]]);
    if (variantName === 'ErrorResponse') {
      throw new BBApiException(result.message || 'Unknown error from barretenberg');
    }
    if (variantName !== '${responseType}') {
      throw new BBApiException(\`Expected variant name '${responseType}' but got '\${variantName}'\`);
    }
    return to${responseType}(result);
  }`;
    }
    generateNativeApiClass(methods) {
        return `interface NativeApiRequest {
  resolve: (value: any) => void;
  reject: (error: any) => void;
}

class StreamBuffer {
  private buffer = Buffer.alloc(0);
  private expectedLength: number | null = null;

  addData(data: Buffer): Buffer[] {
    // Create buffer to grow as needed
    const newBuffer = Buffer.allocUnsafe(this.buffer.length + data.length);
    this.buffer.copy(newBuffer, 0);
    data.copy(newBuffer, this.buffer.length);
    this.buffer = newBuffer;

    const messages: Buffer[] = [];

    while (true) {
      if (this.expectedLength === null) {
        if (this.buffer.length < 4) break;
        this.expectedLength = this.buffer.readUInt32LE(0);
        this.buffer = this.buffer.subarray(4);
      }

      if (this.buffer.length < this.expectedLength) break;

      // Extract complete message
      const messageBuffer = this.buffer.subarray(0, this.expectedLength);
      messages.push(messageBuffer);
      this.buffer = this.buffer.subarray(this.expectedLength);
      this.expectedLength = null;
    }

    return messages;
  }
}

export class NativeApi implements BbApiBase {
  private decoder = new Decoder({ useRecords: false });
  private encoder = new Encoder({ useRecords: false });
  private pendingRequests: NativeApiRequest[] = [];

  private constructor(private proc: ChildProcess) {}

  static async new(bbPath = 'bb', logger = console.log): Promise<NativeApi> {
    const proc = spawn(bbPath, ['msgpack', 'run'], {
      stdio: ['pipe', 'pipe', 'pipe'],
    });

    if (!proc.stdout || !proc.stdin) {
      throw new Error('Failed to initialize bb process');
    }

    const api = new NativeApi(proc);
    const streamBuffer = new StreamBuffer();

    proc.stdout.on('data', (data: Buffer) => {
      const messages = streamBuffer.addData(data);

      for (const messageBuffer of messages) {
        const pendingRequest = api.pendingRequests.shift();
        if (!pendingRequest) {
          throw new Error('Received response without a pending request');
        }

        try {
          const decoded = api.decoder.decode(messageBuffer);
          if (!Array.isArray(decoded) || decoded.length !== 2) {
            throw new Error(\`Invalid response format: \${JSON.stringify(decoded)}\`);
          }
          const [variantName, result] = decoded;
          pendingRequest.resolve([variantName, result]);
        } catch (error) {
          pendingRequest.reject(error);
          break;
        }
      }
    });

    proc.stderr.on('data', (data: Buffer) => {
      logger(data.toString().trim());
    });

    proc.on('error', err => {
      throw new Error(err.message);
    });
    return api;
  }

  private sendCommand(command: any): Promise<any> {
    return new Promise((resolve, reject) => {
      this.pendingRequests.push({ resolve, reject });
      const encoded = this.encoder.encode(command);

      // Write length prefix (4 bytes, little-endian)
      const lengthBuffer = Buffer.allocUnsafe(4);
      lengthBuffer.writeUInt32LE(encoded.length, 0);

      // Write length prefix followed by the encoded data
      this.proc.stdin!.write(lengthBuffer);
      this.proc.stdin!.write(encoded);
    });
  }

  async close(): Promise<void> {
    this.proc.kill();
  }

  destroy(): Promise<void> {
    return this.close();
  }

${methods}
}`;
    }
}
// Factory methods for creating configured compilers
export function createSharedTypesCompiler() {
    return new SchemaCompiler({
        mode: 'types',
        imports: [],
    });
}
export function createSyncApiCompiler() {
    return new SchemaCompiler({
        mode: 'sync',
        imports: [
            `import { BarretenbergWasmMain } from "../../barretenberg_wasm/barretenberg_wasm_main/index.js";`,
            `import { Decoder, Encoder } from 'msgpackr';`,
            `import { BBApiException } from '../../bbapi_exception.js';`,
        ],
    });
}
export function createAsyncApiCompiler() {
    return new SchemaCompiler({
        mode: 'async',
        imports: [
            `import { BarretenbergWasmMainWorker } from "../../barretenberg_wasm/barretenberg_wasm_main/index.js";`,
            `import { Decoder, Encoder } from 'msgpackr';`,
            `import { BBApiException } from '../../bbapi_exception.js';`
        ],
    });
}
export function createNativeApiCompiler() {
    return new SchemaCompiler({
        mode: 'native',
        imports: [
            `import { spawn, ChildProcess } from 'child_process';`,
            `import { Decoder, Encoder } from 'msgpackr';`,
            `import { BBApiException } from '../../bbapi_exception.js';`
        ],
    });
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoic2NoZW1hX2NvbXBpbGVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiLi4vLi4vLi4vc3JjL2NiaW5kL3NjaGVtYV9jb21waWxlci50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7R0FFRztBQXVDSCxtQkFBbUI7QUFDbkIsU0FBUyxVQUFVLENBQUMsQ0FBUztJQUMzQixPQUFPLENBQUMsQ0FBQyxNQUFNLENBQUMsQ0FBQyxDQUFDLENBQUMsV0FBVyxFQUFFLEdBQUcsQ0FBQyxDQUFDLFNBQVMsQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNwRCxDQUFDO0FBRUQsU0FBUyxTQUFTLENBQUMsQ0FBUztJQUMxQixPQUFPLENBQUM7U0FDTCxLQUFLLENBQUMsR0FBRyxDQUFDO1NBQ1YsR0FBRyxDQUFDLENBQUMsSUFBSSxFQUFFLEtBQUssRUFBRSxFQUFFLENBQUMsQ0FBQyxLQUFLLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUMsQ0FBQyxDQUFDLFdBQVcsRUFBRSxHQUFHLElBQUksQ0FBQyxTQUFTLENBQUMsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQyxDQUFDO1NBQ3pHLElBQUksQ0FBQyxFQUFFLENBQUMsQ0FBQztBQUNkLENBQUM7QUFFRCxTQUFTLFVBQVUsQ0FBQyxDQUFTO0lBQzNCLE9BQU8sQ0FBQyxDQUFDLEtBQUssQ0FBQyxHQUFHLENBQUMsQ0FBQyxHQUFHLENBQUMsVUFBVSxDQUFDLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQyxDQUFDO0FBQy9DLENBQUM7QUFFRCxNQUFNLE9BQU8sY0FBYztJQU16QixZQUFvQixNQUFzQjtRQUF0QixXQUFNLEdBQU4sTUFBTSxDQUFnQjtRQUxsQyxjQUFTLEdBQUcsSUFBSSxHQUFHLEVBQW9CLENBQUM7UUFDeEMscUJBQWdCLEdBQXVCLEVBQUUsQ0FBQztRQUNsRCxvRUFBb0U7UUFDNUQsb0JBQWUsR0FBRyxJ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